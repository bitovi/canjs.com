<!DOCTYPE html>

<html>
<head>
  <title>can/view/stache/mustache_core.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="html_section.html">
                html_section.js
              </a>
            
              
              <a class="source" href="mustache_core.html">
                mustache_core.js
              </a>
            
              
              <a class="source" href="mustache_helpers.html">
                mustache_helpers.js
              </a>
            
              
              <a class="source" href="stache.html">
                stache.js
              </a>
            
              
              <a class="source" href="system.html">
                system.js
              </a>
            
              
              <a class="source" href="text_section.html">
                text_section.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="can-view-stache-mustache_core-js">can/view/stache/mustache_core.js</h1>
<p>This provides helper utilities for Mustache processing. Currently,
only stache uses these helpers.  Ideally, these utilities could be used
in other libraries implementing Mustache-like features.  </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
steal(<span class="hljs-string">"can/util"</span>,
	<span class="hljs-string">"./utils"</span>,
	<span class="hljs-string">"./mustache_helpers"</span>,
	<span class="hljs-string">"can/view/live"</span>,
	<span class="hljs-string">"can/view/elements.js"</span>,
	<span class="hljs-string">"can/view/scope"</span>,
	<span class="hljs-string">"can/view/node_lists"</span>,
	<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(can, utils, mustacheHelpers, live, elements, Scope, nodeLists )</span></span>{

	live = live || can.view.live;
	elements = elements || can.view.elements;
	Scope = Scope || can.view.Scope;
	nodeLists = nodeLists || can.view.nodeLists;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="types">Types</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A lookup is an object that is used to identify a lookup in the scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @hide
	 * @typedef {{get: String}} can.mustache.Lookup
	 * @option {String} get A value in the scope to look up.
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="helpers">Helpers</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Breaks up the name and arguments of a mustache expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> argumentsRegExp = <span class="hljs-regexp">/((([^'"\s]+?=)?('.*?'|".*?"))|.*?)\s/g</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Identifies the type of an argument or hash in a mustache expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		literalNumberStringBooleanRegExp = <span class="hljs-regexp">/^(?:(?:('.*?'|".*?")|([0-9]+\.?[0-9]*|true|false|null|undefined))|(?:(.+?)=(?:(?:('.*?'|".*?")|([0-9]+\.?[0-9]*|true|false|null|undefined))|(.+))))$/</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Finds mustache tags and their surrounding whitespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		mustacheLineBreakRegExp = <span class="hljs-regexp">/(?:(?:^|(\r?)\n)(\s*)(\{\{([^\}]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([^\}]*)\}\}\}?)/g</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Identifies if an argument value should be looked up.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		isLookup = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> </span>{
			<span class="hljs-keyword">return</span> obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj.get === <span class="hljs-string">"string"</span>;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>A helper for calling the truthy subsection for each item in a list and putting them in a document Fragment.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		getItemsFragContent = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(items, isObserveList, helperOptions, options)</span></span>{
			<span class="hljs-keyword">var</span> frag = <span class="hljs-built_in">document</span>.createDocumentFragment();
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = items.length; i &lt; len; i++) {
				append(frag, helperOptions.fn( isObserveList ? items.attr(<span class="hljs-string">''</span> + i) : items[i], options) );
			}
			<span class="hljs-keyword">return</span> frag;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Appends some content to a document fragment.  If the content is a string, it puts it in a TextNode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		append = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(frag, content)</span></span>{
			<span class="hljs-keyword">if</span>(content) {
				frag.appendChild(<span class="hljs-keyword">typeof</span> content === <span class="hljs-string">"string"</span> ? <span class="hljs-built_in">document</span>.createTextNode(content) : content);
			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>A helper for calling the truthy subsection for each item in a list and returning them in a string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		getItemsStringContent = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(items, isObserveList, helperOptions, options)</span></span>{
			<span class="hljs-keyword">var</span> txt = <span class="hljs-string">""</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = items.length; i &lt; len; i++) {
				txt += helperOptions.fn( isObserveList ? items.attr(<span class="hljs-string">''</span> + i) : items[i], options);
			}
			<span class="hljs-keyword">return</span> txt;
		},
		getKeyComputeData = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, scope, isArgument)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Get a compute (and some helper data) that represents key’s value in the current scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> data = scope.computeData(key, {
				isArgument: isArgument,
				args: [scope.attr(<span class="hljs-string">'.'</span>), scope]
			});
			
			can.compute.temporarilyBind(data.compute);
			
			<span class="hljs-keyword">return</span> data;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Returns a value or compute for the given key.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		getKeyArgValue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key, scope)</span></span>{
			<span class="hljs-keyword">var</span> data = getKeyComputeData(key, scope, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>If there are no dependencies, just return the value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!data.compute.hasDependencies) {
				<span class="hljs-keyword">return</span> data.initialValue;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> data.compute;
			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Sets .fn and .inverse on a helperOptions object and makes sure 
they can reference the current scope and options.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		convertToScopes = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>overwrite fn and inverse to always convert to scopes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(truthyRenderer) {
				helperOptions.fn = makeRendererConvertScopes(truthyRenderer, scope, options, nodeList);
			}
			<span class="hljs-keyword">if</span>(falseyRenderer) {
				helperOptions.inverse = makeRendererConvertScopes(falseyRenderer, scope, options, nodeList);
			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Returns a new renderer function that makes sure any data or helpers passed
to it are converted to a can.view.Scope and a can.view.Options.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		makeRendererConvertScopes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(renderer, parentScope, parentOptions, nodeList)</span> </span>{
			<span class="hljs-keyword">var</span> rendererWithScope = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx, opts, parentNodeList)</span></span>{
				<span class="hljs-keyword">return</span> renderer(ctx || parentScope, opts, parentNodeList);
			};
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newScope, newOptions, parentNodeList)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>prevent binding on fn.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> reads = can.__clearReading();</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>If a non-scope value is passed, add that to the parent scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (newScope !== <span class="hljs-literal">undefined</span> &amp;&amp; !(newScope <span class="hljs-keyword">instanceof</span> can.view.Scope)) {
					newScope = parentScope.add(newScope);
				}
				<span class="hljs-keyword">if</span> (newOptions !== <span class="hljs-literal">undefined</span> &amp;&amp; !(newOptions <span class="hljs-keyword">instanceof</span> core.Options)) {
					newOptions = parentOptions.add(newOptions);
				}
				<span class="hljs-keyword">var</span> result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList|| nodeList );
				can.__setReading(reads);
				<span class="hljs-keyword">return</span> result;
			};
		};
	

	
	<span class="hljs-keyword">var</span> core = {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h2 id="mustachecore-expressiondata">mustacheCore.expressionData</h2>
<p>Returns processed information about the arguments and hash in a mustache expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Returns processed information about the arguments and hash in a mustache expression.
		 * @param {can.mustache.Expression} An expression minus the mode like: `each items animate="in"`
		 * @return {Object} Packaged info about the expression for faster processing.
		 * @option {can.mustache.Lookup|*} name The first key which is usually the name of a value or a helper to lookup.
		 * @option {Array&lt;can.mustache.Lookup|*&gt;} args An array of lookup values or JS literal values.
		 * @option {Object.&lt;String,can.mustache.Lookup|*&gt;} hashes A mapping of hash name to lookup values or JS literal values.
		 */</span>
		expressionData: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expression)</span></span>{
			<span class="hljs-keyword">var</span> args = [],
				hashes = {},
				i = <span class="hljs-number">0</span>;
			
			(can.trim(expression) + <span class="hljs-string">' '</span>).replace(argumentsRegExp, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(whole, arg)</span> </span>{
				<span class="hljs-keyword">var</span> m;</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Check for special helper arguments (string/number/boolean/hashes).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (i &amp;&amp; (m = arg.match(literalNumberStringBooleanRegExp))) {
					<span class="hljs-keyword">if</span>(m[<span class="hljs-number">1</span>] || m[<span class="hljs-number">2</span>]) {
						args.push(utils.jsonParse(m[<span class="hljs-number">1</span>] || m[<span class="hljs-number">2</span>]));
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Found a hash object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Addd to the hash object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						hashes[m[<span class="hljs-number">3</span>]] =  (m[<span class="hljs-number">6</span>] ?  {get: m[<span class="hljs-number">6</span>]} :  utils.jsonParse(m[<span class="hljs-number">4</span>] || m[<span class="hljs-number">5</span>]));
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Otherwise output a normal interpolation reference.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">else</span> {
					args.push({get: arg});
				}
				i++;
			});
			
			<span class="hljs-keyword">return</span> {
				name: args.shift(),
				args: args,
				hash: hashes
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h2 id="mustachecore-makeevaluator">mustacheCore.makeEvaluator</h2>
<p>Given a scope and expression, returns a function that evaluates that expression in the scope. </p>
<p>This function first reads lookup values in the args and hash.  Then it tries to figure out
if a helper is being called or a value is being read.  Finally, depending on
if it’s a helper, or not, and which mode the expression is in, it returns
a function that can quickly evaluate the expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide 
		 * Given a mode and expresion data, returns a function that evaluates that expression. 
		 * @param {can.view.Scope} The scope in which the expression is evaluated.
		 * @param {can.view.Options} The option helpers in which the expression is evaluated.
		 * @param {String} mode Either null, #, ^. &gt; is handled elsewhere
		 * @param {Object} exprData Data about what was in the mustache expression
		 * @param {renderer} [truthyRenderer] Used to render a subsection 
		 * @param {renderer} [falseyRenderer] Used to render the inverse subsection
		 * @param {String} [stringOnly] A flag to indicate that only strings will be returned by subsections.
		 * @return {Function} An 'evaluator' function that evaluates the expression.
		 */</span>
		makeEvaluator: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Arguments for the helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> args = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Hash values for helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				hash = {},</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Helper options object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				helperOptions = {
					fn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{},
					inverse: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{}
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>The current context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				context = scope.attr(<span class="hljs-string">"."</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>The main value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				name = exprData.name,</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>If name is a helper, this gets set to the helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				helper,</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><code>true</code> if the expression looks like a helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				looksLikeAHelper = exprData.args.length || !can.isEmptyObject(exprData.hash),</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>The “peaked” at value of the name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				initialValue;</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Convert lookup values in arguments to actual values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = exprData.args.length; i &lt; len; i++) {
				<span class="hljs-keyword">var</span> arg = exprData.args[i];
				<span class="hljs-keyword">if</span> (arg &amp;&amp; isLookup(arg)) {
					args.push(getKeyArgValue(arg.get, scope, <span class="hljs-literal">true</span>));
				} <span class="hljs-keyword">else</span> {
					args.push(arg);
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Convert lookup values in hash to actual values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> exprData.hash) {
				<span class="hljs-keyword">if</span> (isLookup(exprData.hash[prop])) {
					hash[prop] = getKeyArgValue(exprData.hash[prop].get, scope);
				} <span class="hljs-keyword">else</span> {
					hash[prop] = exprData.hash[prop];
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Lookup value in name.  Also determine if name is a helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ( isLookup(name) ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>If the expression looks like a helper, try to get a helper right away.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (looksLikeAHelper) {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Try to find a registered helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					helper = mustacheHelpers.getHelper(name.get, options);</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>If a function is on top of the context, call that as a helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span>(!helper &amp;&amp; <span class="hljs-keyword">typeof</span> context[name.get] === <span class="hljs-string">"function"</span>) {
						helper = {fn: context[name.get]};
					}

				}</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>If a helper has not been found, either because this does not look like a helper
or because a helper was not found, get the value of name and determine 
if it’s a value or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span>(!helper) {
					<span class="hljs-keyword">var</span> get = name.get;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Get info about the compute that represents this lookup.
This way, we can get the initial value without “reading” the compute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> computeData = getKeyComputeData(name.get, scope, <span class="hljs-literal">false</span>),
						compute = computeData.compute;
						
					initialValue = computeData.initialValue;</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Optimize for a simple attribute read.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span>(computeData.reads &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>a single property read</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						computeData.reads.length === <span class="hljs-number">1</span> &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>on a map</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						computeData.root <span class="hljs-keyword">instanceof</span> can.Map &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>that isn’t calling a function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						!can.isFunction(computeData.root[computeData.reads[<span class="hljs-number">0</span>]]) ) {
						compute = can.compute(computeData.root, computeData.reads[<span class="hljs-number">0</span>]);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Set name to be the compute if the compute reads observables,
or the value of the value of the compute if no observables are found.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span>(computeData.compute.hasDependencies) {
						name = compute;
					} <span class="hljs-keyword">else</span> {
						name = initialValue;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>If it doesn’t look like a helper and there is no value, check helpers
anyway. This is for when foo is a helper in <code>{{foo}}</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span>( !looksLikeAHelper &amp;&amp; initialValue === <span class="hljs-literal">undefined</span> ) {
						helper = mustacheHelpers.getHelper(get, options);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Otherwise, if the value is a function, we’ll call that as a helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> initialValue === <span class="hljs-string">"function"</span>) {
						helper = {
							fn: initialValue
						};
					}

				}</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>!steal-remove-start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> ( !helper &amp;&amp; initialValue === <span class="hljs-literal">undefined</span>) {
					<span class="hljs-keyword">if</span>(looksLikeAHelper) {
						can.dev.warn(<span class="hljs-string">'can/view/stache/mustache_core.js: Unable to find helper "'</span> + exprData.name.get + <span class="hljs-string">'".'</span>);
					} <span class="hljs-keyword">else</span> {
						can.dev.warn(<span class="hljs-string">'can/view/stache/mustache_core.js: Unable to find key or helper "'</span> + exprData.name.get + <span class="hljs-string">'".'</span>);
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>!steal-remove-end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			}</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>If inverse mode, reverse renderers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(mode === <span class="hljs-string">"^"</span>) {
				<span class="hljs-keyword">var</span> temp = truthyRenderer;
				truthyRenderer = falseyRenderer;
				falseyRenderer = temp;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Check for a registered helper or a helper-like function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ( helper ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Add additional data to be used by helper functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				convertToScopes(helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer);

				can.simpleExtend(helperOptions, {
					context: context,
					scope: scope,
					contexts: scope,
					hash: hash,
					nodeList: nodeList
				});

				args.push(helperOptions);</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Call the helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
					<span class="hljs-keyword">return</span> helper.fn.apply(context, args) || <span class="hljs-string">''</span>;
				};

			}</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Return evaluators for no mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(!mode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>If it’s computed, return a function that just reads the compute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span>(name &amp;&amp; name.isComputed) {
					<span class="hljs-keyword">return</span> name;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Just return name as the value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">else</span> {
					
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
						<span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + (name != <span class="hljs-literal">null</span> ? name : <span class="hljs-string">''</span>);
					};
				}
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( mode === <span class="hljs-string">"#"</span> || mode === <span class="hljs-string">"^"</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Setup renderers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				convertToScopes(helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer);
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>Get the value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> value;
					<span class="hljs-keyword">if</span> (can.isFunction(name) &amp;&amp; name.isComputed) {
						value = name();
					} <span class="hljs-keyword">else</span> {
						value = name;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>If it’s an array, render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (utils.isArrayLike(value) ) {
						<span class="hljs-keyword">var</span> isObserveList = utils.isObserveLike(value);
						
						<span class="hljs-keyword">if</span>(isObserveList ? value.attr(<span class="hljs-string">"length"</span>) : value.length) {
							<span class="hljs-keyword">return</span> (stringOnly ? getItemsStringContent: getItemsFragContent  )
								(value, isObserveList, helperOptions, options);
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> helperOptions.inverse(scope, options);
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>If truthy, render fn, otherwise, inverse.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> value ? helperOptions.fn(value || scope, options) : helperOptions.inverse(scope, options);
					}
				};
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>not supported!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h2 id="mustachecore-makelivebindingpartialrenderer">mustacheCore.makeLiveBindingPartialRenderer</h2>
<p>Returns a renderer function that live binds a partial.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Returns a renderer function that live binds a partial.
		 * @param {String} partialName the name of the partial.
		 * @return {function(this:HTMLElement,can.view.Scope,can.view.Options)} A renderer function 
		 * live binds a partial.
		 */</span>
		makeLiveBindingPartialRenderer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(partialName, state)</span></span>{
			partialName = can.trim(partialName);

			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(scope, options, parentSectionNodeList)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Look up partials in options first.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> partial = options.attr(<span class="hljs-string">"partials."</span> + partialName),
					res;
				<span class="hljs-keyword">if</span> (partial) {
					res = partial.render ? partial.render(scope, options) :
						partial(scope, options);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Use can.view to get and render the partial.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">else</span> {
					
					res = can.view.render(partialName, scope, options );
				}

				res = can.frag(res);

				<span class="hljs-keyword">var</span> nodeList = [<span class="hljs-keyword">this</span>];

				nodeLists.register(nodeList, <span class="hljs-literal">null</span>, state.directlyNested ? parentSectionNodeList || <span class="hljs-literal">true</span> :  <span class="hljs-literal">true</span>);
				nodeLists.update(nodeList, res.childNodes);
				elements.replace([<span class="hljs-keyword">this</span>], res);
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <h2 id="mustachecore-makestringbranchrenderer">mustacheCore.makeStringBranchRenderer</h2>
<p>Return a renderer function that evalutes to a string and caches
the evaluator on the scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Return a renderer function that evaluates to a string.
		 * @param {String} mode
		 * @param {can.mustache.Expression} expression
		 * @return {function(can.view.Scope,can.view.Options, can.view.renderer, can.view.renderer)} 
		 */</span>
		makeStringBranchRenderer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mode, expression)</span></span>{
			<span class="hljs-keyword">var</span> exprData = expressionData(expression),</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Use the full mustache expression as the cache key.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				fullExpression = mode+expression;</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>A branching renderer takes truthy and falsey renderer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">branchRenderer</span><span class="hljs-params">(scope, options, truthyRenderer, falseyRenderer)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Check the scope’s cache if the evaluator already exists for performance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> evaluator = scope.__cache[fullExpression];
				<span class="hljs-keyword">if</span>(mode || !evaluator) {
					evaluator = makeEvaluator( scope, options, <span class="hljs-literal">null</span>, mode, exprData, truthyRenderer, falseyRenderer, <span class="hljs-literal">true</span>);
					<span class="hljs-keyword">if</span>(!mode) {
						scope.__cache[fullExpression] = evaluator;
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Run the evaluator and return the result.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> res = evaluator();
				<span class="hljs-keyword">return</span> res == <span class="hljs-literal">null</span> ? <span class="hljs-string">""</span> : <span class="hljs-string">""</span>+res;
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <h2 id="mustachecore-makelivebindingbranchrenderer">mustacheCore.makeLiveBindingBranchRenderer</h2>
<p>Return a renderer function that evaluates the mustache expression and 
sets up live binding if a compute with dependencies is found. Otherwise,
the element’s value is set.</p>
<p>This function works by creating a <code>can.compute</code> from the mustache expression.
If the compute has dependent observables, it passes the compute to <code>can.view.live</code>; otherwise,
it updates the element’s property based on the compute’s value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Returns a renderer function that evaluates the mustache expression.
		 * @param {String} mode
		 * @param {can.mustache.Expression} expression
		 * @param {Object} state The html state of where the expression was found.
		 */</span>
		makeLiveBindingBranchRenderer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mode, expression, state)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Pre-process the expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> exprData = expressionData(expression);</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>A branching renderer takes truthy and falsey renderer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">branchRenderer</span><span class="hljs-params">(scope, options, parentSectionNodeList, truthyRenderer, falseyRenderer)</span></span>{
				
				<span class="hljs-keyword">var</span> nodeList = [<span class="hljs-keyword">this</span>];
				nodeList.expression = expression;</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>register this nodeList.
Regsiter it with its parent ONLY if this is directly nested.  Otherwise, it’s unencessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				nodeLists.register(nodeList, <span class="hljs-literal">null</span>, state.directlyNested ? parentSectionNodeList || <span class="hljs-literal">true</span> :  <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Get the evaluator. This does not need to be cached (probably) because if there
an observable value, it will be handled by <code>can.view.live</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> evaluator = makeEvaluator( scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer,</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>If this is within a tag, make sure we only get string values. </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					state.tag );</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Create a compute that can not be observed by other 
comptues. This is important because this renderer is likely called by 
parent expresions.  If this value changes, the parent expressions should
not re-evaluate. We prevent that by making sure this compute is ignored by 
everyone else.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> compute = can.compute(evaluator, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Bind on the compute to set the cached value. This helps performance
so live binding can read a cached value instead of re-calculating.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				compute.bind(<span class="hljs-string">"change"</span>, can.k);
				<span class="hljs-keyword">var</span> value = compute();</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>If value is a function, it’s a helper that returned a function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"function"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>A helper function should do it’s own binding.  Similar to how
we prevented this function’s compute from being noticed by parent expressions,
we hide any observables read in the function by saving any observables that
have been read and then setting them back which overwrites any <code>can.__reading</code> calls
performed in value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> old = can.__clearReading();
					value(<span class="hljs-keyword">this</span>);
					can.__setReading(old);
					
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>If the compute has observable dependencies, setup live binding.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( compute.hasDependencies ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Depending on where the template is, setup live-binding differently.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span>(state.attr) {
						live.simpleAttribute(<span class="hljs-keyword">this</span>, state.attr, compute);
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( state.tag )  {
						live.attributes( <span class="hljs-keyword">this</span>, compute );
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state.text &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">"object"</span>){
						live.text(<span class="hljs-keyword">this</span>, compute, <span class="hljs-keyword">this</span>.parentNode, nodeList);
					}
					<span class="hljs-keyword">else</span> {
						live.html(<span class="hljs-keyword">this</span>, compute, <span class="hljs-keyword">this</span>.parentNode, nodeList);
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>If the compute has no observable dependencies, just set the value on the element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">else</span> {
					
					<span class="hljs-keyword">if</span>(state.attr) {
						can.attr.set(<span class="hljs-keyword">this</span>, state.attr, value);
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state.tag) {
						live.setAttributes(<span class="hljs-keyword">this</span>, value);
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state.text &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"string"</span>) {
						<span class="hljs-keyword">this</span>.nodeValue = value;
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( value ){
						elements.replace([<span class="hljs-keyword">this</span>], can.frag(value));
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>Unbind the compute. </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				compute.unbind(<span class="hljs-string">"change"</span>, can.k);
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <h2 id="mustachecore-splitmodefromexpression">mustacheCore.splitModeFromExpression</h2>
<p>Returns the mustache mode split from the rest of the expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Returns the mustache mode split from the rest of the expression.
		 * @param {can.mustache.Expression} expression
		 * @param {Object} state The state of HTML where the expression was found.
		 */</span>
		splitModeFromExpression: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expression, state)</span></span>{
			expression = can.trim(expression);
			<span class="hljs-keyword">var</span> mode = expression.charAt(<span class="hljs-number">0</span>);
	
			<span class="hljs-keyword">if</span>( <span class="hljs-string">"#/{&amp;^&gt;!"</span>.indexOf(mode) &gt;= <span class="hljs-number">0</span> ) {
				expression = can.trim( expression.substr(<span class="hljs-number">1</span>) );
			} <span class="hljs-keyword">else</span> {
				mode = <span class="hljs-literal">null</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Triple braces do nothing within a tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(mode === <span class="hljs-string">"{"</span> &amp;&amp; state.node) {
				mode = <span class="hljs-literal">null</span>;
			}
			<span class="hljs-keyword">return</span> {
				mode: mode,
				expression: expression
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <h2 id="mustachecore-cleanlineendings">mustacheCore.cleanLineEndings</h2>
<p>Removes line breaks accoding to the mustache specification.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Prunes line breaks accoding to the mustache specification.
		 * @param {String} template
		 * @return {String}
		 */</span>
		cleanLineEndings: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(template)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Finds mustache tags with space around them or no space around them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> template.replace( mustacheLineBreakRegExp,
				<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(whole,
					returnBefore,
					spaceBefore,
					special,
					expression,
					spaceAfter,
					returnAfter,
</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>A mustache magic tag that has no space around it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					spaceLessSpecial,
					spaceLessExpression,
					matchIndex){</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>IE 8 will provide undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				spaceAfter = (spaceAfter || <span class="hljs-string">""</span>);
				returnBefore = (returnBefore || <span class="hljs-string">""</span>);
				spaceBefore = (spaceBefore || <span class="hljs-string">""</span>);
				
				<span class="hljs-keyword">var</span> modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>If it’s a partial or tripple stache, leave in place.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span>(spaceLessSpecial || <span class="hljs-string">"&gt;{"</span>.indexOf( modeAndExpression.mode) &gt;= <span class="hljs-number">0</span>) {
					<span class="hljs-keyword">return</span> whole;
				}  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-string">"^#!/"</span>.indexOf(  modeAndExpression.mode ) &gt;= <span class="hljs-number">0</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>Return the magic tag and a trailing linebreak if this did not 
start a new line and there was an end line.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> special+( matchIndex !== <span class="hljs-number">0</span> &amp;&amp; returnAfter.length ? returnBefore+<span class="hljs-string">"\n"</span> :<span class="hljs-string">""</span>);

							
				} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>There is no mode, return special with spaces around it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== <span class="hljs-number">0</span> ? returnBefore+<span class="hljs-string">"\n"</span> : <span class="hljs-string">""</span>);
				}
				
			});
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <h2 id="can-view-options">can.view.Options</h2>
<p>This contains the local helpers, partials, and tags available to a template.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * The Options scope.
		 */</span>
		Options: can.view.Scope.extend({
			init: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, parent)</span> </span>{
				<span class="hljs-keyword">if</span> (!data.helpers &amp;&amp; !data.partials &amp;&amp; !data.tags) {
					data = {
						helpers: data
					};
				}
				can.view.Scope.prototype.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			}
		})
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <h2 id="local-variable-cache">Local Variable Cache</h2>
<p>The following creates slightly more quickly accessible references of the following
core functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> makeEvaluator = core.makeEvaluator,
		expressionData = core.expressionData,
		splitModeFromExpression = core.splitModeFromExpression;
	
	
	<span class="hljs-keyword">return</span> core;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
