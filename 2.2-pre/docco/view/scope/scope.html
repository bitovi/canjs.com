<!DOCTYPE html>

<html>
<head>
  <title>can/view/scope/scope.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="can-view-scope-scope-js">can/view/scope/scope.js</h1>
<p>This allows you to define a lookup context and parent contexts that a key’s value can be retrieved from.
If no parent scope is provided, only the scope’s context will be explored for values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
steal(
	<span class="hljs-string">'can/util'</span>,
	<span class="hljs-string">'can/construct'</span>,
	<span class="hljs-string">'can/map'</span>,
	<span class="hljs-string">'can/list'</span>,
	<span class="hljs-string">'can/view'</span>,
	<span class="hljs-string">'can/compute'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(can)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="helpers">Helpers</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Regex for escaped periods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> escapeReg = <span class="hljs-regexp">/(\\)?\./g</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Regex for double escaped periods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			escapeDotReg = <span class="hljs-regexp">/\\\./g</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p><strong>getNames</strong>
Returns array of names by splitting provided string by periods and single escaped periods.
<code>getNames(&quot;a.b\.c.d\\.e&quot;) //-&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d.e&#39;]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			getNames = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attr)</span> </span>{
				<span class="hljs-keyword">var</span> names = [],
					last = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Goes through attr string and places the characters found between the periods and single escaped periods into the
<code>names</code> array.  Double escaped periods are ignored.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				attr.replace(escapeReg, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(first, second, index)</span> </span>{
					<span class="hljs-comment">/* If period is double escaped then leave in place */</span>
					<span class="hljs-keyword">if</span> (!second) {
						names.push(
							attr
								.slice(last, index)
								<span class="hljs-comment">/* replaces double-escaped period with period */</span>
								.replace(escapeDotReg, <span class="hljs-string">'.'</span>)
						);
						last = index + first.length;
					}
				});
				<span class="hljs-comment">/* Adds last portion of attr to names array */</span>
				names.push(
					attr
						.slice(last)
						<span class="hljs-comment">/* replaces double-escaped period with period */</span>
						.replace(escapeDotReg, <span class="hljs-string">'.'</span>)
				);
				<span class="hljs-keyword">return</span> names;
			};

		<span class="hljs-comment">/**
		 * @add can.view.Scope
		 */</span>
		<span class="hljs-keyword">var</span> Scope = can.Construct.extend(

			<span class="hljs-comment">/**
			 * @static
			 */</span>
			{</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2 id="scope-read">Scope.read</h2>
<p>Scope.read was moved to can.compute.read
can.compute.read reads properties from a parent.  A much more complex version of getObject.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				read: can.compute.read
			},
			<span class="hljs-comment">/**
			 * @prototype
			 */</span>
			{
				init: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(context, parent)</span> </span>{
					<span class="hljs-keyword">this</span>._context = context;
					<span class="hljs-keyword">this</span>._parent = parent;
					<span class="hljs-keyword">this</span>.__cache = {};
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2 id="scope-prototype-attr">Scope.prototype.attr</h2>
<p>Reads a value from the current context or parent contexts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				attr: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, value)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Reads for whatever called before attr.  It’s possible
that this.read clears them.  We want to restore them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> previousReads = can.__clearReading(),
						res = <span class="hljs-keyword">this</span>.read(key, {
							isArgument: <span class="hljs-literal">true</span>,
							returnObserveMethods: <span class="hljs-literal">true</span>,
							proxyMethods: <span class="hljs-literal">false</span>
						});</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Allow setting a value on the context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) {
						<span class="hljs-keyword">var</span> lastIndex = key.lastIndexOf(<span class="hljs-string">'.'</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Either get the paren of a key or the current context object with <code>.</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							readKey = lastIndex !== -<span class="hljs-number">1</span> ? key.substring(<span class="hljs-number">0</span>, lastIndex) : <span class="hljs-string">'.'</span>,
							obj = <span class="hljs-keyword">this</span>.read(readKey, {
								isArgument: <span class="hljs-literal">true</span>,
								returnObserveMethods: <span class="hljs-literal">true</span>,
								proxyMethods: <span class="hljs-literal">false</span>
							}).value;

						<span class="hljs-keyword">if</span>(lastIndex !== -<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Get the last part of the key which is what we want to set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							key = key.substring(lastIndex + <span class="hljs-number">1</span>, key.length);
						}

						can.compute.set(obj, key, value);
					}

					can.__setReading(previousReads);
					<span class="hljs-keyword">return</span> res.value;
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h2 id="scope-prototype-add">Scope.prototype.add</h2>
<p>Creates a new scope and sets the current scope to be the parent.</p>
<pre><code><span class="hljs-keyword">var</span> scope = <span class="hljs-keyword">new</span> can.view.Scope([{name:<span class="hljs-string">"Chris"</span>}, {name: <span class="hljs-string">"Justin"</span>}]).add({name: <span class="hljs-string">"Brian"</span>});
scope.attr(<span class="hljs-string">"name"</span>) <span class="hljs-comment">//-&gt; "Brian"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>				add: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(context)</span> </span>{
					<span class="hljs-keyword">if</span> (context !== <span class="hljs-keyword">this</span>._context) {
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor(context, <span class="hljs-keyword">this</span>);
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
					}
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h2 id="scope-prototype-computedata">Scope.prototype.computeData</h2>
<p>Finds the first location of the key in the scope and then provides a get-set compute that represents the key’s value
and other information about where the value was found.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				computeData: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, options)</span> </span>{
					options = options || {
						args: []
					};
					<span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>,
						rootObserve,
						rootReads,
						computeData = {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>computeData.compute returns a get-set compute that is tied to the first location of the provided
key in the context of the scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							compute: can.compute(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newVal)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p><strong>Compute setter</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length) {
									<span class="hljs-keyword">if</span>(rootObserve.isComputed) {
										rootObserve(newVal);
									} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rootReads.length) {
										<span class="hljs-keyword">var</span> last = rootReads.length - <span class="hljs-number">1</span>;
										<span class="hljs-keyword">var</span> obj = rootReads.length ? can.compute.read(rootObserve, rootReads.slice(<span class="hljs-number">0</span>, last)).value
											: rootObserve;
										can.compute.set(obj, rootReads[last], newVal);
									}</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p><strong>Compute getter</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>If computeData has found the value for the key in the past in an observable then go directly to
the observable (rootObserve) that the value was found in the last time and return the new value.  This
is a huge performance gain for the fact that we aren’t having to check the entire scope each time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">if</span> (rootObserve) {
										<span class="hljs-keyword">return</span> can.compute.read(rootObserve, rootReads, options)
											.value;
									}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>If the key has not already been located in a observable then we need to search the scope for the
key.  Once we find the key then we need to return it’s value and if it is found in an observable
then we need to store the observable so the next time this compute is called it can grab the value
directly from the observable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">var</span> data = self.read(key, options);
									rootObserve = data.rootObserve;
									rootReads = data.reads;
									computeData.scope = data.scope;
									computeData.initialValue = data.value;
									computeData.reads = data.reads;
									computeData.root = rootObserve;
									<span class="hljs-keyword">return</span> data.value;
								}
							})
						};
					<span class="hljs-keyword">return</span> computeData;
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h2 id="scope-prototype-compute">Scope.prototype.compute</h2>
<p>Provides a get-set compute that represents a key’s value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				compute: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, options)</span> </span>{
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.computeData(key, options)
						.compute;
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h2 id="scope-prototype-read">Scope.prototype.read</h2>
<p>Finds the first isntance of a key in the available scopes and returns the keys value along with the the observable the key
was found in, readsData and the current scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/**
				 * @hide
				 * @param {can.mustache.key} attr A dot seperated path.  Use `"\."` if you have a property name that includes a dot.
				 * @param {can.view.Scope.readOptions} options that configure how this gets read.
				 * @return {{}}
				 * @option {Object} parent the value's immediate parent
				 * @option {can.Map|can.compute} rootObserve the first observable to read from.
				 * @option {Array&lt;String&gt;} reads An array of properties that can be used to read from the rootObserve to get the value.
				 * @option {*} value the found value
				 */</span>
				read: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attr, options)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>check if we should only look within current scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> stopLookup;
					<span class="hljs-keyword">if</span>(attr.substr(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) === <span class="hljs-string">'./'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>set flag to halt lookup from walking up scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						stopLookup = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>stop lookup from checking parent scopes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						attr = attr.substr(<span class="hljs-number">2</span>);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>check if we should be running this on a parent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attr.substr(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) === <span class="hljs-string">"../"</span>) {
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._parent.read(attr.substr(<span class="hljs-number">3</span>), options);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attr === <span class="hljs-string">".."</span>) {
						<span class="hljs-keyword">return</span> {
							value: <span class="hljs-keyword">this</span>._parent._context
						};
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attr === <span class="hljs-string">"."</span> || attr === <span class="hljs-string">"this"</span>) {
						<span class="hljs-keyword">return</span> {
							value: <span class="hljs-keyword">this</span>._context
						};
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Array of names from splitting attr string into names.  <code>&quot;a.b\.c.d\\.e&quot; //-&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d.e&#39;]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> names = attr.indexOf(<span class="hljs-string">'\\.'</span>) === -<span class="hljs-number">1</span> ?</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Reference doesn’t contain escaped periods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							attr.split(<span class="hljs-string">'.'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Reference contains escaped periods <code>(`a.b\.c.foo` == `a[&quot;b.c&quot;].foo)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							: getNames(attr),</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>The current context (a scope is just data and a parent scope).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						context,</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>The current scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						scope = <span class="hljs-keyword">this</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>While we are looking for a value, we track the most likely place this value will be found.
This is so if there is no me.name.first, we setup a listener on me.name.
The most likely candidate is the one with the most “read matches” “lowest” in the
context chain.
By “read matches”, we mean the most number of values along the key.
By “lowest” in the context chain, we mean the closest to the current context.
We track the starting position of the likely place with <code>defaultObserve</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						defaultObserve,</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Tracks how to read from the defaultObserve.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						defaultReads = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Tracks the highest found number of “read matches”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						defaultPropertyDepth = -<span class="hljs-number">1</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><code>scope.read</code> is designed to be called within a compute, but
for performance reasons only listens to observables within one context.
This is to say, if you have me.name in the current context, but me.name.first and
we are looking for me.name.first, we don’t setup bindings on me.name and me.name.first.
To make this happen, we clear readings if they do not find a value.  But,
if that path turns out to be the default read, we need to restore them.  This
variable remembers those reads so they can be restored.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						defaultComputeReadings,</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Tracks the default’s scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						defaultScope,</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Tracks the first found observe.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						currentObserve,</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Tracks the reads to get the value for a scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						currentReads;</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Goes through each scope context provided until it finds the key (attr).  Once the key is found
then it’s value is returned along with an observe, the current scope and reads.
While going through each scope context searching for the key, each observable found is returned and
saved so that either the observable the key is found in can be returned, or in the case the key is not
found in an observable the closest observable can be returned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
					<span class="hljs-keyword">while</span> (scope) {
						context = scope._context;
						<span class="hljs-keyword">if</span> (context !== <span class="hljs-literal">null</span>) {
							<span class="hljs-keyword">var</span> data = can.compute.read(context, names, can.simpleExtend({
								<span class="hljs-comment">/* Store found observable, incase we want to set it as the rootObserve. */</span>
								foundObservable: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(observe, nameIndex)</span> </span>{
									currentObserve = observe;
									currentReads = names.slice(nameIndex);
								},</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Called when we were unable to find a value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								earlyExit: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(parentValue, nameIndex)</span> </span>{
									<span class="hljs-comment">/* If this has more matching values */</span>
									<span class="hljs-keyword">if</span> (nameIndex &gt; defaultPropertyDepth) {
										defaultObserve = currentObserve;
										defaultReads = currentReads;
										defaultPropertyDepth = nameIndex;
										defaultScope = scope;
										<span class="hljs-comment">/* Clear and save readings so next attempt does not use these readings */</span>
										defaultComputeReadings = can.__clearReading();
									}
								},</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Execute anonymous functions found along the way</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								executeAnonymousFunctions: <span class="hljs-literal">true</span>
							}, options));</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p><strong>Key was found</strong>, return value and location data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (data.value !== <span class="hljs-literal">undefined</span>) {
								<span class="hljs-keyword">return</span> {
									scope: scope,
									rootObserve: currentObserve,
									value: data.value,
									reads: currentReads
								};
							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Prevent prior readings and then move up to the next scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						can.__clearReading();
						<span class="hljs-keyword">if</span>(!stopLookup) {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Move up to the next scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							scope = scope._parent;
						} <span class="hljs-keyword">else</span> {
							scope = <span class="hljs-literal">null</span>;
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p><strong>Key was not found</strong>, return undefined for the value.  Unless an observable was
found in the process of searching for the key, then return the most likely observable along with it’s
scope and reads.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
					<span class="hljs-keyword">if</span> (defaultObserve) {
						can.__setReading(defaultComputeReadings);
						<span class="hljs-keyword">return</span> {
							scope: defaultScope,
							rootObserve: defaultObserve,
							reads: defaultReads,
							value: <span class="hljs-literal">undefined</span>
						};
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> {
							names: names,
							value: <span class="hljs-literal">undefined</span>
						};
					}
				}
			});

		can.view.Scope = Scope;
		<span class="hljs-keyword">return</span> Scope;
	});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
