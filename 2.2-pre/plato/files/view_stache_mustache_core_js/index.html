<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>view/stache/mustache_core.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">61.21</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">631</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">67.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">4.48</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// # can/view/stache/mustache_core.js
// 
// This provides helper utilities for Mustache processing. Currently,
// only stache uses these helpers.  Ideally, these utilities could be used
// in other libraries implementing Mustache-like features.  

steal(&quot;can/util&quot;,
	&quot;./utils&quot;,
	&quot;./mustache_helpers&quot;,
	&quot;can/view/live&quot;,
	&quot;can/view/elements.js&quot;,
	&quot;can/view/scope&quot;,
	&quot;can/view/node_lists&quot;,
	function(can, utils, mustacheHelpers, live, elements, Scope, nodeLists ){

	live = live || can.view.live;
	elements = elements || can.view.elements;
	Scope = Scope || can.view.Scope;
	nodeLists = nodeLists || can.view.nodeLists;
	
	// ## Types
	
	// A lookup is an object that is used to identify a lookup in the scope.
	/**
	 * @hide
	 * @typedef {{get: String}} can.mustache.Lookup
	 * @option {String} get A value in the scope to look up.
	 */
	

	// ## Helpers
	
	// Breaks up the name and arguments of a mustache expression.
	var argumentsRegExp = /((([^&#039;&quot;\s]+?=)?(&#039;.*?&#039;|&quot;.*?&quot;))|.*?)\s/g,
		// Identifies the type of an argument or hash in a mustache expression.
		literalNumberStringBooleanRegExp = /^(?:(?:(&#039;.*?&#039;|&quot;.*?&quot;)|([0-9]+\.?[0-9]*|true|false|null|undefined))|(?:(.+?)=(?:(?:(&#039;.*?&#039;|&quot;.*?&quot;)|([0-9]+\.?[0-9]*|true|false|null|undefined))|(.+))))$/,
		// Finds mustache tags and their surrounding whitespace.
		mustacheLineBreakRegExp = /(?:(?:^|(\r?)\n)(\s*)(\{\{([^\}]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([^\}]*)\}\}\}?)/g,
		// Identifies if an argument value should be looked up.
		isLookup = function (obj) {
			return obj &amp;&amp; typeof obj.get === &quot;string&quot;;
		},
		// A helper for calling the truthy subsection for each item in a list and putting them in a document Fragment.
		getItemsFragContent = function(items, isObserveList, helperOptions, options){
			var frag = document.createDocumentFragment();
			for (var i = 0, len = items.length; i &lt; len; i++) {
				append(frag, helperOptions.fn( isObserveList ? items.attr(&#039;&#039; + i) : items[i], options) );
			}
			return frag;
		},
		// Appends some content to a document fragment.  If the content is a string, it puts it in a TextNode.
		append = function(frag, content){
			if(content) {
				frag.appendChild(typeof content === &quot;string&quot; ? document.createTextNode(content) : content);
			}
		},
		// A helper for calling the truthy subsection for each item in a list and returning them in a string.
		getItemsStringContent = function(items, isObserveList, helperOptions, options){
			var txt = &quot;&quot;;
			for (var i = 0, len = items.length; i &lt; len; i++) {
				txt += helperOptions.fn( isObserveList ? items.attr(&#039;&#039; + i) : items[i], options);
			}
			return txt;
		},
		getKeyComputeData = function (key, scope, isArgument) {

			// Get a compute (and some helper data) that represents key&#039;s value in the current scope
			var data = scope.computeData(key, {
				isArgument: isArgument,
				args: [scope.attr(&#039;.&#039;), scope]
			});
			
			can.compute.temporarilyBind(data.compute);
			
			return data;
		},
		// Returns a value or compute for the given key.
		getKeyArgValue = function(key, scope){
			var data = getKeyComputeData(key, scope, true);
			// If there are no dependencies, just return the value.
			if (!data.compute.hasDependencies) {
				return data.initialValue;
			} else {
				return data.compute;
			}
		},
		// Sets .fn and .inverse on a helperOptions object and makes sure 
		// they can reference the current scope and options.
		convertToScopes = function(helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer){
			// overwrite fn and inverse to always convert to scopes
			if(truthyRenderer) {
				helperOptions.fn = makeRendererConvertScopes(truthyRenderer, scope, options, nodeList);
			}
			if(falseyRenderer) {
				helperOptions.inverse = makeRendererConvertScopes(falseyRenderer, scope, options, nodeList);
			}
		},
		// Returns a new renderer function that makes sure any data or helpers passed
		// to it are converted to a can.view.Scope and a can.view.Options.
		makeRendererConvertScopes = function (renderer, parentScope, parentOptions, nodeList) {
			var rendererWithScope = function(ctx, opts, parentNodeList){
				return renderer(ctx || parentScope, opts, parentNodeList);
			};
			return function (newScope, newOptions, parentNodeList) {
				// prevent binding on fn.
				var reads = can.__clearReading();
				// If a non-scope value is passed, add that to the parent scope.
				if (newScope !== undefined &amp;&amp; !(newScope instanceof can.view.Scope)) {
					newScope = parentScope.add(newScope);
				}
				if (newOptions !== undefined &amp;&amp; !(newOptions instanceof core.Options)) {
					newOptions = parentOptions.add(newOptions);
				}
				var result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList|| nodeList );
				can.__setReading(reads);
				return result;
			};
		};
	

	
	var core = {
		// ## mustacheCore.expressionData
		// Returns processed information about the arguments and hash in a mustache expression.
		/**
		 * @hide
		 * Returns processed information about the arguments and hash in a mustache expression.
		 * @param {can.mustache.Expression} An expression minus the mode like: `each items animate=&quot;in&quot;`
		 * @return {Object} Packaged info about the expression for faster processing.
		 * @option {can.mustache.Lookup|*} name The first key which is usually the name of a value or a helper to lookup.
		 * @option {Array&lt;can.mustache.Lookup|*&gt;} args An array of lookup values or JS literal values.
		 * @option {Object.&lt;String,can.mustache.Lookup|*&gt;} hashes A mapping of hash name to lookup values or JS literal values.
		 */
		expressionData: function(expression){
			var args = [],
				hashes = {},
				i = 0;
			
			(can.trim(expression) + &#039; &#039;).replace(argumentsRegExp, function (whole, arg) {
				var m;
				// Check for special helper arguments (string/number/boolean/hashes).
				if (i &amp;&amp; (m = arg.match(literalNumberStringBooleanRegExp))) {
					if(m[1] || m[2]) {
						args.push(utils.jsonParse(m[1] || m[2]));
					}
					// Found a hash object.
					else {
						// Addd to the hash object.
						hashes[m[3]] =  (m[6] ?  {get: m[6]} :  utils.jsonParse(m[4] || m[5]));
					}
				}
				// Otherwise output a normal interpolation reference.
				else {
					args.push({get: arg});
				}
				i++;
			});
			
			return {
				name: args.shift(),
				args: args,
				hash: hashes
			};
		},
		// ## mustacheCore.makeEvaluator
		// Given a scope and expression, returns a function that evaluates that expression in the scope. 
		// 
		// This function first reads lookup values in the args and hash.  Then it tries to figure out
		// if a helper is being called or a value is being read.  Finally, depending on
		// if it&#039;s a helper, or not, and which mode the expression is in, it returns
		// a function that can quickly evaluate the expression.
		/**
		 * @hide 
		 * Given a mode and expresion data, returns a function that evaluates that expression. 
		 * @param {can.view.Scope} The scope in which the expression is evaluated.
		 * @param {can.view.Options} The option helpers in which the expression is evaluated.
		 * @param {String} mode Either null, #, ^. &gt; is handled elsewhere
		 * @param {Object} exprData Data about what was in the mustache expression
		 * @param {renderer} [truthyRenderer] Used to render a subsection 
		 * @param {renderer} [falseyRenderer] Used to render the inverse subsection
		 * @param {String} [stringOnly] A flag to indicate that only strings will be returned by subsections.
		 * @return {Function} An &#039;evaluator&#039; function that evaluates the expression.
		 */
		makeEvaluator: function (scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {
			// Arguments for the helper.
			var args = [],
				// Hash values for helper.
				hash = {},
				// Helper options object.
				helperOptions = {
					fn: function () {},
					inverse: function () {}
				},
				// The current context.
				context = scope.attr(&quot;.&quot;),
				
				// The main value.
				name = exprData.name,
				
				// If name is a helper, this gets set to the helper.
				helper,
				// `true` if the expression looks like a helper.
				looksLikeAHelper = exprData.args.length || !can.isEmptyObject(exprData.hash),
				// The &quot;peaked&quot; at value of the name.
				initialValue;
				
			// Convert lookup values in arguments to actual values.
			for(var i = 0, len = exprData.args.length; i &lt; len; i++) {
				var arg = exprData.args[i];
				if (arg &amp;&amp; isLookup(arg)) {
					args.push(getKeyArgValue(arg.get, scope, true));
				} else {
					args.push(arg);
				}
			}
			// Convert lookup values in hash to actual values.
			for(var prop in exprData.hash) {
				if (isLookup(exprData.hash[prop])) {
					hash[prop] = getKeyArgValue(exprData.hash[prop].get, scope);
				} else {
					hash[prop] = exprData.hash[prop];
				}
			}

			// Lookup value in name.  Also determine if name is a helper.
			if ( isLookup(name) ) {
			
				// If the expression looks like a helper, try to get a helper right away.
				if (looksLikeAHelper) {
					// Try to find a registered helper.
					helper = mustacheHelpers.getHelper(name.get, options);
					
					// If a function is on top of the context, call that as a helper.
					if(!helper &amp;&amp; typeof context[name.get] === &quot;function&quot;) {
						helper = {fn: context[name.get]};
					}

				}
				// If a helper has not been found, either because this does not look like a helper
				// or because a helper was not found, get the value of name and determine 
				// if it&#039;s a value or not.
				if(!helper) {
					var get = name.get;
					
					// Get info about the compute that represents this lookup.
					// This way, we can get the initial value without &quot;reading&quot; the compute.
					var computeData = getKeyComputeData(name.get, scope, false),
						compute = computeData.compute;
						
					initialValue = computeData.initialValue;
					// Optimize for a simple attribute read.
					if(computeData.reads &amp;&amp;
						// a single property read
						computeData.reads.length === 1 &amp;&amp;
						// on a map
						computeData.root instanceof can.Map &amp;&amp;
						// that isn&#039;t calling a function
						!can.isFunction(computeData.root[computeData.reads[0]]) ) {
						compute = can.compute(computeData.root, computeData.reads[0]);
					}
					
					
					// Set name to be the compute if the compute reads observables,
					// or the value of the value of the compute if no observables are found.
					if(computeData.compute.hasDependencies) {
						name = compute;
					} else {
						name = initialValue;
					}

					// If it doesn&#039;t look like a helper and there is no value, check helpers
					// anyway. This is for when foo is a helper in `{{foo}}`.
					if( !looksLikeAHelper &amp;&amp; initialValue === undefined ) {
						helper = mustacheHelpers.getHelper(get, options);
					}
					// Otherwise, if the value is a function, we&#039;ll call that as a helper.
					else if(typeof initialValue === &quot;function&quot;) {
						helper = {
							fn: initialValue
						};
					}

				}
				//!steal-remove-start
				if ( !helper &amp;&amp; initialValue === undefined) {
					if(looksLikeAHelper) {
						can.dev.warn(&#039;can/view/stache/mustache_core.js: Unable to find helper &quot;&#039; + exprData.name.get + &#039;&quot;.&#039;);
					} else {
						can.dev.warn(&#039;can/view/stache/mustache_core.js: Unable to find key or helper &quot;&#039; + exprData.name.get + &#039;&quot;.&#039;);
					}
				}
				//!steal-remove-end
			}


			
			// If inverse mode, reverse renderers.
			if(mode === &quot;^&quot;) {
				var temp = truthyRenderer;
				truthyRenderer = falseyRenderer;
				falseyRenderer = temp;
			}
			
			// Check for a registered helper or a helper-like function.
			if ( helper ) {
				
				// Add additional data to be used by helper functions
				convertToScopes(helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer);

				can.simpleExtend(helperOptions, {
					context: context,
					scope: scope,
					contexts: scope,
					hash: hash,
					nodeList: nodeList
				});

				args.push(helperOptions);
				// Call the helper.
				return function () {
					return helper.fn.apply(context, args) || &#039;&#039;;
				};

			}
			
			// Return evaluators for no mode.
			if(!mode) {
				// If it&#039;s computed, return a function that just reads the compute.
				if(name &amp;&amp; name.isComputed) {
					return name;
				}
				// Just return name as the value
				else {
					
					return function(){
						return &#039;&#039; + (name != null ? name : &#039;&#039;);
					};
				}
			} else if( mode === &quot;#&quot; || mode === &quot;^&quot; ) {
				// Setup renderers.
				convertToScopes(helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer);
				return function(){
					// Get the value
					var value;
					if (can.isFunction(name) &amp;&amp; name.isComputed) {
						value = name();
					} else {
						value = name;
					}
					// If it&#039;s an array, render.
					if (utils.isArrayLike(value) ) {
						var isObserveList = utils.isObserveLike(value);
						
						if(isObserveList ? value.attr(&quot;length&quot;) : value.length) {
							return (stringOnly ? getItemsStringContent: getItemsFragContent  )
								(value, isObserveList, helperOptions, options);
						} else {
							return helperOptions.inverse(scope, options);
						}
					}
					// If truthy, render fn, otherwise, inverse.
					else {
						return value ? helperOptions.fn(value || scope, options) : helperOptions.inverse(scope, options);
					}
				};
			} else {
				// not supported!
			}
		},
		// ## mustacheCore.makeLiveBindingPartialRenderer
		// Returns a renderer function that live binds a partial.
		/**
		 * @hide
		 * Returns a renderer function that live binds a partial.
		 * @param {String} partialName the name of the partial.
		 * @return {function(this:HTMLElement,can.view.Scope,can.view.Options)} A renderer function 
		 * live binds a partial.
		 */
		makeLiveBindingPartialRenderer: function(partialName, state){
			partialName = can.trim(partialName);

			return function(scope, options, parentSectionNodeList){
				// Look up partials in options first.
				var partial = options.attr(&quot;partials.&quot; + partialName),
					res;
				if (partial) {
					res = partial.render ? partial.render(scope, options) :
						partial(scope, options);
				}
				// Use can.view to get and render the partial.
				else {
					
					res = can.view.render(partialName, scope, options );
				}

				res = can.frag(res);

				var nodeList = [this];

				nodeLists.register(nodeList, null, state.directlyNested ? parentSectionNodeList || true :  true);
				nodeLists.update(nodeList, res.childNodes);
				elements.replace([this], res);
			};
		},
		// ## mustacheCore.makeStringBranchRenderer
		// Return a renderer function that evalutes to a string and caches
		// the evaluator on the scope.
		/**
		 * @hide
		 * Return a renderer function that evaluates to a string.
		 * @param {String} mode
		 * @param {can.mustache.Expression} expression
		 * @return {function(can.view.Scope,can.view.Options, can.view.renderer, can.view.renderer)} 
		 */
		makeStringBranchRenderer: function(mode, expression){
			var exprData = expressionData(expression),
				// Use the full mustache expression as the cache key.
				fullExpression = mode+expression;

			// A branching renderer takes truthy and falsey renderer.
			return function branchRenderer(scope, options, truthyRenderer, falseyRenderer){
				// Check the scope&#039;s cache if the evaluator already exists for performance.
				var evaluator = scope.__cache[fullExpression];
				if(mode || !evaluator) {
					evaluator = makeEvaluator( scope, options, null, mode, exprData, truthyRenderer, falseyRenderer, true);
					if(!mode) {
						scope.__cache[fullExpression] = evaluator;
					}
				}

				// Run the evaluator and return the result.
				var res = evaluator();
				return res == null ? &quot;&quot; : &quot;&quot;+res;
			};
		},
		// ## mustacheCore.makeLiveBindingBranchRenderer
		// Return a renderer function that evaluates the mustache expression and 
		// sets up live binding if a compute with dependencies is found. Otherwise,
		// the element&#039;s value is set.
		//
		// This function works by creating a `can.compute` from the mustache expression.
		// If the compute has dependent observables, it passes the compute to `can.view.live`; otherwise,
		// it updates the element&#039;s property based on the compute&#039;s value.
		/**
		 * @hide
		 * Returns a renderer function that evaluates the mustache expression.
		 * @param {String} mode
		 * @param {can.mustache.Expression} expression
		 * @param {Object} state The html state of where the expression was found.
		 */
		makeLiveBindingBranchRenderer: function(mode, expression, state){
			
			// Pre-process the expression.
			var exprData = expressionData(expression);
			
			// A branching renderer takes truthy and falsey renderer.
			return function branchRenderer(scope, options, parentSectionNodeList, truthyRenderer, falseyRenderer){
				
				var nodeList = [this];
				nodeList.expression = expression;
				// register this nodeList.
				// Regsiter it with its parent ONLY if this is directly nested.  Otherwise, it&#039;s unencessary.
				nodeLists.register(nodeList, null, state.directlyNested ? parentSectionNodeList || true :  true);
				
				
				// Get the evaluator. This does not need to be cached (probably) because if there
				// an observable value, it will be handled by `can.view.live`.
				var evaluator = makeEvaluator( scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer,
					// If this is within a tag, make sure we only get string values. 
					state.tag );
				
				// Create a compute that can not be observed by other 
				// comptues. This is important because this renderer is likely called by 
				// parent expresions.  If this value changes, the parent expressions should
				// not re-evaluate. We prevent that by making sure this compute is ignored by 
				// everyone else.
				var compute = can.compute(evaluator, null, false, true);
				
				// Bind on the compute to set the cached value. This helps performance
				// so live binding can read a cached value instead of re-calculating.
				compute.bind(&quot;change&quot;, can.k);
				var value = compute();
				
				// If value is a function, it&#039;s a helper that returned a function.
				if(typeof value === &quot;function&quot;) {
					
					// A helper function should do it&#039;s own binding.  Similar to how
					// we prevented this function&#039;s compute from being noticed by parent expressions,
					// we hide any observables read in the function by saving any observables that
					// have been read and then setting them back which overwrites any `can.__reading` calls
					// performed in value.
					var old = can.__clearReading();
					value(this);
					can.__setReading(old);
					
				}
				// If the compute has observable dependencies, setup live binding.
				else if( compute.hasDependencies ) {
					
					// Depending on where the template is, setup live-binding differently.
					if(state.attr) {
						live.simpleAttribute(this, state.attr, compute);
					}
					else if( state.tag )  {
						live.attributes( this, compute );
					}
					else if(state.text &amp;&amp; typeof value !== &quot;object&quot;){
						live.text(this, compute, this.parentNode, nodeList);
					}
					else {
						live.html(this, compute, this.parentNode, nodeList);
					}
				}
				// If the compute has no observable dependencies, just set the value on the element.
				else {
					
					if(state.attr) {
						can.attr.set(this, state.attr, value);
					}
					else if(state.tag) {
						live.setAttributes(this, value);
					}
					else if(state.text &amp;&amp; typeof value === &quot;string&quot;) {
						this.nodeValue = value;
					}
					else if( value ){
						elements.replace([this], can.frag(value));
					}
				}
				// Unbind the compute. 
				compute.unbind(&quot;change&quot;, can.k);
			};
		},
		// ## mustacheCore.splitModeFromExpression
		// Returns the mustache mode split from the rest of the expression.
		/**
		 * @hide
		 * Returns the mustache mode split from the rest of the expression.
		 * @param {can.mustache.Expression} expression
		 * @param {Object} state The state of HTML where the expression was found.
		 */
		splitModeFromExpression: function(expression, state){
			expression = can.trim(expression);
			var mode = expression.charAt(0);
	
			if( &quot;#/{&amp;^&gt;!&quot;.indexOf(mode) &gt;= 0 ) {
				expression = can.trim( expression.substr(1) );
			} else {
				mode = null;
			}
			// Triple braces do nothing within a tag.
			if(mode === &quot;{&quot; &amp;&amp; state.node) {
				mode = null;
			}
			return {
				mode: mode,
				expression: expression
			};
		},
		// ## mustacheCore.cleanLineEndings
		// Removes line breaks accoding to the mustache specification.
		/**
		 * @hide
		 * Prunes line breaks accoding to the mustache specification.
		 * @param {String} template
		 * @return {String}
		 */
		cleanLineEndings: function(template){
			
			// Finds mustache tags with space around them or no space around them.
			return template.replace( mustacheLineBreakRegExp,
				function(whole,
					returnBefore,
					spaceBefore,
					special,
					expression,
					spaceAfter,
					returnAfter,
					// A mustache magic tag that has no space around it.
					spaceLessSpecial,
					spaceLessExpression,
					matchIndex){
				
				// IE 8 will provide undefined
				spaceAfter = (spaceAfter || &quot;&quot;);
				returnBefore = (returnBefore || &quot;&quot;);
				spaceBefore = (spaceBefore || &quot;&quot;);
				
				var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});
				
				// If it&#039;s a partial or tripple stache, leave in place.
				if(spaceLessSpecial || &quot;&gt;{&quot;.indexOf( modeAndExpression.mode) &gt;= 0) {
					return whole;
				}  else if( &quot;^#!/&quot;.indexOf(  modeAndExpression.mode ) &gt;= 0 ) {
					
					// Return the magic tag and a trailing linebreak if this did not 
					// start a new line and there was an end line.
					return special+( matchIndex !== 0 &amp;&amp; returnAfter.length ? returnBefore+&quot;\n&quot; :&quot;&quot;);

							
				} else {
					// There is no mode, return special with spaces around it.
					return spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+&quot;\n&quot; : &quot;&quot;);
				}
				
			});
		},
		// ## can.view.Options
		// 
		// This contains the local helpers, partials, and tags available to a template.
		/**
		 * @hide
		 * The Options scope.
		 */
		Options: can.view.Scope.extend({
			init: function (data, parent) {
				if (!data.helpers &amp;&amp; !data.partials &amp;&amp; !data.tags) {
					data = {
						helpers: data
					};
				}
				can.view.Scope.prototype.init.apply(this, arguments);
			}
		})
	};
	
	// ## Local Variable Cache
	//
	// The following creates slightly more quickly accessible references of the following
	// core functions.
	var makeEvaluator = core.makeEvaluator,
		expressionData = core.expressionData,
		splitModeFromExpression = core.splitModeFromExpression;
	
	
	return core;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
