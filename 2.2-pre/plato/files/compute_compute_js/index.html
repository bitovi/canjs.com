<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>compute/compute.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">65.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">731</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">98.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">4.70</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* jshint maxdepth:7*/

// # can.compute
// 
// `can.compute` allows creation of observable values
// from the result of a funciton. Any time an observable
// value that the function depends on changes, the
// function automatically updates. This enables creating
// observable data that relies on other sources, potentially
// multiple different ones. For instance, a `can.compute` is
// able to:
// - Combine a first and last name into a full name and update when either changes
// - Calculate the absolute value of an observable number, updating any time the observable number does
// - Specify complicated behavior for getting and setting a value, as well as how to handle changes

steal(&#039;can/util&#039;, &#039;can/util/bind&#039;, &#039;can/util/batch&#039;, function (can, bind) {

	// ## Reading Helpers
	//
	// The following methods are used to call a function that relies on
	// observable data and to track the observable events which should 
	// be listened to when changes occur.
	// To do this, [`can.__reading(observable, event)`](#can-__reading) is called to
	// &quot;broadcast&quot; the corresponding event on each read.
	// 
	// ### Observed
	//
	// An &quot;Observed&quot; is an object of observable objects and events that
	// a function relies on. These objects and events must be listened to
	// in order to determine when to check a function for updates.
	// This looks like the following:
	//
	//     { 
	//       &quot;map1|first&quot;: {obj: map, event: &quot;first&quot;},
	//       &quot;map1|last&quot; : {obj: map, event: &quot;last&quot;}
	//     }
	// 
	// Each object-event pair is mapped so no duplicates will be listed.

	// ### State
	// 
	// `can.__read` may call a function that calls `can.__read` again. For
	// example, a compute can read another compute. To track each compute&#039;s
	// `Observed` object (containing observable objects and events), we maintain
	// a stack of Observed values for each call to `__read`.
	var stack = [];

	// ### can.__read
	//
	// With a given function and context, calls the function
	// and returns the resulting value of the function as well
	// as the observable properties and events that were read.
	can.__read = function (func, self) {

		// Add an object that `can.__read` will write to.
		stack.push({});

		var value = func.call(self);

		// Example return value:
		// `{value: 100, observed: Observed}`
		return {
			value: value,
			observed: stack.pop()
		};
	};

	// ### can.__reading
	//
	// When an observable value is read, it must call `can.__reading` to 
	// broadcast which object and event should be listened to.
	can.__reading = function (obj, event) {
		// Add the observable object and the event
		// that was read to the `Observed` object on
		// the stack.
		if (stack.length) {
			stack[stack.length-1][obj._cid + &#039;|&#039; + event] = {
				obj: obj,
				event: event + &quot;&quot;
			};
		}

	};

	// ### can.__clearReading
	//
	// Clears and returns the current observables.
	// This can be used to access a value without 
	// it being handled as a regular `read`.
	can.__clearReading = function () {
		if (stack.length) {
			var ret = stack[stack.length-1];
			stack[stack.length-1] = {};
			return ret;
		}
	};
	// Specifies current observables.
	can.__setReading = function (o) {
		if (stack.length) {
			stack[stack.length-1] = o;
		}
	};
	can.__addReading = function(o){
		if (stack.length) {
			can.simpleExtend(stack[stack.length-1], o);
		}
	};

	// ## Section Name

	// ### getValueAndBind
	//
	// Calls a function and sets up bindings to call `onchanged`
	// when events from its &quot;Observed&quot; object are triggered.
	// Removes bindings from `oldObserved` that are no longer needed.
	// - func - the function to call.
	// - context - the `this` of the function.
	// - oldObserved - an object that contains what has already been bound to
	// - onchanged - the function to call when any change occurs
	var getValueAndBind = function (func, context, oldObserved, onchanged) {
		// Call the function, get the value as well as the observed objects and events
		var info = can.__read(func, context),
			// The objects-event pairs that must be bound to
			newObserveSet = info.observed;
		// Go through what needs to be observed.
		bindNewSet(oldObserved, newObserveSet, onchanged);
		unbindOldSet(oldObserved, onchanged);
		
		return info;
	};
	// This will not be optimized.
	var bindNewSet = function(oldObserved, newObserveSet, onchanged){
		for(var name in newObserveSet ) {
			bindOrPreventUnbinding(oldObserved, newObserveSet, name, onchanged);
		}
	};
	// This will be optimized.
	var bindOrPreventUnbinding = function(oldObserved, newObserveSet, name, onchanged){
		if( oldObserved[name] ) {
			// After binding is set up, values
			// in `oldObserved` will be unbound. So if a name
			// has already be observed, remove from `oldObserved`
			// to prevent this.
			delete oldObserved[name];
		} else {
			// If current name has not been observed, listen to it.
			var obEv = newObserveSet[name];
			obEv.obj.bind(obEv.event, onchanged);
		}
	};
	// Iterate through oldObserved, looking for observe/attributes
	// that are no longer being bound and unbind them.
	var unbindOldSet = function(oldObserved, onchanged){
		for (var name in oldObserved) {
			var obEv = oldObserved[name];
			obEv.obj.unbind(obEv.event, onchanged);
		}
	};
	
	// ### updateOnChange
	//
	// Fires a change event when a compute&#039;s value changes
	var updateOnChange = function(compute, newValue, oldValue, batchNum){
		// Only trigger event when value has changed
		if (newValue !== oldValue) {
			can.batch.trigger(compute, batchNum ? {type: &quot;change&quot;, batchNum: batchNum} : &#039;change&#039;, [
				newValue,
				oldValue
			]);
		}
	};
	
	// ###setupComputeHandlers
	//
	// Sets up handlers for a compute.
	// - compute - the compute to set up handlers for
	// - func - the getter/setter function for the compute
	// - context - the `this` for the compute
	// - setCachedValue - function for setting cached value
	//
	// Returns an object with `on` and `off` functions.
	var setupComputeHandlers = function(compute, func, context, setCachedValue) {
		var readInfo,
			onchanged,
			batchNum;
		
		return {
			// Set up handler for when the compute changes
			on: function(updater){
				if(!onchanged) {
					onchanged = function(ev){
						if (compute.bound &amp;&amp; (ev.batchNum === undefined || ev.batchNum !== batchNum) ) {
							// Keep the old value
							var oldValue = readInfo.value;
								
							// Get the new value
							readInfo = getValueAndBind(func, context, readInfo.observed, onchanged);

							// Call the updater with old and new values
							updater(readInfo.value, oldValue, ev.batchNum);
						
							batchNum = batchNum = ev.batchNum;
						}
					};
				}
				
				readInfo = getValueAndBind(func, context, {}, onchanged);
				
				setCachedValue(readInfo.value);
				
				compute.hasDependencies = !can.isEmptyObject(readInfo.observed);
			},
			// Remove handler for the compute
			off: function(updater){
				for (var name in readInfo.observed) {
					var ob = readInfo.observed[name];
					ob.obj.unbind(ob.event, onchanged);
				}
			}
		};
	};
	var setupSingleBindComputeHandlers = function(compute, func, context, setCachedValue) {
		var readInfo,
			oldValue,
			onchanged,
			batchNum;
		
		return {
			// Set up handler for when the compute changes
			on: function(updater){
				if(!onchanged) {
					onchanged = function(ev){
						if (compute.bound &amp;&amp; (ev.batchNum === undefined || ev.batchNum !== batchNum) ) {
							// Get the new value
							var reads = can.__clearReading();
							var newValue = func.call(context);
							can.__setReading(reads);
							// Call the updater with old and new values
							updater(newValue, oldValue, ev.batchNum);
							oldValue = newValue;
							batchNum = batchNum = ev.batchNum;
						}
					};
				}
				
				readInfo = getValueAndBind(func, context, {}, onchanged);
				oldValue = readInfo.value;
				
				setCachedValue(readInfo.value);
				
				compute.hasDependencies = !can.isEmptyObject(readInfo.observed);
			},
			// Remove handler for the compute
			off: function(updater){
				for (var name in readInfo.observed) {
					var ob = readInfo.observed[name];
					ob.obj.unbind(ob.event, onchanged);
				}
			}
		};
	};

	// ###isObserve
	//
	// Checks if an object is observable
	var isObserve = function (obj) {
		return obj instanceof can.Map || obj &amp;&amp; obj.__get;
	},
	// Instead of calculating whether anything is listening every time,
	// use a function to do nothing (which may be overwritten)
		k = function () {};

	// ## Creating a can.compute
	//
	// A `can.compute` can be created by
	// - [Specifying the getterSeter function](#specifying-gettersetter-function)
	// - [Observing a property of an object](#observing-a-property-of-an-object)
	// - [Specifying an initial value and a setter function](#specifying-an-initial-value-and-a-setter)
	// - [Specifying an initial value and how to read, update, and listen to changes](#specifying-an-initial-value-and-a-settings-object)
	// - [Simply specifying an initial value](#specifying-only-a-value)
	can.compute = function (getterSetter, context, eventName, bindOnce) {
	// ### Setting up
		// Do nothing if getterSetter is already a compute
		if (getterSetter &amp;&amp; getterSetter.isComputed) {
			return getterSetter;
		}
		// The computed object
		var computed,
			// The following functions are overwritten depending on how compute() is called
			// A method to set up listening
			on = k,
			// A method to teardown listening
			off = k,
			// Current cached value (valid only when bound is true)
			value,
			// How the value is read by default
			get = function () {
				return value;
			},
			// How the value is set by default
			set = function (newVal) {
				value = newVal;
			},
			setCached = set,
			// Save arguments for cloning
			args = [],
			// updater for when value is changed
			updater = function (newValue, oldValue, batchNum) {
				setCached(newValue);
				updateOnChange(computed, newValue,oldValue, batchNum);
			},
			// the form of the arguments
			form;
			
			
		// convert arguments to args to make V8 Happy
		for(var i = 0, arglen = arguments.length; i&lt; arglen; i++){
			args[i] = arguments[i];
		}
		
		computed = function (newVal) {
			// If the computed function is called with arguments,
			// a value should be set
			if (arguments.length) {
				// Save a reference to the old value
				var old = value;
				// Setter may return the value if setter
				// is for a value maintained exclusively by this compute.
				var setVal = set.call(context, newVal, old);
				// If the computed function has dependencies,
				// return the current value
				if (computed.hasDependencies) {
					return get.call(context);
				}
				// Setting may not fire a change event, in which case
				// the value must be read
				if (setVal === undefined) {
					value = get.call(context);
				} else {
					value = setVal;
				}
				// Fire the change
				updateOnChange(computed, value, old);
				return value;
			} else {
				// Another compute may bind to this `computed`
				if (stack.length &amp;&amp; computed.canReadForChangeEvent !== false) {

					// Tell the compute to listen to change on this computed
					// Use `can.__reading` to allow other compute to listen
					// for a change on this `computed`
					can.__reading(computed, &#039;change&#039;);
					// We are going to bind on this compute.
					// If we are not bound, we should bind so that
					// we don&#039;t have to re-read to get the value of this compute.
					if (!computed.bound) {
						can.compute.temporarilyBind(computed);
					}
				}
				// If computed is bound, use the cached value
				if (computed.bound) {
					return value;
				} else {
					return get.call(context);
				}
			}
		};
		// ###Specifying getterSetter function
		//
		// If `can.compute` is [called with a getterSetter function](http://canjs.com/docs/can.compute.html#sig_can_compute_getterSetter__context__),
		// override set and get
		if (typeof getterSetter === &#039;function&#039;) {
			// `can.compute(getterSetter, [context])`
			set = getterSetter;
			get = getterSetter;
			computed.canReadForChangeEvent = eventName === false ? false : true;
			
			var handlers = bindOnce ?
				setupSingleBindComputeHandlers(computed, getterSetter, context || this, setCached) :
				setupComputeHandlers(computed, getterSetter, context || this, setCached);
			on = handlers.on;
			off = handlers.off;
		
		// ###Observing a property of an object
		//
		// If `can.compute` is called with an 
		// [object, property name, and optional event name](http://canjs.com/docs/can.compute.html#sig_can_compute_object_propertyName__eventName__),
		// create a compute from a property of an object. This allows the
		// creation of a compute on objects that can be listened to with [`can.bind`](http://canjs.com/docs/can.bind.html)
		} else if (context) {
			if (typeof context === &#039;string&#039;) {
				// `can.compute(obj, &quot;propertyName&quot;, [eventName])`
				var propertyName = context,
					isObserve = getterSetter instanceof can.Map;
				if (isObserve) {
					computed.hasDependencies = true;
					var handler;
					get = function(){
						return getterSetter.attr(propertyName);
					};
					set = function(newValue){
						getterSetter.attr(propertyName, newValue);
					};
					on = function(update){
						handler = function(ev, newVal,oldVal){
							update(newVal,oldVal, ev.batchNum);
						};
						getterSetter.bind( eventName || propertyName, handler);
						// Set the cached value
						value = can.__read(get).value;
					};
					off = function(update){
						getterSetter.unbind( eventName || propertyName, handler);
					};
				} else {
					get = function(){
						return getterSetter[propertyName];
					};
					set = function(newValue){
						getterSetter[propertyName] = newValue;
					};
					
					on = function(update){
						handler = function () {
							update(get(), value);
						};
						can.bind.call(getterSetter, eventName || propertyName, handler);
						// use can.__read because
						// we should not be indicating that some parent
						// reads this property if it happens to be binding on it
						value = can.__read(get)
							.value;
					};
					off = function(update){
						can.unbind.call(getterSetter, eventName || propertyName, handler);
					};
				}
			// ###Specifying an initial value and a setter
			//
			// If `can.compute` is called with an [initial value and a setter function](http://canjs.com/docs/can.compute.html#sig_can_compute_initialValue_setter_newVal_oldVal__),
			// a compute that can adjust incoming values is set up.
			} else {
				// `can.compute(initialValue, setter)`
				if (typeof context === &#039;function&#039;) {
					
					value = getterSetter;
					set = context;
					context = eventName;
					form = &#039;setter&#039;;
                    // ###Specifying an initial value and a settings object
                    //
                    // If `can.compute` is called with an [initial value and optionally a settings object](http://canjs.com/docs/can.compute.html#sig_can_compute_initialValue__settings__),
                    // a can.compute is created that can optionally specify how to read,
                    // update, and listen to changes in dependent values. This form of
                    // can.compute can be used to derive a compute that derives its
                    // value from any source
				} else {
					// `can.compute(initialValue,{get:, set:, on:, off:})`
					
					
					value = getterSetter;
					var options = context,
						oldUpdater = updater;
						
					context = options.context || options;
					get = options.get || get;
					set = options.set || function(){
						return value;
					};
					// This is a &quot;hack&quot; to allow async computes.
					if(options.fn) {
						var fn = options.fn,
							data;
						// make sure get is called with the newVal, but not setter
						get = function(){
							return fn.call(context, value);
						};
						// Check the number of arguments the 
						// async function takes.
						if(fn.length === 0) {
							
							data = setupComputeHandlers(computed, fn, context, setCached);

						} else if(fn.length === 1){
							data = setupComputeHandlers(computed, function(){
								return fn.call(context, value);
							}, context, setCached);
						} else {
							updater = function(newVal){
								if(newVal !== undefined) {
									oldUpdater(newVal, value);
								}
							};
							data = setupComputeHandlers(computed, function(){
								var res = fn.call(context, value, function(newVal){
									oldUpdater(newVal, value);
								});
								// If undefined is returned, don&#039;t update the value.
								return res !== undefined ? res : value;
							}, context, setCached);
						}
						
							
						on = data.on;
						off = data.off;
					} else {
						updater = function(){
							var newVal = get.call(context);
							oldUpdater(newVal, value);
						};
					}
					
					on = options.on || on;
					off = options.off || off;
				}
			}
		// ###Specifying only a value
		//
		// If can.compute is called with an initialValue only,
		// reads to this value can be observed.
		} else {
			// `can.compute(initialValue)`
			value = getterSetter;
		}
		can.cid(computed, &#039;compute&#039;);
		return can.simpleExtend(computed, {
			/**
			 * @property {Boolean} can.computed.isComputed compute.isComputed
			 * @parent can.compute
			 * Whether the value of the compute has been computed yet.
			 */
			isComputed: true,
			_bindsetup: function () {
				this.bound = true;
				// Set up live-binding
				// While binding, this should not count as a read
				var oldReading = can.__clearReading();
				on.call(this, updater);
				// Restore &quot;Observed&quot; for reading
				can.__setReading(oldReading);
			},
			_bindteardown: function () {
				off.call(this, updater);
				this.bound = false;
			},
			/**
			 * @function can.computed.bind compute.bind
			 * @parent can.compute
			 * @description Bind an event handler to a compute.
			 * @signature `compute.bind(eventType, handler)`
			 * @param {String} eventType The event to bind this handler to.
			 * The only event type that computes emit is _change_.
			 * @param {function({Object},{*},{*})} handler The handler to call when the event happens.
			 * The handler should have three parameters:
			 *
			 * - _event_ is the event object.
			 * - _newVal_ is the newly-computed value of the compute.
			 * - _oldVal_ is the value of the compute before it changed.
			 *
			 * `bind` lets you listen to a compute to know when it changes. It works just like
			 * can.Map&#039;s `[can.Map.prototype.bind bind]`:
			 * @codestart
			 * var tally = can.compute(0);
			 * tally.bind(&#039;change&#039;, function(ev, newVal, oldVal) {
			 *     console.log(&#039;The tally is now at &#039; + newVal + &#039;.&#039;);
			 * });
			 *
			 * tally(tally() + 5); // The log reads:
			 *                     // &#039;The tally is now at 5.&#039;
			 * @codeend
			 */
			bind: can.bindAndSetup,
			/**
			 * @function computed.unbind compute.unbind
			 * @parent can.compute
			 * @description Unbind an event handler from a compute.
			 * @signature `compute.unbind(eventType[, handler])`
			 * @param {String} eventType The type of event to unbind.
			 * The only event type available for computes is _change_.
			 * @param {function} [handler] If given, the handler to unbind.
			 * If _handler_ is not supplied, all handlers bound to _eventType_
			 * will be removed.
			 */
			unbind: can.unbindAndTeardown,
			clone: function (context) {
				if (context) {
					if (form === &#039;setter&#039;) {
						args[2] = context;
					} else {
						args[1] = context;
					}
				}
				return can.compute.apply(can, args);
			}
		});
	};
	// A list of temporarily bound computes
	var computes, unbindComputes = function () {
			for (var i = 0, len = computes.length; i &lt; len; i++) {
				computes[i].unbind(&#039;change&#039;, k);
			}
			computes = null;
		};
	// Binds computes for a moment to retain their value and prevent caching
	can.compute.temporarilyBind = function (compute) {
		compute.bind(&#039;change&#039;, k);
		if (!computes) {
			computes = [];
			setTimeout(unbindComputes, 10);
		}
		computes.push(compute);
	};
	
	// Whether a compute is truthy
	can.compute.truthy = function (compute) {
		return can.compute(function () {
			var res = compute();
			if (typeof res === &#039;function&#039;) {
				res = res();
			}
			return !!res;
		});
	};
	can.compute.async = function(initialValue, asyncComputer, context){
		return can.compute(initialValue, {
			fn: asyncComputer,
			context: context
		});
	};
	// {map: new can.Map({first: &quot;Justin&quot;})}, [&quot;map&quot;,&quot;first&quot;]
	can.compute.read = function (parent, reads, options) {
		options = options || {};
		// `cur` is the current value.
		var cur = parent,
			type,
			// `prev` is the object we are reading from.
			prev,
			// `foundObs` did we find an observable.
			foundObs;
		for (var i = 0, readLength = reads.length; i &lt; readLength; i++) {
			// Update what we are reading from.
			prev = cur;
			// Read from the compute. We can&#039;t read a property yet.
			if (prev &amp;&amp; prev.isComputed) {
				if (options.foundObservable) {
					options.foundObservable(prev, i);
				}
				prev = cur = prev();
			}
			// Look to read a property from something.
			if (isObserve(prev)) {
				if (!foundObs &amp;&amp; options.foundObservable) {
					options.foundObservable(prev, i);
				}
				foundObs = 1;
				// is it a method on the prototype?
				if (typeof prev[reads[i]] === &#039;function&#039; &amp;&amp; prev.constructor.prototype[reads[i]] === prev[reads[i]]) {
					// call that method
					if (options.returnObserveMethods) {
						cur = cur[reads[i]];
					} else if ( (reads[i] === &#039;constructor&#039; &amp;&amp; prev instanceof can.Construct) ||
						(prev[reads[i]].prototype instanceof can.Construct)) {
						cur = prev[reads[i]];
					} else {
						cur = prev[reads[i]].apply(prev, options.args || []);
					}
				} else {
					// use attr to get that value
					cur = cur.attr(reads[i]);
				}
			} else {
				// just do the dot operator
				if(cur == null) {
					cur = undefined;
				} else {
					cur = prev[reads[i]];
				}
				
			}
			type = typeof cur;
			// If it&#039;s a compute, get the compute&#039;s value
			// unless we are at the end of the 
			if (cur &amp;&amp; cur.isComputed &amp;&amp; (!options.isArgument &amp;&amp; i &lt; readLength - 1)) {
				if (!foundObs &amp;&amp; options.foundObservable) {
					options.foundObservable(prev, i + 1);
				}
				cur = cur();
			}
			// If it&#039;s an anonymous function, execute as requested
			else if (i &lt; reads.length - 1 &amp;&amp; type === &#039;function&#039; &amp;&amp; options.executeAnonymousFunctions &amp;&amp; !(can.Construct &amp;&amp; cur.prototype instanceof can.Construct)) {
				cur = cur();
			}
			// if there are properties left to read, and we don&#039;t have an object, early exit
			if (i &lt; reads.length - 1 &amp;&amp; (cur === null || type !== &#039;function&#039; &amp;&amp; type !== &#039;object&#039;)) {
				if (options.earlyExit) {
					options.earlyExit(prev, i, cur);
				}
				// return undefined so we know this isn&#039;t the right value
				return {
					value: undefined,
					parent: prev
				};
			}
		}
		// handle an ending function
		// unless it is a can.Construct-derived constructor
		if (typeof cur === &#039;function&#039; &amp;&amp; !(can.Construct &amp;&amp; cur.prototype instanceof can.Construct) &amp;&amp; !(can.route &amp;&amp; cur === can.route)) {
			if (options.isArgument) {
				if (!cur.isComputed &amp;&amp; options.proxyMethods !== false) {
					cur = can.proxy(cur, prev);
				}
			} else {
				if (cur.isComputed &amp;&amp; !foundObs &amp;&amp; options.foundObservable) {
					options.foundObservable(cur, i);
				}
				cur = cur.call(prev);
			}
		}
		// if we don&#039;t have a value, exit early.
		if (cur === undefined) {
			if (options.earlyExit) {
				options.earlyExit(prev, i - 1);
			}
		}
		return {
			value: cur,
			parent: prev
		};
	};

	can.compute.set = function(parent, key, value) {
		if(isObserve(parent)) {
			return parent.attr(key, value);
		}

		if(parent[key] &amp;&amp; parent[key].isComputed) {
			return parent[key](value);
		}

		if(typeof parent === &#039;object&#039;) {
			parent[key] = value;
		}
	};

	return can.compute;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
