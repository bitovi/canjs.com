{
    "can/can.md": {
        "type": "script",
        "name": "can/can.md"
    },
    "canjs": {
        "type": "page",
        "name": "canjs",
        "body": "<p>This is the detailed documentation of the API for CanJS, a framework for building\nweb applications that provides a lightweight inheritance system, observable\nobjects and values, and a powerful MVC core with live-bound templates, among other\nresources. You can use it out of the box on top of jQuery, Zepto, YUI, and Mootools,\nand it's only 13K.</p>\n\n<p>If you are just starting with CanJS, you may want to try our <a href=\"../guides/Tutorial.html\">getting started guide</a>.</p>",
        "description": "",
        "title": "CanJS API",
        "parent": "index",
        "order": 0,
        "comment": " ",
        "src": "can/can.md",
        "id": 0
    },
    "can/construct/construct.md": {
        "type": "script",
        "name": "can/construct/construct.md"
    },
    "can.Construct": {
        "type": "constructor",
        "name": "can.Construct",
        "body": "",
        "description": "",
        "title": "",
        "download": "can/construct",
        "test": "can/construct/qunit.html",
        "parent": "canjs",
        "comment": " ",
        "signatures": [{
                "code": "can.Construct([name, [staticProperties,]] instanceProperties)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "optional": true,
                        "name": "name",
                        "description": "<p>the namespace and name of the constructor</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "staticProperties",
                        "description": "<p>properties that will belong to the constructor</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "instanceProperties",
                        "description": "<p>properties that will belong to instances made with the constructor</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "function",
                            "returns": {
                                "types": [{
                                        "type": "undefined"
                                    }
                                ]
                            },
                            "params": []
                        }
                    ],
                    "description": "<p>The constructor.</p>"
                }
            }
        ],
        "src": "can/construct/construct.md",
        "id": 1
    },
    "can/construct/construct.js": {
        "type": "script",
        "name": "can/construct/construct.js"
    },
    "can.Construct.static": {
        "type": "static",
        "body": "",
        "description": "",
        "name": "can.Construct.static",
        "parent": "can.Construct",
        "src": "can/construct/construct.js",
        "line": 22,
        "id": 2
    },
    "can.Construct.newInstance": {
        "type": "function",
        "name": "can.Construct.newInstance",
        "parent": "can.Construct.static",
        "body": "<p>Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n<strong>new</strong> operator.</p>\n\n<h2>Example</h2>\n\n<p>The following creates a <code>Person</code> Construct and then creates a new instance of Person,\nusing <code>apply</code> on newInstance to pass arbitrary parameters.</p>\n\n<pre><code class=\"lang-javascript\">var Person = can.Construct({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\nvar args = [\"Justin\",\"Barry\",\"Meyer\"],\n    justin = new Person.newInstance.apply(null, args);</code></pre>     ",
        "description": "<p>Create a new instance of a Construct. </p>",
        "title": "newInstance",
        "signatures": [{
                "code": "newInstance([...args])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "optional": true,
                        "name": "args",
                        "description": "<p>arguments that get passed to [can.Construct::setup] and [can.Construct::init]. Note\nthat if [can.Construct::setup] returns an array, those arguments will be passed to [can.Construct::init]\ninstead.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "class"
                        }
                    ],
                    "description": "<p>instance of the class</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/construct/construct.js",
        "line": 26,
        "id": 3
    },
    "can.Construct.setup": {
        "type": "function",
        "name": "can.Construct.setup",
        "parent": "can.Construct.static",
        "body": "<p>The static <code>setup</code> method is called immediately after a constructor function is created and \nset to inherit from its base constructor. It is useful for setting up additional inheritance work.\nDo not confuse this with the prototype <code>[can.Construct::setup]</code> method.</p>\n\n<h2>Setup Extends Defaults</h2>\n\n<p>Setup deeply extends the static <code>defaults</code> property of the base constructor with \nproperties of the inheriting constructor.  For example:</p>\n\n<pre><code class=\"lang-javascript\">Parent = can.Construct({\n  defaults : {\n    parentProp: 'foo'\n  }\n},{})\n\nChild = Parent({\n  defaults : {\n    childProp : 'bar'\n  }\n},{}\n\nChild.defaults // {parentProp: 'foo', 'childProp': 'bar'}</code></pre>\n\n<h2>Example</h2>\n\n<p>This <code>Parent</code> class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.</p>\n\n<pre><code class=\"lang-javascript\">Parent = can.Construct({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    can.Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // can.Construct\n\nChild = Parent({});\n\nChild.base; // Parent</code></pre>     ",
        "description": "<p>Perform initialization logic for a constructor function. </p>",
        "title": "setup",
        "signatures": [{
                "code": "setup(base, fullName, staticProps, protoProps)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "constructor"
                            }
                        ],
                        "name": "base",
                        "description": "<p>The base constructor that is being inherited from.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "fullName",
                        "description": "<p>The name of the new constructor.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "staticProps",
                        "description": "<p>The static properties of the new constructor.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "protoProps",
                        "description": "<p>The prototype properties of the new constructor.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/construct/construct.js",
        "line": 94,
        "id": 4
    },
    "can.Construct.static.extend": {
        "type": "function",
        "name": "can.Construct.static.extend",
        "params": [{
                "types": [{
                        "type": "String"
                    }
                ],
                "optional": true,
                "name": "fullName",
                "description": "<p>the class's name (used for classes w/ introspection)</p>"
            }, {
                "types": [{
                        "type": "Object",
                        "template": [{
                                "types": [{
                                        "type": "string"
                                    }
                                ]
                            }, {
                                "types": [{
                                        "type": "function",
                                        "returns": {
                                            "types": [{
                                                    "type": "undefined"
                                                }
                                            ]
                                        },
                                        "params": []
                                    }
                                ]
                            }
                        ]
                    }
                ],
                "optional": true,
                "name": "klass",
                "description": "<p>the new class's static functions</p>"
            }, {
                "types": [{
                        "type": "Object",
                        "template": [{
                                "types": [{
                                        "type": "string"
                                    }
                                ]
                            }, {
                                "types": [{
                                        "type": "function",
                                        "returns": {
                                            "types": [{
                                                    "type": "undefined"
                                                }
                                            ]
                                        },
                                        "params": []
                                    }
                                ]
                            }
                        ]
                    }
                ],
                "optional": true,
                "name": "proto",
                "description": "<p>the new class's prototype functions</p>"
            }
        ],
        "parent": "can.Construct.static",
        "body": "",
        "description": "<p>Extends a class with new static and prototype functions.  There are a variety of ways\nto use extend:</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>\n\n<p>You no longer have to use <code>extend</code>.  Instead, you can pass those options directly to\ncan.Construct (and any inheriting classes):</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>",
        "hide": true,
        "returns": {
            "types": [{
                    "type": "can.Construct"
                }
            ],
            "description": "<p>returns the new class</p>"
        },
        "src": "can/construct/construct.js",
        "line": 170,
        "id": 5
    },
    "can.Construct.namespace": {
        "name": "can.Construct.namespace",
        "type": "property",
        "parent": "can.Construct.static",
        "body": "",
        "description": "<p>The <code>namespace</code> property returns the namespace your constructor is in.\nThis provides a way organize code and ensure globally unique types.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
        "types": [{
                "type": "String"
            }
        ],
        "title": "namespace",
        "src": "can/construct/construct.js",
        "line": 268,
        "id": 6
    },
    "can.Construct.shortName": {
        "name": "can.Construct.shortName",
        "type": "property",
        "parent": "can.Construct.static",
        "body": "",
        "description": "<p>If you pass a name when creating a Construct, the <code>shortName</code> property will be set to the\nname you passed without the namespace.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
        "types": [{
                "type": "String"
            }
        ],
        "title": "shortName",
        "src": "can/construct/construct.js",
        "line": 283,
        "id": 7
    },
    "can.Construct.fullName": {
        "name": "can.Construct.fullName",
        "type": "property",
        "parent": "can.Construct.static",
        "body": "",
        "description": "<p>If you pass a name when creating a Construct, the <code>fullName</code> property will be set to\nthe name you passed.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
        "types": [{
                "type": "String"
            }
        ],
        "title": "fullName",
        "src": "can/construct/construct.js",
        "line": 299,
        "id": 8
    },
    "can.Construct.prototype": {
        "type": "prototype",
        "body": "",
        "description": "",
        "name": "can.Construct.prototype",
        "parent": "can.Construct",
        "src": "can/construct/construct.js",
        "line": 329,
        "id": 9
    },
    "can.Construct.prototype.setup": {
        "body": "<p>If a prototype <code>setup</code> method is provided, it is called when a new \ninstance is created. It is passed the same arguments that were passed\nto the constructor.</p>\n\n<p>Because <code>setup</code> is not defined on <code>can.Construct</code> itself, calling super from\ndirectly-inheriting classes will break. In other words, don't do this:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('Snowflake', {\n    setup: function() {\n        this._super(); // this will break!\n    }\n});</code></pre>\n\n<h2><code>setup</code> vs. <code>init</code></h2>\n\n<p>Usually, you should use [can.Construct::init] to do your class's initialization.\nUse <code>setup</code> instead for:</p>\n\n<ul>\n<li>initialization code that you want to run before the inheriting constructor's \n<code>init</code> method is called.</li>\n<li>initialization code that should run whether or not inheriting constructors\ncall their base's <code>init</code> methods.</li>\n<li>modifying the arguments that will get passed to <code>init</code>.</li>\n</ul>\n\n<h2>Example</h2>\n\n<p>This code is a simplified version of the code in [can.Control]'s setup\nmethod. It converts the first argument to a jQuery collection and\nextends the controller's defaults with the options that were passed.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"can.Control\", {\n    setup: function(domElement, rawOptions) {\n        // set up this.element\n        this.element = $(domElement);\n\n        // set up this.options\n        this.options = can.extend({},\n                                  this.constructor.defaults,\n                                  rawOptions\n                                 );\n\n        // pass this.element and this.options to init.\n        return [this.element, this.options];        \n    }\n});</code></pre>         ",
        "description": "",
        "title": "setup",
        "name": "can.Construct.prototype.setup",
        "type": "function",
        "parent": "can.Construct.prototype",
        "signatures": [{
                "code": "setup(...args)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "args",
                        "description": "<p>the arguments passed to the constructor.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Array"
                        }, {
                            "type": "undefined"
                        }
                    ],
                    "description": "<p>if an array is returned, the elements of that array are passed as\narguments to [can.Construct::init]. Otherwise, the arguments to the\nconstructor are passed to [can.Construct::init] and the return value of <code>setup</code> is discarded.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/construct/construct.js",
        "line": 333,
        "id": 10
    },
    "can.Construct.prototype.init": {
        "body": "<p>If a prototype <code>init</code> method is provided, it is called when a new Construct is created,\nafter [can.Construct::setup]. The <code>init</code> method is where the bulk of your initialization code\nshould go, and a common thing to do in <code>init</code> is to save the arguments passed into the constructor.</p>\n\n<h2>Examples</h2>\n\n<p>First, we'll make a Person constructor that has a first and last name:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"Person\", {\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"</code></pre>\n\n<p>Then we'll extend Person into Programmer and add a favorite language:</p>\n\n<pre><code class=\"lang-javascript\">Person(\"Programmer\", {\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return 'Hi! I'm ' + this.first + ' ' + this.last +\n            ' and I write ' + this.language + '.';\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";</code></pre>\n\n<h2>Be Aware</h2>\n\n<p>[can.Construct::setup] is able to modify the arguments passed to <code>init</code>.\nIf you aren't receiving the right arguments to <code>init</code>, check to make sure\nthat they aren't being changed by <code>setup</code> somewhere along the inheritance chain.</p>",
        "description": "",
        "title": "init",
        "name": "can.Construct.prototype.init",
        "type": "function",
        "parent": "can.Construct.prototype",
        "signatures": [{
                "code": "init(...args)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "args",
                        "description": "<p>the arguments passed to the constructor (or the elements of the array returned from [can.Construct::setup])</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/construct/construct.js",
        "line": 393,
        "id": 11
    },
    "can.Construct.prototype.constructor": {
        "type": "property",
        "body": "",
        "description": "<p>A reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.</p>\n\n<h2>Example</h2>\n\n<p>This class has a static counter that counts how mane instances have been created:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"Counter\", {\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nnew Counter();\nCounter.count; // 1</code></pre>         ",
        "types": [{
                "type": "function",
                "returns": {
                    "types": [{
                            "type": "undefined"
                        }
                    ]
                },
                "params": []
            }
        ],
        "title": "constructor",
        "name": "can.Construct.prototype.constructor",
        "parent": "can.Construct.prototype",
        "src": "can/construct/construct.js",
        "line": 449,
        "id": 12
    },
    "can/construct/proxy/proxy.md": {
        "type": "script",
        "name": "can/construct/proxy/proxy.md"
    },
    "proxy": {
        "type": "page",
        "name": "proxy",
        "body": "",
        "description": "<p>can.Construct.proxy is a plugin that helps you manage scope when creating\ncallback functions by ensuring that <code>this</code> is set correctly and sensibly\ninside callbacks.</p>",
        "parent": "can.Construct.plugins",
        "test": "can/construct/proxy/qunit.html",
        "download": "http://donejs.com/can/dist/can.construct.proxy.js",
        "signatures": [{
                "code": "proxy(callback, [...args])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }, {
                                "type": "String"
                            }, {
                                "type": "Array",
                                "template": [{
                                        "types": [{
                                                "type": "function",
                                                "returns": {
                                                    "types": [{
                                                            "type": "undefined"
                                                        }
                                                    ]
                                                },
                                                "params": []
                                            }, {
                                                "type": "String"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "name": "callback",
                        "description": "<p>the function or functions to proxy</p>"
                    }, {
                        "variable": true,
                        "types": [{
                                "type": "["
                            }
                        ],
                        "name": "args",
                        "description": "<p>parameters to curry into the proxied functions</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "function",
                            "returns": {
                                "types": [{
                                        "type": "undefined"
                                    }
                                ]
                            },
                            "params": []
                        }
                    ],
                    "description": "<p>a function that calls <code>callback</code> with the same context as the current context</p>\n\n<p><code>can.Construct.prototype.proxy</code> takes a function and returns a new function that, when invoked,\ncalls the given function with the same <code>this</code> as <code>proxy</code> was called with.</p>\n\n<p>Here is a counter that increments its count after a second:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('DelayedCounter', {\n    init: function() {\n        this.count = 0;\n        setTimeout(this.proxy(function() {\n            this.count++;\n        }), 1000);\n    }\n});\n\nvar counter = new DelayedCounter();\n// check counter's value later\nsetTimeout(function() {\n    counter.count; // 1\n}, 5000);</code></pre>\n\n<p>(Recall that setTimeout executes its callback in the global scope.)</p>\n\n<p>If you pass the name of a function on the <code>this</code> that <code>proxy</code> is called with,\n<code>proxy</code> will use that function. Here's how you write the previous example using\nthis technique:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('DelayedCounter', {\n    init: function() {\n        this.count = 0;\n        setTimeout(this.proxy('increment'), 1000);\n    },\n    increment: function() {\n        this.count++;\n    }\n});\n\nvar counter = new DelayedCounter();\n// check counter's value later\nsetTimeout(function() {\n    counter.count; // 1\n}, 5000);</code></pre>\n\n<h2>Currying arguments</h2>\n\n<p>If you pass more than one parameter to <code>proxy</code>, the additional parameters will\nbe passed as parameters to the callback before any parameters passed to the\nproxied function.</p>\n\n<p>Here's a delayed counter that increments by a given amount:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('IncrementalCounter', {\n    init: function(amount) {\n        this.count = 0;\n        setTimeout(this.proxy(function(amount) {\n            this.count += amount;\n        }, amount), 1000);\n    }\n});\n\nvar counter = new IncrementalCounter(5);\n// check counter's value later\nsetTimeout(function() { \n    counter.count; // 5\n}, 5000);</code></pre>\n\n<h2>Piping callbacks</h2>\n\n<p>If you pass an array of functions and strings as the first parameter to <code>proxy</code>,\n<code>proxy</code> will call the callbacks in sequence, passing the return value of each\nas a parameter to the next. This is useful to avoid having to curry callbacks.</p>\n\n<p>Here's a delayed counter that takes a callback to call after incrementing by a given amount:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('IncrementalCounter', {\n    init: function(amount, callback) {\n        this.count = 0;\n        setTimeout(this.proxy([function(amount) {\n            this.count += amount;\n            return this.count;\n        }, callback], amount), 1000);\n    }\n});\n\nvar counter = new IncrementalCounter(5, function(count) {\n    console.log('The count is ' + count + '.');\n});\n\n// after 1 second, the log says \"The count is 5.\"</code></pre>\n\n<h2><code>proxy</code> on constructors</h2>\n\n<p>can.Construct.proxy also adds <code>proxy</code> to the constructor, so you can use it\nin static functions with the constructor as <code>this</code>.</p>\n\n<p>Here's a counter construct that keeps its count staticly and increments after one second:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('DelayedStaticCounter', {\n    setup: function() {\n        this.count = 0;\n    }\n    incrementSoon: function() {\n        setTimeout(this.proxy(function() {\n            this.count++;\n        }), 1000);\n    }\n}, {});\n\nDelayedStaticCounter.incrementSoon();</code></pre>\n\n<h2>See also</h2>\n\n<p>[can.proxy] is a way to proxy callbacks outside of <code>can.Construct</code>s.</p>"
                }
            }
        ],
        "src": "can/construct/proxy/proxy.md",
        "id": 13
    },
    "can/construct/super/super.md": {
        "type": "script",
        "name": "can/construct/super/super.md"
    },
    "super": {
        "type": "page",
        "name": "super",
        "body": "",
        "description": "<p>can.Construct.super is a plugin that makes it easier to call base\nfunctions from inside inheriting functions.</p>",
        "parent": "can.Construct.plugins",
        "plugin": "can/construct/super",
        "test": "can/construct/super/qunit.html",
        "download": "http://donejs.com/can/dist/can.construct.super.js",
        "signatures": [{
                "code": "_super([...args])",
                "description": "",
                "params": [{
                        "variable": true,
                        "types": [{
                                "type": "["
                            }
                        ],
                        "name": "args",
                        "description": "<p>parameters to pass to the base function</p>\n\n<p>With this plugin, functions that are inheriting from base functions\nare provided with a specialized <code>this._super</code> reference to the base\nfunction from which they inherit.</p>\n\n<p>This is especially useful for calling base classes' <code>[can.Construct::init init]</code> and <code>[can.Construct::setup ssetup]</code>, but it can be used in any inheriting function.</p>\n\n<p>The <code>Person</code> and <code>Programmer</code> examples from <code>[can.Construct::init init]</code> demonstrate <code>_super</code>'s use.\nHere's how those classes look without can.Construct.super:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"Person\", {\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nPerson(\"Programmer\", {\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return 'Hi! I'm ' + this.first + ' ' + this.last +\n            ' and I write ' + this.language + '.';\n    }\n});</code></pre>\n\n<p>And here's how <code>Programmer</code> works using <code>_super</code>:</p>\n\n<pre><code class=\"lang-javascript\">Person(\"Programmer\", {\n    init: function(first, last, language) {\n        // call base's init\n        this._super(first, last);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return 'Hi! I'm ' + this.first + ' ' + this.last +\n            ' and I write ' + this.language + '.';\n    }\n});</code></pre>\n\n<p>If you want to pass an array of arguments (or an arguments object) to <code>_super</code>, use <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply\">apply</a>:</p>\n\n<pre><code class=\"lang-javascript\">Person(\"Programmer\", {\n    init: function(first, last, language) {\n        // call base's init\n        this._super.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return 'Hi! I'm ' + this.first + ' ' + this.last +\n            ' and I write ' + this.language + '.';\n    }\n});</code></pre>\n\n<h2><code>_super</code> on constructors</h2>\n\n<p>can.Construct.super also adds <code>super</code> to the constructor, so you\ncan use it in static functions.</p>\n\n<p>Here is a base class that has a method that squares numbers and an inherited class that has a method that cubes numbers:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('Squarer', {\n    raise: function(n) {\n        return n*n;\n    }\n}, {});\n\nSquarer('Cuber', {\n    raise: function(n) {\n        return n * this_super(n);\n    }\n}, {});</code></pre>"
                    }
                ]
            }
        ],
        "src": "can/construct/super/super.md",
        "id": 14
    },
    "can/observe/observe.md": {
        "type": "script",
        "name": "can/observe/observe.md"
    },
    "can.Observe": {
        "type": "constructor",
        "name": "can.Observe",
        "body": "<h2>Working with Observes</h2>\n\n<p>To create an Observe, use <code>new can.Observe([props])</code>. This will return a\ncopy of <code>props</code> that emits events when its properties are changed with\n<code>[can.Observe.prototype.attr attr]</code>.</p>\n\n<p>You can read the values of properties on Observes directly, but you should\nnever set them directly. You can also read property values using <code>attr</code>.\nUsually, you will want to do this when creating a <code>[can.compute]</code> or when\nlive-binding properties in an [can.EJS EJS] template. (If you are using\n[can.Mustache Mustache], you don't need to use <code>attr</code>.)</p>\n\n<pre><code class=\"lang-javascript\">var aName = {a: 'Alexis'},\n    observe = can.Observe(aName);\n\n// Observes are copies of data:\naName === observe; // false\n\n// reading from an Observe:\nobserve.attr();    // {a: 'Alexis'}\nobserve.a;         // 'Alexis'\nobserve.attr('a'); // 'Alexis'\n\n// setting an Observe's property:\nobserve.attr('a, 'Alice');\nobserve.a; // Alice\n\n// removing an Observe's property;\nobserve.removeAttr('a');\nobserve.attr(); // {}\n\n// Don't do this!\nobserve.a = 'Adam'; // wrong!</code></pre>\n\n<p>Find out more about manipulating properties of Observes under\n[can.Observe.protoype.attr attr] and [can.Observe.protoype.removeAtt removeAttr].</p>\n\n<h2>Listening to changes</h2>\n\n<p>The real power of observable objects comes from being able to react to\nproperties being added, set, and removed. Observes emit events when\nproperties are changed that you can bind to.</p>\n\n<p><code>can.Observe</code> has two types of events that fire due to changes on an Observe:\n- the <em>change</em> event fires on every change to an Observe.\n- an event named after the property name fires on every change to that property.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log('Something on o changed.');\n});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log('a was changed.');\n});\n\no.attr('a', 'Alexis'); // 'Something on o changed.'\n                       // 'a was changed.'\no.attr({\n    'a': 'Alice',      // 'Something on o changed.' (for a's change)\n    'b': 'Bob'         // 'Something on o changed.' (for b's change)\n});                    // 'a was changed.'\n\no.removeAttr('a');     // 'Something on o changed.'\n                       // 'a was changed.'</code></pre>\n\n<p>For more detail on how to use these events, see [can.Observe.prototype.bind bind] and\n[can.Observe.prototype.unbind unbind]. There is also a plugin called [can.Observe.delegate]\nthat makes binding to specific types of events easier:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.delegate('a', 'add' function(ev, newVal, oldVal) {\n    console.log('a was added.');\n});\no.delegate('a', 'set' function(ev, newVal, oldVal) {\n    console.log('a was set.');\n});\no.delegate('a', 'remove' function(ev, newVal, oldVal) {\n    console.log('a was removed.');\n});\no.delegate('a', 'change' function(ev, newVal, oldVal) {\n    console.log('a was changed.');\n});\n\no.attr('a', 'Alexis'); // 'a was added.'\n                       // 'a was changed.'\n\no.attr('a', 'Alice'); // 'a was set.'\n                      // 'a was changed.'\n\n\no.removeAttr('a'); // 'a was removed.'\n                   // 'a was changed.'</code></pre>",
        "description": "<p><code>can.Observe</code> provides a way for you to listen for and keep track of changes\nto objects. When you use the getters and setters provided by <code>can.Observe</code>,\nevents are fired that you can react to. <code>can.Observe</code> also has support for\nworking with deep properties. Observable arrays are also available with\n<code>[can.Observe.List]</code>, which is based on <code>can.Observe</code>.</p>",
        "title": "",
        "inherits": "can.Construct",
        "parent": "canjs",
        "comment": " ",
        "test": "can/observe/qunit.html",
        "download": "can/observe",
        "signatures": [{
                "code": "can.Observe([props])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "props",
                        "description": "<p>properties and values to seed the Observe with</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe"
                        }
                    ],
                    "description": "<p>an instance of <code>can.Observe</code> with the properties from <em>props</em></p>"
                }
            }
        ],
        "src": "can/observe/observe.md",
        "id": 15
    },
    "can/observe/observe.js": {
        "type": "script",
        "name": "can/observe/observe.js"
    },
    "can.Observe.static": {
        "type": "static",
        "body": "",
        "description": "",
        "name": "can.Observe.static",
        "parent": "can.Observe",
        "src": "can/observe/observe.js",
        "line": 122,
        "id": 16
    },
    "can.Observe.startBatch": {
        "type": "function",
        "name": "can.Observe.startBatch",
        "parent": "can.Observe.static",
        "body": "<p><code>startBatch</code> causes can.Observe to begin an event batch. Until <code>[can.Observe.stopBatch]</code> is called, any\nevents that would result from calls to <code>[can.Observe::attr attr]</code> are held back from firing. If you have\nlots of changes to make to can.Observes, batching them together can help performance &emdash; especially if\nthose can.Observes are live-bound to the DOM.</p>\n\n<p>In this example, you can see how the <em>first</em> and <em>change</em> events are not fired (and their handlers\nare not called) until <code>stopBatch</code> is called.</p>\n\n<pre><code class=\"lang-javascript\">var person = new can.Observe({\n    first: 'Alexis',\n    last: 'Abril'\n});\n\nperson.bind('first', function() {\n    console.log(\"First name changed.\"\");\n}).bind('change', function() {\n    console.log(\"Something changed.\");\n});\n\ncan.Observe.startBatch();\nperson.attr('first', 'Alex');\nconsole.log('Still in the batch.');\ncan.Observe.stopBatch();\n\n// the log has:\n// Still in the batch.\n// First name changed.\n// Something changed.</code></pre>\n\n<p>You can also pass a callback to <code>startBatch</code> which will be called after all the events have\nbeen fired:</p>\n\n<pre><code class=\"lang-javascript\">can.Observe.startBatch(function() {\n    console.log('The batch is over.');\n});\nperson.attr('first', 'Izzy');\nconsole.log('Still in the batch.');\ncan.Observe.stopBatch();\n\n// The console has:\n// Still in the batch.\n// First name changed.\n// Something changed.\n// The batch is over.</code></pre>\n\n<h2>Calling <code>startBatch</code> multiple times</h2>\n\n<p>If you call <code>startBatch</code> more than once, <code>stopBatch</code> needs to be called\nthe same number of times before any batched events will fire. For ways\nto circumvent this process, see [can.Observe.stopBatch].</p>\n\n<p>Here is an example that demonstrates how events are affected by calling\n<code>startBatch</code> multiple times.</p>\n\n<pre><code class=\"lang-javascript\">var addPeople = function(observable) {\n    can.Observe.startBatch();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.Observe.stopBatch();\n};\n\n// In a completely different place:\nvar list = new can.Observe();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.Observe.startBatch();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.Observe.stopBatch();\n\n// Here, the console has:\n// Still in the batch.\n// The list changed.\n// The list changed.\n// The list changed.</code></pre>     ",
        "description": "<p>Begin an event batch. </p>",
        "title": "startBatch",
        "signatures": [{
                "code": "startBatch([batchStopHandler])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "batchStopHandler",
                        "description": "<p>a callback that gets called after all batched events have been called</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 133,
        "id": 17
    },
    "can.Observe.stopBatch": {
        "type": "function",
        "name": "can.Observe.stopBatch",
        "parent": "can.Observe.static",
        "body": "<p><code>stopBatch</code> matches an earlier <code>[can.Observe.startBatch]</code> call. If <code>stopBatch</code> has been\ncalled as many times as <code>startBatch</code> (or if <em>force</em> is true), all batched events will be\nfired and any callbacks passed to <code>startBatch</code> since the beginning of the batch will be\ncalled. If <em>force and _callStart</em> are both true, a new batch will be started when all\nthe events and callbacks have been fired.</p>\n\n<p>See <code>[can.Observe.startBatch]</code> for examples of <code>startBatch</code> and <code>stopBatch</code> in normal use.</p>\n\n<p>In this example, the batch is forceably ended in the <code>addPeople</code> function.</p>\n\n<pre><code class=\"lang-javascript\">var addPeople = function(observable) {\n    can.Observe.startBatch();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.Observe.stopBatch(true);\n};\n\n// In a completely different place:\nvar list = new can.Observe();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.Observe.startBatch();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.Observe.stopBatch();\n\n// Here, the console has:\n// The list changed.\n// The list changed.\n// The list changed.\n// Still in the batch.</code></pre>     ",
        "description": "<p>End an event batch. </p>",
        "title": "stopBatch",
        "signatures": [{
                "code": "stopBatch([force[, callStart]])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "bool"
                            }
                        ],
                        "optional": true,
                        "name": "force",
                        "defaultValue": "false",
                        "description": "<p>whether to stop batching events immediately</p>"
                    }, {
                        "types": [{
                                "type": "bool"
                            }
                        ],
                        "optional": true,
                        "name": "callStart",
                        "defaultValue": "false",
                        "description": "<p>whether to call <code>[can.Observe.startBatch startBatch]</code> after firing batched events</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 233,
        "id": 18
    },
    "can.Observe.triggerBatch": {
        "type": "function",
        "name": "can.Observe.triggerBatch",
        "parent": "can.Observe.static",
        "body": "<p>If events are currently being batched, calling <code>triggerBatch</code> adds an event\nto the batch. If events are not currently being batched, the event is triggered\nimmediately.</p>",
        "description": "<p>Trigger an event to be added to the current batch. </p>",
        "title": "triggerBatch",
        "signatures": [{
                "code": "can.Observe.triggerBatch(item, event [, args])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "can.Observe"
                            }
                        ],
                        "name": "item",
                        "description": "<p>the target of the event</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }, {
                                "type": "Object",
                                "options": [{
                                        "name": "type",
                                        "types": [{
                                                "type": "String"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "name": "event",
                        "description": "<p>the type of event, or an event object with a type given</p>"
                    }, {
                        "types": [{
                                "type": "Array"
                            }
                        ],
                        "optional": true,
                        "name": "args",
                        "description": "<p>the parameters to trigger the event with.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 304,
        "id": 19
    },
    "can.Observe.keys": {
        "type": "function",
        "name": "can.Observe.keys",
        "parent": "can.Observe.static",
        "body": "<p><code>keys</code> iterates over an observe to get an array of its keys.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({\n    a: 'Alice',\n    b: 'Bob',\n    e: 'Eve'\n});\n\ncan.Observe.keys(people); // ['a', 'b', 'e']</code></pre>     ",
        "description": "<p>Iterate over the keys of an Observe. </p>",
        "title": "keys",
        "signatures": [{
                "code": "can.Observe.keys(observe)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "can.Observe"
                            }
                        ],
                        "name": "observe",
                        "description": "<p>the <code>can.Observe</code> to get the keys from</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Array"
                        }
                    ],
                    "description": "<p>array An array containing the keys from <em>observe</em>.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 335,
        "id": 20
    },
    "can.Observe.prototype": {
        "type": "prototype",
        "body": "",
        "description": "",
        "name": "can.Observe.prototype",
        "parent": "can.Observe",
        "src": "can/observe/observe.js",
        "line": 365,
        "id": 21
    },
    "can.Observe.prototype._cid": {
        "type": "property",
        "body": "",
        "description": "<p>A globally unique ID for this <code>can.Observe</code> instance.</p>",
        "types": [{
                "type": "String"
            }
        ],
        "title": "",
        "name": "can.Observe.prototype._cid",
        "hide": true,
        "src": "can/observe/observe.js",
        "line": 372,
        "id": 22
    },
    "can.Observe.prototype.attr": {
        "type": "function",
        "name": "can.Observe.prototype.attr",
        "parent": "can.Observe.prototype",
        "body": "<p><code>attr</code> gets or sets properties on the <code>can.Observe</code> it's called on. Here's a tour through\nhow all of its forms work:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({});\n\n// set a property:\npeople.attr('a', 'Alex');\n\n// get a property:\npeople.attr('a'); // 'Alex'\n\n// set and merge multiple properties:\npeople.attr({\n    a: 'Alice',\n    b: 'Bob'\n});\n\n// get all properties:\npeople.attr(); // {a: 'Alice', b: 'Bob'}\n\n// set properties while removing others:\npeople.attr({\n    b: 'Bill',\n    e: 'Eve'\n}, true);\n\npeople.attr(); // {b: 'Bill', e: 'Eve'}</code></pre>\n\n<h2>Deep properties</h2>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({names: {}});\n\n// set a property:\npeople.attr('names.a', 'Alice');\n\n// get a property:\npeople.attr('names.a'); // 'Alice'\npeople.names.attr('a'); // 'Alice'\n\n// get all properties:\npeople.attr(); // {names: {a: 'Alice'}}</code></pre>\n\n<p>Objects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call <code>attr</code> at:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({names: {}});\n\npeople.bind('change', function(ev, attr, how, newVal, oldVal) {\n  console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n   console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names', function(ev, newVal, oldVal) {\n    console.log('people names: ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('a', function(ev, newVal, oldVal) {\n    console.log('people.names a: ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names.a', function(ev, newVal, oldVal) {\n    console.log('people names.a: ' + newVal + ', ' + oldVal);\n});\n\npeople.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                 // people.names change: a, add, Alice, undefined\n                                 // people.names a: Alice, undefined\n                                 // people names.a: Alice, undefined\n\npeople.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                 // people.names change: b, add, Bob, undefined\n                                 // people.names b: Bob, undefined\n                                 // people names.b: Bob, undefined</code></pre>\n\n<h2>See also</h2>\n\n<p>For information on the events that are fired on property changes and how\nto listen for those events, see [can.Observe.prototype.bind bind].</p>",
        "description": "<p>Get or set properties on an Observe. </p>",
        "title": "attr",
        "signatures": [{
                "code": "attr()",
                "description": "<p>Gets a collection of all the properties in this <code>can.Observe</code>.</p>",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "Object",
                            "template": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ]
                                }, {
                                    "types": [{
                                            "type": "*"
                                        }
                                    ]
                                }
                            ]
                        }
                    ],
                    "description": "<p>an object with all the properties in this <code>can.Observe</code>.</p>"
                }
            }, {
                "code": "attr(key)",
                "description": "<p>Reads a property from this <code>can.Observe</code>.</p>",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "key",
                        "description": "<p>the property to read</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "*"
                        }
                    ],
                    "description": "<p>the value assigned to <em>key</em>.</p>"
                }
            }, {
                "code": "attr(key, value)",
                "description": "<p>Assigns <em>value</em> to a property on this <code>can.Observe</code> called <em>key</em>.</p>",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "key",
                        "description": "<p>the property to set</p>"
                    }, {
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "the",
                        "description": "<p>value to assign to <em>key</em>.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe"
                        }
                    ],
                    "description": "<p>this Observe, for chaining</p>"
                }
            }, {
                "code": "attr(obj[, removeOthers])",
                "description": "<p>Assigns each value in <em>obj</em> to a property on this <code>can.Observe</code> named after the\ncorresponding key in <em>obj</em>, effectively merging <em>obj</em> into the Observe.</p>",
                "params": [{
                        "types": [{
                                "type": "Object",
                                "template": [{
                                        "types": [{
                                                "type": "String"
                                            }
                                        ]
                                    }, {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "name": "obj",
                        "description": "<p>a collection of key-value pairs to set.\nIf any properties already exist on the <code>can.Observe</code>, they will be overwritten.</p>"
                    }, {
                        "types": [{
                                "type": "bool"
                            }
                        ],
                        "optional": true,
                        "name": "removeOthers",
                        "defaultValue": "false",
                        "description": "<p>whether to remove keys not present in <em>obj</em>.\nTo remove keys without setting other keys, use <code>[can.Observe::removeAttr removeAttr]</code>.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe"
                        }
                    ],
                    "description": "<p>this Observe, for chaining</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 408,
        "id": 23
    },
    "can.Observe.prototype.each": {
        "type": "function",
        "name": "can.Observe.prototype.each",
        "parent": "can.Observe.prototype",
        "body": "<pre><code class=\"lang-javascript\">var names = [];\nnew can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n});\n\nnames; // ['Alice', 'Bob', 'Eve']\n\nnames = [];\nnew can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n    if(key === 'b') {\n        return false;\n    }\n});\n\nnames; // ['Alice', 'Bob']\n</code></pre>     ",
        "description": "<p>Call a function on each property of an Observe. </p>",
        "title": "each",
        "signatures": [{
                "code": "each(callback)",
                "description": "<p><code>each</code> iterates through the Observe, calling a function\nfor each property value and key.</p>",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "callback",
                        "description": "<p>the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe"
                        }
                    ],
                    "description": "<p>this Observe, for chaining</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 555,
        "id": 24
    },
    "can.Observe.prototype.removeAttr": {
        "type": "function",
        "name": "can.Observe.prototype.removeAttr",
        "parent": "can.Observe.prototype",
        "body": "<p><code>removeAttr</code> removes a property by name from an Observe.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'});\n\npeople.removeAttr('b'); // 'Bob'\npeople.attr();          // {a: 'Alice', e: 'Eve'}</code></pre>\n\n<p>Removing an attribute will cause a <em>change</em> event to fire with <code>'remove'</code>\npassed as the <em>how</em> parameter and <code>undefined</code> passed as the <em>newVal</em> to\nhandlers. It will also cause a <em>property name</em> event to fire with <code>undefined</code>\npassed as <em>newVal</em>. An in-depth description at these events can be found\nunder <code>[can.Observe.prototype.attr attr]</code>.</p>",
        "description": "<p>Remove a property from an Observe. </p>",
        "title": "removeAttr",
        "signatures": [{
                "code": "removeAttr(attrName)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "attrName",
                        "description": "<p>the name of the property to remove</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "*"
                        }
                    ],
                    "description": "<p>the value of the property that was removed</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 595,
        "id": 25
    },
    "can.Observe.prototype.bind": {
        "name": "can.Observe.prototype.bind",
        "type": "function",
        "parent": "can.Observe.prototype",
        "body": "<p><code>bind</code> binds event handlers to property changes on <code>can.Observe</code>s. When you change\na property using <code>attr</code>, two events are fired on the Observe, allowing other parts\nof your application to observe the changes to the object.</p>\n\n<h2>The <em>change</em> event</h2>\n\n<p>The first event that is fired is the <em>change</em> event. The <em>change</em> event is useful\nif you want to react to all changes on an Observe.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log('Something changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>change</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>attr</em> Which property changed.</li>\n<li><em>how</em> Whether the property was added, removed, or set. Possible values are <code>'add'</code>, <code>'remove'</code>, or <code>'set'</code>.</li>\n<li><em>newVal</em> The value of the property after the change. <code>newVal</code> will be <code>undefined</code> if the property was removed.</li>\n<li><em>oldVal</em> Thishe value of the property before the change. <code>oldVal</code> will be <code>undefined</code> if the property was added.</li>\n</ul>\n\n<p>Here is a concrete tour through the <em>change</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\no.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\no.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\no.attr({\n    'a': 'Alice',      // [object Object], a, set, Alice, Adam\n    'b': 'Bob'         // [object Object], b, add, Bob, undefined\n});\no.removeAttr('a');     // [object Object], a, remove, undefined, Alice</code></pre>\n\n<p>(See also <code>[can.Observe::removeAttr removeAttr]</code>, which removes properties).</p>\n\n<h2>The <em>property name</em> event</h2>\n\n<p>The second event that is fired is an event whose type is the same as the changed\nproperty's name. This event is useful for noticing changes to a specific property.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log('The value of a changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>property name</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>newVal</em> The value of the property after the change. <code>newVal</code> will be <code>undefined</code> if the property was removed.</li>\n<li><em>oldVal</em> The value of the property before the change. <code>oldVal</code> will be <code>undefined</code> if the property was added.</li>\n</ul>\n\n<p>Here is a concrete tour through the <em>property name</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log(ev + ', ' + newVal + ', ' + oldVal);\n});\n\no.attr('a', 'Alexis'); // [object Object], Alexis, undefined\no.attr('a', 'Adam');   // [object Object], Adam, Alexis\no.attr({\n    'a': 'Alice',      // [object Object], Alice, Adam\n    'b': 'Bob' \n});\no.removeAttr('a');     // [object Object], undefined, Alice</code></pre>\n\n<h2>See also</h2>\n\n<p>More information about changing properties on Observes can be found under\n[can.Observe.prototype.attr attr].</p>\n\n<p>For a more specific way to changes on Observes, see the [can.Observe.delegate] plugin.</p>",
        "description": "<p>Bind event handlers to an Observe. </p>",
        "title": "bind",
        "signatures": [{
                "code": "bind(eventType, handler)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventType",
                        "description": "<p>the type of event to bind this handler to</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "handler",
                        "description": "<p>the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe"
                        }
                    ],
                    "description": "<p>this Observe, for chaining</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 749,
        "id": 26
    },
    "can.Observe.prototype.unbind": {
        "name": "can.Observe.prototype.unbind",
        "type": "function",
        "parent": "can.Observe.prototype",
        "body": "<p><code>unbind</code> unbinds event handlers previously bound with [can.Observe.prototype.bind|<code>bind</code>].\nIf no <em>handler</em> is passed, all handlers for the given event type will be unbound.</p>\n\n<pre><code class=\"lang-javascript\">var i = 0,\n    increaseBy2 = function() { i += 2; },\n    increaseBy3 = function() { i += 3; },\n    o = new can.Observe();\n\no.bind('change', increaseBy2);\no.bind('change', increaseBy3);\no.attr('a', 'Alice');\ni; // 5\n\no.unbind('change', increaseBy2);\no.attr('b', 'Bob');\ni; // 8\n\no.unbind('change');\no.attr('e', 'Eve');\ni; // 8</code></pre>     ",
        "description": "<p>Unbind event handlers from an Observe. </p>",
        "title": "unbind",
        "signatures": [{
                "code": "unbind(eventType[, handler])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventType",
                        "description": "<p>the type of event to unbind, exactly as passed to <code>bind</code></p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "handler",
                        "description": "<p>the handler to unbind</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 846,
        "id": 27
    },
    "can.Observe.prototype.serialize": {
        "type": "function",
        "name": "can.Observe.prototype.serialize",
        "params": [],
        "parent": "can.Observe.prototype",
        "body": "",
        "description": "<p>Get the serialized Object form of the observe.  Serialized\ndata is typically used to send back to a server.</p>\n\n<pre><code>o.serialize() //-&gt; { name: 'Justin' }\n</code></pre>\n\n<p>Serialize currently returns the same data \nas [can.Observe.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:</p>\n\n<pre><code>new Observe({time: new Date()})\n  .serialize() //-&gt; { time: 1319666613663 }\n</code></pre>",
        "hide": true,
        "returns": {
            "types": [{
                    "type": "Object"
                }
            ],
            "description": "<p>a JavaScript Object that can be \nserialized with <code>JSON.stringify</code> or other methods. </p>"
        },
        "src": "can/observe/observe.js",
        "line": 878,
        "id": 28
    },
    "can.Observe.prototype._attrs": {
        "type": "function",
        "name": "can.Observe.prototype._attrs",
        "params": [{
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "props",
                "description": ""
            }, {
                "types": [{
                        "type": "Boolean"
                    }
                ],
                "name": "remove",
                "description": "<p>true if you should remove properties that are not in props</p>"
            }
        ],
        "parent": "can.Observe.prototype",
        "body": "",
        "description": "<p>Set multiple properties on the observable</p>",
        "hide": true,
        "src": "can/observe/observe.js",
        "line": 900,
        "id": 29
    },
    "can.Observe.prototype.compute": {
        "type": "function",
        "name": "can.Observe.prototype.compute",
        "parent": "can.Observe.prototype",
        "body": "<p><code>compute</code> is a convenience method for making computes from properties\nof Observes. More information about computes can be found under [can.compute].</p>",
        "description": "<p>Make a can.compute from an observable property. </p>",
        "title": "compute",
        "signatures": [{
                "code": "compute(attrName)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "attrName",
                        "description": "<p>the property to bind to</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.compute"
                        }
                    ],
                    "description": "<p>a [can.compute] bound to <em>attrName</em></p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 952,
        "id": 30
    },
    "can.Observe.List": {
        "name": "can.Observe.List",
        "type": "constructor",
        "parent": "canjs",
        "body": "<h2>Working with Lists</h2>\n\n<p><code>can.Observe.List</code> extends <code>[can.Observe]</code>, so all the ways that you're used to working with\nObserves also work here, including [can.Observe.prototype.bind bind], [can.Observe.prototype.unbind unbind],\nand [can.Observe.prototype.each each]. And just as you can directly read properties normally\noff of an Observe, you can use array accessors ([]) to read elements directly off of a List.</p>\n\n<p>The one function of <code>can.Observe</code> that works slightly differently is <code>attr</code>. As expected when working with\narrays, top-level keys passed into <code>attr</code> are required to be numeric. (Strings may still be used when getting\nor modifying deep properties). Any top-level keys that are non-numeric are ignored. In addition, as might be\nexpected, a call to argument-less <code>attr</code> returns an array instead of an object.</p>\n\n<p>Just as you shouldn't set properties of an Observe directly, you shouldn't change elements\nof a List directly. Always use <code>attr</code> to set the elements of a List, or use [can.Observe.List.push push],\n[can.Observe.List.pop pop], [can.Observe.List.shift shift], [can.Observe.List.unshift unshift], or [can.Observe.List.splice splice].</p>\n\n<p>Here is a tour through the forms of <code>can.Observe.List</code>'s <code>attr</code> that parallels the one found under [can.Observe.prototype.attr attr]:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe.List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\npeople[0] = 'Adam'; // don't do this!\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']</code></pre>\n\n<h2>Listening to changes</h2>\n\n<p>As with <code>can.Observe</code>s, the real power of observable arrays comes from being able to\nreact to changes in the member elements of the array. Lists emit five types of events:\n- the <em>change</em> event fires on every change to a List.\n- the <em>set</em> event is fired when an element is set.\n- the <em>add</em> event is fired when an element is added to the List.\n- the <em>remove</em> event is fired when an element is removed from the List.\n- the <em>length</em> event is fired when the length of the List changes.</p>\n\n<p>This example presents a brief concrete survey of the times these events are fired:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\n\nlist.bind('change', function() { console.log('An element changed.'); });\nlist.bind('set', function() { console.log('An element was set.'); });\nlist.bind('add', function() { console.log('An element was added.'); });\nlist.bind('remove', function() { console.log('An element was removed.'); });\nlist.bind('length', function() { console.log('The length of the list changed.'); });\n\nlist.attr(0, 'Alexis'); // 'An element changed.'\n                        // 'An element was set.'\n\nlist.attr(3, 'Xerxes'); // 'An element changed.'\n                        // 'An element was added.'\n                        // 'The length of the list was changed.'\n\nlist.attr(['Adam', 'Bill']); // 'An element changed.'\n                             // 'An element was set.'\n                             // 'An element was changed.'\n                             // 'An element was set.'\n\nlist.pop(); // 'An element changed.'\n            // 'An element was removed.'\n            // 'The length of the list was changed.'</code></pre>\n\n<p>More information about binding to these events can be found under [can.Observe.List.attr attr].</p>",
        "description": "<p><code>can.Observe.List</code> provides a way for you to use <code>can.Observe</code>s with arrays. Much like <code>can.Observe</code>,\nwhen you use the getters and setters on <code>can.Observe.List</code>, events are fired that you can listen for\nand react to.</p>",
        "inherits": "can.Observe",
        "download": "can/observe",
        "test": "can/observe/qunit.html",
        "signatures": [{
                "code": "can.Observe.List([elements])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Array"
                            }
                        ],
                        "optional": true,
                        "name": "elements",
                        "description": "<p>elements to seed the List with</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe.List"
                        }
                    ],
                    "description": "<p>an instance of <code>can.Observe.List</code> with the elements from <em>elements</em></p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 984,
        "id": 31
    },
    "can.Observe.List.prototype": {
        "type": "prototype",
        "body": "",
        "description": "",
        "name": "can.Observe.List.prototype",
        "parent": "can.Observe.List",
        "src": "can/observe/observe.js",
        "line": 1084,
        "id": 32
    },
    "can.Observe.List.prototype.serialize": {
        "type": "function",
        "name": "can.Observe.List.prototype.serialize",
        "params": [],
        "parent": "can.Observe.List.prototype",
        "body": "",
        "description": "<p>Returns the serialized form of this list.</p>",
        "hide": true,
        "src": "can/observe/observe.js",
        "line": 1138,
        "id": 33
    },
    "can.Observe.List.prototype.each": {
        "body": "<pre><code class=\"lang-javascript\">var i = 0;\nnew can.Observe([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew can.Observe([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11</code></pre>     ",
        "description": "<p>Call a function on each element of a List. </p>",
        "title": "each",
        "name": "can.Observe.List.prototype.each",
        "type": "function",
        "signatures": [{
                "code": "each(callback)",
                "description": "<p><code>each</code> iterates through the Observe, calling a function\nfor each element.</p>",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": [{
                                        "types": [{
                                                "type": "*"
                                            }
                                        ]
                                    }, {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "name": "callback",
                        "description": "<p>the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe.List"
                        }
                    ],
                    "description": "<p>this List, for chaining</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1145,
        "id": 34
    },
    "can.Observe.List.prototype.splice": {
        "type": "function",
        "name": "can.Observe.List.prototype.splice",
        "parent": "can.Observe.List.prototype",
        "body": "<p><code>splice</code> lets you remove elements from and insert elements into a List.</p>\n\n<p>This example demonstrates how to do surgery on a list of numbers:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.attr(); // [0, 1, 'Alice', 'Bob', 3]</code></pre>\n\n<h2>Events</h2>\n\n<p><code>splice</code> causes the List it's called on to emit <em>change</em> events,\n<em>add</em> events, <em>remove</em> events, and <em>length</em> events. If there are\nany elements to remove, a <em>change</em> event, a <em>remove</em> event, and a\n<em>length</em> event will be fired. If there are any elements to insert, a\nseparate <em>change</em> event, an <em>add</em> event, and a separate <em>length</em> event\nwill be fired. </p>\n\n<p>This slightly-modified version of the above example should help\nmake it clear how <code>splice</code> causes events to be emitted:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['a', 'b', 'c', 'd']);\nlist.bind('change', function(ev, attr, how, newVals, oldVals) {\n    console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\nlist.bind('add', function(ev, newVals, where) {\n    console.log('add: ' + newVals + ', ' + where);\n});\nlist.bind('remove', function(ev, oldVals, where) {\n    console.log('remove: ' + oldVals + ', ' + where);\n});\nlist.bind('length', function(ev, length) {\n    console.log('length: ' + length + ', ' + this.attr());\n});\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                   // remove: ['c'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                   // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                   // add: ['Alice', 'Bob'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']</code></pre>\n\n<p>More information about binding to these events can be found under [can.Observe.List.attr attr].</p>",
        "description": "<p>Insert and remove elements from a List. </p>",
        "title": "splice",
        "signatures": [{
                "code": "splice(index[, howMany[, ...newElements]])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Number"
                            }
                        ],
                        "name": "index",
                        "description": "<p>where to start removing or inserting elements</p>"
                    }, {
                        "types": [{
                                "type": "Number"
                            }
                        ],
                        "optional": true,
                        "name": "howMany",
                        "description": "<p>the number of elements to remove\nIf <em>howMany</em> is not provided, <code>splice</code> will all elements from <code>index</code> to the end of the List.</p>"
                    }, {
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "newElements",
                        "description": "<p>elements to insert into the List</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Array"
                        }
                    ],
                    "description": "<p>the elements removed by <code>splice</code></p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1181,
        "id": 35
    },
    "can.Observe.List.prototype.attr": {
        "type": "function",
        "name": "can.Observe.List.prototype.attr",
        "parent": "can.Observe.List.prototype",
        "body": "<p><code>attr</code> gets or sets elements on the <code>can.Observe.List</code> it's called on. Here's a tour through\n how all of its forms work:</p>\n\n<pre><code class=\"lang-javascript\"> var people = new can.Observe.List(['Alex', 'Bill']);\n\n // set an element:\n people.attr(0, 'Adam');\n\n // get an element:\n people.attr(0); // 'Adam'\n people[0]; // 'Adam'\n\n // get all elements:\n people.attr(); // ['Adam', 'Bill']\n\n // extend the array:\n people.attr(4, 'Charlie');\n people.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n // merge the elements:\n people.attr(['Alice', 'Bob', 'Eve']);\n people.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']</code></pre> \n\n<p>## Deep properties</p>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\n the property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre><code class=\"lang-javascript\"> var people = new can.Observe.List([{name: 'Alex'}, {name: 'Bob'}]);\n\n // set a property:\n people.attr('0.name', 'Alice');\n\n // get a property:\n people.attr('0.name');  // 'Alice'\n people[0].attr('name'); // 'Alice'\n\n // get all properties:\n people.attr(); // [{name: 'Alice'}, {name: 'Bob'}]</code></pre>\n\n<p>The discussion of deep properties under <code>[can.Observe.prototype.attr]</code> may also\n be enlightening.</p>\n\n<p>## Events</p>\n\n<p><code>can.Observe.List</code>s emit five types of events in response to changes. They are:\n - the <em>change</em> event fires on every change to a List.\n - the <em>set</em> event is fired when an element is set.\n - the <em>add</em> event is fired when an element is added to the List.\n - the <em>remove</em> event is fired when an element is removed from the List.\n - the <em>length</em> event is fired when the length of the List changes.</p>\n\n<ul>\n<li><h2>The <em>change</em> event</h2>\n\n<p>The first event that is fired is the <em>change</em> event. The <em>change</em> event is useful\nif you want to react to all changes on an List.</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List([]);\n list.bind('change', function(ev, index, how, newVal, oldVal) {\n     console.log('Something changed.');\n });</code></pre> \n\n<p>The parameters of the event handler for the <em>change</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>index</em> Where the change took place.</li>\n<li><em>how</em> Whether elements were added, removed, or set.\nPossible values are <code>'add'</code>, <code>'remove'</code>, or <code>'set'</code>.</li>\n<li><em>newVal</em> The elements affected after the change\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere added, and <code>undefined</code> if elements were removed.</li>\n<li><p><em>oldVal</em> The elements affected before the change.\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere removed, and <code>undefined</code> if elements were added.</p>\n\n<p>Here is a concrete tour through the <em>change</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('change', function(ev, index, how, newVal, oldVal) {\n     console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n });\n\n list.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\n list.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\n list.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\n list.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                                // [object Object], 1, set, Bob, Bill\n list.removeAttr(1);            // [object Object], 1, remove, undefined, Bob</code></pre>\n\n<p>## The <em>set</em> event</p>\n\n<p><em>set</em> events are fired when an element at an index that already exists in the List is\n modified. Actions can cause <em>set</em> events to fire never also cause <em>length</em> events\n to fire (although some functions, such as <code>[can.Observe.List.prototype.splice splice]</code>\n may cause unrelated sets of events to fire after being batched).</p>\n\n<p>The parameters of the event handler for the <em>set</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>newVal</em> The new value of the element.</li>\n<li><p><em>index</em> where the set took place.</p>\n\n<p>Here is a concrete tour through the <em>set</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('set', function(ev, newVal, index) {\n     console.log(newVal + ', ' + index);\n });\n\n list.attr(['Alexis', 'Bill']);\n list.attr(2, 'Eve');          \n list.attr(0, 'Adam');          // Adam, 0\n list.attr(['Alice', 'Bob']);   // Alice, 0\n                                // Bob, 1\n list.removeAttr(1);            </code></pre>\n\n<p>## The <em>add</em> event</p>\n\n<p><em>add</em> events are fired when elements are added or inserted\n into the List.</p>\n\n<p>The parameters of the event handler for the <em>add</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>newElements</em> The new elements.\nIf more than one element is added, <em>newElements</em> will be an array.\nOtherwise, it is simply the new element itself.</li>\n<li><p><em>index</em> Where the add or insert took place.</p>\n\n<p>Here is a concrete tour through the <em>add</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('add', function(ev, newElements, index) {\n     console.log(newElements + ', ' + index);\n });\n\n list.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\n list.attr(2, 'Eve');           // Eve, 2\n list.attr(0, 'Adam');          \n list.attr(['Alice', 'Bob']);   \n\n list.removeAttr(1);            </code></pre>\n\n<p>## The <em>remove</em> event</p>\n\n<p><em>remove</em> events are fired when elements are removed from the list.</p>\n\n<p>The parameters of the event handler for the <em>remove</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>removedElements</em> The removed elements.\nIf more than one element was removed, <em>removedElements</em> will be an array.\nOtherwise, it is simply the element itself.</li>\n<li><p><em>index</em> Where the removal took place.</p>\n\n<p>Here is a concrete tour through the <em>remove</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('remove', function(ev, removedElements, index) {\n     console.log(removedElements + ', ' + index);\n });\n\n list.attr(['Alexis', 'Bill']); \n list.attr(2, 'Eve');           \n list.attr(0, 'Adam');          \n list.attr(['Alice', 'Bob']);   \n\n list.removeAttr(1);            // Bob, 1</code></pre>\n\n<p>## The <em>length</em> event</p>\n\n<p><em>length</em> events are fired whenever the list changes.</p>\n\n<p>The parameters of the event handler for the <em>length</em> event are:</p>\n\n<ul>\n<li><p><em>ev</em> The event object.</p>\n\n<ul><li><em>length</em> The current length of the list.\nIf events were batched when the <em>length</em> event was triggered, <em>length</em>\nwill have the length of the list when <code>stopBatch</code> was called. Because\nof this, you may recieve multiple <em>length</em> events with the same\n<em>length</em> parameter.</li></ul>\n\n<p>Here is a concrete tour through the <em>length</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('length', function(ev, length) {\n     console.log(length);\n });\n\n list.attr(['Alexis', 'Bill']); // 2\n list.attr(2, 'Eve');           // 3\n list.attr(0, 'Adam');          \n list.attr(['Alice', 'Bob']);   \n\n list.removeAttr(1);            // 2</code></pre>         ",
        "description": "<p>Get or set elements in a List. </p>",
        "title": "attr",
        "signatures": [{
                "code": "attr()",
                "description": "<p>Gets a collection of all the elements in this <code>can.Observe.List</code>.</p>",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "Array"
                        }
                    ],
                    "description": "<p>array with all the elements in this List.</p>"
                }
            }, {
                "code": "attr(index)",
                "description": "<p>Reads a element from this <code>can.Observe.List</code>.</p>",
                "params": [{
                        "types": [{
                                "type": "Number"
                            }
                        ],
                        "name": "index",
                        "description": "<p>the element to read</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "*"
                        }
                    ],
                    "description": "<p>the value at <em>index</em>.</p>"
                }
            }, {
                "code": "attr(index, value)",
                "description": "<p>Assigns <em>value</em> to the index <em>index</em> on this <code>can.Observe.List</code>, expanding the list if necessary.</p>",
                "params": [{
                        "types": [{
                                "type": "Number"
                            }
                        ],
                        "name": "index",
                        "description": "<p>the element to set</p>"
                    }, {
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "the",
                        "description": "<p>value to assign at <em>index</em></p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe.List"
                        }
                    ],
                    "description": "<p>this List, for chaining</p>"
                }
            }, {
                "code": "attr(elements[, replaceCompletely])",
                "description": "<p>Merges the members of <em>elements</em> into this List, replacing each from the beginning in order. If\n <em>elements</em> is longer than the current List, the current List will be expanded. If <em>elements</em>\n is shorter than the current List, the extra existing members are not affected (unless\n <em>replaceCompletely</em> is <code>true</code>). To remove elements without replacing them, use <code>[can.Observe.List.prototype.removeAttr removeAttr]</code>.</p>",
                "params": [{
                        "types": [{
                                "type": "Array"
                            }
                        ],
                        "name": "elements",
                        "description": "<p>an array of elements to merge in</p>"
                    }, {
                        "types": [{
                                "type": "bool"
                            }
                        ],
                        "optional": true,
                        "name": "replaceCompletely",
                        "defaultValue": "false",
                        "description": "<p>whether to completely replace the elements of List\n If <em>replaceCompletely</em> is <code>true</code> and <em>elements</em> is shorter than the List, the existing\n extra members of the List will be removed.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe.List"
                        }
                    ],
                    "description": "<p>this List, for chaining</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1270,
        "id": 36
    },
    "can.Observe.List.prototype.push": {
        "name": "can.Observe.List.prototype.push",
        "type": "function",
        "parent": "can.Observe.List.prototype",
        "body": "<p><code>push</code> is fairly straightforward:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']</code></pre>\n\n<p>If you have an array you want to concatenate to the end\nof the List, you can use <code>apply</code>:</p>\n\n<pre><code class=\"lang-javascript\">var names = ['Bob', 'Eve'],\n    list = new can.Observe.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']</code></pre>\n\n<h2>Events</h2>\n\n<p><code>push</code> causes <em>change</em>, <em>add</em>, and <em>length</em> events to be fired.</p>\n\n<h2>See also</h2>\n\n<p><code>push</code> has a counterpart in [can.Observe.List.pop pop], or you may be\nlooking for [can.Observe.List.unshift unshift] and its counterpart [can.Observe.List.shift shift].</p>",
        "description": "<p>Add elements to the end of a list. </p>",
        "title": "push",
        "signatures": [{
                "code": "push(...elements)",
                "description": "<p><code>push</code> adds elements onto the end of a List.]</p>",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "elements",
                        "description": "<p>the elements to add to the List</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Number"
                        }
                    ],
                    "description": "<p>the new length of the List</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1568,
        "id": 37
    },
    "can.Observe.List.prototype.unshift": {
        "name": "can.Observe.List.prototype.unshift",
        "type": "function",
        "parent": "can.Observe.List.prototype",
        "body": "<p><code>unshift</code> adds elements to the front of the list in bulk in the order specified:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']</code></pre>\n\n<p>If you have an array you want to concatenate to the beginning\nof the List, you can use <code>apply</code>:</p>\n\n<pre><code class=\"lang-javascript\">var names = ['Bob', 'Eve'],\n    list = new can.Observe.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']</code></pre>\n\n<h2>Events</h2>\n\n<p><code>unshift</code> causes <em>change</em>, <em>add</em>, and <em>length</em> events to be fired.</p>\n\n<h2>See also</h2>\n\n<p><code>unshift</code> has a counterpart in [can.Observe.List.shift shift], or you may be\nlooking for [can.Observe.List.push push] and its counterpart [can.Observe.List.pop pop].</p>",
        "description": "<p>Add elements to the beginning of a List. </p>",
        "title": "unshift",
        "signatures": [{
                "code": "unshift(...elements)",
                "description": "<p><code>unshift</code> adds elements onto the beginning of a List.</p>",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "elements",
                        "description": "<p>the elements to add to the List</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Number"
                        }
                    ],
                    "description": "<p>the new length of the List</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1610,
        "id": 38
    },
    "can.Observe.List.prototype.pop": {
        "name": "can.Observe.List.prototype.pop",
        "type": "function",
        "parent": "can.Observe.List.prototype",
        "body": "<p><code>pop</code> is the opposite action from <code>[can.Observe.List.push push]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined</code></pre>\n\n<h2>Events</h2>\n\n<p><code>pop</code> causes <em>change</em>, <em>remove</em>, and <em>length</em> events to be fired if the List is not empty\nwhen it is called.</p>\n\n<h2>See also</h2>\n\n<p><code>pop</code> has its counterpart in [can.Observe.List.push push], or you may be\nlooking for [can.Observe.List.unshift unshift] and its counterpart [can.Observe.List.shift shift].</p>",
        "description": "<p>Remove an element from the end of a List. </p>",
        "title": "pop",
        "signatures": [{
                "code": "pop()",
                "description": "<p><code>push</code> removes an element from the end of a List.</p>",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "*"
                        }
                    ],
                    "description": "<p>the element just popped off the List, or <code>undefined</code> if the List was empty</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1689,
        "id": 39
    },
    "can.Observe.List.prototype.shift": {
        "name": "can.Observe.List.prototype.shift",
        "type": "function",
        "parent": "can.Observe.List.prototype",
        "body": "<p><code>shift</code> is the opposite action from <code>[can.Observe.List.unshift unshift]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined</code></pre>\n\n<h2>Events</h2>\n\n<p><code>pop</code> causes <em>change</em>, <em>remove</em>, and <em>length</em> events to be fired if the List is not empty\nwhen it is called.</p>\n\n<h2>See also</h2>\n\n<p><code>shift</code> has a counterpart in [can.Observe.List.unshift unshift], or you may be\nlooking for [can.Observe.List.push push] and its counterpart [can.Observe.List.pop pop].</p>",
        "description": "<p>Remove en element from the front of a list. </p>",
        "title": "shift",
        "signatures": [{
                "code": "shift()",
                "description": "<p><code>shift</code> removes an element from the beginning of a List.</p>",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "*"
                        }
                    ],
                    "description": "<p>the element just shifted off the List, or <code>undefined</code> if the List is empty</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1724,
        "id": 40
    },
    "can.Observe.List.prototype.indexOf": {
        "type": "function",
        "name": "can.Observe.List.prototype.indexOf",
        "parent": "can.Observe.List.prototype",
        "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1</code></pre>\n\n<p>It is trivial to make a <code>contains</code>-type function using <code>indexOf</code>:</p>\n\n<pre><code class=\"lang-javascript\">function(list, item) {\n    return list.indexOf(item) >= 0;\n}</code></pre>     ",
        "description": "<p>Look for an item in a List. </p>",
        "title": "indexOf",
        "signatures": [{
                "code": "indexOf(item)",
                "description": "<p><code>indexOf</code> finds the position of a given item in the List.</p>",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "item",
                        "description": "<p>the item to find</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Number"
                        }
                    ],
                    "description": "<p>the position of the item in the List, or -1 if the item is not found.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1785,
        "id": 41
    },
    "can.Observe.List.prototype.join": {
        "name": "can.Observe.List.prototype.join",
        "type": "function",
        "parent": "can.Observe.List.prototype",
        "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new can.Observe.List(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'</code></pre>     ",
        "description": "<p>Join a List's elements into a string. </p>",
        "title": "join",
        "signatures": [{
                "code": "join(separator)",
                "description": "<p><code>join</code> turns a List into a string by inserting <em>separator</em> between the string representations\nof all the elements of the List.</p>",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "separator",
                        "description": "<p>the string to seperate elements with</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>the joined string</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1816,
        "id": 42
    },
    "can.Observe.List.prototype.reverse": {
        "name": "can.Observe.List.prototype.reverse",
        "type": "function",
        "parent": "can.Observe.List.prototype",
        "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true</code></pre>     ",
        "description": "<p>Reverse the order of a List. </p>",
        "title": "reverse",
        "signatures": [{
                "code": "reverse()",
                "description": "<p><code>reverse</code> reverses the elements of the List in place.</p>",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "can.Observe.List"
                        }
                    ],
                    "description": "<p>the List, for chaining</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1839,
        "id": 43
    },
    "can.Observe.List.prototype.slice": {
        "type": "function",
        "name": "can.Observe.List.prototype.slice",
        "parent": "can.Observe.List.prototype",
        "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']</code></pre>\n\n<p><code>slice</code> is the simplest way to copy a List:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false</code></pre>     ",
        "description": "<p>Make a copy of a part of a List. </p>",
        "title": "slice",
        "signatures": [{
                "code": "slice([start[, end]])",
                "description": "<p><code>slice</code> creates a copy of a portion of the List.</p>",
                "params": [{
                        "types": [{
                                "type": "Number"
                            }
                        ],
                        "optional": true,
                        "name": "start",
                        "defaultValue": "0",
                        "description": "<p>the index to start copying from</p>"
                    }, {
                        "types": [{
                                "type": "Number"
                            }
                        ],
                        "optional": true,
                        "name": "end",
                        "description": "<p>the first index not to include in the copy\nIf <em>end</em> is not supplied, <code>slice</code> will copy until the end of the list.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe.List"
                        }
                    ],
                    "description": "<p>a new <code>can.Observe.List</code> with the extracted elements</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1859,
        "id": 44
    },
    "can.Observe.List.prototype.concat": {
        "type": "function",
        "name": "can.Observe.List.prototype.concat",
        "parent": "can.Observe.List.prototype",
        "body": "<p><code>concat</code> makes a new List with the elements of the List followed by the elements of the parameters.</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new can.Observe.List(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]</code></pre>     ",
        "description": "<p>Merge many collections together into a List. </p>",
        "title": "concat",
        "signatures": [{
                "code": "concat(...args)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Array"
                            }, {
                                "type": "can.Observe.List"
                            }, {
                                "type": "*"
                            }
                        ],
                        "name": "args",
                        "description": "<p>Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1895,
        "id": 45
    },
    "can.Observe.List.prototype.forEach": {
        "type": "function",
        "name": "can.Observe.List.prototype.forEach",
        "parent": "can.Observe.List.prototype",
        "body": "<p><code>forEach</code> calls a callback for each element in the List.</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]</code></pre>     ",
        "description": "<p>Call a function for each element of a List. </p>",
        "title": "forEach",
        "signatures": [{
                "code": "forEach(callback[, thisArg])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": [{
                                        "types": [{
                                                "type": "element"
                                            }
                                        ]
                                    }, {
                                        "types": [{
                                                "type": "index"
                                            }
                                        ]
                                    }, {
                                        "types": [{
                                                "type": "list"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "name": "callback",
                        "description": "<p>a function to call with each element of the List\nThe three parameters that <em>callback</em> gets passed are <em>element</em>, the element at <em>index</em>, <em>index</em> the\ncurrent element of the list, and <em>list</em> the List the elements are coming from.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "thisArg",
                        "description": "<p>the object to use as <code>this</code> inside the callback</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1925,
        "id": 46
    },
    "can.Observe.List.prototype.replace": {
        "type": "function",
        "name": "can.Observe.List.prototype.replace",
        "parent": "can.Observe.List.prototype",
        "body": "<p><code>replace</code> replaces all the elements of this List with new ones.</p>\n\n<p><code>replace</code> is especially useful when <code>can.Observe.List</code>s are live-bound into <code>[can.Control]</code>s,\nand you intend to populate them with the results of a <code>[can.Model]</code> call:</p>\n\n<pre><code class=\"lang-javascript\">can.Control({\n    init: function() {\n        this.list = new Todo.List();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.mustache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});</code></pre>\n\n<p>Learn more about [can.Model.List making Lists of models].</p>\n\n<h2>Events</h2>\n\n<p>A major difference between <code>replace</code> and <code>attr(newElements, true)</code> is that <code>replace</code> always emits\nan<em>add</em> event and a <em>remove</em> event, whereas <code>attr</code> will cause <em>set</em> events along an <em>add</em> or <em>remove</em>\nevent if needed. Corresponding <em>change</em> and <em>length</em> events will be fired as well.</p>\n\n<p>The differences in the events fired by <code>attr</code> and <code>replace</code> are demonstrated concretely by this example:</p>\n\n<pre><code class=\"lang-javascript\">var attrList = new can.Observe.List(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new can.Observe.List(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, undefined, ['Adam', 'Ben']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber</code></pre>     ",
        "description": "<p>Replace all the elements of a List. </p>",
        "title": "replace",
        "signatures": [{
                "code": "replace(collection)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Array"
                            }, {
                                "type": "can.Observe.List"
                            }, {
                                "type": "can.Deferred"
                            }
                        ],
                        "name": "collection",
                        "description": "<p>the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an <code>Array</code> or <code>can.Observe.List</code>.\nThe elements of the list are not actually removed until the Deferred resolves.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/observe/observe.js",
        "line": 1949,
        "id": 47
    },
    "can/observe/attributes/attributes.md": {
        "type": "script",
        "name": "can/observe/attributes/attributes.md"
    },
    "can.Observe.attributes": {
        "type": "page",
        "name": "can.Observe.attributes",
        "body": "<p>There are three important static properties to give the class you want to use attributes with:\n- <code>[can.Observe.attributes.attributes attributes]</code> lists the properties that will be normalized\nand the types those properties should be.\n- <code>[can.Observe.attributes.convert convert]</code> lists how to convert and normalize arbitrary values\nto the types this class uses.\n- <code>[can.Observe.attributes.serialize serialize]</code> lists serialization algorithms for the types\nthis class uses.</p>\n\n<p>Together, the functions in <em>convert</em> and <em>serialize</em> make up the type definitions for the class.\nThe attributes plugin comes with three useful predefined types: <code>'date'</code>, <code>'number'</code>, and <code>'boolean'</code>.</p>\n\n<p>Here is a quick example of an Observe-based class using the attributes plugin to convert and normalize\nits data, and then to serialize the instance:</p>\n\n<pre><code class=\"lang-javascript\">can.Observe('Bio', {\n    attributes: {\n        birthday: 'date',\n        weight: 'number'\n    }\n    // Bio only uses built-in types, so no\n    // need to specify serialize or convert.\n}, {});\n\nvar alice = new Bio({\n    birthday: Date.parse('1985-04-01'), // 481161600000\n    weight: '120'\n});\n\nalice.attr();      // { birthday: Date(481161600000), weight: 120 }\nalice.serialize(); // { birthday: 481161600000, weight: 120 }\n</code></pre>\n\n<h3>Demo</h3>\n\n<p>When a user enters a new date in the format of <em>YYYY-DD-MM</em>, the control \nlistens for changes in the input box and updates the Observable using \nthe <code>attr</code> method which then converts the string into a JavaScript date object.  </p>\n\n<p>Additionally, the control also listens for changes on the Observable and \nupdates the age in the page for the new birthdate of the contact.</p>\n\n<div class='demo_wrapper' data-demo-src='can/observe/attributes/attributes.html'></div>\n\n<h3>Reference types</h3>\n\n<p>Types listed in <code>attributes</code> can also be a functions, such as the <code>model</code> or\n<code>models</code> methods of a [can.Model]. When data of this kind of type is set, this\nfunction is used to convert the raw data into an instance of the Model.</p>\n\n<p>This example builds on the previous one to demonstrate these reference types.</p>\n\n<p>can.Observe('Bio', {\n    attributes: {\n        birthday: 'date',\n        weight: 'number'\n    }\n    // Contact only uses built-in types, so you don't have\n    // to specify serialize or convert.\n}, {});</p>\n\n<p>can.Observe('Contact', {\n  attributes: {\n    bio: 'Bio.newInstance'\n  }\n}, {});</p>\n\n<p>var alice = new Contact({\n  first: 'Alice',\n  last: 'Liddell',\n  bio: {\n    birthday: Date.parse('1985-04-01'), // 481161600000\n    weight: 120\n  }\n});</p>\n\n<p>The Attributes plugin provides functionality for converting data attributes from raw types and \nserializing complex types for the server.</p>\n\n<p>Below is an example code of an Observe providing serialization and conversion for dates and numbers.  </p>\n\n<p>When <code>Contact</code> is initialized, the <code>weight</code> attribute is set and converted to a <code>number</code> using the\nconverter we provided.  Next the <code>birthday</code> attribute is set using the <code>attr</code> method and gets converted\nas well.  Lastly, <code>serialize</code> is invoked converting the new attributes to raw types for the server.</p>\n\n<pre><code>var Contact = new can.Observe({\n    attributes: {\n        birthday: 'date'\n        weight: 'number'\n    },\n    serialize : {\n        date : function( val, type ){\n            // returns the string formatted as 'YYYY-DD-MM'\n            return val.getYear() + \n                    \"-\" + (val.getMonth() + 1) + \n                    \"-\" + val.getDate(); \n        },\n        number: (val){\n            return val + '';\n        }\n    },\n    convert: {\n        // converts string to date\n        date: function( date ) {\n            if ( typeof date == 'string' ) {\n                //- Extracts dates formated 'YYYY-DD-MM'\n                var matches = raw.match( /(\\d+)-(\\d+)-(\\d+)/ ); \n\n                //- Parses to date object and returns\n                date = new Date( matches[ 1 ],\n                        ( +matches[ 2 ] ) - 1, \n                        matches[ 3 ] ); \n            }\n\n            return date;\n        },\n\n        // converts string to number\n        number: function(number){\n            if(typeof number === 'string'){\n                number = parseInt(number);\n            }\n            return number;\n        }\n    }\n}, {});\n\nvar brian = new Contact({\n    weight: '300'\n});\n\nvar weight = brian.attr('weight'); //-&gt; 300\n\n//- sets brian's birthday\nbrian.attr('birthday', '11-29-1983');\n\nvar date = brian.attr('birthday'); //-&gt; Date()\n\nvar seralizedObj = brian.serialize();\n//-&gt; { 'birthday': '11-29-1983', 'weight': '300' }\n</code></pre>\n\n<h2>Associations</h2>\n\n<p>Attribute type values can also represent the name of a function. The most common case this is used is for associated data.</p>\n\n<p>For example, a <code>Deliverable</code> might have many tasks and an owner (which is a Person). The attributes property might look like:</p>\n\n<pre><code>var Deliverable = new can.Observe({\n    attributes : {\n        tasks : \"App.Models.Task.models\"\n        owner: \"App.Models.Person.model\"\n    }\n});\n</code></pre>\n\n<p>This points tasks and owner properties to use <em>Task</em> and <em>Person</em> to convert the raw data into an array of Tasks and a Person.</p>\n\n<p>Its important to note that the full names of the models themselves are <em>App.Models.Task</em> and <em>App.Models.Person</em>. The <code>.model</code> \nand <code>.models</code> parts are appended for the benefit of convert to identify the types as models.</p>\n\n<h3>Demo</h3>\n\n<p>Below is a demo that showcases associations between 2 different models to show the tasks\nfor each contact and how much time they have left to complete the task(s) using converters.</p>\n\n<div class='demo_wrapper' data-demo-src='can/observe/attributes/attributes-assocations.html'></div>",
        "description": "<p>can.Observe.attributes is a plugin that helps convert and normalize data being set on an Observe\nand allows you to specify the way complex types get serialized. The attributes plugin is most\nhelpful when used with [can.Model] (because the serialization aids in sending data to a server),\nbut you can use it with any Observe you plan to make instances\nfrom.</p>",
        "title": "attributes",
        "parent": "can.Observe.plugins",
        "plugin": "can/observe/attributes",
        "test": "can/observe/attributes/qunit.html",
        "download": "http://donejs.com/can/dist/can.observe.attributes.js",
        "comment": " ",
        "src": "can/observe/attributes/attributes.md",
        "id": 48
    },
    "can/observe/attributes/attributes.js": {
        "type": "script",
        "name": "can/observe/attributes/attributes.js"
    },
    "can.Observe.attributes.static.attributes": {
        "name": "can.Observe.attributes.static.attributes",
        "type": "property",
        "parent": "can.Observe.attributes",
        "body": "",
        "description": "<p><code>can.Observe.attributes</code> is a property that contains key/value pair(s) of an attribute's name and its\nrespective type for using in [can.Observe.attributes.static.convert convert] and [can.Observe.prototype.serialize serialize].</p>\n\n<pre><code>var Contact = can.Observe({\n    attributes : {\n        birthday : 'date',\n        age: 'number',\n        name: 'string'\n    }\n});\n</code></pre>",
        "title": "attributes (static)",
        "src": "can/observe/attributes/attributes.js",
        "line": 12,
        "id": 49
    },
    "can.Observe.attributes.static.convert": {
        "name": "can.Observe.attributes.static.convert",
        "type": "property",
        "parent": "can.Observe.attributes",
        "body": "",
        "description": "<p>You often want to convert from what the observe sends you to a form more useful to JavaScript. \nFor example, contacts might be returned from the server with dates that look like: \"1982-10-20\". \nWe can observe to convert it to something closer to <code>new Date(1982,10,20)</code>.</p>\n\n<p>Convert comes with the following types:</p>\n\n<ul>\n<li><strong>date</strong> Converts to a JS date. Accepts integers or strings that work with Date.parse</li>\n<li><strong>number</strong> An integer or number that can be passed to parseFloat</li>\n<li><strong>boolean</strong> Converts \"false\" to false, and puts everything else through Boolean()</li>\n</ul>\n\n<p>The following sets the birthday attribute to \"date\" and provides a date conversion function:</p>\n\n<pre><code>var Contact = can.Observe({\n    attributes : {\n        birthday : 'date'\n    },\n    convert : {\n        date : function(raw){\n            if(typeof raw == 'string'){\n                //- Extracts dates formated 'YYYY-DD-MM'\n                var matches = raw.match(/(\\d+)-(\\d+)-(\\d+)/);\n\n                //- Parses to date object and returns\n                return new Date(matches[1], \n                                (+matches[2])-1, \n                                matches[3]);\n\n            }else if(raw instanceof Date){\n                return raw;\n            }\n        }\n    }\n},{});\n\nvar contact = new Contact();\n\n//- calls convert on attribute set\ncontact.attr('birthday', '4-26-2012') \n\ncontact.attr('birthday'); //-&gt; Date\n</code></pre>\n\n<p>If a property is set with an object as a value, the corresponding converter is called with the unmerged data (the raw object)\nas the first argument, and the old value (a can.Observe) as the second:</p>\n\n<pre><code>    var MyObserve = can.Observe({\n    attributes: {\n          nested: \"nested\"\n    },\n    convert: {\n        nested: function(data, oldVal) {\n            if(oldVal instanceof MyObserve) {\n                return oldVal.attr(data);\n            }\n            return new MyObserve(data);\n        }\n    }\n},{});\n</code></pre>\n\n<h2>Differences From <code>attr</code></h2>\n\n<p>The way that return values from convertors affect the value of an Observe's property is\ndifferent from [can.Observe::attr attr]'s normal behavior. Specifically, when the \nproperty's current value is an Observe or List, and an Observe or List is returned\nfrom a convertor, the effect will not be to merge the values into the current value as\nif the return value was fed straight into <code>attr</code>, but to replace the value with the\nnew Observe or List completely. Because of this, any bindings you have on the previous\nobservable object will break.</p>\n\n<p>If you would rather have the new Observe or List merged into the current value, call\n<code>attr</code> directly on the property instead of on the Observe:</p>\n\n<pre><code class=\"lang-javascript\">var Contact = can.Observe({\n  attributes: {\n    info: 'info'\n  },\n  convert: {\n    'info': function(data, oldVal) {\n      return data;\n    }\n  }\n}, {}));\n\nvar alice = new Contact({info: {name: 'Alice Liddell', email: 'alice@liddell.com'}});\nalice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\nalice.info._cid; // '.observe1'\n\nalice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\nalice.attr(); // {name: 'Allison Wonderland', 'phone': '888-888-8888'}\nalice.info._cid; // '.observe2'\n\nalice.info.attr({email: 'alice@wonderland.com', phone: '000-000-0000'});\nalice.attr(); // {name: 'Allison Wonderland', email: 'alice@wonderland.com', 'phone': '000-000-0000'}\nalice.info._cid; // '.observe2'</code></pre>\n\n<h2>Assocations and Convert</h2>\n\n<p>If you have assocations defined within your model(s), you can use convert to automatically\ncall serialize on those models.</p>\n\n<pre><code>    can.Model(\"Contact\",{\n        attributes : {\n            tasks: \"Task.models\"\n        }\n    }, {});\n\n    can.Model(\"Task\",{\n        attributes : {\n            due : 'date'\n        }\n    },{});\n\n    var contact = new Contact({\n        tasks: [ new Task({\n            due: new Date()\n        }) ]\n    });\n\n    contact.seralize(); \n    //-&gt; { tasks: [ { due: 1333219754627 } ] }\n</code></pre>",
        "title": "convert",
        "src": "can/observe/attributes/attributes.js",
        "line": 30,
        "id": 50
    },
    "can.Observe.attributes.static.serialize": {
        "name": "can.Observe.attributes.static.serialize",
        "type": "property",
        "parent": "can.Observe.attributes",
        "body": "",
        "description": "<p><code>can.Observe.serialize</code> is an object of name-function pairs that are used to \nserialize attributes.</p>\n\n<p>Similar to [can.Observe.convert], in that the keys of this object correspond to \nthe types specified in [can.Observe.attributes].</p>\n\n<p>By default every attribute will be passed through the 'default' serialization method \nthat will return the value if the property holds a primitive value (string, number, ...), \nor it will call the \"serialize\" method if the property holds an object with the \"serialize\" method set.</p>\n\n<p>For example, to serialize all dates to ISO format:</p>\n\n<pre><code>    var Contact = can.Observe({\n        attributes : {\n            birthday : 'date'\n        },\n        serialize : {\n            date : function(val, type){\n                return new Date(val).toISOString();\n            }\n        }\n    },{});\n\n    var contact = new Contact({ \n        birthday: new Date(\"Oct 25, 1973\") \n    }).serialize();\n    //-&gt; { \"birthday\" : \"1973-10-25T05:00:00.000Z\" }\n</code></pre>",
        "title": "serialize (static)",
        "src": "can/observe/attributes/attributes.js",
        "line": 191,
        "id": 51
    },
    "can.Observe.setup": {
        "name": "can.Observe.setup",
        "type": "function",
        "body": "",
        "description": "<p><code>can.Observe.static.setup</code> overrides default <code>can.Observe</code> setup to provide\nfunctionality for attributes.</p>",
        "hide": true,
        "title": "",
        "parent": "can.Observe.attributes",
        "src": "can/observe/attributes/attributes.js",
        "line": 237,
        "id": 52
    },
    "can.Observe.prototype.convert": {
        "name": "can.Observe.prototype.convert",
        "type": "function",
        "body": "",
        "description": "",
        "hide": true,
        "title": "",
        "parent": "can.Observe.attributes",
        "src": "can/observe/attributes/attributes.js",
        "line": 283,
        "id": 53
    },
    "can.Observe.prototype.attributes.serialize": {
        "type": "function",
        "name": "can.Observe.prototype.attributes.serialize",
        "parent": "can.Observe.attributes",
        "body": "<p>You can set the serialization methods similar to the convert methods:</p>\n\n<pre><code>var Contact = can.Observe({\n    attributes : { \n        birthday : 'date'\n    },\n    serialize : {\n        date : function( val, type ){\n            return val.getYear() + \n                \"-\" + (val.getMonth() + 1) + \n                \"-\" + val.getDate(); \n        }\n    }\n},{})\n\nvar contact = new Contact();\ncontact.attr('birthday', new Date());\ncontact.serialize()\n//-&gt; { birthday: 'YYYY-MM-DD' }\n</code></pre>\n\n<p>You can also get and serialize an individual property by passing the attribute\nname to the <code>serialize</code> function.  Building on the above demo, we can serialize\nthe <code>birthday</code> attribute only.</p>\n\n<pre><code>contact.serialize('birthday') //-&gt; 'YYYY-MM-DD'\n</code></pre>",
        "description": "<p><code>can.Observe.prototype.serialize</code> serializes an object for the object.  Serialized data is typically used to send back to a server.</p>",
        "title": "serialize (prototype)",
        "signatures": [{
                "code": "serialize([attrName])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "optional": true,
                        "name": "attrName",
                        "description": "<p>If passed, returns only a serialization of the named attribute.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>A serialization of this Observe.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/attributes/attributes.js",
        "line": 308,
        "id": 54
    },
    "can/observe/backup/backup.md": {
        "type": "script",
        "name": "can/observe/backup/backup.md"
    },
    "can.Observe.backup": {
        "type": "page",
        "name": "can.Observe.backup",
        "body": "",
        "description": "<p>can.Observe.backup is a plugin that provides a dirty bit for properties on an Observe,\nand lets you restore the original values of an Observe's properties after they are changed.</p>\n\n<p>Here is an example showing how to use <code>[can.Observe.prototype.backup backup]</code> to save values,\n<code>[can.Observe.prototype.restore restore]</code> to restore them, and <code>[can.Observe.prototype.isDirty isDirty]</code>\nto check if the Observe has changed:</p>\n\n<pre><code class=\"lang-javascript\">var recipe = new can.Observe({\n  title: 'Pancake Mix',\n  yields: '3 batches',\n  ingredients: [{\n    ingredient: 'flour',\n    quantity: '6 cups'\n  },{\n    ingredient: 'baking soda',\n    quantity: '1 1/2 teaspoons'\n  },{\n    ingredient: 'baking powder',\n    quantity: '3 teaspoons'\n  },{\n    ingredient: 'salt',\n    quantity: '1 tablespoon'\n  },{\n    ingredient: 'sugar',\n    quantity: '2 tablespoons'\n  }]\n});\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.title;     // 'Flapjack Mix'\nrecipe.isDirty(); // true\n\nrecipe.restore();\nrecipe.title;     // 'Pancake Mix'</code></pre>",
        "title": "backup",
        "parent": "can.Observe.plugins",
        "plugin": "can/observe/backup",
        "test": "can/observe/backup/qunit.html",
        "download": "http://donejs.com/can/dist/can.observe.backup.js",
        "src": "can/observe/backup/backup.md",
        "id": 55
    },
    "can/observe/backup/backup.js": {
        "type": "script",
        "name": "can/observe/backup/backup.js"
    },
    "can.Observe.backup.prototype.backup": {
        "type": "function",
        "name": "can.Observe.backup.prototype.backup",
        "parent": "can.Observe.backup",
        "body": "",
        "description": "<p>Save the values of the properties of an Observe. </p>",
        "title": "backup",
        "plugin": "can/observe/backup",
        "signatures": [{
                "code": "backup()",
                "description": "",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "can.Observe"
                        }
                    ],
                    "description": "<p>The Observe, for chaining.</p>\n\n<p><code>backup</code> backs up the current state of the properties of an Observe and marks\nthe Observe as clean. If any of the properties change value, the original\nvalues can be restored with <code>[can.Observe.prototype.restore]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var recipe = new can.Observe({\n  title: 'Pancake Mix',\n  yields: '3 batches',\n  ingredients: [{\n    ingredient: 'flour',\n    quantity: '6 cups'\n  },{\n    ingredient: 'baking soda',\n    quantity: '1 1/2 teaspoons'\n  },{\n    ingredient: 'baking powder',\n    quantity: '3 teaspoons'\n  },{\n    ingredient: 'salt',\n    quantity: '1 tablespoon'\n  },{\n    ingredient: 'sugar',\n    quantity: '2 tablespoons'\n  }]\n});\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.title;     // 'Flapjack Mix'\n\nrecipe.restore();\nrecipe.title;     // 'Pancake Mix'</code></pre>"
                }
            }
        ],
        "src": "can/observe/backup/backup.js",
        "line": 14,
        "id": 56
    },
    "can.Observe.backup.prototype.isDirty": {
        "type": "function",
        "name": "can.Observe.backup.prototype.isDirty",
        "parent": "can.Observe.backup",
        "body": "",
        "description": "<p>Check whether an Observe has changed since the last time it was backed up. </p>",
        "title": "isDirty",
        "plugin": "can/observe/backup",
        "signatures": [{
                "code": "isDirty([deep])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "bool"
                            }
                        ],
                        "optional": true,
                        "name": "deep",
                        "defaultValue": "false",
                        "description": "<p>whether to check nested Observes</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "bool"
                        }
                    ],
                    "description": "<p>Whether the Observe has changed since the last time it was [can.Observe.prototype.backup backed up].\nIf the Observe has never been backed up, <code>isDirty</code> returns <code>undefined</code>.</p>\n\n<p><code>isDirty</code> checks whether any properties have changed value or whether any properties have\nbeen added or removed since the last time the Observe was backed up. If <em>deep</em> is <code>true</code>,\n<code>isDirty</code> will include nested Observes in its checks.</p>\n\n<pre><code class=\"lang-javascript\">var recipe = new can.Observe({\n  title: 'Pancake Mix',\n  yields: '3 batches',\n  ingredients: [{\n    ingredient: 'flour',\n    quantity: '6 cups'\n  },{\n    ingredient: 'baking soda',\n    quantity: '1 1/2 teaspoons'\n  },{\n    ingredient: 'baking powder',\n    quantity: '3 teaspoons'\n  },{\n    ingredient: 'salt',\n    quantity: '1 tablespoon'\n  },{\n    ingredient: 'sugar',\n    quantity: '2 tablespoons'\n  }]\n});\n\nrecipe.isDirty();     // false\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.isDirty();     // true\nrecipe.restore();\n* recipe.isDirty();   // false\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // true\n\nrecipe.backup();\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // false</code></pre>"
                }
            }
        ],
        "src": "can/observe/backup/backup.js",
        "line": 63,
        "id": 57
    },
    "can.Observe.backup.prototype.restore": {
        "type": "function",
        "name": "can.Observe.backup.prototype.restore",
        "parent": "can.Observe.backup",
        "body": "",
        "description": "<p>Restore saved values of an Observe's properties. </p>",
        "title": "restore",
        "plugin": "can/observe/backup",
        "signatures": [{
                "code": "restore([deep])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "bool"
                            }
                        ],
                        "optional": true,
                        "name": "deep",
                        "defaultValue": "false",
                        "description": "<p>whether to restore properties in nested Observes</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Observe"
                        }
                    ],
                    "description": "<p>The Observe, for chaining.</p>\n\n<p><code>restore</code> sets the properties of an Observe back to what they were the last time \n[can.Observe.prototype.backup backup] was called. If <em>deep</em> is <code>true</code>,\n<code>restore</code> will also restore the properties of nested Observes.</p>\n\n<p><code>restore</code> will not remove properties that were added since the last backup, but it\nwill re-add properties that have been removed.</p>\n\n<pre><code class=\"lang-javascript\">var recipe = new can.Observe({\n  title: 'Pancake Mix',\n  yields: '3 batches',\n  ingredients: [{\n    ingredient: 'flour',\n    quantity: '6 cups'\n  },{\n    ingredient: 'baking soda',\n    quantity: '1 1/2 teaspoons'\n  },{\n    ingredient: 'baking powder',\n    quantity: '3 teaspoons'\n  },{\n    ingredient: 'salt',\n    quantity: '1 tablespoon'\n  },{\n    ingredient: 'sugar',\n    quantity: '2 tablespoons'\n  }]\n});\n\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.restore();\nrecipe.attr('title'); // 'Pancake Mix'\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.restore();\nrecipe.attr('ingredients.0.quantity'); // '7 cups'\nrecipe.restore(true);\nrecipe.attr('ingredients.0.quantity'); // '6 cups'</code></pre>\n\n<h2>Events</h2>\n\n<p>When <code>restore</code> sets values or re-adds properties, the same events will be fired (including\n<em>change</em>, <em>add</em>, and <em>set</em>) as if the values of the properties had been set using <code>[can.Observe.attr attr]</code>.</p>"
                }
            }
        ],
        "src": "can/observe/backup/backup.js",
        "line": 128,
        "id": 58
    },
    "can/observe/delegate/delegate.js": {
        "type": "script",
        "name": "can/observe/delegate/delegate.js"
    },
    "can.Observe.prototype.delegate": {
        "type": "function",
        "name": "can.Observe.prototype.delegate",
        "params": [{
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "selector",
                "description": "<p>The attributes you want to listen for changes in.</p>\n\n<p>Selector should be the property or \n  property names of the element you are searching.  Examples:</p>\n\n<pre><code>\"name\" - listens to the \"name\" property changing\n\"name, address\" - listens to \"name\" or \"address\" changing\n\"name address\" - listens to \"name\" or \"address\" changing\n\"address.*\" - listens to property directly in address\n\"address.**\" - listens to any property change in address\n\"foo=bar\" - listens when foo is \"bar\"\n</code></pre>"
            }, {
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "event",
                "description": "<p>The event name.  One of (\"set\",\"add\",\"remove\",\"change\")</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": [{
                                "name": "ev"
                            }, {
                                "name": "newVal"
                            }, {
                                "name": "oldVal"
                            }, {
                                "name": "prop"
                            }
                        ]
                    }
                ],
                "name": "handler",
                "description": "<p>The callback handler \ncalled with:</p>\n\n<ul>\n<li>newVal - the new value set on the observe</li>\n<li>oldVal - the old value set on the observe</li>\n<li>prop - the prop name that was changed</li>\n</ul>"
            }
        ],
        "parent": "can.Observe.delegate",
        "body": "",
        "description": "<p><code>delegate( selector, event, handler(ev,newVal,oldVal,from) )</code> listen for changes \nin a child attribute from the parent. The child attribute\ndoes not have to exist.</p>\n\n<pre><code>// create an observable\nvar observe = can.Observe({\n  foo : {\n    bar : \"Hello World\"\n  }\n})\n\n//listen to changes on a property\nobserve.delegate(\"foo.bar\",\"change\", function(ev, prop, how, newVal, oldVal){\n  // foo.bar has been added, set, or removed\n  this //-&gt; \n});\n\n// change the property\nobserve.attr('foo.bar',\"Goodbye Cruel World\")\n</code></pre>\n\n<h2>Types of events</h2>\n\n<p>Delegate lets you listen to add, set, remove, and change events on property.</p>\n\n<p><strong>add</strong></p>\n\n<p>An add event is fired when a new property has been added.</p>\n\n<pre><code>var o = new can.Control({});\no.delegate(\"name\",\"add\", function(ev, value){\n  // called once\n  can.$('#name').show()\n})\no.attr('name',\"Justin\")\no.attr('name',\"Brian\");\n</code></pre>\n\n<p>Listening to add events is useful for 'setup' functionality (in this case\nshowing the <code>#name</code> element.</p>\n\n<p><strong>set</strong></p>\n\n<p>Set events are fired when a property takes on a new value.  set events are\nalways fired after an add.</p>\n\n<pre><code>o.delegate(\"name\",\"set\", function(ev, value){\n  // called twice\n  can.$('#name').text(value)\n})\no.attr('name',\"Justin\")\no.attr('name',\"Brian\");\n</code></pre>\n\n<p><strong>remove</strong></p>\n\n<p>Remove events are fired after a property is removed.</p>\n\n<pre><code>o.delegate(\"name\",\"remove\", function(ev){\n  // called once\n  $('#name').text(value)\n})\no.attr('name',\"Justin\");\no.removeAttr('name');\n</code></pre>\n\n<h2>Wildcards - matching multiple properties</h2>\n\n<p>Sometimes, you want to know when any property within some part \nof an observe has changed. Delegate lets you use wildcards to \nmatch any property name.  The following listens for any change\non an attribute of the params attribute:</p>\n\n<pre><code>var o = can.Control({\n  options : {\n    limit : 100,\n    offset: 0,\n    params : {\n      parentId: 5\n    }\n  }\n})\no.delegate('options.*','change', function(){\n  alert('1');\n})\no.delegate('options.**','change', function(){\n  alert('2');\n})\n\n// alerts 1\n// alerts 2\no.attr('options.offset',100)\n\n// alerts 2\no.attr('options.params.parentId',6);\n</code></pre>\n\n<p>Using a single wildcard (<code><em></code>) matches single level\nproperties.  Using a double wildcard (<code></em>*</code>) matches\nany deep property.</p>\n\n<h2>Listening on multiple properties and values</h2>\n\n<p>Delegate lets you listen on multiple values at once.  The following listens\nfor first and last name changes:</p>\n\n<pre><code>var o = new can.Observe({\n  name : {first: \"Justin\", last: \"Meyer\"}\n})\n\no.bind(\"name.first,name.last\", \n       \"set\",\n       function(ev,newVal,oldVal,from){\n\n})\n</code></pre>\n\n<h2>Listening when properties are a particular value</h2>\n\n<p>Delegate lets you listen when a property is <strong>set</strong> to a specific value:</p>\n\n<pre><code>var o = new can.Observe({\n  name : \"Justin\"\n})\n\no.bind(\"name=Brian\", \n       \"set\",\n       function(ev,newVal,oldVal,from){\n\n})\n</code></pre>",
        "title": "delegate",
        "plugin": "can/observe/delegate",
        "returns": {
            "types": [{
                    "type": "can.Observe"
                }
            ],
            "description": "<p>the observe for chaining</p>"
        },
        "src": "can/observe/delegate/delegate.js",
        "line": 133,
        "id": 59
    },
    "can.Observe.prototype.undelegate": {
        "type": "function",
        "name": "can.Observe.prototype.undelegate",
        "params": [{
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "selector",
                "description": "<p>the attribute name of the object you want to undelegate from.</p>"
            }, {
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "event",
                "description": "<p>the event name</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "name": "handler",
                "description": "<p>the callback handler</p>"
            }
        ],
        "parent": "can.Observe.delegate",
        "body": "",
        "description": "<p><code>undelegate( selector, event, handler )</code> removes a delegated event handler from an observe.</p>\n\n<pre><code>observe.undelegate(\"name\",\"set\", handler )\n</code></pre>",
        "title": "undelegate",
        "returns": {
            "types": [{
                    "type": "can.Observe"
                }
            ],
            "description": "<p>the observe for chaining</p>"
        },
        "src": "can/observe/delegate/delegate.js",
        "line": 327,
        "id": 60
    },
    "can/observe/delegate/delegate.md": {
        "type": "script",
        "name": "can/observe/delegate/delegate.md"
    },
    "can.Observe.delegate": {
        "type": "page",
        "name": "can.Observe.delegate",
        "body": "",
        "description": "<p>The <strong>delegate</strong> plugin allows you to listen to more specific event changes on \n[can.Observe Observes].  It allows you to specify:</p>\n\n<ul>\n<li>the <strong>attribute</strong> or <strong>attributes</strong> - that you want to listen to and optionally the <strong>value</strong> you want it to match</li>\n<li>the <strong>type</strong> of event (add,set,remove,change)</li>\n</ul>\n\n<p>Listen to specific event changes with \n<code>[can.Observe::delegate delegate](selector, event, handler(ev,newVal,oldVal,from))</code> :</p>\n\n<pre><code>// create an observable\nvar observe = new can.Observe({\n  name : {\n    first : \"Justin Meyer\"\n  }\n})\n  var handler;\n//listen to changes on a property\nobserve.delegate(\"name.first\",\"set\", \n  handler = function(ev, newVal, oldVal, prop){\n\n  this   //-&gt; \"Justin\"\n  ev.currentTarget //-&gt; observe\n  newVal //-&gt; \"Justin Meyer\"\n  oldVal //-&gt; \"Justin\"\n  prop   //-&gt; \"name.first\"\n});\n\n// change the property\nobserve.attr('name.first',\"Justin\")\n</code></pre>\n\n<p>Delegate will listen on the object until you \ncall <code>[can.Observe::undelegate undelegate](selector, event, handler)</code> to remove the event handler.</p>\n\n<pre><code>observe.undelegate(\"name.first\",\"set\", handler );\n</code></pre>",
        "title": "delegate",
        "parent": "can.Observe.plugins",
        "plugin": "can/observe/delegate",
        "test": "can/observe/delegate/qunit.html",
        "download": "http://donejs.com/can/dist/can.observe.delegate.js",
        "src": "can/observe/delegate/delegate.md",
        "id": 61
    },
    "can/observe/setter/setter.md": {
        "type": "script",
        "name": "can/observe/setter/setter.md"
    },
    "can.Observe.setter": {
        "type": "page",
        "name": "can.Observe.setter",
        "body": "<p>The <code>attr</code> function looks for a <code>setATTRNAME</code> function to handle setting \nthe <code>ATTRNAME</code> property.</p>\n\n<p>By providing a function that takes the raw data and returns a form useful for JavaScript, \nwe can make our observes automatically convert data.</p>\n\n<pre><code>var Contact = can.Observe({\n    setBirthday : function(raw){\n        if(typeof raw == 'number'){\n            return new Date( raw )\n        }else if(raw instanceof Date){\n            return raw;\n        }\n    }\n});\n\n// set on init\nvar contact = new Contact({ birthday: 1332777411799 });\n\n// get the contact's birthday via 'attr' method\ncontact.attr('birthday') \n    // -&gt; Mon Mar 26 2012 08:56:51 GMT-0700 (MST)\n\n// set via 'attr' method\ncontact.attr('birthday', new Date('11/11/11').getTime())\n\ncontact.attr('birthday') \n    // -&gt; Fri Nov 11 2011 00:00:00 GMT-0700 (MST)\n\ncontact.attr({\n    'birthday': new Date('03/31/12').getTime()\n});\n\ncontact.attr('birthday') \n    // -&gt; Sat Mar 31 2012 00:00:00 GMT-0700 (MST)\n</code></pre>\n\n<p>If the returned value is <code>undefined</code>, this means the setter is either in an async \nevent or the attribute(s) were not set. </p>\n\n<h2>Differences From <code>attr</code></h2>\n\n<p>The way that return values from setters affect the value of an Observe's property is\ndifferent from [can.Observe::attr attr]'s normal behavior. Specifically, when the \nproperty's current value is an Observe or List, and an Observe or List is returned\nfrom a setter, the effect will not be to merge the values into the current value as\nif the return value was fed straight into <code>attr</code>, but to replace the value with the\nnew Observe or List completely:</p>\n\n<pre><code class=\"lang-javascript\">var Contact = can.Observe({\n    setInfo: function(raw) {\n      return raw;\n    }\n});\n\nvar alice = new Contact({info: {name: 'Alice Liddell', email: 'alice@liddell.com'}});\nalice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\nalice.info._cid; // '.observe1'\n\nalice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\nalice.attr(); // {name: 'Allison Wonderland', 'phone': '888-888-8888'}\nalice.info._cid; // '.observe2'</code></pre>\n\n<p>If you would rather have the new Observe or List merged into the current value, call\n<code>attr</code> inside the setter:</p>\n\n<pre><code class=\"lang-javascript\">var Contact = can.Observe({\n    setInfo: function(raw) {\n      this.info.attr(raw);\n      return this.info;\n    }\n});\n\nvar alice = new Contact({info: {name: 'Alice Liddell', email: 'alice@liddell.com'}});\nalice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\nalice.info._cid; // '.observe1'\n\nalice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\nalice.attr(); // {name: 'Allison Wonderland', email: 'alice@liddell.com', 'phone': '888-888-8888'}\nalice.info._cid; // '.observe1'</code></pre>\n\n<h2>Error Handling</h2>\n\n<p>Setters can trigger errors if values passed didn't meet your defined validation(s).</p>\n\n<p>Below is an example of a <em>School</em> observable that accepts a name property and errors\nwhen no value or a empty string is passed.</p>\n\n<pre><code>var School = can.Observe({\n    setName : function(name, success, error){\n        if(!name){\n            error(\"no name\");\n        }\n        return error;\n    }\n});\n\nvar school = new School();\n\n// bind to error handler\nschool.bind(\"error\", function(ev, attr, error){\n    alert(\"no name\")\n})\n\n// set to empty string\nschool.attr(\"name\",\"\");\n</code></pre>\n\n<h2>Demo</h2>\n\n<p>The example app is a pagination widget that updates\nthe offsets when the <em>Prev</em> or <em>Next</em> button is clicked.</p>\n\n<div class='demo_wrapper' data-demo-src='can/observe/setter/setter-paginate.html'></div>",
        "description": "<p><code>can.Observe.setter(name, success(value), error(errors))</code> extends the Observe object \nto provide convenient helper methods for setting attributes on a observable.</p>",
        "title": "setter",
        "parent": "can.Observe.plugins",
        "plugin": "can/observe/setter",
        "download": "http://donejs.com/can/dist/can.observe.setter.js",
        "test": "can/observe/setter/qunit.html",
        "comment": " ",
        "src": "can/observe/setter/setter.md",
        "id": 62
    },
    "can/observe/setter/setter.js": {
        "type": "script",
        "name": "can/observe/setter/setter.js"
    },
    "can.classize": {
        "type": "function",
        "name": "can.classize",
        "parent": "can.Observe.setter",
        "body": "<p><code>can.classize</code> splits a string by underscores or\ndashes and capitalizes each part before joining\nthem back together. This method is useful for\ntaking HTML class names and getting the original\nControl name from them.</p>\n\n<pre><code class=\"lang-javascript\">can.classize('my_control_name'); // 'MyControlName'</code></pre>",
        "description": "<p>Make a string into a class name. </p>",
        "title": "can.classize",
        "signatures": [{
                "code": "can.classize(str)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "str",
                        "description": "<p>The string to transform.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>The string as a class name.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/observe/setter/setter.js",
        "line": 2,
        "id": 63
    },
    "can/observe/validations/validations.md": {
        "type": "script",
        "name": "can/observe/validations/validations.md"
    },
    "can.Observe.validations": {
        "type": "page",
        "name": "can.Observe.validations",
        "body": "<div class='demo_wrapper' data-demo-src='can/observe/validations/validations.html'></div>",
        "description": "<p>The <code>can/observe/validations</code> plugin provides validations on observes. Validations\nare set on [can.Observe]'s <strong>static</strong> <code>init</code> function.</p>\n\n<p>The following validates the <code>birthday</code> attribute in Contacts:</p>\n\n<pre><code>Contact = can.Observe({\n    init : function(){\n        // validates that birthday is in the future\n        this.validate(\"birthday\",function(birthday){\n            if(birthday &gt; new Date){\n                return \"your birthday needs to be in the past\"\n            }\n        })\n    }\n},{});\n\nvar contact = new Contact({birthday: new Date(2012,0) })\n</code></pre>\n\n<p>Use [can.Observe::errors errors] <code>( [attrs...], newVal )</code> to read errors\nor to test if setting a value would create an error:</p>\n\n<pre><code>// Check if there are errors on the instance\ncontact.errors() //-&gt; null - there are no errors\n\n// Test if setting birthday to new Date(3013,0) would error\ncontact.errros(\"birthday\", \n               new Date(3013,0) ) \n               //-&gt; [\"your birthday needs to be in the past\"] \n\n// Set birthday anyway\ncontact.attr(\"birthday\", new Date(3013,0) )\n\n// Get all errors\ncontact.errors() \n    //-&gt; {\n    //     birthday: [\"your birthday needs to be in the past\"]\n    //   }\n\n// Get errors for birthday\ncontact.errors(\"birthday\") \n    //-&gt; [\"your birthday needs to be in the past\"]\n</code></pre>\n\n<h2>Validation Methods</h2>\n\n<p>The most basic validate method is [can.Observe.validate validate]<code>()</code>.  </p>\n\n<p>There are several built-in validation methods so you don't have to define your own in all cases like in the birthday example above.</p>\n\n<ul>\n<li>[can.Observe.validate]<code>(attrNames, options, proc)</code> Attributes validated with function.</li>\n<li>[can.Observe.validateFormatOf]<code>(attrNames, regexp, options)</code> Attributes match the regular expression.    </li>\n<li>[can.Observe.validateInclusionOf]<code>( attrNames, inArray, [options] )</code> Attributes are available in a particular array.    </li>\n<li>[can.Observe.validateLengthOf validateLengthOf]<code>(attrNames, min, max, [options])</code> Attributes' lengths are in the given range.    </li>\n<li>[can.Observe.validatePresenceOf validatePresenceOf]<code>( attrNames, [options] )</code> Attributes are not blank.    </li>\n<li>[can.Observe.validateRangeOf validateRangeOf]<code>(attrNames, low, hi, [options])</code> Attributes are in the given numeric range.</li>\n</ul>\n\n<h2>Error Method</h2>\n\n<p><a href=\"\">can.Observe::errors</a> runs the validations on this model. You can also pass it an array \nof attributes to run only those attributes. It returns \nnothing if there are no errors, or an object of errors by attribute.</p>\n\n<p>To use validations, it's required you use the <em>observe/validations</em> plugin.</p>\n\n<pre><code>can.Observe(\"Task\",{\n    init : function(){\n        this.validatePresenceOf(\"dueDate\")\n    }\n},{});\n\nvar task = new Task(),\n    errors = task.errors()\n\nerrors.dueDate[0] //-&gt; \"can't be empty\"\n</code></pre>\n\n<h2>Listening to events</h2>\n\n<p>Use [can.Observe::bind bind] to listen to error messages:</p>\n\n<pre><code>contact.bind(\"error\", function(ev, attr, errors){\n    // attr = \"birthday\"\n    // errors = { birthday: \n    //      [\"your birthday needs to be in the past\"] }\n})\n</code></pre>\n\n<h2>Demo</h2>\n\n<p>Click a person's name to update their birthday.  If you put the date\nin the future, say the year 2525, it will report back an error.</p>",
        "title": "validations",
        "parent": "can.Observe.plugins",
        "plugin": "can/observe/validations",
        "download": "http://donejs.com/can/dist/can.observe.validations.js",
        "test": "can/observe/validations/qunit.html",
        "src": "can/observe/validations/validations.md",
        "id": 64
    },
    "can/observe/validations/validations.js": {
        "type": "script",
        "name": "can/observe/validations/validations.js"
    },
    "static": {
        "type": "static",
        "body": "",
        "description": "",
        "name": "static",
        "parent": null,
        "src": "can/observe/validations/validations.js",
        "line": 68,
        "id": 65
    },
    "can.Observe.validations.static.validate": {
        "name": "can.Observe.validations.static.validate",
        "type": "function",
        "parent": "can.Observe.validations",
        "body": "",
        "description": "<p><code>validate(attrNames, [options,] validateProc(value, attrName) )</code> validates each of the\nspecified attributes with the given <code>validateProc</code> function.  The function\nshould return a value if there is an error.  By default, the return value is\nthe error message.  Validations should be set in the Constructor's static init method.</p>\n\n<p>The following example validates that a person's age is a number:</p>\n\n<pre><code>Person = can.Observe({\n    init : function(){\n      this.validate([\"age\"], function(val){\n        if( typeof val === 'number' ){\n          return \"must be a number\"\n        }\n      })\n    }\n},{})\n</code></pre>\n\n<p>The error message can be overwritten with <code>options</code> <strong>message</strong> property:</p>\n\n<pre><code>Person = can.Observe({\n    init : function(){\n      this.validate(\n        \"age\",\n      {message: \"must be a number\"},\n      function(val){\n          if( typeof val === 'number' ){\n            return true\n          }\n      })\n  }\n},{})\n</code></pre>",
        "title": "validate",
        "params": [{
                "types": [{
                        "type": "Array",
                        "template": [{
                                "types": [{
                                        "type": "String"
                                    }
                                ]
                            }
                        ]
                    }
                ],
                "name": "attrNames",
                "description": "<p>Attribute name(s) to to validate</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "options",
                "description": "<p>Options for the\nvalidations.  Valid options include 'message' and 'testIf'.</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": [{
                                "types": [{
                                        "type": "*"
                                    }
                                ],
                                "name": "value"
                            }, {
                                "types": [{
                                        "type": "String"
                                    }
                                ],
                                "name": "attrName"
                            }
                        ]
                    }
                ],
                "name": "validateProc",
                "description": "<p>Function used to validate each\ngiven attribute. Returns nothing if valid and an error message\notherwise. Function is called in the instance context and takes the\n<code>value</code> and <code>attrName</code> to validate.</p>"
            }
        ],
        "src": "can/observe/validations/validations.js",
        "line": 78,
        "id": 66
    },
    "can.Observe.validations.static.validationMessages": {
        "name": "can.Observe.validations.static.validationMessages",
        "type": "property",
        "parent": "can.Observe.validations",
        "body": "",
        "description": "<p><code>validationMessages</code> has the default validation error messages that will be returned by the builtin\nvalidation methods. These can be overwritten by assigning new messages\nto <code>can.Observe.validationMessages</code> in your application setup.</p>\n\n<p>The following messages (with defaults) are available:</p>\n\n<ul>\n<li>format - \"is invalid\"</li>\n<li>inclusion - \"is not a valid option (perhaps out of range)\"</li>\n<li>lengthShort - \"is too short\"</li>\n<li>lengthLong - \"is too long\"</li>\n<li>presence - \"can't be empty\"</li>\n<li>range - \"is out of range\"</li>\n</ul>\n\n<p>It is important to steal can/observe/validations before\noverwriting the messages, otherwise the changes will\nbe lost once steal loads it later.</p>\n\n<h2>Example</h2>\n\n<pre><code>can.Observe.validationMessages.format = \"is invalid dummy!\"\n</code></pre>",
        "title": "validationMessages",
        "src": "can/observe/validations/validations.js",
        "line": 127,
        "id": 67
    },
    "can.Observe.validations.static.validateFormatOf": {
        "type": "function",
        "name": "can.Observe.validations.static.validateFormatOf",
        "params": [{
                "types": [{
                        "type": "Array",
                        "template": [{
                                "types": [{
                                        "type": "String"
                                    }
                                ]
                            }
                        ]
                    }
                ],
                "name": "attrNames",
                "description": "<p>Attribute name(s) to to validate</p>"
            }, {
                "types": [{
                        "type": "RegExp"
                    }
                ],
                "name": "regexp",
                "description": "<p>Regular expression used to match for validation</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "options",
                "description": "<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"
            }
        ],
        "parent": "can.Observe.validations",
        "body": "",
        "description": "<p><code>validateFormatOf(attrNames, regexp, options)</code> validates where the values of\nspecified attributes are of the correct form by\nmatching it against the regular expression provided.</p>\n\n<pre><code>init : function(){\n     this.validateFormatOf([\"email\"],/[\\w\\.]+@]w+\\.\\w+/,{\n       message : \"invalid email\"\n  })\n}\n</code></pre>",
        "title": "validateFormatOf",
        "src": "can/observe/validations/validations.js",
        "line": 161,
        "id": 68
    },
    "can.Observe.validations.static.validateInclusionOf": {
        "type": "function",
        "name": "can.Observe.validations.static.validateInclusionOf",
        "params": [{
                "types": [{
                        "type": "Array",
                        "template": [{
                                "types": [{
                                        "type": "String"
                                    }
                                ]
                            }
                        ]
                    }
                ],
                "name": "attrNames",
                "description": "<p>Attribute name(s) to to validate</p>"
            }, {
                "types": [{
                        "type": "Array"
                    }
                ],
                "name": "inArray",
                "description": "<p>Array of options to test for inclusion</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "options",
                "description": "<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"
            }
        ],
        "parent": "can.Observe.validations",
        "body": "",
        "description": "<p>Validates whether the values of the specified attributes are available in a particular\narray.</p>\n\n<pre><code>init : function(){\n  this.validateInclusionOf([\"salutation\"],[\"Mr.\",\"Mrs.\",\"Dr.\"])\n}\n</code></pre>",
        "title": "validateInclusionOf",
        "src": "can/observe/validations/validations.js",
        "line": 188,
        "id": 69
    },
    "can.Observe.validations.static.validateLengthOf": {
        "type": "function",
        "name": "can.Observe.validations.static.validateLengthOf",
        "params": [{
                "types": [{
                        "type": "Array",
                        "template": [{
                                "types": [{
                                        "type": "String"
                                    }
                                ]
                            }
                        ]
                    }
                ],
                "name": "attrNames",
                "description": "<p>Attribute name(s) to to validate</p>"
            }, {
                "types": [{
                        "type": "Number"
                    }
                ],
                "name": "min",
                "description": "<p>Minimum length (inclusive)</p>"
            }, {
                "types": [{
                        "type": "Number"
                    }
                ],
                "name": "max",
                "description": "<p>Maximum length (inclusive)</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "options",
                "description": "<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"
            }
        ],
        "parent": "can.Observe.validations",
        "body": "",
        "description": "<p>Validates that the specified attributes' lengths are in the given range.</p>\n\n<pre><code>init : function(){\n  this.validateInclusionOf([\"suffix\"],3,5)\n}\n</code></pre>",
        "title": "validateLengthOf",
        "src": "can/observe/validations/validations.js",
        "line": 217,
        "id": 70
    },
    "can.Observe.validations.static.validatePresenceOf": {
        "type": "function",
        "name": "can.Observe.validations.static.validatePresenceOf",
        "params": [{
                "types": [{
                        "type": "Array",
                        "template": [{
                                "types": [{
                                        "type": "String"
                                    }
                                ]
                            }
                        ]
                    }
                ],
                "name": "attrNames",
                "description": "<p>Attribute name(s) to to validate</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "options",
                "description": "<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"
            }
        ],
        "parent": "can.Observe.validations",
        "body": "",
        "description": "<p>Validates that the specified attributes are not blank.</p>\n\n<pre><code>init : function(){\n  this.validatePresenceOf([\"name\"])\n}\n</code></pre>",
        "title": "validatePresenceOf",
        "src": "can/observe/validations/validations.js",
        "line": 243,
        "id": 71
    },
    "can.Observe.validations.static.validateRangeOf": {
        "type": "function",
        "name": "can.Observe.validations.static.validateRangeOf",
        "params": [{
                "types": [{
                        "type": "Array",
                        "template": [{
                                "types": [{
                                        "type": "String"
                                    }
                                ]
                            }
                        ]
                    }
                ],
                "name": "attrNames",
                "description": "<p>Attribute name(s) to to validate</p>"
            }, {
                "types": [{
                        "type": "Number"
                    }
                ],
                "name": "low",
                "description": "<p>Minimum value (inclusive)</p>"
            }, {
                "types": [{
                        "type": "Number"
                    }
                ],
                "name": "hi",
                "description": "<p>Maximum value (inclusive)</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "options",
                "description": "<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"
            }
        ],
        "parent": "can.Observe.validations",
        "body": "",
        "description": "<p>Validates that the specified attributes are in the given numeric range.</p>\n\n<pre><code>init : function(){\n  this.validateRangeOf([\"age\"],21, 130);\n}\n</code></pre>",
        "title": "validateRangeOf",
        "src": "can/observe/validations/validations.js",
        "line": 264,
        "id": 72
    },
    "prototype": {
        "body": "",
        "description": "",
        "type": "prototype",
        "name": "prototype",
        "parent": null,
        "src": "can/observe/validations/validations.js",
        "line": 291,
        "id": 73
    },
    "can/observe/compute/compute.js": {
        "type": "script",
        "name": "can/observe/compute/compute.js"
    },
    "can.compute": {
        "name": "can.compute",
        "type": "constructor",
        "body": "<p><code>can.compute</code> lets you make observable values. A compute is actually a function that returns\nthe computed value, but you can also use the compute to set the value and you can use\n<code>bind</code> to listen to changes in the compute's return value. In this way, computes are similar\nto [can.Observe Observes], but they represent a single value rather than a collection of values.</p>\n\n<h2>Working with computes</h2>\n\n<p>The simplest way to use a compute is to have it store a single value, and to set it when\nthat value needs to change:</p>\n\n<pre><code class=\"lang-javascript\">var tally = can.compute(12);\ntally(); // 12\n\ntally(13);\ntally(); // 13</code></pre>\n\n<p>This is useful for making observable values, but the real power of <code>can.compute</code> reveals\nitself when you combine it with <code>[can.Observe]</code>. If you use a compute that derives its\nvalue from properties of an Observe, the compute will listen for changes in those\nproperties and automatically recalculate itself, emitting a <em>change</em> event if its value\nchanges.</p>\n\n<p>As this example shows, this kind of compute rarely has need to be set directly:</p>\n\n<pre><code class=\"lang-javascript\">var person = new can.Observe({\n    firstName: 'Alice',\n    lastName: 'Liddell'\n});\n\nvar fullName = can.compute(function() {\n    return person.attr('firstName') + ' ' + person.attr('lastName');\n});\nfullName.bind('change', function(ev, newVal, oldVal) {\n    console.log(\"This person's full name is now \" + newVal + '.');\n});\n\nperson.attr('firstName', 'Allison'); // The log reads:\n                                     // \"This person's full name is now Allison Liddell.\"</code></pre>\n\n<p>Take special notice of how the definition of the compute uses <code>[can.Observe.prototype.attr attr]</code>\nto read the values of the properties of <code>person</code>. This is how the compute knows to listen\nfor changes. and is similar to the need to use <code>attr</code> when live-binding properties of Observes into\n<code>[can.EJS EJS]</code> templates.</p>\n\n<p>A specific use for bound computes like this is to provide a way to work with values of Observable\nproperties in different units:</p>\n\n<pre><code class=\"lang-javascript\">var wall = new can.Observe({\n    material: 'brick',\n    length: 10 // in feet\n});\n\nvar wallLengthInMeters = can.compute(function(lengthInM) {\n    if(lengthInM !== undefined) {\n        wall.attr('length', lengthInM / 3.28084);\n    } else {\n        return wall.attr('length') * 3.28084;\n    }\n});\n\nwallLengthInMeters(); // 3.048\n\n// When you set the compute...\nwallLengthInMeters(5);\nwallLengthInMeters(); // 5\n// ...the original Observe changes too.\nwall.length;          // 16.4042</code></pre>\n\n<h2>Events</h2>\n\n<p>When a compute's value is changed, it emits a <em>change</em> event. You can listen for this change\nevent by using <code>[can.compute.bind bind]</code> to bind an event handler to the compute:</p>\n\n<pre><code class=\"lang-javascript\">var tally = can.compute(0);\ntally.bind('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'</code></pre>\n\n<h2>Using computes to build Controls</h2>\n\n<p>It's a piece of cake to build a <code>[can.Control]</code> off of the value of a compute. And since computes\nare observable, it means that the view of that Control will update itself whenever the value\nof the compute updates. Here's a simple slider that works off of a compute:</p>\n\n<pre><code class=\"lang-javascript\">var project = new Observe({\n    name: 'A Very Important Project',\n    percentDone: .35\n});\n\ncan.Control('SimpleSlider', { }, {\n    init: function() {\n        this.element.html(can.view(this.options.view, this.options));\n    },\n    '.handle dragend': function(el, ev) {\n        var percent = this.calculateSliderPercent();\n        // set the compute's value\n        this.options.percentDone(percent);\n    },\n    '{percentDone} change': function(ev, newVal, oldVal) {\n       // react to the percentage changing some other way\n        this.moveSliderTo(newVal);\n    }\n    // Implementing calculateSliderPercent and moveSliderTo\n    // has been left as an exercise for the reader.\n});\n\nnew SimpleSlider('#slider', {percentDone: project.compute('percentDone')});</code></pre>\n\n<p>Now that's some delicious cake. More information on Controls can be found under <code>[can.Control]</code>.\nThere is also a full explanation of can.Observe's <code>[can.Observe.prototype.compute compute]</code>,\nwhich is used in the last line of the example above.</p>",
        "description": "",
        "parent": "canjs",
        "comment": " ",
        "signatures": [{
                "code": "can.compute(getterSetter[, context])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "getterSetter",
                        "description": "<p>A function that gets and optionally sets the value of the compute.\nWhen called with no parameters, <em>getterSetter</em> should return the current value of the compute. When\ncalled with a single parameter, <em>getterSetter</em> should arrange things so that the next read of the compute\nproduces that value.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "context",
                        "description": "<p>The context to use when evaluating the compute.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.compute"
                        }
                    ],
                    "description": "<p>A new compute.</p>"
                }
            }
        ],
        "src": "can/observe/compute/compute.js",
        "line": 132,
        "id": 74
    },
    "can.compute.isComputed": {
        "name": "can.compute.isComputed",
        "type": "property",
        "parent": "can.compute.prototype",
        "body": "",
        "description": "<p>Whether the value of the compute has been computed yet.</p>",
        "title": "isComputed",
        "src": "can/observe/compute/compute.js",
        "line": 422,
        "id": 75
    },
    "can.compute.bind": {
        "name": "can.compute.bind",
        "type": "function",
        "parent": "can.compute.prototype",
        "body": "",
        "description": "<p>Bind an event handler to a compute. </p>",
        "title": "bind",
        "signatures": [{
                "code": "bind(eventType, handler)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventType",
                        "description": "<p>The event to bind this handler to.\nThe only event type that computes emit is <em>change</em>.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": [{
                                        "types": [{
                                                "type": "Object",
                                                "options": [{
                                                        "name": "Object"
                                                    }
                                                ]
                                            }
                                        ]
                                    }, {
                                        "types": [{
                                                "type": "Object",
                                                "options": [{
                                                        "name": "*"
                                                    }
                                                ]
                                            }
                                        ]
                                    }, {
                                        "types": [{
                                                "type": "Object",
                                                "options": [{
                                                        "name": "*"
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "name": "handler",
                        "description": "<p>The handler to call when the event happens.\nThe handler should have three parameters:</p>\n\n<ul>\n<li><em>event</em> is the event object.</li>\n<li><em>newVal</em> is the newly-computed value of the compute.</li>\n<li><em>oldVal</em> is the value of the compute before it changed.</li>\n</ul>\n\n<p><code>bind</code> lets you listen to a compute to know when it changes. It works just like\ncan.Observe's <code>[can.Observe.prototype.bind bind]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var tally = can.compute(0);\ntally.bind('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'</code></pre>"
                    }
                ]
            }
        ],
        "src": "can/observe/compute/compute.js",
        "line": 447,
        "id": 76
    },
    "can.compute.unbind": {
        "name": "can.compute.unbind",
        "type": "function",
        "parent": "can.compute.prototype",
        "body": "",
        "description": "<p>Unbind an event handler from a compute. </p>",
        "title": "unbind",
        "signatures": [{
                "code": "unbind(eventType[, handler])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventType",
                        "description": "<p>The type of event to unbind.\nThe only event type available for computes is <em>change</em>.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "handler",
                        "description": "<p>If given, the handler to unbind.\nIf <em>handler</em> is not supplied, all handlers bound to <em>eventType</em>\nwill be removed.</p>"
                    }
                ]
            }
        ],
        "src": "can/observe/compute/compute.js",
        "line": 474,
        "id": 77
    },
    "can/model/model.md": {
        "type": "script",
        "name": "can/model/model.md"
    },
    "can.Model": {
        "type": "constructor",
        "name": "can.Model",
        "body": "",
        "description": "",
        "title": "",
        "parent": "canjs",
        "download": "can/model",
        "test": "can/model/qunit.html",
        "signatures": [{
                "code": "can.Model([name,] staticProperties, instanceProperties)",
                "description": "<p>Creates a can.Model class constructor. (See [can.Construct] for more details on this syntax.)</p>",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "optional": true,
                        "name": "name",
                        "description": "<p>If given, this will be the globally-available name of the constructor function.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "staticProperties",
                        "description": "<p>The static properties of the class. See below for properties with\nspecial meanings to <code>can.Model</code>.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "instanceProperties",
                        "description": "<p>The instance properties of instances of the class. These will usually\nbe functions.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "function",
                            "returns": {
                                "types": [{
                                        "type": "undefined"
                                    }
                                ]
                            },
                            "params": []
                        }
                    ],
                    "description": "<p>A can.Model constructor.</p>"
                }
            }, {
                "code": "new ModelConstructor([options])",
                "description": "<p>Creates a new instance of <em>ModelConstructor</em>.</p>",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "options",
                        "description": "<p>Options to pass to <code>setup</code> or <code>init</code>.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Model"
                        }
                    ],
                    "description": "<p>A new instance of <em>ModelConstructor</em>.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.md",
        "id": 78
    },
    "can/model/model.js": {
        "type": "script",
        "name": "can/model/model.js"
    },
    "can.Model.static": {
        "body": "",
        "description": "",
        "type": "static",
        "name": "can.Model.static",
        "parent": "can.Model",
        "src": "can/model/model.js",
        "line": 118,
        "id": 79
    },
    "can.Model.bind": {
        "body": "<p><code>bind(eventType, handler(event, instance))</code> listens to\n<strong>created</strong>, <strong>updated</strong>, <strong>destroyed</strong> events on all \ninstances of the model.</p>\n\n<pre><code>Task.bind(\"created\", function(ev, createdTask){\n     this //-&gt; Task\n  createdTask.attr(\"name\") //-&gt; \"Dishes\"\n})\n\nnew Task({name: \"Dishes\"}).save();\n</code></pre>",
        "description": "<p>Listen for events on a Model class. </p>",
        "title": "bind",
        "name": "can.Model.bind",
        "type": "function",
        "parent": "can.Model.static",
        "signatures": [{
                "code": "bind(eventType, handler)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventType",
                        "description": "<p>The type of event.  It must be\n<code>\"created\"</code>, <code>\"udpated\"</code>, <code>\"destroyed\"</code>.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "handler",
                        "description": "<p>A callback function\nthat gets called with the event and instance that was\ncreated, destroyed, or updated.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Model"
                        }
                    ],
                    "description": "<p>The model constructor function.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 122,
        "id": 80
    },
    "can.Model.unbind": {
        "body": "<p><code>unbind(eventType, handler)</code> removes a listener\nattached with [can.Model.bind].</p>\n\n<pre><code>var handler = function(ev, createdTask){\n\n}\nTask.bind(\"created\", handler)\nTask.unbind(\"created\", handler)\n</code></pre>\n\n<p>You have to pass the same function to <code>unbind</code> that you\npassed to <code>bind</code>.</p>",
        "description": "<p>Stop listening for events on a Model class. </p>",
        "title": "unbind",
        "name": "can.Model.unbind",
        "type": "function",
        "parent": "can.Model.static",
        "signatures": [{
                "code": "unbind(eventType, handler)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventType",
                        "description": "<p>The type of event. It must be\n<code>\"created\"</code>, <code>\"udpated\"</code>, <code>\"destroyed\"</code>.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "handler",
                        "description": "<p>A callback function\nthat was passed to <code>bind</code>.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Model"
                        }
                    ],
                    "description": "<p>The model constructor function.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 148,
        "id": 81
    },
    "can.Model.id": {
        "body": "",
        "description": "<p>The name of the id field.  Defaults to <code>'id'</code>. Change this if it is something different.</p>\n\n<p>For example, it's common in .NET to use <code>'Id'</code>.  Your model might look like:</p>\n\n<pre><code>Friend = can.Model({\n  id: \"Id\"\n},{});\n</code></pre>",
        "types": [{
                "type": "String"
            }
        ],
        "title": "id",
        "name": "can.Model.id",
        "type": "property",
        "parent": "can.Model.static",
        "src": "can/model/model.js",
        "line": 174,
        "id": 82
    },
    "can.Model.create": {
        "name": "can.Model.create",
        "type": "function",
        "parent": "can.Model.static",
        "body": "<p><code>create(attributes) -&gt; Deferred</code> is used by [can.Model::save save] to create a \nmodel instance on the server. </p>\n\n<h2>Implement with a URL</h2>\n\n<p>The easiest way to implement create is to give it the url \nto post data to:</p>\n\n<pre><code>var Recipe = can.Model({\n  create: \"/recipes\"\n},{})\n</code></pre>\n\n<p>This lets you create a recipe like:</p>\n\n<pre><code>new Recipe({name: \"hot dog\"}).save();\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>You can also implement create by yourself. Create gets called \nwith <code>attrs</code>, which are the [can.Observe::serialize serialized] model \nattributes.  Create returns a <code>Deferred</code> \nthat contains the id of the new instance and any other \nproperties that should be set on the instance.</p>\n\n<p>For example, the following code makes a request \nto <code>POST /recipes.json {'name': 'hot+dog'}</code> and gets back\nsomething that looks like:</p>\n\n<pre><code>{ \n  \"id\": 5,\n  \"createdAt\": 2234234329\n}\n</code></pre>\n\n<p>The code looks like:</p>\n\n<pre><code>can.Model(\"Recipe\", {\n  create : function( attrs ){\n    return $.post(\"/recipes.json\",attrs, undefined ,\"json\");\n  }\n},{})\n</code></pre>",
        "description": "<p>Create a new resource on the server. </p>",
        "title": "create",
        "signatures": [{
                "code": "[METHOD] /path/to/resource",
                "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or POST if none is specified) when saving a\nnew instance on the server. (See below for more details.)</p>",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A Deferred that resolves to the created model.</p>"
                }
            }, {
                "code": "function(serialized)",
                "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "serialized",
                        "description": "<p>The [can.Observe::serialize serialized] properties of\nthe model to create.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A Deferred that resolves to the created model.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 209,
        "id": 83
    },
    "can.Model.update": {
        "name": "can.Model.update",
        "type": "function",
        "parent": "can.Model.static",
        "body": "<p><code>update( id, attrs ) -&gt; Deferred</code> is used by [can.Model::save save] to \nupdate a model instance on the server. </p>\n\n<h2>Implement with a URL</h2>\n\n<p>The easist way to implement update is to just give it the url to <code>PUT</code> data to:</p>\n\n<pre><code>Recipe = can.Model({\n  update: \"/recipes/{id}\"\n},{});\n</code></pre>\n\n<p>This lets you update a recipe like:</p>\n\n<pre><code>Recipe.findOne({id: 1}, function(recipe){\n  recipe.attr('name','salad');\n  recipe.save();\n})\n</code></pre>\n\n<p>This will make an XHR request like:</p>\n\n<pre><code>PUT /recipes/1 \nname=salad\n</code></pre>\n\n<p>If your server doesn't use PUT, you can change it to post like:</p>\n\n<pre><code>$.Model(\"Recipe\",{\n  update: \"POST /recipes/{id}\"\n},{});\n</code></pre>\n\n<p>The server should send back an object with any new attributes the model \nshould have.  For example if your server udpates the \"updatedAt\" property, it\nshould send back something like:</p>\n\n<pre><code>// PUT /recipes/4 {name: \"Food\"} -&gt;\n{\n  updatedAt : \"10-20-2011\"\n}\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>You can also implement update by yourself.  Update takes the <code>id</code> and\n<code>attributes</code> of the instance to be udpated.  Update must return\na [can.Deferred Deferred] that resolves to an object that contains any \nproperties that should be set on the instance.</p>\n\n<p>For example, the following code makes a request \nto '/recipes/5.json?name=hot+dog' and gets back\nsomething that looks like:</p>\n\n<pre><code>{ \n  updatedAt: \"10-20-2011\"\n}\n</code></pre>\n\n<p>The code looks like:</p>\n\n<pre><code>Recipe = can.Model({\n  update : function(id, attrs ) {\n    return $.post(\"/recipes/\"+id+\".json\",attrs, null,\"json\");\n  }\n},{});\n</code></pre>",
        "description": "<p>Update a resource on the server. </p>",
        "title": "update",
        "signatures": [{
                "code": "[METHOD] /path/to/resource",
                "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or PUT if none is specified) when updating an\ninstance on the server. (See below for more details.)</p>",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A Deferred that resolves to the updated model.</p>"
                }
            }, {
                "code": "function(id, serialized)",
                "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "id",
                        "description": "<p>The ID of the model to update.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "serialized",
                        "description": "<p>The [can.Observe::serialize serialized] properties of\nthe model to update.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A Deferred that resolves to the updated model.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 272,
        "id": 84
    },
    "can.Model.destroy": {
        "name": "can.Model.destroy",
        "type": "function",
        "parent": "can.Model.static",
        "body": "<p><code>destroy(id) -&gt; Deferred</code> is used by [can.Model::destroy] remove a model \ninstance from the server.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>You can implement destroy with a string like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"/recipe/{id}\"\n},{})\n</code></pre>\n\n<p>And use [can.Model::destroy] to destroy it like:</p>\n\n<pre><code>Recipe.findOne({id: 1}, function(recipe){\n      recipe.destroy();\n});\n</code></pre>\n\n<p>This sends a <code>DELETE</code> request to <code>/thing/destroy/1</code>.</p>\n\n<p>If your server does not support <code>DELETE</code> you can override it like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"POST /recipe/destroy/{id}\"\n},{})\n</code></pre>\n\n<h2>Implement with a function</h2>\n\n<p>Implement destroy with a function like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : function(id){\n    return $.post(\"/recipe/destroy/\"+id,{});\n  }\n},{})\n</code></pre>\n\n<p>Destroy just needs to return a deferred that resolves.</p>",
        "description": "<p>Destroy a resource on the server. </p>",
        "title": "destroy",
        "signatures": [{
                "code": "[METHOD] /path/to/resource",
                "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or DELETE if none is specified) when deleting an\ninstance on the server. (See below for more details.)</p>",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A Deferred that resolves to the destroyed model.</p>"
                }
            }, {
                "code": "function(id)",
                "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "id",
                        "description": "<p>The ID of the resource to destroy.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A Deferred that resolves to the destroyed model.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 364,
        "id": 85
    },
    "can.Model.findAll": {
        "name": "can.Model.findAll",
        "type": "function",
        "parent": "can.Model.static",
        "body": "<p><code>findAll( params, success(instances), error(xhr) ) -&gt; Deferred</code> is used to retrieve model \ninstances from the server. Before you can use <code>findAll</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : \"/recipes.json\"\n},{});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>[\n  {\"id\" : 57, \"name\": \"Ice Water\"},\n  {\"id\" : 58, \"name\": \"Toast\"}\n]\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement findAll with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : {\n    url: \"/recipes.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findAll</code> is passed <strong>params</strong> to filter\nthe instances retrieved from the server and it should return a\ndeferred that resolves to an array of model data. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : function(params){\n    return $.ajax({\n      url: '/recipes.json',\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findAll</code>, you can use it to retrieve instances of the model\nlike:</p>\n\n<pre><code>Recipe.findAll({favorite: true}, function(recipes){\n  recipes[0].attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n  // called if an error\n}) //-&gt; Deferred\n</code></pre>",
        "description": "<p>Retrieve multiple resources from a server. </p>",
        "title": "findAll",
        "signatures": [{
                "code": "findAll(params[, success[, error]])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "params",
                        "description": "<p>Values to filter the request or results with.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "success",
                        "description": "<p>A callback to call on successful retrieval. The callback recieves\na can.Model.List of the retrieved resources.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "error",
                        "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 425,
        "id": 86
    },
    "can.Model.findOne": {
        "name": "can.Model.findOne",
        "type": "function",
        "parent": "can.Model.static",
        "body": "<p><code>findOne( params, success(instance), error(xhr) ) -&gt; Deferred</code> is used to retrieve a model \ninstance from the server. Before you can use <code>findOne</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : \"/recipes/{id}.json\"\n},{});\n</code></pre>\n\n<p>If <code>findOne</code> is called like:</p>\n\n<pre><code>Recipe.findOne({id: 57});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>{\"id\" : 57, \"name\": \"Ice Water\"}\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement <code>findOne</code> with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : {\n    url: \"/recipes/{id}.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findOne</code> is passed <strong>params</strong> to specify\nthe instance retrieved from the server and it should return a\ndeferred that resolves to the model data.  Also notice that you now need to\nbuild the URL manually. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : function(params){\n    return $.ajax({\n      url: '/recipes/' + params.id,\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findOne</code>, you can use it to retrieve an instance of the model\nlike:</p>\n\n<pre><code>Recipe.findOne({id: 57}, function(recipe){\n     recipe.attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n     // called if an error\n}) //-&gt; Deferred\n</code></pre>",
        "description": "<p>Retrieve a resource from a server. </p>",
        "title": "findOne",
        "signatures": [{
                "code": "findOne(params[, success[, error]])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "params",
                        "description": "<p>Values to filter the request or results with.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "success",
                        "description": "<p>A callback to call on successful retrieval. The callback recieves\nthe retrieved resource as a can.Model.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "error",
                        "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 498,
        "id": 87
    },
    "can.Model.models": {
        "type": "function",
        "name": "can.Model.models",
        "parent": "can.Model.static",
        "body": "<p><code>can.Model.models(data, xhr)</code> is used to \nconvert the raw response of a [can.Model.findAll] request \ninto a [can.Model.List] of model instances.  </p>\n\n<p>This method is rarely called directly. Instead the deferred returned\nby findAll is piped into <code>models</code>.  This creates a new deferred that\nresolves to a [can.Model.List] of instances instead of an array of\nsimple JS objects.</p>\n\n<p>If your server is returning data in non-standard way,\noverwriting <code>can.Model.models</code> is the best way to normalize it.</p>\n\n<h2>Quick Example</h2>\n\n<p>The following uses models to convert to a [can.Model.List] of model\ninstances.</p>\n\n<pre><code>Task = can.Model({},{})\nvar tasks = Task.models([\n  {id: 1, name : \"dishes\", complete : false},\n  {id: 2, name: \"laundry\", compelte: true}\n])\n\ntasks.attr(\"0.complete\", true)\n</code></pre>\n\n<h2>Non-standard Services</h2>\n\n<p><code>can.Model.models</code> expects data to be an array of name-value pair \nobjects like:</p>\n\n<pre><code>[{id: 1, name : \"dishes\"},{id:2, name: \"laundry\"}, ...]\n</code></pre>\n\n<p>It can also take an object with additional data about the array like:</p>\n\n<pre><code>{\n  count: 15000 //how many total items there might be\n  data: [{id: 1, name : \"justin\"},{id:2, name: \"brian\"}, ...]\n}\n</code></pre>\n\n<p>In this case, models will return a [can.Model.List] of instances found in \ndata, but with additional properties as expandos on the list:</p>\n\n<pre><code>var tasks = Task.models({\n  count : 1500,\n  data : [{id: 1, name: 'dishes'}, ...]\n})\ntasks.attr(\"name\") // -&gt; 'dishes'\ntasks.count // -&gt; 1500\n</code></pre>\n\n<h3>Overwriting Models</h3>\n\n<p>If your service returns data like:</p>\n\n<pre><code>{thingsToDo: [{name: \"dishes\", id: 5}]}\n</code></pre>\n\n<p>You will want to overwrite models to pass the base models what it expects like:</p>\n\n<pre><code>Task = can.Model({\n  models : function(data){\n    return can.Model.models.call(this,data.thingsToDo);\n  }\n},{})\n</code></pre>\n\n<p><code>can.Model.models</code> passes each intstance's data to <code>can.Model.model</code> to\ncreate the individual instances.</p>",
        "description": "<p>Convert raw data into can.Model instances. </p>",
        "title": "models",
        "signatures": [{
                "code": "models(data[, oldList])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Array",
                                "template": [{
                                        "types": [{
                                                "type": "Object"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "name": "data",
                        "description": "<p>The raw data from a <code>[can.Model.findAll findAll()]</code> request.</p>"
                    }, {
                        "types": [{
                                "type": "can.Model.List"
                            }
                        ],
                        "optional": true,
                        "name": "oldList",
                        "description": "<p>If supplied, this List will be updated with the data from\n<strong>data</strong>.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Model.List"
                        }
                    ],
                    "description": "<p>A List of Models made from the raw data.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 655,
        "id": 88
    },
    "can.Model.model": {
        "type": "function",
        "name": "can.Model.model",
        "parent": "can.Model.static",
        "body": "<p><code>can.Model.model(attributes)</code> is used to convert data from the server into\na model instance.  It is rarely called directly.  Instead it is invoked as \na result of [can.Model.findOne] or [can.Model.findAll].  </p>\n\n<p>If your server is returning data in non-standard way,\noverwriting <code>can.Model.model</code> is a good way to normalize it.</p>\n\n<h2>Example</h2>\n\n<p>The following uses <code>model</code> to convert to a model\ninstance.</p>\n\n<pre><code>Task = can.Model({},{})\nvar task = Task.model({id: 1, name : \"dishes\", complete : false})\n\ntasks.attr(\"complete\", true)\n</code></pre>\n\n<p><code>Task.model(attrs)</code> is very similar to simply calling <code>new Model(attrs)</code> except\nthat it checks the model's store if the instance has already been created.  The model's \nstore is a collection of instances that have event handlers.  </p>\n\n<p>This means that if the model's store already has an instance, you'll get the same instance\nback.  Example:</p>\n\n<pre><code>// create a task\nvar taskA = new Task({id: 5, complete: true});\n\n// bind to it, which puts it in the store\n   taskA.bind(\"complete\", function(){});\n\n// use model to create / retrieve a task\nvar taskB = Task.model({id: 5, complete: true});\n\ntaskA === taskB //-&gt; true\n</code></pre>\n\n<h2>Non-standard Services</h2>\n\n<p><code>can.Model.model</code> expects to retreive attributes of the model \ninstance like:</p>\n\n<pre><code>{id: 5, name : \"dishes\"}\n</code></pre>\n\n<p>If the service returns data formatted differently, like:</p>\n\n<pre><code>{todo: {name: \"dishes\", id: 5}}\n</code></pre>\n\n<p>Overwrite <code>model</code> like:</p>\n\n<pre><code>Task = can.Model({\n  model : function(data){\n    return can.Model.model.call(this,data.todo);\n  }\n},{});\n</code></pre>",
        "description": "<p>Convert raw data into a can.Model instance. </p>",
        "title": "model",
        "signatures": [{
                "code": "model(data)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "data",
                        "description": "<p>The data to convert to a can.Model instance.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Model"
                        }
                    ],
                    "description": "<p>An instance of can.Model made with the given data.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 794,
        "id": 89
    },
    "can.Model.prototype": {
        "type": "prototype",
        "body": "",
        "description": "",
        "name": "can.Model.prototype",
        "parent": "can.Model",
        "src": "can/model/model.js",
        "line": 875,
        "id": 90
    },
    "can.Model.prototype.isNew": {
        "type": "function",
        "name": "can.Model.prototype.isNew",
        "parent": "can.Model.prototype",
        "body": "<p><code>isNew()</code> returns if the instance is has been created \non the server. This is essentially if the [can.Model.id]\nproperty is null or undefined.</p>\n\n<pre><code>new Recipe({id: 1}).isNew() //-&gt; false\n</code></pre>",
        "description": "<p>Check if a Model has yet to be saved on the server. </p>",
        "title": "isNew",
        "signatures": [{
                "code": "isNew()",
                "description": "",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "Boolean"
                        }
                    ],
                    "description": "<p>Whether an instance has been saved on the server.\n(This is determined by whether <code>id</code> has a value set yet.)</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 879,
        "id": 91
    },
    "can.Model.prototype.save": {
        "type": "function",
        "name": "can.Model.prototype.save",
        "parent": "can.Model.prototype",
        "body": "<p><code>model.save([success(model)],[error(xhr)])</code> creates or updates \nthe model instance using [can.Model.create] or\n[can.Model.update] depending if the instance\n[can.Model::isNew has an id or not].</p>\n\n<h2>Using <code>save</code> to create an instance.</h2>\n\n<p>If <code>save</code> is called on an instance that does not have \nan [can.Model.id id] property, it calls [can.Model.create]\nwith the instance's properties.  It also [can.trigger triggers]\na \"created\" event on the instance and the model.</p>\n\n<pre><code>// create a model instance\nvar todo = new Todo({name: \"dishes\"})\n\n// listen when the instance is created\ntodo.bind(\"created\", function(ev){\n     this //-&gt; todo\n})\n\n// save it on the server\ntodo.save(function(todo){\n     console.log(\"todo\", todo, \"created\")\n});\n</code></pre>\n\n<h2>Using <code>save</code> to update an instance.</h2>\n\n<p>If save is called on an instance that has \nan [can.Model.id id] property, it calls [can.Model.create]\nwith the instance's properties.  When the save is complete,\nit triggers an \"updated\" event on the instance and the instance's model.</p>\n\n<p>Instances with an\n<strong>id</strong> are typically retrieved with [can.Model.findAll] or\n[can.Model.findOne].  </p>\n\n<pre><code>// get a created model instance\nTodo.findOne({id: 5},function(todo){\n\n  // listen when the instance is updated\n  todo.bind(\"updated\", function(ev){\n       this //-&gt; todo\n  })\n\n  // update the instance's property\n  todo.attr(\"complete\", true)\n\n  // save it on the server\n  todo.save(function(todo){\n       console.log(\"todo\", todo, \"updated\")\n  });\n\n});\n</code></pre>",
        "description": "<p>Save a model back to the server. </p>",
        "title": "save",
        "signatures": [{
                "code": "save([success[, error]])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "success",
                        "description": "<p>A callback to call on successful save. The callback recieves\nthe can.Model after saving.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "error",
                        "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A Deferred that resolves to the Model after it has been saved.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 897,
        "id": 92
    },
    "can.Model.prototype.destroy": {
        "type": "function",
        "name": "can.Model.prototype.destroy",
        "parent": "can.Model.prototype",
        "body": "<p>Destroys the instance by calling \n[Can.Model.destroy] with the id of the instance.</p>\n\n<pre><code>recipe.destroy(success, error);\n</code></pre>\n\n<p>This triggers \"destroyed\" events on the instance and the \nModel constructor function which can be listened to with\n[can.Model::bind] and [can.Model.bind]. </p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"DELETE /services/recipes/{id}\",\n  findOne : \"/services/recipes/{id}\"\n},{})\n\nRecipe.bind(\"destroyed\", function(){\n  console.log(\"a recipe destroyed\");    \n});\n\n// get a recipe\nRecipe.findOne({id: 5}, function(recipe){\n  recipe.bind(\"destroyed\", function(){\n    console.log(\"this recipe destroyed\")    \n  })\n  recipe.destroy();\n})\n</code></pre>",
        "description": "<p>Destroy a Model on the server. </p>",
        "title": "destroy",
        "signatures": [{
                "code": "destroy([success[, error]])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "success",
                        "description": "<p>A callback to call on successful destruction. The callback recieves\nthe can.Model as it was just prior to destruction.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "error",
                        "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A Deferred that resolves to the Model as it was before destruction.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 967,
        "id": 93
    },
    "can.Model.prototype.bind": {
        "type": "function",
        "name": "can.Model.prototype.bind",
        "parent": "can.Model.prototype",
        "body": "<p><code>bind(eventName, handler(ev, args...) )</code> is used to listen\nto events on this model instance.  Example:</p>\n\n<pre><code>Task = can.Model()\nvar task = new Task({name : \"dishes\"})\ntask.bind(\"name\", function(ev, newVal, oldVal){})\n</code></pre>\n\n<p>Use <code>bind</code> the\nsame as [can.Observe::bind] which should be used as\na reference for listening to property changes.</p>\n\n<p>Bind on model can be used to listen to when \nan instance is:</p>\n\n<ul>\n<li>created</li>\n<li>updated</li>\n<li>destroyed</li>\n</ul>\n\n<p>like:</p>\n\n<pre><code>Task = can.Model()\nvar task = new Task({name : \"dishes\"})\n\ntask.bind(\"created\", function(ev, newTask){\n     console.log(\"created\", newTask)\n})\n.bind(\"updated\", function(ev, updatedTask){\n  console.log(\"updated\", updatedTask)\n})\n.bind(\"destroyed\", function(ev, destroyedTask){\n     console.log(\"destroyed\", destroyedTask)\n})\n\n// create, update, and destroy\ntask.save(function(){\n  task.attr('name', \"do dishes\")\n      .save(function(){\n            task.destroy()\n      })\n}); \n</code></pre>\n\n<p><code>bind</code> also extends the inherited \nbehavior of [can.Observe::bind] to track the number\nof event bindings on this object which is used to store\nthe model instance.  When there are no bindings, the \nmodel instance is removed from the store, freeing memory.  </p>",
        "description": "<p>Listen to events on this Model. </p>",
        "title": "bind",
        "signatures": [{
                "code": "bind(eventName, handler)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventName",
                        "description": "<p>The event to bind to.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "handler",
                        "description": "<p>The function to call when the\nevent occurs. <strong>handler</strong> is passed the event and the\nModel instance.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Model"
                        }
                    ],
                    "description": "<p>The Model, for chaining.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 1013,
        "id": 94
    },
    "can.Model.prototype.unbind": {
        "type": "function",
        "name": "can.Model.prototype.unbind",
        "parent": "can.Model.prototype",
        "body": "<p><code>unbind(eventName, handler)</code> removes a listener\nattached with [can.Model::bind].</p>\n\n<pre><code>var handler = function(ev, createdTask){\n\n}\ntask.bind(\"created\", handler)\ntask.unbind(\"created\", handler)\n</code></pre>\n\n<p>You have to pass the same function to <code>unbind</code> that you\npassed to <code>bind</code>.</p>\n\n<p>Unbind will also remove the instance from the store\nif there are no other listeners.</p>",
        "description": "<p>Stop listening to events on this Model. </p>",
        "title": "unbind",
        "signatures": [{
                "code": "unbind(eventName[, handler])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventName",
                        "description": "<p>The event to unbind from.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "handler",
                        "description": "<p>A handler previously bound with <code>bind</code>.\nIf <strong>handler</strong> is not passed, <code>unbind</code> will remove all handlers\nfor the given event.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Model"
                        }
                    ],
                    "description": "<p>The Model, for chaining.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/model/model.js",
        "line": 1076,
        "id": 95
    },
    "can.Model.prototype.created": {
        "type": "function",
        "body": "",
        "description": "<p>Called by save after a new instance is created.  Publishes 'created'.</p>",
        "title": "created",
        "name": "can.Model.prototype.created",
        "hide": true,
        "params": [{
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "attrs",
                "description": ""
            }
        ],
        "src": "can/model/model.js",
        "line": 1135,
        "id": 96
    },
    "can.Model.prototype.updated": {
        "type": "function",
        "body": "",
        "description": "<p>Called by save after an instance is updated.  Publishes 'updated'.</p>",
        "title": "updated",
        "name": "can.Model.prototype.updated",
        "hide": true,
        "params": [{
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "attrs",
                "description": ""
            }
        ],
        "src": "can/model/model.js",
        "line": 1142,
        "id": 97
    },
    "can.Model.prototype.destroyed": {
        "type": "function",
        "body": "",
        "description": "<p>Called after an instance is destroyed. <br />\n  - Publishes \"shortName.destroyed\".\n  - Triggers a \"destroyed\" event on this model.\n  - Removes the model from the global list if its used.</p>",
        "title": "destroyed",
        "name": "can.Model.prototype.destroyed",
        "hide": true,
        "src": "can/model/model.js",
        "line": 1149,
        "id": 98
    },
    "can.Model.List": {
        "name": "can.Model.List",
        "type": "constructor",
        "parent": "canjs",
        "body": "",
        "description": "<p>Works exactly like [can.Observe.List] and has all of the same properties,\nevents, and functions as an observable list. The only difference is that \nwhen an item from the list is destroyed, it will automatically get removed\nfrom the list.</p>\n\n<h2>Creating a new Model List</h2>\n\n<p>To create a new model list, just use <code>new {model_name}.List(ARRAY)</code> like:</p>\n\n<pre><code>var todo1 = new Todo( { name: \"Do the dishes\" } ),\n    todo2 = new Todo( { name: \"Wash floors\" } )\nvar todos = new Todo.List( [todo1, todo2] );\n</code></pre>\n\n<h3>Model Lists in <code>can.Model</code></h3>\n\n<p>[can.Model.static.findAll can.Model.findAll] or [can.Model.models] will\nalmost always be used to return a <code>can.Model.List</code> object, even though it\nis possible to create new lists like below:</p>\n\n<pre><code>var todos = Todo.models([\n    new Todo( { name: \"Do the dishes\" } ),\n    new Todo( { name: \"Wash floors\" } )\n])\n\ntodos.constructor // -&gt; can.Model.List\n\n// the most correct way to get a can.Model.List\nTodo.findAll({}, function(todos) {\n    todos.constructor // -&gt; can.Model.List\n})\n</code></pre>\n\n<h3>Extending <code>can.Model.List</code></h3>\n\n<p>Creating custom <code>can.Model.Lists</code> allows you to extend lists with helper\nfunctions for a list of a specific type. So, if you wanted to be able to\nsee how many todos were completed and remaining something could be written\nlike:</p>\n\n<pre><code>Todo.List = can.Model.List({\n    completed: function() {\n        var completed = 0;\n        this.each(function(i, todo) {\n            completed += todo.attr('complete') ? 1 : 0\n        })\n        return completed;\n    },\n    remaining: function() {\n        return this.attr('length') - this.completed();\n    }\n})\n\nTodo.findAll({}, function(todos) {\n    todos.completed() // -&gt; 0\n    todos.remaining() // -&gt; 2\n});\n</code></pre>\n\n<h2>Removing models from model list</h2>\n\n<p>The advantage that <code>can.Model.List</code> has over a traditional <code>can.Observe.List</code>\nis that when you destroy a model, if it is in that list, it will automatically\nbe removed from the list. </p>\n\n<pre><code>// Listen for when something is removed from the todos list.\ntodos.bind(\"remove\", function( ev, oldVals, indx ) {\n    console.log(oldVals[indx].attr(\"name\") + \" removed\")\n})\n\ntodo1.destroy(); // console shows \"Do the dishes removed\"\n</code></pre>",
        "title": "",
        "inherits": "can.Observe.List",
        "download": "can/model",
        "test": "can/model/qunit.html",
        "src": "can/model/model.js",
        "line": 1185,
        "id": 99
    },
    "can/control/control.md": {
        "type": "script",
        "name": "can/control/control.md"
    },
    "can.Control": {
        "type": "constructor",
        "name": "can.Control",
        "body": "<div class='demo_wrapper' data-demo-src='can/control/control.html'></div><div class='iframe_wrapper' data-iframe-src='can/test/demo.html' data-iframe-height='400'></div>",
        "description": "<p>widget factory with declarative event binding. \ncan.Control helps create organized, memory-leak free, rapidly performing,\nstateful controls. Use it to create UI controls like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.</p>\n\n<h2>Todo Example</h2>\n\n<p>Here is an example of how to build a simple tab widget using can.Control:</p>\n\n<h2>Creating a Control</h2>\n\n<p>The following example builds up a basic todos widget for listing \nand completing todo items. Start by creating a control constructor \nfunction of your own by extending can.Control:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( 'todos.ejs', todos );\n    });\n  }\n});\n</code></pre>\n\n<p>Create an instance of the Todos control on the <code>todos</code> element with:</p>\n\n<pre><code>var todosControl = new Todos( '#todos', {} );\n</code></pre>\n\n<p>The control's associated [can.EJS EJS] template looks like:</p>\n\n<pre><code>&lt;% list( todos, function( todo ) { %&gt;\n  &lt;li &lt;%= (el) -&gt; el.data( 'todo', todo ) %&gt; &gt;\n    &lt;%= todo.attr( 'name' ) %&gt;\n    &lt;a href=\"javascript://\" class=\"destroy\"&gt;\n  &lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h2>init <code>can.Control.prototype.init( element, options )</code></h2>\n\n<p><code>init</code> is called when a new can.Control instance is created. It is called with:</p>\n\n<ul>\n<li><strong>element</strong> - The wrapped element passed to the \n            control. Control accepts a\n            raw HTMLElement, a CSS selector, or a NodeList. This is\n            set as <strong>this.element</strong> on the control instance.</li>\n<li><strong>options</strong> - The second argument passed to new Control, extended with\n            the can.Control's static <strong>defaults</strong>. This is set as \n            <strong>this.options</strong> on the control instance.</li>\n</ul>\n\n<p>and any other arguments passed to <code>new can.Control()</code>. For example:</p>\n\n<pre><code>var Todos = can.Control({\n  defaults : { view: 'todos.ejs' }\n}, {\n  init: function( element , options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n        self.element.html( self.options.view, todos );\n    });\n  }\n});\n\n// create a Todos with default options\nnew Todos( document.body.firstElementChild );\n\n// overwrite the template option\nnew Todos( $( '#todos' ), { template: 'specialTodos.ejs' } );\n</code></pre>\n\n<h2>element <code>this.element</code></h2>\n\n<p>[can.Control::element] is the \nNodeList consisting of the element the control is created on. </p>\n\n<pre><code>var todosControl = new Todos( document.body.firstElementChild );\ntodosControl.element[0] //-&gt; document.body.firstElementChild\n</code></pre>\n\n<p>Each library wraps elements differently. If you are using jQuery, for example,\nthe element is wrapped with <code>jQuery( element )</code>.</p>\n\n<h2>options <code>this.options</code></h2>\n\n<p>[can.Control::options] is the second argument passed to \n<code>new can.Control()</code>, merged with the control's static <strong>defaults</strong> property.</p>\n\n<h2>Listening to events</h2>\n\n<p>Control automatically binds prototype methods that look\nlike event handlers. Listen to <strong>click</strong>s on <code>&lt;li&gt;</code> elements like:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element , options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li, event ) {\n    console.log( 'You clicked', li.text() );\n\n    // let other controls know what happened\n    li.trigger( 'selected' );\n  }\n});\n</code></pre>\n\n<p>When an <code>&lt;li&gt;</code> is clicked, <code>\"li click\"</code> is called with:</p>\n\n<ul>\n<li>The library-wrapped <strong>element</strong> that was clicked</li>\n<li>The <strong>event</strong> data</li>\n</ul>\n\n<p>Control uses event delegation, so you can add <code>&lt;li&gt;</code>s without needing to rebind\nevent handlers.</p>\n\n<p>To destroy a todo when its <code>&lt;a href=\"javascript://\" class=\"destroy\"&gt;</code> link \nis clicked:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li ) {\n    li.trigger( 'selected', li.model() );\n  },\n\n  'li .destroy click': function( el, ev ) {\n    // get the li element that has todo data\n    var li = el.closest( 'li' );\n\n    // get the model\n    var todo = li.data( 'todo' );\n\n    //destroy it\n    todo.destroy();\n  }\n});\n</code></pre>\n\n<p>When the todo is destroyed, EJS's live binding will remove its LI automatically.</p>\n\n<h2>Templated Event Handlers Part 1 <code>\"{eventName}\"</code></h2>\n\n<p>Customize event handler behavior with <code>\"{NAME}\"</code> in\nthe event handler name.  The following allows customization \nof the event that destroys a todo:</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  'li click': function( li ) { ... },\n\n  'li .destroy {destroyEvent}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// create Todos with this.options.destroyEvent\nnew Todos( '#todos', { destroyEvent: 'mouseenter' } );\n</code></pre>\n\n<p>Values inside <code>{NAME}</code> are looked up on the control's <code>this.options</code> first,\nand then the <code>window</code>. For example, we could customize it instead like:</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  'li click': function( li ) { ... },\n\n  'li .destroy {Events.destroy}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// Events config\nEvents = { destroy: 'click' };\n\n// Events.destroy is looked up on the window.\nnew Todos( '#todos' );\n</code></pre>\n\n<p>The selector can also be templated.</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  '{listElement} click': function( li ) { ... },\n\n  '{listElement} .destroy {destroyEvent}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// create Todos with this.options.destroyEvent\nnew Todos( '#todos',  { \n  destroyEvent: 'mouseenter', \n  listElement: 'li' \n} );\n</code></pre>\n\n<h2>Templated Event Handlers Part 2 <code>\"{objectName}\"</code></h2>\n\n<p>Control can also bind to objects other than <code>this.element</code> with\ntemplated event handlers.  This is <em>critical</em>\nfor avoiding memory leaks that are so common among MVC applications.  </p>\n\n<p>If the value inside <code>{NAME}</code> is an object, Control will bind to that\nobject to listen for events. For example, the following tooltip listens to \nclicks on the window:</p>\n\n<pre><code>var Tooltip = can.Control({\n  '{window} click': function( el, ev ) {\n    // hide only if we clicked outside the tooltip\n    if ( !this.element.has( ev.target ) ) {\n      this.element.remove();\n    }\n  }\n});\n\n// create a Tooltip\nnew Tooltip( $( '&lt;div&gt;INFO&lt;/div&gt;' ).appendTo( el ) );\n</code></pre>\n\n<p>This is convenient when listening for model changes. If EJS were not\ntaking care of removing <code>&lt;li&gt;</code>s after their associated models were destroyed,\nwe could implement it in <code>Todos</code> like:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.todosList = todos;\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li ) {\n    li.trigger( 'selected', li.model() );\n  },\n\n  'li .destroy click': function( el, ev ) {\n    // get the li element that has todo data\n    var li = el.closest( 'li' );\n\n    // get the model\n    var todo = li.data( 'todo' );\n\n    //destroy it\n    todo.destroy();\n  },\n\n  '{Todo} destroyed': function( Todo, ev, todoDestroyed ) {\n    // find where the element\n    var index = this.todosList.indexOf( todoDestroyed );\n    this.element.children( ':nth-child(' + ( index + 1 ) + ')' )\n                .remove();\n  }\n});\n\nnew Todos( '#todos' );\n</code></pre>\n\n<h2>destroy <code>control.destroy()</code></h2>\n\n<p>[can.Control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove \nthe element from the page. </p>\n\n<pre><code>var todo = new Todos( '#todos' );\ntodo.destroy();\n</code></pre>\n\n<p>When a control's element is removed from the page\n<strong>destroy</strong> is called automatically.</p>\n\n<pre><code>new Todos( '#todos' );\n$( '#todos' ).remove();\n</code></pre>\n\n<p>All event handlers bound with Control are unbound when the control \nis destroyed (or its element is removed).</p>\n\n<p><em>Brief aside on destroy and templated event binding. Taken \ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible \nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all \ndata by calling <code>$(document.body).empty()</code>.</em></p>\n\n<h2>on <code>control.on()</code></h2>\n\n<p>[can.Control::on] rebinds a control's event handlers. This is useful when you want\nto listen to a specific model and change it:</p>\n\n<pre><code>var Editor = can.Control({\n  todo: function( todo ) {\n    this.options.todo = todo;\n    this.on();\n    this.setName();\n  },\n\n  // a helper that sets the value of the input\n  // to the todo's name\n  setName: function() {\n    this.element.val( this.options.todo.name );\n  },\n\n  // listen for changes in the todo\n  // and update the input\n  '{todo} updated': function() {\n    this.setName();\n  },\n\n  // when the input changes\n  // update the todo instance\n  'change': function() {\n    var todo = this.options.todo;\n    todo.attr( 'name', this.element.val() );\n    todo.save();\n  }\n});\n\nvar todo1 = new Todo({ id: 6, name: 'trash' }),\n    todo2 = new Todo({ id: 6, name: 'dishes' });\n\n// create the editor;\nvar editor = new Editor( '#editor' );\n\n// show the first todo\neditor.todo( todo1 );\n\n// switch it to the second todo\neditor.todo( todo2 );\n</code></pre>\n\n<p>Here's the full todo list manager in action:</p>",
        "title": "",
        "parent": "canjs",
        "download": "can/route",
        "test": "can/control/qunit.html",
        "inherits": "can.Construct",
        "comment": "undefined@group can.Control.plugins plugins\n",
        "src": "can/control/control.md",
        "id": 100
    },
    "can/control/control.js": {
        "type": "script",
        "name": "can/control/control.js"
    },
    "can.Control.static": {
        "type": "static",
        "body": "",
        "description": "",
        "name": "can.Control.static",
        "parent": "can.Control",
        "src": "can/control/control.js",
        "line": 43,
        "id": 101
    },
    "can.Control.static.setup": {
        "type": "function",
        "name": "can.Control.static.setup",
        "params": [],
        "parent": "can.Control.static",
        "body": "",
        "description": "<p>Setup pre-process which methods are event listeners.</p>",
        "hide": true,
        "src": "can/control/control.js",
        "line": 48,
        "id": 102
    },
    "can.Control.static._isAction": {
        "type": "function",
        "name": "can.Control.static._isAction",
        "params": [{
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "methodName",
                "description": "<p>a prototype function</p>"
            }
        ],
        "parent": "can.Control.static",
        "body": "",
        "description": "",
        "hide": true,
        "returns": {
            "types": [{
                    "type": "Boolean"
                }
            ],
            "description": "<p>truthy if an action or not</p>"
        },
        "src": "can/control/control.js",
        "line": 93,
        "id": 103
    },
    "can.Control.static._action": {
        "type": "function",
        "name": "can.Control.static._action",
        "params": [{
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "methodName",
                "description": "<p>the method that will be bound</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "options",
                "description": "<p>first param merged with class default options</p>"
            }
        ],
        "parent": "can.Control.static",
        "body": "",
        "description": "<p>Takes a method name and the options passed to a control\nand tries to return the data necessary to pass to a processor\n(something that binds things).</p>\n\n<p>For performance reasons, this called twice.  First, it is called when \nthe Control class is created.  If the methodName is templated\nlike: \"{window} foo\", it returns null.  If it is not templated\nit returns event binding data.</p>\n\n<p>The resulting data is added to this.actions.</p>\n\n<p>When a control instance is created, _action is called again, but only\non templated actions.  </p>",
        "hide": true,
        "returns": {
            "types": [{
                    "type": "Object"
                }
            ],
            "description": "<p>null or the processor and pre-split parts. <br />\nThe processor is what does the binding/subscribing.</p>"
        },
        "src": "can/control/control.js",
        "line": 112,
        "id": 104
    },
    "can.Control.processors": {
        "name": "can.Control.processors",
        "type": "property",
        "parent": "can.Control.static",
        "body": "<p><code>processors</code> is an object that allows you to add new events to bind\nto on a control, or to change how existent events are bound. Each\nkey-value pair of <code>processors</code> is a specification that pertains to\nan event where the key is the name of the event, and the value is\na function that processes calls to bind to the event.</p>\n\n<p>The processor function takes five arguments:</p>\n\n<ul>\n<li><em>el</em>: The Control's element.</li>\n<li><em>event</em>: The event type.</li>\n<li><em>selector</em>: The selector preceding the event in the binding used on the Control.</li>\n<li><em>callback</em>: The callback function being bound.</li>\n<li><em>control</em>: The Control the event is bound on.</li>\n</ul>\n\n<p>Inside your processor function, you should bind <em>callback</em> to the event, and\nreturn a function for can.Control to call when <em>callback</em> needs to be unbound.\n(If <em>selector</em> is defined, you will likely want to use some form of delegation\nto bind the event.)</p>\n\n<p>Here is a Control with a custom event processor set and two callbacks bound\nto that event:</p>\n\n<pre><code class=\"lang-javascript\">can.Control.processors.birthday = function(el, ev, selector, callback, control) {\n  if(selector) {\n    myFramework.delegate(ev, el, selector, callback);\n    return function() { myFramework.undelegate(ev, el, selector, callback); };\n  } else {\n    myFramework.bind(ev, el, callback);\n    return function() { myFramework.unbind(ev, el, callback); };  \n  }\n};\n\ncan.Control(\"EventTarget\", { }, {\n  'birthday': function(el, ev) {\n    // do something appropriate for the occasion\n  },\n  '.grandchild birthday': function(el, ev) {\n    // do something appropriate for the occasion\n  }\n});\n\nvar target = new EventTarget('#person');</code></pre>\n\n<p>When <code>target</code> is initialized, can.Control will call <code>can.Control.processors.birthday</code>\ntwice (because there are two event hookups for the <em>birthday</em> event). The first\ntime it's called, the arguments will be:</p>\n\n<ul>\n<li><em>el</em>: A NodeList that wraps the element with id 'person'.</li>\n<li><em>ev</em>: <code>'birthday'</code></li>\n<li><em>selector</em>: <code>''</code></li>\n<li><em>callback</em>: The function assigned to <code>' birthday'</code> in the prototype section of <code>EventTarget</code>'s\ndefinition.</li>\n<li><em>control</em>: <code>target</code> itself.</li>\n</ul>\n\n<p>The second time, the arguments are slightly different:</p>\n\n<ul>\n<li><em>el</em>: A NodeList that wraps the element with id 'person'.</li>\n<li><em>ev</em>: <code>'birthday'</code></li>\n<li><em>selector</em>: <code>'.grandchild'</code></li>\n<li><em>callback</em>: The function assigned to <code>'.grandchild birthday'</code> in the prototype section of <code>EventTarget</code>'s\ndefinition.</li>\n<li><em>control</em>: <code>target</code> itself.</li>\n</ul>\n\n<p>can.Control already has processors for these events:</p>\n\n<ul>\n<li>change </li>\n<li>click </li>\n<li>contextmenu </li>\n<li>dblclick </li>\n<li>focusin</li>\n<li>focusout</li>\n<li>keydown </li>\n<li>keyup </li>\n<li>keypress </li>\n<li>mousedown </li>\n<li>mouseenter</li>\n<li>mouseleave</li>\n<li>mousemove </li>\n<li>mouseout </li>\n<li>mouseover </li>\n<li>mouseup </li>\n<li>reset </li>\n<li>resize </li>\n<li>scroll </li>\n<li>select </li>\n<li>submit  </li>\n</ul>",
        "description": "<p>A collection of hookups for custom events on Controls. </p>",
        "title": "processors",
        "comment": " ",
        "src": "can/control/control.js",
        "line": 165,
        "id": 105
    },
    "can.Control.defaults": {
        "type": "property",
        "body": "<p><code>defaults</code> provides default values for a Control's options.\nOptions passed into the constructor function will be shallowly merged\ninto the values from defaults in [can.Control::setup], and\nthe result will be stored in <code>[can.Control::options this.options]</code>.</p>\n\n<pre><code>Message = can.Control({\n  defaults: {\n    message: \"Hello World\"\n  }\n}, {\n  init: function(){\n    this.element.text( this.options.message );\n  }\n});\n\nnew Message( \"#el1\" ); //writes \"Hello World\"\nnew Message( \"#el12\", { message: \"hi\" } ); //writes hi\n</code></pre>",
        "description": "<p>Default values for the Control's options. </p>",
        "title": "defaults",
        "name": "can.Control.defaults",
        "parent": "can.Control.static",
        "comment": " ",
        "src": "can/control/control.js",
        "line": 264,
        "id": 106
    },
    "can.Control.prototype": {
        "type": "prototype",
        "body": "",
        "description": "",
        "name": "can.Control.prototype",
        "parent": "can.Control",
        "src": "can/control/control.js",
        "line": 290,
        "id": 107
    },
    "can.Control.prototype.element": {
        "body": "",
        "description": "<p>The element the Control is associated with. \nThe control instance's HTMLElement (or window) wrapped by the \nutil library for ease of use. It is set by the first\nparameter to <code>new can.Construct( element, options )</code> \nin [can.Control::setup].  Control listens on <code>this.element</code>\nfor events.</p>\n\n<h3>Quick Example</h3>\n\n<p>The following <code>HelloWorld</code> control sets the control`s text to \"Hello World\":</p>\n\n<pre><code>HelloWorld = can.Control({\n  init: function(){\n       this.element.text( 'Hello World' );\n  }\n});\n\n// create the controller on the element\nnew HelloWorld( document.getElementById( '#helloworld' ) );\n</code></pre>\n\n<h2>Wrapped NodeList</h2>\n\n<p><code>this.element</code> is a wrapped NodeList of one HTMLELement (or window).  This\nis for convience in libraries like jQuery where all methods operate only on a\nNodeList.  To get the raw HTMLElement, write:</p>\n\n<pre><code>this.element[0] //-&gt; HTMLElement\n</code></pre>\n\n<p>The following details the NodeList used by each library with \nan example of updating it's text:</p>\n\n<p><strong>jQuery</strong> <code>jQuery( HTMLElement )</code></p>\n\n<pre><code>this.element.text(\"Hello World\")\n</code></pre>\n\n<p><strong>Zepto</strong> <code>Zepto( HTMLElement )</code></p>\n\n<pre><code>this.element.text(\"Hello World\")\n</code></pre>\n\n<p><strong>Dojo</strong> <code>new dojo.NodeList( HTMLElement )</code></p>\n\n<pre><code>// TODO\n</code></pre>\n\n<p><strong>Mootools</strong> <code>$$( HTMLElement )</code></p>\n\n<p>this.element.empty().appendText(\"Hello World\")</p>\n\n<p><strong>YUI</strong> </p>\n\n<p>// TODO</p>\n\n<h2>Changing <code>this.element</code></h2>\n\n<p>Sometimes you don't want what's passed to <code>new can.Control</code>\nto be this.element.  You can change this by overwriting\nsetup or by unbinding, setting this.element, and rebinding.</p>\n\n<h3>Overwriting Setup</h3>\n\n<p>The following Combobox overwrites setup to wrap a\nselect element with a div.  That div is used \nas <code>this.element</code>. Notice how <code>destroy</code> sets back the\noriginal element.</p>\n\n<pre><code>Combobox = can.Control({\n  setup: function( el, options ) {\n     this.oldElement = $( el );\n     var newEl = $( '&lt;div/&gt;' );\n     this.oldElement.wrap( newEl );\n     can.Controll.prototype.setup.call( this, newEl, options );\n  },\n  init: function() {\n     this.element //-&gt; the div\n  },\n  \".option click\": function() {\n    // event handler bound on the div\n  },\n  destroy: function() {\n     var div = this.element; //save reference\n     can.Control.prototype.destroy.call( this );\n     div.replaceWith( this.oldElement );\n  }\n});\n</code></pre>\n\n<h3>unbinding, setting, and rebinding.</h3>\n\n<p>You could also change this.element by calling\n[can.Control::off], setting this.element, and \nthen calling [can.Control::on] like:</p>\n\n<pre><code>move: function( newElement ) {\n   this.off();\n   this.element = $( newElement );\n   this.on();\n}\n</code></pre>",
        "title": "element",
        "name": "can.Control.prototype.element",
        "type": "property",
        "parent": "can.Control.prototype",
        "comment": " ",
        "src": "can/control/control.js",
        "line": 295,
        "id": 108
    },
    "can.Control.prototype.setup": {
        "type": "function",
        "name": "can.Control.prototype.setup",
        "parent": "can.Control.prototype",
        "body": "<p>Setup is where most of control's magic happens.  It does the following:</p>\n\n<h3>Sets this.element</h3>\n\n<p>The first parameter passed to new Control( el, options ) is expected to be \nan element.  This gets converted to a Wrapped NodeList element and set as\n[can.Control.prototype.element this.element].</p>\n\n<h3>Adds the control's name to the element's className</h3>\n\n<p>Control adds it's plugin name to the element's className for easier \ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.</p>\n\n<h3>Saves the control in $.data</h3>\n\n<p>A reference to the control instance is saved in $.data.  You can find \ninstances of \"Foo.Bar\" like: </p>\n\n<pre><code>$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n</code></pre>\n\n<h3>Merges Options</h3>\n\n<p>Merges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can.Control.static.defaults defaults] \nso that users can change them.</p>\n\n<h3>Binds event handlers</h3>\n\n<p>Setup does the event binding described in [can.Control].</p>",
        "description": "<p>Perform pre-initialization logic. </p>",
        "title": "setup",
        "signatures": [{
                "code": "setup(element, options)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "HTMLElement"
                            }, {
                                "type": "NodeList"
                            }, {
                                "type": "String"
                            }
                        ],
                        "name": "element",
                        "description": "<p>The element as passed to the constructor.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "options",
                        "description": "<p>option values for the control.  These get added to\nthis.options and merged with [can.Control.static.defaults defaults].</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "undefined"
                        }, {
                            "type": "Array"
                        }
                    ],
                    "description": "<p>return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/control/control.js",
        "line": 311,
        "id": 109
    },
    "can.Control.prototype.options": {
        "name": "can.Control.prototype.options",
        "type": "property",
        "parent": "can.Control.prototype",
        "body": "<p>Options are used to configure a control.  They are\nthe 2nd argument\npassed to a control (or the first argument passed to the \n[can.Control.plugin control]'s jQuery plugin).</p>\n\n<p>For example:</p>\n\n<pre><code>can.Control('Hello')\n\nvar h1 = new Hello( $( '#content1' ), { message: 'World' } );\nequal( h1.options.message , \"World\" );\n\nvar h2 = $( '#content2' ).hello({ message: 'There' })\n                         .control();\nequal( h2.options.message , \"There\" );\n</code></pre>\n\n<p>Options are merged with [can.Control.static.defaults defaults] in\n[can.Control.prototype.setup setup].</p>\n\n<p>For example:</p>\n\n<pre><code>Tabs = can.Control({\n   defaults: {\n     activeClass: \"ui-active-state\"\n   }\n}, {\n   init: function(){\n     this.element.addClass( this.options.activeClass );\n   }\n});\n\nnew Tabs( $( \"#tabs1\" ) ); // adds 'ui-active-state'\nnew Tabs( $( \"#tabs2\" ), { activeClass : 'active' } ); // adds 'active'\n</code></pre>",
        "description": "",
        "title": "options",
        "comment": " ",
        "src": "can/control/control.js",
        "line": 371,
        "id": 110
    },
    "can.Control.prototype.on": {
        "type": "function",
        "name": "can.Control.prototype.on",
        "parent": "can.Control.prototype",
        "body": "<p><code>on(el, selector, eventName, func)</code> binds an event handler for an event to a selector under the scope of the given element.</p>\n\n<p><code>this.on()</code> is used to rebind \nall event handlers when [can.Control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.</p>\n\n<h2>Rebinding</h2>\n\n<p>By using templated event handlers, a control can listen to objects outside\n<code>this.element</code>.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's <code>completed</code> property and\ntoggle a strike className like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function(){\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: 'true' }) \n});\n</code></pre>\n\n<p>To update the taskstriker's task, add a task method that updates\nthis.options and calls rebind like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function() {\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  },\n  task: function( newTask ) {\n    this.options.task = newTask;\n    this.on();\n    this.update();\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: true }) \n});\ntaskstriker.task( new TaskStriker({ \n  task: new Task({ completed: false }) \n}));\n</code></pre>\n\n<h2>Adding new events</h2>\n\n<p>If events need to be bound to outside of the control and templated event handlers\nare not sufficent, you can call this.on to bind or delegate programatically:</p>\n\n<pre><code>init: function() {\n   // calls somethingClicked( el, ev )\n   this.on( 'click', 'somethingClicked' ); \n\n   // calls function when the window is clicked\n   this.on( window, 'click', function( ev ) {\n     //do something\n   });\n},\nsomethingClicked: function( el, ev ) {\n\n}\n</code></pre>",
        "description": "<p>Bind an event handler to a Control, or rebind all event handlers on a Control. </p>",
        "title": "on",
        "signatures": [{
                "code": "on([el,] selector, eventName, func)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "HTMLElement"
                            }, {
                                "type": "jQuery"
                            }, {
                                "type": "collection"
                            }, {
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "el",
                        "defaultValue": "this.element",
                        "description": "<p>The element to be bound.  If no element is provided, the control's element is used instead.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "selector",
                        "description": "<p>A css selector for event delegation.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventName",
                        "description": "<p>The event to listen for.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }, {
                                "type": "String"
                            }
                        ],
                        "name": "func",
                        "description": "<p>A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Number"
                        }
                    ],
                    "description": "<p>The id of the binding in this._bindings</p>"
                }
            }, {
                "code": "on()",
                "description": "",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "Number"
                        }
                    ],
                    "description": "<p>The number of handlers bound to this Control.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/control/control.js",
        "line": 519,
        "id": 111
    },
    "can.Control.prototype.off": {
        "type": "function",
        "name": "can.Control.prototype.off",
        "params": [],
        "parent": "can.Control.prototype",
        "body": "",
        "description": "<p>Unbinds all event handlers on the controller. You should never\nbe calling this unless in use with [can.Control::on].</p>",
        "hide": true,
        "src": "can/control/control.js",
        "line": 670,
        "id": 112
    },
    "can.Control.prototype.destroy": {
        "type": "function",
        "name": "can.Control.prototype.destroy",
        "parent": "can.Control.prototype",
        "body": "<p><code>destroy</code> prepares a control for garbage collection and is a place to\nreset any changes the control has made.  </p>\n\n<h2>Allowing Garbage Collection</h2>\n\n<p>Destroy is called whenever a control's element is removed from the page using \nthe library's standard HTML modifier methods.  This means that you\ndon't have to call destroy yourself and it \nwill be called automatically when appropriate.  </p>\n\n<p>The following <code>Clicker</code> widget listens on the window for clicks and updates\nits element's innerHTML.  If we remove the element, the window's event handler\nis removed auto-magically:</p>\n\n<pre><code> Clickr = can.Control({\n  \"{window} click\": function() {\n       this.element.html( this.count ? \n                          this.count++ : this.count = 0 );\n  }  \n});\n\n// create a clicker on an element\nnew Clicker( \"#clickme\" );\n\n// remove the element\n$( '#clickme' ).remove();\n</code></pre>\n\n<p>The methods you can use that will destroy controls automatically by library:</p>\n\n<p><strong>jQuery and Zepto</strong></p>\n\n<ul>\n<li>$.fn.remove</li>\n<li>$.fn.html</li>\n<li>$.fn.replaceWith</li>\n<li>$.fn.empty</li>\n</ul>\n\n<p><strong>Dojo</strong></p>\n\n<ul>\n<li>dojo.destroy</li>\n<li>dojo.empty</li>\n<li>dojo.place (with the replace option)</li>\n</ul>\n\n<p><strong>Mootools</strong></p>\n\n<ul>\n<li>Element.prototype.destroy</li>\n</ul>\n\n<p><strong>YUI</strong></p>\n\n<ul>\n<li>TODO!</li>\n</ul>\n\n<h2>Teardown in Destroy</h2>\n\n<p>Sometimes, you want to reset a controlled element back to its\noriginal state when the control is destroyed.  Overwriting destroy\nlets you write teardown code of this manner.  <strong>When overwriting\ndestroy, make sure you call Control's base functionality</strong>.</p>\n\n<p>The following example changes an element's text when the control is\ncreated and sets it back when the control is removed:</p>\n\n<pre><code>Changer = can.Control({\n  init: function() {\n    this.oldText = this.element.text();\n    this.element.text( \"Changed!!!\" );\n  },\n  destroy: function() {\n    this.element.text( this.oldText );\n    can.Control.prototype.destroy.call( this );\n  }\n});\n\n// create a changer which changes #myel's text\nvar changer = new Changer( '#myel' );\n\n// destroy changer which will reset it\nchanger.destroy();\n</code></pre>\n\n<h2>Base Functionality</h2>\n\n<p>Control prepares the control for garbage collection by:</p>\n\n<ul>\n<li>unbinding all event handlers</li>\n<li>clearing references to this.element and this.options</li>\n<li>clearing the element's reference to the control</li>\n<li>removing it's [can.Control.pluginName] from the element's className</li>\n</ul>",
        "description": "<p>Remove a Control from an element and clean up the Control. </p>",
        "signatures": [{
                "code": "destroy()",
                "description": "",
                "params": []
            }
        ],
        "title": "destroy",
        "comment": " ",
        "src": "can/control/control.js",
        "line": 684,
        "id": 113
    },
    "can/control/route/route.md": {
        "type": "script",
        "name": "can/control/route/route.md"
    },
    "route": {
        "type": "page",
        "name": "route",
        "body": "<p>The can.Control.route plugin adds a <strong>route</strong> [can.Control.processors processor] to [can.Control].\nThis allows creating routes and binding to [can.route] in a single step by listening to the <em>route</em> event\nand a route part. Route events will be triggered whenever the route changes to the route part\nthe control is listening to. For example:</p>\n\n<pre><code>var Router = can.Control({\n    init : function(el, options) {\n    },\n\n    \":type route\" : function(data) {\n        // the route says anything but todo\n    },\n\n    \"todo/:id route\" : function(data) {\n        // the route says todo/[id]\n        // data.id is the id or default value\n    },\n\n    \"route\" : function(data){\n        // the route is empty\n    }\n});\n\nnew Router(window);\n</code></pre>\n\n<p><code>route</code> without a route part will get called when the route is empty.\nThe data passed to the event handler is the serialized route data without the\n<em>route</em> attribute.</p>\n\n<h2>Demo</h2>\n\n<p>The following demo shows the above control in action.\nYou can edit the hash, follow some example links or directly change the can.route atttributes.\nAt the top it shows the control action being called and the data passed to it:</p>\n\n<div class='iframe_wrapper' data-iframe-src='can/control/route/demo.html' data-iframe-height='700'></div>",
        "description": "",
        "parent": "can.Control.plugins",
        "plugin": "can/control/route",
        "test": "can/control/view/qunit.html",
        "download": "http://donejs.com/can/dist/can.control.route.js",
        "comment": " ",
        "src": "can/control/route/route.md",
        "id": 114
    },
    "can/control/plugin/plugin.md": {
        "type": "script",
        "name": "can/control/plugin/plugin.md"
    },
    "can.Control.plugin": {
        "type": "page",
        "name": "can.Control.plugin",
        "body": "<div class='demo_wrapper' data-demo-src='can/control/plugin/plugin.html'></div>",
        "description": "<p>The <code>can.Control.plugin</code> extension is a plugin for creating and accessing \ncontrols with jQuery helper methods.  It uses the control's [can.Construct.fullName fullName] \nor a static [can.Control.plugin.static.pluginName pluginName] attribute for the name of the control.</p>\n\n<p>For example, the following plugin:</p>\n\n<pre><code>var Tabs = can.Control({\n  pluginName : 'tabs'\n},{\n  init : function(element, options, arg1){ },\n  update : function(options) {}\n})\n</code></pre>\n\n<p>Can now be created directly on the jQuery collection like:</p>\n\n<pre><code>$(\".tabs\").tabs();\n</code></pre>\n\n<p><strong>Note:</strong> This plugin only supports jQuery.</p>\n\n<h2>Invoking Methods</h2>\n\n<p>You can invoke methods on a control instance after its created through a few\ndifferent approaches.  </p>\n\n<p>Once a controller is initialized on a DOM element, you can invoke a method by calling\nthe plugin with the method name followed by the parameters for that method.\nWhen calling a method and it returns a value other than <code>undefined</code>, this value will\nbe returned. Otherwise the method call will return the jQuery object (for chaining).</p>\n\n<pre><code>var MyTodo = can.Control({\n  pluginName : 'my_todo'\n}, {\n  addTask: function(name, task){\n    this.element.append(name + \": \" + task)\n  },\n\n  getTasks : function() {\n    return this.element.text();\n  }\n});\n\n// Initialize MyTodo\n$('.my_todo').my_todo();\n\n// Calls addTask, returns the jQuery element\n$('.my_todo').my_todo(\"addTask\", 'Brian', 'Sweep garage') // -&gt; jQuery\n// Calls getTasks, returns the element text\n$('.my_todo').my_todo(\"getTasks\") // -&gt; Brian: Sweep garage\n</code></pre>\n\n<p>You can also retrieve the control instance and invoke the method directly.</p>\n\n<pre><code>var control = $('.my_todo').control();\ncontrol.addTask('Brian', 'Sweep garage');\n</code></pre>\n\n<p>For more information on this, see [jQuery.fn.control] or [jQuery.fn.controls].</p>\n\n<h2>Demo</h2>\n\n<p>The following demo shows creating a plugin widget and then updating the widget's <code>times</code> variable\nfor each time the button was clicked.</p>",
        "title": "jQuery plugin",
        "parent": "can.Control.plugins",
        "plugin": "can/control/plugin",
        "test": "can/control/plugin/qunit.html",
        "download": "http://donejs.com/can/dist/can.control.plugin.js",
        "src": "can/control/plugin/plugin.md",
        "id": 115
    },
    "can/control/plugin/plugin.js": {
        "type": "script",
        "name": "can/control/plugin/plugin.js"
    },
    "can.Control.setup": {
        "name": "can.Control.setup",
        "type": "constructor",
        "body": "",
        "description": "<p>static</p>",
        "src": "can/control/plugin/plugin.js",
        "line": 15,
        "id": 116
    },
    "can.Control.plugin.static.pluginName": {
        "name": "can.Control.plugin.static.pluginName",
        "type": "property",
        "parent": "can.Control.plugin",
        "body": "",
        "description": "<p>Setting the static <code>pluginName</code> property allows you to override the default name\nwith your own.</p>\n\n<pre><code>var Filler = can.Control({\n  pluginName: 'fillWith'\n},{});\n\n$(\"#foo\").fillWith();\n</code></pre>\n\n<p>If you don't provide a <code>pluginName</code>, the control falls back to the\n[can.Construct.fullName fullName] attribute:</p>\n\n<pre><code>can.Control('Ui.Layout.FillWith', {}, {});\n$(\"#foo\").ui_layout_fill_with();\n</code></pre>",
        "title": "pluginName",
        "src": "can/control/plugin/plugin.js",
        "line": 22,
        "id": 117
    },
    "jQuery.fn.controls": {
        "type": "function",
        "name": "jQuery.fn.controls",
        "parent": "can.Control.plugin",
        "body": "<p>When the widget is initialized, the plugin control creates an array \nof control instance(s) with the DOM element it was initialized on using \n[can.data] method.</p>\n\n<p>The <code>controls</code> method allows you to get the control instance(s) for any element.  </p>\n\n<pre><code>//- Inits the widgets\n$('.widgets:eq(0)').my_box();\n$('.widgets:eq(1)').my_clock();\n\n&lt;div class=\"widgets my_box\" /&gt;\n&lt;div class=\"widgets my_clock\" /&gt;\n\n$('.widgets').controls() //-&gt; [ MyBox, MyClock ]\n</code></pre>\n\n<p>Additionally, you can invoke it passing the name of a control\nto fetch a specific instance(s).</p>\n\n<pre><code>//- Inits the widgets\n$('.widgets:eq(0)').my_box();\n$('.widgets:eq(1)').my_clock();\n\n&lt;div class=\"widgets my_box\" /&gt;\n&lt;div class=\"widgets my_clock\" /&gt;\n\n$('.widgets').controls('MyBox') //-&gt; [ MyBox ]\n</code></pre>",
        "description": "<p>Get the Controls associated with elements. </p>",
        "title": "jQuery.fn.controls",
        "signatures": [{
                "code": "jQuery.fn.controls([type])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }, {
                                "type": "can.Control"
                            }
                        ],
                        "optional": true,
                        "name": "control",
                        "description": "<p>The type of Controls to find.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Control"
                        }
                    ],
                    "description": "<p>The controls associated with the given elements.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/control/plugin/plugin.js",
        "line": 58,
        "id": 118
    },
    "jQuery.fn.control": {
        "type": "function",
        "name": "jQuery.fn.control",
        "parent": "can.Control.plugin",
        "body": "<p>This is ths same as [jQuery.fn.controls $().controls] except that\nit only returns the first Control found.</p>\n\n<pre><code>//- Init MyBox widget\n$('.widgets').my_box();\n\n&lt;div class=\"widgets my_box\" /&gt;\n\n$('.widgets').controls() //-&gt; MyBox\n</code></pre>",
        "description": "<p>Get the Control associated with elements. </p>",
        "title": "jQuery.fn.control",
        "signatures": [{
                "code": "jQuery.fn.control([type])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }, {
                                "type": "can.Control"
                            }
                        ],
                        "optional": true,
                        "name": "control",
                        "description": "<p>The type of Control to find.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.Control"
                        }
                    ],
                    "description": "<p>The first control found.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/control/plugin/plugin.js",
        "line": 115,
        "id": 119
    },
    "can.Control.plugin.prototype.update": {
        "type": "function",
        "name": "can.Control.plugin.prototype.update",
        "parent": "can.Control.plugin",
        "body": "<p>Update extends [can.Control.prototype.options options] \nwith the <code>options</code> argument and rebinds all events.  It \nre-configures the control.</p>\n\n<p>For example, the following control wraps a recipe form. When the form\nis submitted, it creates the recipe on the server.  When the recipe\nis <code>created</code>, it resets the form with a new instance.</p>\n\n<pre><code>var Creator = can.Control({\n  \"{recipe} created\" : function(){\n    this.update({recipe : new Recipe()});\n    this.element[0].reset();\n    this.element.find(\"[type=submit]\").val(\"Create Recipe\")\n  },\n  \"submit\" : function(el, ev){\n    ev.preventDefault();\n    var recipe = this.options.recipe;\n    recipe.attrs( this.element.formParams() );\n    this.element.find(\"[type=submit]\").val(\"Saving...\")\n    recipe.save();\n  }\n});\n\n$('#createRecipes').creator({ recipe : new Recipe() })\n</code></pre>\n\n<p><em>Update</em> is called if a control's plugin helper is called with the plugin options on an element\nthat already has a control instance of the same type. If you want to implement your\nown update method make sure to call the old one either using the [can.Construct.super super] plugin or\nby calling <code>can.Control.prototype.update.apply(this, arguments);</code>.\nFor example, you can change the content of the control element every time the options change:</p>\n\n<pre><code>var Plugin = can.Control({\n    pluginName: 'myPlugin'\n  }, {\n    init : function(el, options) {\n      this.updateCount = 0;\n      this.update({\n        text : 'Initialized'\n      });\n    },\n    update : function(options) {\n      // Call the can.Control update first.\n      // Use this._super when using can/construct/super\n      can.Control.prototype.update.call(this, options);\n      this.element.html(this.options.text + ' ' +\n        (++this.updateCount) + ' times');\n    }\n});\n\n$('#control').myPlugin();\n$('#control').html();\n// Initialized. Updated 1 times\n\n$('#control').myPlugin({ text : 'Calling update. Updated' });\n$('#control').html();\n// Calling update. Updated 2 times\n</code></pre>\n\n<div class='demo_wrapper' data-demo-src='can/control/plugin/demo-update.html'></div>",
        "description": "<p>Reconfigure a control. </p>",
        "title": "update",
        "signatures": [{
                "code": "update(newOptions)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "newOptions",
                        "description": "<p>Options to merge into the current options.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "options",
                        "description": "<p>A list of options to merge with \n[can.Control.prototype.options this.options].  Often this method\nis called by the [can.Control.plugin jQuery helper function].</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/control/plugin/plugin.js",
        "line": 172,
        "id": 120
    },
    "can/route/route.md": {
        "type": "script",
        "name": "can/route/route.md"
    },
    "can.route": {
        "type": "function",
        "name": "can.route",
        "body": "<h2>Background Information</h2>\n\n<p>To support the browser's back button and bookmarking\nin an Ajax application, most applications use\nthe <code>window.location.hash</code>.  By\nchanging the hash (via a link or JavaScript), \none is able to add to the browser's history \nwithout changing the page.</p>\n\n<p>This provides the basics needed to\ncreate history enabled Ajax websites.  However,\n<code>can.route</code> addresses several other needs such as:</p>\n\n<ul>\n<li>Pretty urls (actually hashes)</li>\n<li>Keeping routes independent of application code</li>\n<li>Listening to specific parts of the history changing</li>\n<li>Setup / Teardown of widgets.</li>\n</ul>\n\n<h2>How it works</h2>\n\n<p><code>can.route</code> is a [can.Observe] that represents the\n<code>window.location.hash</code> as an \nobject.  For example, if the hash looks like:</p>\n\n<pre><code>#!type=videos&amp;id=5\n</code></pre>\n\n<p>the data in <code>can.route</code> looks like:</p>\n\n<pre><code>{ type: 'videos', id: 5 }\n</code></pre>\n\n<p><code>can.route</code> keeps the state of the hash in-sync with the <code>data</code> contained within \n<code>can.route</code>.</p>\n\n<h2>can.Observe</h2>\n\n<p><code>can.route</code> is a [can.Observe]. Understanding\n<code>can.Observe</code> is essential for using <code>can.route</code> correctly.</p>\n\n<p>You can listen to changes in an Observe with <code>bind(eventName, handler(ev, args...))</code> and\nchange can.route's properties with \n[can.Observe.prototype.attr attr].</p>\n\n<h3>Listening to changes in an Observable</h3>\n\n<p>Listen to changes in history \nby [can.Observe.prototype.bind bind]ing to\nchanges in <code>can.route</code> like:</p>\n\n<pre><code>can.route.bind('change', function(ev, attr, how, newVal, oldVal) {\n\n})\n</code></pre>\n\n<ul>\n<li><code>attr</code> - the name of the changed attribute</li>\n<li><code>how</code> - the type of Observe change event (add, set or remove)</li>\n<li><code>newVal</code>/<code>oldVal</code> - the new and old values of the attribute</li>\n</ul>\n\n<p>You can also listen to specific changes \nwith [can.Observe.delegate delegate]:</p>\n\n<pre><code>can.route.delegate('id','change', function(){ ... })\n</code></pre>\n\n<p>Observe lets you listen to the following events:</p>\n\n<ul>\n<li>change - any change to the object</li>\n<li>add - a property is added</li>\n<li>set - a property value is added or changed</li>\n<li>remove - a property is removed</li>\n</ul>\n\n<p>Listening for <code>add</code> is useful for widget setup\nbehavior, <code>remove</code> is useful for teardown.</p>\n\n<h3>Updating an observable</h3>\n\n<p>Create changes in the route data with [can.Observe.prototype.attr attr] like:</p>\n\n<pre><code>can.route.attr('type','images');\n</code></pre>\n\n<p>Or change multiple properties at once like:</p>\n\n<pre><code>can.route.attr({type: 'pages', id: 5}, true)\n</code></pre>\n\n<p>When you make changes to can.route, they will automatically\nchange the <code>hash</code>.</p>\n\n<h2>Creating a Route</h2>\n\n<p>Use <code>can.route(url, defaults)</code> to create a \nroute. A route is a mapping from a url to \nan object (that is the can.route's state). \nIn order to map to a specific properties in the url,\nprepend a colon to the name of the property like:</p>\n\n<pre><code>can.route( \"!#content/:type\" )\n</code></pre>\n\n<p>If no routes are added, or no route is matched, \ncan.route's data is updated with the [can.deparam deparamed]\nhash.</p>\n\n<pre><code>location.hash = \"#!type=videos\";\n// can.route -&gt; {type : \"videos\"}\n</code></pre>\n\n<p>Once routes are added and the hash changes,\ncan.route looks for matching routes and uses them\nto update can.route's data.</p>\n\n<pre><code>can.route( \"!#content/:type\" );\nlocation.hash = \"#!content/images\";\n// can.route -&gt; {type : \"images\"}\ncan.route.attr( \"type\", \"songs\" )\n// location.hash -&gt; \"#!content/songs\"\n</code></pre>\n\n<p>Default values can also be added:</p>\n\n<pre><code>can.route(\"content/:type\",{type: \"videos\" });\nlocation.hash = \"#!content/\"\n// can.route -&gt; {type : \"videos\"}\n</code></pre>\n\n<h2>Delay setting can.route</h2>\n\n<p>By default, <code>can.route</code> sets its initial data\non document ready.  Sometimes, you want to wait to set \nthis data.  To wait, call:</p>\n\n<pre><code>can.route.ready(false);\n</code></pre>\n\n<p>and when ready, call:</p>\n\n<pre><code>can.route.ready(true);\n</code></pre>\n\n<h2>Changing the route.</h2>\n\n<p>Typically, you never want to set <code>location.hash</code>\ndirectly.  Instead, you can change properties on <code>can.route</code>\nlike:</p>\n\n<pre><code>can.route.attr('type', 'videos')\n</code></pre>\n\n<p>This will automatically look up the appropriate \nroute and update the hash.</p>\n\n<p>Often, you want to create links.  <code>can.route</code> provides\nthe [can.route.link] and [can.route.url] helpers to make this \neasy:</p>\n\n<pre><code>can.route.link(\"Videos\", {type: 'videos'})\n</code></pre>\n\n<h2>Demo</h2>\n\n<p>The following demo shows the relationship between <code>window.location.hash</code>,\nroutes given to <code>can.data</code>,\n<code>can.route</code>'s data, and events on <code>can.data</code>.  Most properties \nare editable so experiment!</p>\n\n<div class='iframe_wrapper' data-iframe-src='can/route/demo.html' data-iframe-height='980'></div>\n\n<h2>IE Compatibility</h2>\n\n<p>Internet Explorer 6 and 7 does not support <code>window.onhashchange</code>. \nEven Internet Explorer 8 running in IE7 compatibility mode reports <code>true</code> \nfor <code>onhashchange</code> in window, even though the event isn't supported.</p>\n\n<p>If you are using jQuery, you can include Ben Alman's [HashChange Plugin http://benalman.com/projects/jquery-hashchange-plugin/]\nto support the event in the unsupported browser(s).  Include <code>can/route/hashchange.js</code>\nin your file to support those browsers.</p>\n\n<h2>Using routes with <code>can.Control</code></h2>\n\n<p>Using templated event handlers, it is possible to listen to changes to\n<code>can.route</code> within <code>can.Control</code>. This is convenient as it allows the\ncontrol to listen to and make changes whenever the route is modified, \neven outside of the control itself.</p>\n\n<pre><code>// create the route\ncan.route(\"!#content/:type\")\n\n// the route has changed\n\"{can.route} change\": function(ev, attr, how, newVal, oldVal) {\n    if (attr === \"type\") {\n        // the route has a type\n    }\n}\n</code></pre>\n\n<h3>Creating and binding routes with <code>can.Control.route</code></h3>\n\n<p>Using [can.Control.route], a builtin plugin to CanJS, cuts down on the amount\nof code needed to work with <code>can.route</code> in <code>can.Control</code>. With this plugin, it is possible\nto both create routes and bind to <code>can.route</code> at the same time. Instead of creating\nseveral routes to handle changes to <strong>type</strong> and <strong>id</strong>, write something like this\nin a control:</p>\n\n<pre><code>// the route is empty\n\"route\": function(data) {\n\n},\n// the route has a type\n\":type route\": function(data) {\n\n}, \n// the route has a type and id\n\":type/:id route\": function(data) {\n\n}\n</code></pre>\n\n<h3>Getting more specific with the <code>can.Observe.delegate</code> plugin</h3>\n\n<p>Sometimes, you might only want to trigger a function when the route changes\nonly once, even if the route change gets called multiple times. By using the \n[can.Observe.delegate] plugin, this is extremely easy. This plugin allows you to \nlisten to change, set, add, and remove on <code>can.route</code>.</p>\n\n<p>If you wanted to, say, show a list of recipes when  <strong>type</strong> was set to recipe\nand show a specific recipe when <strong>id</strong> was set, you could do something like:</p>\n\n<pre><code>\"{can.route} type=recipe set\": \n        function( ev, prop, how, newVal, oldVal ) {\n    // show list of recipes\n},\n\"recipe/:id\": function(data) {\n    // show a single recipe\n}\n</code></pre>\n\n<p>If we didn't only listen to when recipe is set, then every time we chose to\nshow a single recipe, we would create and show the list of recipes again which \nwould not very efficient.</p>",
        "description": "<p>can.route is a plugin that helps manage browser history and\nclient state by synchronizing the window.location.hash with\nan [can.Observe].</p>",
        "title": "can.route",
        "comment": " ",
        "inherits": "can.Observe",
        "download": "can/route",
        "test": "can/route/qunit.html",
        "parent": "canjs",
        "signatures": [{
                "code": "can.route(template[, defaults])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "template",
                        "description": "<p>the fragment identifier to match.  The fragment identifier\nshould start with either a character (a-Z) or colon (:).  Examples:</p>\n\n<pre><code>can.route(\":foo\")\ncan.route(\"foo/:bar\")\n</code></pre>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "defaults",
                        "description": "<p>an object of default values</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.route"
                        }
                    ],
                    "description": ""
                }
            }
        ],
        "src": "can/route/route.md",
        "id": 121
    },
    "can/route/route.js": {
        "type": "script",
        "name": "can/route/route.js"
    },
    "can.route.param": {
        "type": "function",
        "name": "can.route.param",
        "parent": "can.route.static",
        "body": "<p>Parameterizes the raw JS object representation provided in data.</p>\n\n<pre><code>can.route.param( { type: \"video\", id: 5 } ) \n     // -&gt; \"type=video&amp;id=5\"\n</code></pre>\n\n<p>If a route matching the provided data is found, that URL is built\nfrom the data. Any remaining data is added at the end of the\nURL as &amp; separated key/value parameters.</p>\n\n<pre><code>can.route(\":type/:id\")\n\ncan.route.param( { type: \"video\", id: 5 } ) // -&gt; \"video/5\"\ncan.route.param( { type: \"video\", id: 5, isNew: false } ) \n     // -&gt; \"video/5&amp;isNew=false\"\n</code></pre>",
        "description": "<p>Get a route URL from given data. </p>",
        "title": "param",
        "signatures": [{
                "code": "param(data)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "data"
                            }
                        ],
                        "name": "object",
                        "description": "<p>The data to populate the route with.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>The route, with the data populated in it.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/route/route.js",
        "line": 99,
        "id": 122
    },
    "can.route.deparam": {
        "type": "function",
        "name": "can.route.deparam",
        "parent": "can.route.static",
        "body": "<p>Creates a data object based on the query string passed into it. This is \nuseful to create an object based on the <code>location.hash</code>.</p>\n\n<pre><code>can.route.deparam(\"id=5&amp;type=videos\") \n     // -&gt; { id: 5, type: \"videos\" }\n</code></pre>\n\n<p>It's important to make sure the hash or exclamantion point is not passed\nto <code>can.route.deparam</code> otherwise it will be included in the first property's\nname.</p>\n\n<pre><code>can.route.attr(\"id\", 5) // location.hash -&gt; #!id=5\ncan.route.attr(\"type\", \"videos\") \n     // location.hash -&gt; #!id=5&amp;type=videos\ncan.route.deparam(location.hash) \n     // -&gt; { #!id: 5, type: \"videos\" }\n</code></pre>\n\n<p><code>can.route.deparam</code> will try and find a matching route and, if it does,\nwill deconstruct the URL and parse our the key/value parameters into the data object.</p>\n\n<pre><code>can.route(\":type/:id\")\n\ncan.route.deparam(\"videos/5\");\n     // -&gt; { id: 5, route: \":type/:id\", type: \"videos\" }\n</code></pre>",
        "description": "<p>Extract data from a route URL. </p>",
        "title": "deparam",
        "signatures": [{
                "code": "deparam(url)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "url",
                        "description": "<p>A URL to extract data from.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Object"
                        }
                    ],
                    "description": "<p>An object containing the extracted data.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/route/route.js",
        "line": 187,
        "id": 123
    },
    "static.data": {
        "name": "static.data",
        "type": "property",
        "parent": "static",
        "body": "",
        "description": "<p>A can.Observe that represents the state of the history.</p>",
        "hide": true,
        "src": "can/route/route.js",
        "line": 263,
        "id": 124
    },
    "routes": {
        "name": "routes",
        "type": "property",
        "parent": "static",
        "body": "",
        "description": "<p>A list of routes recognized by the router indixed by the url used to add it.\nEach route is an object with these members:</p>\n\n<ul>\n<li><p>test - A regular expression that will match the route when variable values \nare present; i.e. for :page/:type the <code>RegExp</code> is /([\\w.]<em>)/([\\w.]</em>)/ which\nwill match for any value of :page and :type (word chars or period).</p></li>\n<li><p>route - The original URL, same as the index for this entry in routes.</p></li>\n<li><p>names - An array of all the variable names in this route</p></li>\n<li><p>defaults - Default values provided for the variables or an empty object.</p></li>\n<li><p>length - The number of parts in the URL separated by '/'.</p></li>\n</ul>",
        "types": [{
                "type": "Object"
            }
        ],
        "title": "",
        "hide": true,
        "src": "can/route/route.js",
        "line": 268,
        "id": 125
    },
    "can.route.ready": {
        "type": "function",
        "name": "can.route.ready",
        "parent": "can.route.static",
        "body": "<p>Indicates that all routes have been added and sets can.route.data\nbased upon the routes and the current hash.</p>\n\n<p>By default, ready is fired on jQuery's ready event.  Sometimes\nyou might want it to happen sooner or earlier.  To do this, call:</p>\n\n<pre><code>can.route.ready(false); //prevents firing by the ready event\ncan.route.ready(true); // fire the first route change\n</code></pre>",
        "description": "",
        "title": "ready",
        "signatures": [{
                "code": "ready(readyYet)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Boolean"
                            }
                        ],
                        "optional": true,
                        "name": "readyYet",
                        "description": "<p>Whether the ready event should be fired yet.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "can.route"
                        }
                    ],
                    "description": "<p>The <code>can.route</code> object.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/route/route.js",
        "line": 288,
        "id": 126
    },
    "can.route.url": {
        "type": "function",
        "name": "can.route.url",
        "parent": "can.route.static",
        "body": "<p>Similar to [can.route.link], but instead of creating an anchor tag, <code>can.route.url</code> creates \nonly the URL based on the route options passed into it.</p>\n\n<pre><code>can.route.url( { type: \"videos\", id: 5 } ) \n     // -&gt; \"#!type=videos&amp;id=5\"\n</code></pre>\n\n<p>If a route matching the provided data is found the URL is built from the data. Any remaining\ndata is added at the end of the URL as &amp; separated key/value parameters.</p>\n\n<pre><code>can.route(\":type/:id\")\n\ncan.route.url( { type: \"videos\", id: 5 } ) // -&gt; \"#!videos/5\"\ncan.route.url( { type: \"video\", id: 5, isNew: false } ) \n     // -&gt; \"#!video/5&amp;isNew=false\"\n</code></pre>",
        "description": "",
        "title": "url",
        "signatures": [{
                "code": "url(options[, merge])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "options",
                        "description": "<p>The data to populate the route with.</p>"
                    }, {
                        "types": [{
                                "type": "Boolean"
                            }
                        ],
                        "optional": true,
                        "name": "merge",
                        "description": "<p>Whether the given options should be merged into the current state of the route.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>The route URL and query string.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/route/route.js",
        "line": 315,
        "id": 127
    },
    "can.route.link": {
        "type": "function",
        "name": "can.route.link",
        "parent": "can.route.static",
        "body": "<p>Creates and returns an anchor tag with an href of the route \nattributes passed into it, as well as any properies desired\nfor the tag.</p>\n\n<pre><code>can.route.link( \"My videos\", { type: \"videos\" }, {}, false )\n     // -&gt; &lt;a href=\"#!type=videos\"&gt;My videos&lt;/a&gt;\n</code></pre>\n\n<p>Other attributes besides href can be added to the anchor tag\nby passing in a data object with the attributes desired.</p>\n\n<pre><code>can.route.link( \"My videos\", { type: \"videos\" }, \n  { className: \"new\" }, false ) \n     // -&gt; &lt;a href=\"#!type=videos\" class=\"new\"&gt;My Videos&lt;/a&gt;\n</code></pre>\n\n<p>It is possible to utilize the current route options when making anchor\ntags in order to make your code more reusable. If merge is set to true,\nthe route options passed into <code>can.route.link</code> will be passed into the\ncurrent ones.</p>\n\n<pre><code>location.hash = \"#!type=videos\" \ncan.route.link( \"The zoo\", { id: 5 }, true )\n     // -&gt; &lt;a href=\"#!type=videos&amp;id=5\"&gt;The zoo&lt;/true&gt;\n\nlocation.hash = \"#!type=pictures\" \ncan.route.link( \"The zoo\", { id: 5 }, true )\n     // -&gt; &lt;a href=\"#!type=pictures&amp;id=5\"&gt;The zoo&lt;/true&gt;\n</code></pre>",
        "description": "",
        "title": "link",
        "signatures": [{
                "description": "<p>`link(innerText, options, props[, merge])</p>",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "innerText",
                        "description": "<p>The text inside the link.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "options",
                        "description": "<p>The data to populate the route with.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "props",
                        "description": "<p>Properties for the anchor other than <code>href</code>.</p>"
                    }, {
                        "types": [{
                                "type": "Boolean"
                            }
                        ],
                        "optional": true,
                        "name": "merge",
                        "description": "<p>Whether the given options should be merged into the current state of the route.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>A string with an anchor tag that points to the populated route.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/route/route.js",
        "line": 345,
        "id": 128
    },
    "can.route.current": {
        "type": "function",
        "name": "can.route.current",
        "parent": "can.route.static",
        "body": "<p>Checks the page's current URL to see if the route represents the options passed \ninto the function.</p>\n\n<p>Returns true if the options respresent the current URL.</p>\n\n<pre><code>can.route.attr('id', 5) // location.hash -&gt; \"#!id=5\"\ncan.route.current({ id: 5 }) // -&gt; true\ncan.route.current({ id: 5, type: 'videos' }) // -&gt; false\n\ncan.route.attr('type', 'videos') \n       // location.hash -&gt; #!id=5&amp;type=videos\ncan.route.current({ id: 5, type: 'videos' }) // -&gt; true\n</code></pre>",
        "description": "",
        "title": "current",
        "signatures": [{
                "code": "current(options)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "options",
                        "description": "<p>Data to check agains the current route.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Boolean"
                        }
                    ],
                    "description": "<p>Whether the data matches the current URL.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/route/route.js",
        "line": 391,
        "id": 129
    },
    "can/view/view.md": {
        "type": "script",
        "name": "can/view/view.md"
    },
    "can.view": {
        "type": "constructor",
        "name": "can.view",
        "body": "",
        "description": "",
        "title": "",
        "parent": "canjs",
        "comment": " ",
        "signatures": [{
                "code": "can.view(view, data, helpers)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "view",
                        "description": "<p>The URL to a template or the ID of a template.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "data",
                        "description": "<p>Data to populate the template with.</p>"
                    }, {
                        "types": [{
                                "type": "Object",
                                "template": [{
                                        "types": [{
                                                "type": "String"
                                            }
                                        ]
                                    }, {
                                        "types": [{
                                                "type": "function",
                                                "returns": {
                                                    "types": [{
                                                            "type": "undefined"
                                                        }
                                                    ]
                                                },
                                                "params": []
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "name": "helpers",
                        "description": "<p>Helpers referenced in the template.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>The template with the data interpolated into it.</p>"
                }
            }
        ],
        "src": "can/view/view.md",
        "id": 130
    },
    "can/view/view.js": {
        "type": "script",
        "name": "can/view/view.js"
    },
    "can.view.ejs": {
        "body": "<p><code>can.view.ejs([id,] template)</code> registers an EJS template string\nfor a given id programatically. The following\nregisters <code>myViewEJS</code> and renders it into a documentFragment.</p>\n\n<pre><code> can.view.ejs('myViewEJS', '&lt;h2&gt;&lt;%= message %&gt;&lt;/h2&gt;');\n\n var frag = can.view('myViewEJS', {\n     message : 'Hello there!'\n });\n\n frag // -&gt; &lt;h2&gt;Hello there!&lt;/h2&gt;\n</code></pre>\n\n<p>To convert the template into a render function, just pass\nthe template. Call the render function with the data\nyou want to pass to the template and it returns the\ndocumentFragment.</p>\n\n<pre><code> var renderer = can.view.ejs('&lt;div&gt;&lt;%= message %&gt;&lt;/div&gt;');\n renderer({\n     message : 'EJS'\n }); // -&gt; &lt;div&gt;EJS&lt;/div&gt;\n</code></pre>",
        "description": "<p>Register an EJS template string or create a renderer function. </p>",
        "title": "ejs",
        "name": "can.view.ejs",
        "type": "function",
        "parent": "can.view.static",
        "signatures": [{
                "code": "can.view.ejs(id, template)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "id",
                        "description": "<p>An ID for the template.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "template",
                        "description": "<p>An EJS template in string form.</p>"
                    }
                ]
            }, {
                "code": "can.view.ejs(template)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "template",
                        "description": "<p>An EJS template in string form.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "function",
                            "returns": {
                                "types": [{
                                        "type": "undefined"
                                    }
                                ]
                            },
                            "params": []
                        }
                    ],
                    "description": "<p>A renderer function that takes data and helpers.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/view/view.js",
        "line": 103,
        "id": 131
    },
    "can.view.mustache": {
        "body": "",
        "description": "<p>Register a Mustache template string or create a renderer function. </p>",
        "title": "mustache",
        "name": "can.view.mustache",
        "type": "function",
        "parent": "can.view.static",
        "signatures": [{
                "code": "can.view.mustache(id, template)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "id",
                        "description": "<p>An ID for the template.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "template",
                        "description": "<p>A Mustache template in string form.</p>"
                    }
                ]
            }, {
                "code": "can.view.mustache(template)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "template",
                        "description": "<p>A Mustache template in string form.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "function",
                            "returns": {
                                "types": [{
                                        "type": "undefined"
                                    }
                                ]
                            },
                            "params": []
                        }
                    ],
                    "description": "<p>A renderer function that takes data and helpers.</p>\n\n<p><code>can.view.mustache([id,] template)</code> registers an Mustache template string \nfor a given id programatically. The following\nregisters <code>myStache</code> and renders it into a documentFragment.</p>\n\n<pre><code> can.view.ejs('myStache', '&lt;h2&gt;{{message}}&lt;/h2&gt;');\n\n var frag = can.view('myStache', {\n     message : 'Hello there!'\n });\n\n frag // -&gt; &lt;h2&gt;Hello there!&lt;/h2&gt;\n</code></pre>\n\n<p>To convert the template into a render function, just pass \nthe template. Call the render function with the data\nyou want to pass to the template and it returns the \ndocumentFragment.</p>\n\n<pre><code> var renderer = can.view.mustache('&lt;div&gt;{{message}}&lt;/div&gt;');\n renderer({\n     message : 'Mustache'\n }); // -&gt; &lt;div&gt;Mustache&lt;/div&gt;\n</code></pre>"
                }
            }
        ],
        "src": "can/view/view.js",
        "line": 140,
        "id": 132
    },
    "hookups": {
        "name": "hookups",
        "type": "property",
        "parent": "can.view",
        "body": "",
        "description": "<p>A list of pending 'hookups'</p>",
        "title": "",
        "hide": true,
        "src": "can/view/view.js",
        "line": 176,
        "id": 133
    },
    "can.view.hook": {
        "type": "function",
        "name": "can.view.hook",
        "parent": "can.view.static",
        "body": "<p>Registers a hookup function that can be called back after the html is \nput on the page.  Typically this is handled by the template engine.  Currently\nonly EJS supports this functionality.</p>\n\n<pre><code>var id = can.view.hook(function(el){\n       //do something with el\n    }),\n    html = \"&lt;div data-view-id='\"+id+\"'&gt;\"\n$('.foo').html(html);\n</code></pre>",
        "description": "<p>Create a hookup to insert into templates. </p>",
        "title": "hook",
        "signatures": [{
                "code": "can.view.hook(callback)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "callback",
                        "description": "<p>A callback function to be called with the element.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/view/view.js",
        "line": 183,
        "id": 134
    },
    "can.view.cached": {
        "name": "can.view.cached",
        "type": "property",
        "parent": "can.view",
        "body": "",
        "description": "<p>Cached are put in this object</p>",
        "hide": true,
        "types": [{
                "type": "Object"
            }
        ],
        "title": "view",
        "src": "can/view/view.js",
        "line": 206,
        "id": 135
    },
    "can.view.cache": {
        "name": "can.view.cache",
        "type": "property",
        "parent": "can.view.static",
        "body": "",
        "description": "<p>By default, views are cached on the client.  If you'd like the\nthe views to reload from the server, you can set the <code>cache</code> attribute to <code>false</code>.</p>\n\n<pre><code>    //- Forces loads from server\n    can.view.cache = false; \n</code></pre>",
        "types": [{
                "type": "Boolean"
            }
        ],
        "title": "cache",
        "src": "can/view/view.js",
        "line": 216,
        "id": 136
    },
    "can.view.register": {
        "type": "function",
        "name": "can.view.register",
        "parent": "can.view.static",
        "body": "<p>Registers a template engine to be used with \nview helpers and compression.  </p>\n\n<h2>Example</h2>\n\n<pre><code class=\"lang-javascript\">can.View.register({\n    suffix : \"tmpl\",\n plugin : \"jquery/view/tmpl\",\n    renderer: function( id, text ) {\n        return function(data){\n            return jQuery.render( text, data );\n        }\n    },\n    script: function( id, text ) {\n        var tmpl = can.tmpl(text).toString();\n        return \"function(data){return (\"+\n            tmpl+\n            \").call(jQuery, jQuery, data); }\";\n    }\n})</code></pre>     ",
        "description": "<p>Register a templating language. </p>",
        "title": "register",
        "signatures": [{
                "code": "can.view.register(info)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object",
                                "options": [{
                                        "name": "plugin",
                                        "description": "The location of the templating language's plugin.",
                                        "types": [{
                                                "type": "String"
                                            }
                                        ]
                                    }, {
                                        "name": "suffix",
                                        "description": "Files with this suffix will use this templating language's plugin by default.",
                                        "types": [{
                                                "type": "String"
                                            }
                                        ]
                                    }, {
                                        "name": "renderer",
                                        "description": "A function that returns a function that, given data, will render the template with that data.\nThe __renderer__ function receives the id of the template and the text of the template.",
                                        "types": [{
                                                "type": "function",
                                                "returns": {
                                                    "types": [{
                                                            "type": "undefined"
                                                        }
                                                    ]
                                                },
                                                "params": []
                                            }
                                        ]
                                    }, {
                                        "name": "script",
                                        "description": "A function that returns the string form of the processed template.\n",
                                        "types": [{
                                                "type": "function",
                                                "returns": {
                                                    "types": [{
                                                            "type": "undefined"
                                                        }
                                                    ]
                                                },
                                                "params": []
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "name": "info",
                        "description": "<p>Information about the templating language.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/view/view.js",
        "line": 228,
        "id": 137
    },
    "can.view.ext": {
        "name": "can.view.ext",
        "type": "property",
        "parent": "can.view.static",
        "body": "",
        "description": "<p>The default suffix to use if none is provided in the view's url. <br />\nThis is set to <code>.ejs</code> by default.</p>\n\n<pre><code>    // Changes view ext to 'txt'\n    can.view.ext = 'txt';\n</code></pre>",
        "types": [{
                "type": "String"
            }
        ],
        "title": "ext",
        "src": "can/view/view.js",
        "line": 270,
        "id": 138
    },
    "can.view.registerScript": {
        "type": "function",
        "name": "can.view.registerScript",
        "params": [{
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "type",
                "description": ""
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "id",
                "description": ""
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "src",
                "description": ""
            }
        ],
        "parent": "can.view",
        "body": "",
        "description": "<p>Returns the text that </p>",
        "hide": true,
        "src": "can/view/view.js",
        "line": 282,
        "id": 139
    },
    "can.view.preload": {
        "type": "function",
        "name": "can.view.preload",
        "params": [{
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "id",
                "description": ""
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "name": "renderer",
                "description": ""
            }
        ],
        "parent": "can.view",
        "body": "",
        "description": "<p>Called by a production script to pre-load a renderer function\ninto the view cache.</p>",
        "hide": true,
        "src": "can/view/view.js",
        "line": 291,
        "id": 140
    },
    "can.view.render": {
        "type": "function",
        "name": "can.view.render",
        "parent": "can.view.static",
        "body": "<p><code>can.view.render(view, [data], [helpers], callback)</code> returns the rendered markup produced by the corresponding template\nengine as String. If you pass a deferred object in as data, render returns\na deferred resolving to the rendered markup.</p>\n\n<p><code>can.view.render</code> is commonly used for sub-templates.</p>\n\n<h2>Example</h2>\n\n<p><em>welcome.ejs</em> looks like:</p>\n\n<pre><code>&lt;h1&gt;Hello &lt;%= hello %&gt;&lt;/h1&gt;\n</code></pre>\n\n<p>Render it to a string like:</p>\n\n<pre><code>can.view.render(\"welcome.ejs\",{hello: \"world\"})\n  //-&gt; &lt;h1&gt;Hello world&lt;/h1&gt;\n</code></pre>\n\n<h2>Use as a Subtemplate</h2>\n\n<p>If you have a template like:</p>\n\n<pre><code>&lt;ul&gt;\n  &lt;% list(items, function(item){ %&gt;\n    &lt;%== can.view.render(\"item.ejs\",item) %&gt;\n  &lt;% }) %&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<h2>Using renderer functions</h2>\n\n<p>If you only pass the view path, `can.view will return a renderer function that can be called with\nthe data to render:</p>\n\n<pre><code>var renderer = can.view.render(\"welcome.ejs\");\n// Do some more things\nrenderer({hello: \"world\"}) // -&gt; Document Fragment\n</code></pre>",
        "description": "<p>Render a template. </p>",
        "title": "render",
        "signatures": [{
                "code": "can.view.render(template[, callback])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }, {
                                "type": "Object"
                            }
                        ],
                        "name": "view",
                        "description": "<p>The path of the view template or a view object.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "callback",
                        "description": "<p>A function executed after the template has been processed.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "function",
                            "returns": {
                                "types": [{
                                        "type": "undefined"
                                    }
                                ]
                            },
                            "params": []
                        }, {
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A renderer function to be called with data and helpers\nor a Deferred that resolves to a renderer function.</p>"
                }
            }, {
                "code": "can.view.render(template, data[, [helpers,] callback])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }, {
                                "type": "Object"
                            }
                        ],
                        "name": "view",
                        "description": "<p>The path of the view template or a view object.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "data",
                        "description": "<p>The data to populate the template with.</p>"
                    }, {
                        "types": [{
                                "type": "Object",
                                "template": [{
                                        "types": [{
                                                "type": "String"
                                            }
                                        ]
                                    }, {
                                        "types": [{
                                                "type": "function",
                                                "returns": {
                                                    "types": [{
                                                            "type": "undefined"
                                                        }
                                                    ]
                                                },
                                                "params": []
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "optional": true,
                        "name": "helpers",
                        "description": "<p>Helper methods referenced in the template.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "callback",
                        "description": "<p>A function executed after the template has been processed.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }, {
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>The template with interpolated data in string form\nor a Deferred that resolves to the template with interpolated data.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/view/view.js",
        "line": 300,
        "id": 141
    },
    "can.view.registerView": {
        "type": "function",
        "name": "can.view.registerView",
        "params": [{
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "id",
                "description": ""
            }, {
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "text",
                "description": ""
            }, {
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "type",
                "description": ""
            }, {
                "types": [{
                        "type": "can.Deferred"
                    }
                ],
                "name": "def",
                "description": ""
            }
        ],
        "parent": "can.view",
        "body": "",
        "description": "<p>Registers a view with <code>cached</code> object.  This is used\ninternally by this class and Mustache to hookup views.</p>",
        "hide": true,
        "src": "can/view/view.js",
        "line": 453,
        "id": 142
    },
    "can.view.text": {
        "name": "can.view.text",
        "type": "property",
        "parent": "can.view",
        "body": "",
        "description": "<p>should return something like steal(\"dependencies\",function(EJS){\n     return can.view.preload(\"ID\", options.text)\n})</p>",
        "hide": true,
        "src": "can/view/view.js",
        "line": 598,
        "id": 143
    },
    "can/view/ejs/ejs.md": {
        "type": "script",
        "name": "can/view/ejs/ejs.md"
    },
    "can.EJS": {
        "type": "constructor",
        "name": "can.EJS",
        "body": "<div class='iframe_wrapper' data-iframe-src='can/view/ejs/demo.html' data-iframe-height='1020'></div>",
        "description": "<p>EJS provides <strong>live</strong> ERB-style client-side templates. Use EJS \nwith [can.view] and for live templating use EJS with [can.Observe].</p>\n\n<h2>Basic Example</h2>\n\n<p>The following renders a Teacher's name and students into an element.  First, \ncreate a teacher template in a script tag like:</p>\n\n<pre><code>&lt;script type='text/ejs' id='teacherEJS'&gt;\n\n  &lt;h2 class='&lt;%= teacher.grade &lt; 'c'? \"good\" : \"bad\" %&gt;'&gt;\n    &lt;%= teacher.name %&gt;\n  &lt;/h2&gt;\n\n  &lt;ul&gt;\n    &lt;% for(var i =0; i&lt; teacher.students.length; i++){ %&gt;\n      &lt;li&gt;&lt;%= teacher.students[i].name %&gt;&lt;/li&gt;\n    &lt;% } %&gt;\n  &lt;/ul&gt;\n\n&lt;/script&gt;\n</code></pre>\n\n<p>Notice the magic tags?  Those are things that look like <code>&lt;% %&gt;</code> and \n<code>&lt;%= %&gt;</code>.  Code between <code>&lt;% %&gt;</code> is run and the return value of code\nbetween <code>&lt;%= %&gt;</code> is inserted into the page.</p>\n\n<p>Next, create a teacher and use can.view to render the template:</p>\n\n<pre><code>var teacher = {\n  name : \"Mr. Smith\",\n  grade : \"a\",\n  students : [\n    {name : \"Suzy\"},\n    {name : \"Payal\"},\n    {name : \"Curtis\"},\n    {name : \"Alexis\"}\n  ]\n};\n\ndocument.getElementById('teacher')\n  .appendChild( can.view(\"teacherEjs\", teacher) )\n</code></pre>\n\n<p>This results in HTML like:</p>\n\n<pre><code>&lt;div id='teachers'&gt;\n  &lt;h2 class='good'&gt;\n    Mr. Smith\n  &lt;/h2&gt;\n\n  &lt;ul&gt;\n     &lt;li&gt;Suzy&lt;/li&gt;\n     &lt;li&gt;Payal&lt;/li&gt;\n     &lt;li&gt;Curtis&lt;/li&gt;\n     &lt;li&gt;Alexis&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>This is nice, but what if we change properties of the teacher?</p>\n\n<h2>Basic Live Binding Example</h2>\n\n<p>EJS sets up live templating binding when a [can.Observe]'s properties are read \nvia [can.Observe::attr attr] within a magic tag.  To make this template\nrespond to changes in the teacher data, first rewrite the template\nto use the attr method to read properties and <code>list( observeList, cb(item, i) )</code>\nto iterate through a list like:</p>\n\n<pre><code>&lt;script type='text/ejs' id='teacherEJS'&gt;\n\n  &lt;h2 class='&lt;%= teacher.attr('grade') &lt; 'c'? \"good\" : \"bad\" %&gt;'&gt;\n    &lt;%= teacher.attr('name') %&gt;\n  &lt;/h2&gt;\n\n  &lt;ul&gt;\n    &lt;% list(teacher.students, function(student){ %&gt;\n      &lt;li&gt;&lt;%= student.attr('name') %&gt;&lt;/li&gt;\n    &lt;% }) %&gt;\n  &lt;/ul&gt;\n\n&lt;/script&gt;\n</code></pre>\n\n<p><strong>Note:</strong> The end of this page discusses why using <code>list</code> is \nhelpful, but it does nothing fancy.</p>\n\n<p>Next, turn your teacher into a <code>new can.Observe(object)</code> and pass\nthat to <code>can.view</code>:</p>\n\n<pre><code>var teacher = can.Observe({\n  name : \"Mr. Smith\",\n  grade : \"a\"\n  students : [\n    {name : \"Suzy\"},\n    {name : \"Payal\"},\n    {name : \"Curtis\"},\n    {name : \"Alexis\"}\n  ]\n});\n\ndocument.getElementById('teacher')\n  .appendChild( can.view(\"teacherEjs\", teacher) );\n</code></pre>\n\n<p>Finally, update some properties of teacher and slap your \nhead with disbelief ...</p>\n\n<pre><code>teacher.attr('name',\"Prof. Snape\")\nteacher.attr('grade','f+')\nteacher.attr('students').push({\n  name : \"Harry Potter\"\n})\n</code></pre>\n\n<p>... but don't slap it too hard, you'll need it for building awesome apps.</p>\n\n<h2>Demo</h2>\n\n<p>The following demo shows an EJS template being rendered with observable data. \nIt demonstrates live binding to attributes. The template and all data properties \nare editable, so experiment!</p>\n\n<h2>Magic Tags</h2>\n\n<p>EJS uses 5 types of tags:</p>\n\n<p><strong><code>&lt;% CODE %&gt;</code></strong> - Runs JS Code.</p>\n\n<p>This type of magic tag does not modify the template but is used for JS control statements \nlike for-loops, if/else, switch, etc.  Some examples:</p>\n\n<pre><code>&lt;% if( items.attr('length') === 0 ) { %&gt;\n    &lt;tr&gt;&lt;td&gt;You have no items&lt;/td&gt;&lt;/tr&gt;\n&lt;% } else { %&gt;\n    &lt;% list(items, function(){ %&gt;\n      &lt;tr&gt; .... &lt;/tr&gt;\n    &lt;% }) %&gt;\n&lt;% } %&gt;\n\n\n&lt;% var address = person.attr('address') %&gt;\n&lt;span&gt;&lt;%= address.attr('street') %&gt;&lt;span&gt;\n</code></pre>\n\n<p><strong><code>&lt;%= CODE %&gt;</code></strong> - Runs JS Code and writes the <em>escaped</em> result into the result of the template.</p>\n\n<p>The following results in the user seeing \"my favorite element is &lt;blink>BLINK&lt;blink>\" and not\n<blink>BLINK</blink>.</p>\n\n<pre><code> &lt;div&gt;my favorite element is &lt;%= '&lt;blink&gt;BLINK&lt;/blink&gt;' %&gt;.&lt;/div&gt;\n</code></pre>\n\n<p><strong><code>&lt;%== CODE %&gt;</code></strong>  - Runs JS Code and writes the <em>unescaped</em> result into the result of the template.</p>\n\n<p>The following results in \"my favorite element is <B>B</B>.\". Using <code>&lt;%==</code> is useful\nfor sub-templates.</p>\n\n<pre><code>     &lt;div&gt;my favorite element is &lt;%== '&lt;B&gt;B&lt;/B&gt;' %&gt;.&lt;/div&gt;\n</code></pre>\n\n<p><strong><code>&lt;%% CODE %&gt;</code></strong> - Writes &lt;% CODE %> to the result of the template.  This is very useful for generators.</p>\n\n<pre><code>     &lt;%%= 'hello world' %&gt;\n</code></pre>\n\n<p><strong><code>&lt;%# CODE %&gt;</code></strong>  - Used for comments.  This does nothing.</p>\n\n<pre><code>     &lt;%# 'hello world' %&gt;\n</code></pre>\n\n<h2>Live Binding</h2>\n\n<p>EJS allows live binding by wrapping magic tag content within a function. When <code>attr()</code> is called \nto update an observable object, these functions are executed to return the new value.</p>\n\n<pre><code>// Suppose an observable \"foo\":\n\nvar foo = can.Observe({\n  count: '0'\n});\n\n// Suppose also, the above observable is passed to our view:\n\n&lt;%= foo.attr('bar') %&gt;\n\n// EJS locates the magic tag and turns the above into:\n\nfunction() { return foo.attr('bar'); }\n\n// As \"foo\" is updated using attr(), this function is called again to\n// render the view with the new value.\n</code></pre>\n\n<p>This means that each function tag has a closure will reference variables in it's \nparent functions. This can cause problems if you don't understand closures in \nJavaScript. For example, the following binding does not work:</p>\n\n<pre><code>&lt;% for(var i =0; i &lt; items.attr('length'); i++){ %&gt;\n  &lt;li&gt;&lt;%= items[i].attr('name') %&gt;&lt;/li&gt;\n&lt;% } %&gt;\n</code></pre>\n\n<p>This is because it gets turned into:</p>\n\n<pre><code>&lt;% for(var i =0; i &lt; items.attr('length'); i++){ %&gt;\n  LIVEBIND( function() { return items[i].attr('name') )\n&lt;% } %&gt;\n</code></pre>\n\n<p>When the wrapping function is called again, <code>i</code> will \nnot be the index of the item, but instead be items.length.</p>\n\n<p>The [can.EJS.Helpers::view view]<code>(observeList,function(item,index,list){})</code> method in EJS should be used to iterate through observe lists:</p>\n\n<pre><code>&lt;% list(items, function(item){ %&gt;\n  &lt;li&gt;&lt;%= item.attr('name') %&gt;&lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h2>Advanced Live Binding</h2>\n\n<p>Once you get the hang of how EJS works, it makes live-binding of complex\ncalculations possible.  The following extends a [can.Model.List] to suppot a <code>completed</code> method that\nreturns the total number of completed items in the list.  It can be used in a template like:</p>\n\n<pre><code>&lt;h2&gt;&lt;%= todos.complete() %&gt; Complete Todos &lt;/h2&gt;\n</code></pre>\n\n<p>And implemented like:</p>\n\n<pre><code>Todo.List = can.Model.List({\n  completed: function() {\n    var count = 0;\n\n    this.attr('length');\n    this.each(function(i, todo) {\n      if(this.attr('completed')) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n});\n</code></pre>\n\n<p><code>completed</code> listens on changes to the list (via <code>this.attr('length')</code>) and \neach item's <code>'completed'</code> property.  EJS keeps track of which observe/attribute pairs are called\nby <code>.complete()</code>.  If they change, EJS will automatically unbind.</p>\n\n<p>Adding a \"completed\" helper function to the todo model list to return the number of completed todos:</p>\n\n<p><strong>Note:</strong> The object passed into the view becomes \"this\" within the view template.</p>\n\n<pre><code>var todos = Todo.findAll({}); //returns a can.Model.List\ncan.view('//todo/views/init.ejs', todos)\n</code></pre>",
        "title": "",
        "parent": "canjs",
        "src": "can/view/ejs/ejs.md",
        "id": 144
    },
    "can/view/ejs/ejs.js": {
        "type": "script",
        "name": "can/view/ejs/ejs.js"
    },
    "can.EJS.prototype": {
        "type": "prototype",
        "body": "",
        "description": "",
        "name": "can.EJS.prototype",
        "parent": "can.EJS",
        "src": "can/view/ejs/ejs.js",
        "line": 31,
        "id": 145
    },
    "can.EJS.prototype.render": {
        "type": "function",
        "name": "can.EJS.prototype.render",
        "parent": "can.EJS.prototype",
        "body": "<p>Renders an object with view helpers attached to the view.</p>\n\n<pre><code>new can.EJS({text: \"&lt;%= message %&gt;\"}).render({\n  message: \"foo\"\n},{helper: function(){ ... }})\n</code></pre>",
        "description": "<p>Render a view object with data and helpers. </p>",
        "title": "render",
        "signatures": [{
                "code": "render(data[, helpers])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "data",
                        "description": "<p>The data to populate the template with.</p>"
                    }, {
                        "types": [{
                                "type": "Object",
                                "template": [{
                                        "types": [{
                                                "type": "String"
                                            }
                                        ]
                                    }, {
                                        "types": [{
                                                "type": "function",
                                                "returns": {
                                                    "types": [{
                                                            "type": "undefined"
                                                        }
                                                    ]
                                                },
                                                "params": []
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "optional": true,
                        "name": "helpers",
                        "description": "<p>Helper methods referenced in the template.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>The template with interpolated data.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/view/ejs/ejs.js",
        "line": 36,
        "id": 146
    },
    "can.EJS.prototype.scanner": {
        "name": "can.EJS.prototype.scanner",
        "type": "property",
        "parent": "can.EJS.prototype",
        "body": "",
        "description": "<p>Singleton scanner instance for parsing templates.</p>",
        "hide": true,
        "src": "can/view/ejs/ejs.js",
        "line": 58,
        "id": 147
    },
    "can.EJS.prototype.tokens": {
        "name": "can.EJS.prototype.tokens",
        "type": "property",
        "parent": "can.EJS.prototype",
        "body": "",
        "description": "<p>An ordered token registry for the scanner.\nThis needs to be ordered by priority to prevent token parsing errors.\nEach token is defined as: [\"token-name\", \"string representation\", \"optional regexp override\"]</p>",
        "hide": true,
        "src": "can/view/ejs/ejs.js",
        "line": 63,
        "id": 148
    },
    "can.EJS.static": {
        "type": "constructor",
        "name": "can.EJS.static",
        "params": [{
                "name": "data",
                "description": ""
            }, {
                "name": "extras",
                "description": ""
            }
        ],
        "parent": "can.EJS",
        "body": "",
        "description": "",
        "src": "can/view/ejs/ejs.js",
        "line": 82,
        "id": 149
    },
    "can.EJS.Helpers": {
        "name": "can.EJS.Helpers",
        "type": "page",
        "parent": "can.EJS.static",
        "body": "<p>By adding functions to can.EJS.Helpers.prototype, those functions will be available in the\nviews.</p>\n\n<p>The following helper converts a given string to upper case:</p>\n\n<pre><code>can.EJS.Helpers.prototype.toUpper = function(params)\n{\n    return params.toUpperCase();\n}\n</code></pre>\n\n<p>Use it like this in any EJS template:</p>\n\n<pre><code>&lt;%= toUpper('javascriptmvc') %&gt;\n</code></pre>\n\n<p>To access the current DOM element return a function that takes the element as a parameter:</p>\n\n<pre><code>can.EJS.Helpers.prototype.upperHtml = function(params)\n{\n    return function(el) {\n        $(el).html(params.toUpperCase());\n    }\n}\n</code></pre>\n\n<p>In your EJS view you can then call the helper on an element tag:</p>\n\n<pre><code>&lt;div &lt;%= upperHtml('javascriptmvc') %&gt;&gt;&lt;/div&gt;\n</code></pre>",
        "description": "",
        "title": "Helpers",
        "comment": " ",
        "src": "can/view/ejs/ejs.js",
        "line": 94,
        "id": 150
    },
    "can/view/mustache/doc/acquisition.md": {
        "type": "script",
        "name": "can/view/mustache/doc/acquisition.md"
    },
    "can.Mustache.Acquisition": {
        "type": "page",
        "name": "can.Mustache.Acquisition",
        "body": "",
        "description": "<p>There are number of ways to acquire templates such as: raw text,\nURL, or script tags in the markup.</p>\n\n<p><strong>Raw Text</strong></p>\n\n<p>Raw text can by templated by passing an object with a <code>text</code>\nattribute containing your template and Mustache will return a \ndocument fragment back.  For example:</p>\n\n<pre><code>var template = \"My body lies over the {{.}}\";\nvar fragment = new can.Mustache({ text: template })\n                .render('water');\ncan.append(can.$(document.body), can.view.frag(fragment));\n</code></pre>\n\n<p><strong>Script Tags</strong></p>\n\n<p>Inline script tags in your HTML document can be used to render \ntemplates.  Set the <code>type</code> to <code>text/mustache</code> and the <code>id</code> as a unique\nkey Mustache will use for look up.</p>\n\n<pre><code>&lt;script id=\"mytemplate\" type=\"text/mustache\"&gt;\n    My body lies over the {{.}}\n&lt;/script&gt;\n\nvar template = can.view(\"#mytemplate\", 'water');\ncan.$(document.body).append(template);\n</code></pre>\n\n<p><strong>URL</strong></p>\n\n<p>Templates can be defined in its own file and  Mustache will fetch the \nfiles on render.  This is the preferred way since it will keep your application\nnicely organized seperating views from logic code. </p>\n\n<pre><code>var template = can.view('//lib/views/mytemplate.mustache', \n                dataToPass)\ncan.$(document.body).append(template);\n</code></pre>\n\n<p>Since could potentially make several XHR requests, in a big application\nthis could be a performance concern.  Creating a build step to \nconcatenate and include all of the views in one file would be one way to optimize performance. <br />\nIf you are using Steal, it will do this automatically at build for you.</p>",
        "title": "Template Acquisition",
        "parent": "can.Mustache.pages",
        "order": 3,
        "src": "can/view/mustache/doc/acquisition.md",
        "id": 151
    },
    "can/view/mustache/doc/basics.md": {
        "type": "script",
        "name": "can/view/mustache/doc/basics.md"
    },
    "can.Mustache.Basics": {
        "type": "page",
        "name": "can.Mustache.Basics",
        "body": "",
        "description": "<h2>Keys</h2>\n\n<p>Keys insert data into the template.  They reference variables\nwithin the current context.  For example:</p>\n\n<pre><code>{\n        name: \"Austin\"\n}\n\n{{name}}\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>\"Austin\"\n</code></pre>\n\n<h2>Escaping Values</h2>\n\n<p>Mustache will escape values enclosed in a <code>{{  }}</code> expression.  For example:</p>\n\n<pre><code>{\n    friend: \"&lt;strong&gt;Justin&lt;/strong&gt;\"\n}\n\n{{friend}}\n</code></pre>\n\n<p>would return:</p>\n\n<pre><code>&amp;lt;strong&amp;gt;Justin&amp;lt;/strong&amp;gt;\n</code></pre>\n\n<p>If you would like Mustache to return the value without \nescaping, use the <code>{{{  }}}</code> expression.  For example:</p>\n\n<pre><code>{{{friend}}}\n</code></pre>\n\n<p>would return:</p>\n\n<pre><code>&lt;strong&gt;Justin&lt;/strong&gt;\n</code></pre>\n\n<h2>Paths and Context</h2>\n\n<p>When Mustache is resolving a object in a <a href=\"#Sections\">section</a>, the current\ncontext is the value that its iterating. For example:</p>\n\n<pre><code>{\n    friends: [ 'Austin' ]\n}\n\n{{#friends}}\n    {{this}}\n{{/friends}}\n</code></pre>\n\n<p><strong>Dot Notation</strong></p>\n\n<p>The dot notation lets the template reference the current context implicitly.  So taking the above example\nwe could do:</p>\n\n<pre><code>{{#friends}}\n    {{.}}\n{{/friends}}\n</code></pre>\n\n<p>and the <code>.</code> would represent the 'Austin' value in the array similar to <code>this</code> does too.</p>\n\n<p><strong>Nested Paths</strong></p>\n\n<p>Mustache supports nested paths, making it possible to look up \nproperties nested below the current context.  For example:</p>\n\n<pre><code>{ \n    book: {\n        author: \"James Cameron\",\n        publisher: \"Cengage\"\n    }\n}\n</code></pre>\n\n<p>then we could reference <code>author</code> and <code>publisher</code> like so:</p>\n\n<pre><code>{{book.author}}\n{{book.publisher}}\n</code></pre>\n\n<p><strong>Context Jumping</strong></p>\n\n<p>Internally, Mustache keeps a stack of contexts as the template dives\ndeeper into nested <a href=\"#Sections\">sections</a> and <a href=\"#Helpers\">helpers</a>.  If a key is not found within \nthe current context, Mustache will look for the key in the parent context\nand so on until it resolves the object or reaches the parent most object. <br />\nFor example:</p>\n\n<pre><code>{\n    family: [\n        {\n            name: 'Austin',\n            sisters: [\n                {\n                    name: 'Katherine'\n                }\n            ],\n            brothers: [\n                {\n                    name: 'Justin'\n                }\n            ]\n        }\n    ]\n}\n\n{{#family}\n    {{#brothers}}\n        {{#sisters}}\n            {{name}}\n        {{/sisters}}\n    {{/brothers}}\n{{/family}}\n</code></pre>\n\n<p>Since <code>sisters</code> isn't in the context of the brothers array,\nit jumps up to the family object and resolves sisters there.</p>",
        "title": "Basics",
        "parent": "can.Mustache.pages",
        "order": 0,
        "src": "can/view/mustache/doc/basics.md",
        "id": 152
    },
    "can/view/mustache/doc/helpers.md": {
        "type": "script",
        "name": "can/view/mustache/doc/helpers.md"
    },
    "can.Mustache.Helpers": {
        "type": "page",
        "name": "can.Mustache.Helpers",
        "body": "",
        "description": "<h1>Helpers</h1>\n\n<p>Helpers allow you to register functions that can be called \nfrom any context in a template. </p>\n\n<p>Mustache includes a number of built-in helpers that are listed below\nbut you can register your own helper too.</p>\n\n<h2>if</h2>\n\n<p>In addition to truthy/falsey evaluation with <a href=\"#Sections\">sections</a>, you can use an \nexplicit <code>if</code> condition to render a block.</p>\n\n<pre><code>{\n    friends: true\n}\n\n{{#if friends}}\n    I have friends!\n{{/if}}\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>I have friends!\n</code></pre>\n\n<p><code>if</code> acts similarly to a truthy <code>{{#section}}</code>.</p>\n\n<h2>else</h2>\n\n<p>When using <code>if</code> or a custom helper, you can specify the inverse\nof the evaluation by using the <code>else</code> helper.</p>\n\n<pre><code>{\n    friend: false\n}\n\n&lt;ul&gt;\n    {{#if friends}}\n        &lt;/li&gt;{{name}}&lt;/li&gt;\n    {{else}}\n        &lt;li&gt;No friends.&lt;/li&gt;\n    {{/if}}\n&lt;/ul&gt;\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;No friends.&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p><code>else</code> acts similarly to a falsey <code>{{^inverse}}</code>, but only applies when used within another helper.</p>\n\n<p>In this case, using the <code>if</code>/<code>else</code> helpers simplify your template by not requiring extra <a href=\"#Sections\">sections</a> to be specified.</p>\n\n<h2>unless</h2>\n\n<p>The <code>unless</code> helper evaluates the inverse of the value of the key and renders \nthe block between the helper and the slash.</p>\n\n<pre><code>{\n    friends: []\n}\n\n{{#unless friends}}\n    You don't have any friends!\n{{/unless}}\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>You don't have any friends!\n</code></pre>\n\n<p><code>unless</code> acts similarly to a falsey <code>{{^inverse}}</code>.</p>\n\n<h2>each</h2>\n\n<p>The<code>each</code> helper explicitly iterates over an array of items and\nrenders the block.</p>\n\n<p>Like <a href=\"#Sections\">sections</a>, it will reset the current context to the value for which its iterating.\nSee the <a href=\"#Basics\">basics of contexts</a> for more information.</p>\n\n<pre><code>{ \n    friends: [ \n        { name: \"Austin\" }, \n        { name: \"Justin\" } \n    ] \n}\n\n&lt;ul&gt;\n    {{#each friends}}\n        &lt;li&gt;{{name}}&lt;/li&gt;\n    {{/each}}\n&lt;/ul&gt;\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;Austin&lt;/li&gt;\n    &lt;li&gt;Justin&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<h2>with</h2>\n\n<p>Mustache typically applies the context passed in the <a href=\"#Sections\">sections</a> at runtime.  However,\nyou can override this context by using the <code>with</code> helper.</p>\n\n<p>For example, using the <code>with</code> helper Mustache shifts the context to the friends object.</p>\n\n<pre><code>{\n    name: \"Austin\"\n    friends: 1\n}\n\n\n&lt;h1&gt;Hi {{name}}&lt;/h1&gt;\n{{#with friends}}\n    &lt;p&gt;You have {{.}} new friend!&lt;/p&gt;\n{{/with}}\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>&lt;h1&gt;Hi Austin&lt;/h1&gt;\n&lt;p&gt;You have 1 new friend!&lt;/p&gt;\n</code></pre>\n\n<h2>Element Callbacks</h2>\n\n<p>When rendering HTML with views, you often want to call some JavaScript\nsuch as intializing a jQuery plugin on the new HTML.</p>\n\n<p>Mustache makes it easy to define this code in the markup.  Using the\n<a href=\"http://wiki.ecmascript.org/doku.php?id=strawman:arrow_function_syntax\">ES5 Arrow Syntax</a> \nits easy to define the element for which is passed followed by the arrow\nand the function to execute on the element.</p>\n\n<pre><code>&lt;div class=\"tabs\" {{(el) -&gt; el.jquery_tabs()}}&gt;&lt;/div&gt;\n</code></pre>\n\n<p>After rendering the HTML, <code>jquery_tabs</code> will be called on the tabs div.</p>\n\n<h2>Data Associations</h2>\n\n<p>Attaching data to an element is done by calling the <code>data</code> helper\nfollowed by the attribute name you want to attach it as.</p>\n\n<pre><code>{\n    name: 'Austin'\n}\n\n&lt;ul&gt;\n    &lt;li id=\"personli\" {{data 'person'}}&gt;{{name}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>Now the data can be access by doing:</p>\n\n<pre><code>var nameObject = can.data(can.$('#personli'), 'person');\n</code></pre>\n\n<p>It automatically attaches the data to the\nelement using [can.data] and the implied context of <code>this</code>.</p>\n\n<h2>Registering Helpers</h2>\n\n<p>You can register your own global helper with the <code>Mustache.registerHelper</code> method, or \na local helper (just accessible by the template you're rendering) by passing in an object containing helper functions to can.view.</p>\n\n<p>Localization is a good example of a custom helper you might implement\nin your application. The below example takes a given key and \nreturns the localized value using \n<a href=\"https://github.com/jquery/globalize\">jQuery Globalize</a>.</p>\n\n<pre><code>Mustache.registerHelper('l10n', function(str, options){\n    return Globalize != undefined \n        ? Globalize.localize(str) \n        : str;\n});\n</code></pre>\n\n<p>Or another way to do this:</p>\n\n<pre><code>can.view(\"//path/to/template.mustache\", data, {\n    l10n: function(str, options){\n        return Globalize != undefined \n            ? Globalize.localize(str) \n            : str;\n    }\n})\n</code></pre>\n\n<p>In the template, invoke the helper by calling the helper\nname followed by any additional arguments.</p>\n\n<pre><code>&lt;span&gt;{{l10n 'mystring'}}&lt;/span&gt;\n</code></pre>\n\n<p>will render:</p>\n\n<pre><code>&lt;span&gt;my string localized&lt;/span&gt;\n</code></pre>\n\n<p><strong>Helpers with can.Observe attributes</strong></p>\n\n<p>If a can.Observe attribute is passed as an argument to a helper, it is converted to a can.compute getter/setter function.  This is to allow creating 2-way binding type functionality between a can.Observe attribute and a form element. For example in your template:</p>\n\n<pre><code>&lt;div&gt;{{addPrefix name}}&lt;/div&gt;\n</code></pre>\n\n<p>Your helper would look like:</p>\n\n<pre><code>var item = new can.Observe({name: \"Brian\"}),\n    frag = can.view(\"#template\", item, {\n      addPrefix: function(name){\n        return \"Mr.\" + name()\n      }\n    });\n</code></pre>\n\n<p>Note we're calling <code>name()</code> in order to read its contents.</p>\n\n<p><strong>Multiple Arguments</strong></p>\n\n<p>You can pass multiple arguments just by putting a space between\nthat and the previous argument like so:</p>\n\n<pre><code>{{helper 'cat' 'hat'}}\n\nMustache.registerHelper('helper', function(arg1, arg2, options){\n    // arg1 -&gt; 'cat'\n    // arg2 -&gt; 'hat'\n});\n</code></pre>\n\n<p><strong>Evaluating Helpers</strong></p>\n\n<p>If you want to use a helper with as a <a href=\"#Sections\">section</a>, you need to call \n<code>options.fn(context)</code> in your return statement. This will return a \nstring with the resulting evaluated <a href=\"#Sections\">section</a>.</p>\n\n<p>Similarly, you can call <code>options.inverse(context)</code> to evaluate the \ntemplate between an <code>{{else}}</code> magic tag and the closing magic tag.</p>\n\n<p>For example, when a route matches the string passed to our\nrouting helper it will show/hide the text.</p>\n\n<pre><code>Mustache.registerHelper('routing', function(str, options){\n    if (can.route.attr('filter') === str)\n        return options.fn(this);\n    }\n});\n\n{{#routing 'advanced'}}\n    You have applied the advanced filter.\n{{/routing}}\n</code></pre>\n\n<p><strong>Advanced Helpers</strong></p>\n\n<p>Helpers can be passed normal objects, native objects like numbers and strings, \nas well as a hash object. The hash object will be an object literal containing \nall ending arguments using the <code>key=value</code> syntax. The hash object will be provided \nto the helper as <code>options.hash</code>. Additionally, when using <a href=\"#Sections\">section</a> with the helper, \nyou can set a custom context by passing the object instead of <code>this</code>.</p>\n\n<pre><code>Mustache.registerHelper('exercise', function(group, action, \n                                        num, options){\n    if (group &amp;&amp; group.length &gt; 0 &amp;&amp; action &amp;&amp; num &gt; 0) {\n        return options.fn({\n            group: group,\n            action: action,\n            where: options.hash.where,\n            when: options.hash.when,\n            num: num\n        });\n    }\n    else {\n        return options.inverse(this);\n    }\n});\n\n{{#exercise pets 'walked' 3 where='around the block' when=time}}\n    Along with the {{#group}}{{.}}, {{/group}}\n    we {{action}} {{where}} {{num}} times {{when}}.\n{{else}}\n    We were lazy today.\n{{/exercise}}\n\n{\n    pets: ['cat', 'dog', 'parrot'],\n    time: 'this morning'\n}\n</code></pre>\n\n<p>This would output:</p>\n\n<pre><code>Along with the cat, dog, parrot, we walked around the block \n3 times this morning.\n</code></pre>\n\n<p>Whereas, an empty data object would output:</p>\n\n<pre><code>We were lazy today.\n</code></pre>",
        "title": "Helpers",
        "parent": "can.Mustache.pages",
        "order": 4,
        "src": "can/view/mustache/doc/helpers.md",
        "id": 153
    },
    "can/view/mustache/doc/livebinding.md": {
        "type": "script",
        "name": "can/view/mustache/doc/livebinding.md"
    },
    "can.Mustache.Binding": {
        "type": "page",
        "name": "can.Mustache.Binding",
        "body": "",
        "description": "<p>Live binding is templates that update themselves as the data \nused in the magic tags change.</p>\n\n<p>It's very common as the page is interacted with that the underlying \ndata represented in the page changes.  Typically, you have callbacks \nin your AJAX methods or events and then update the content of your \ncontrols manually.</p>\n\n<p>In this example, we have a simple user welcome screen.</p>\n\n<pre><code>&lt;h1&gt;Welcome {{user}}!&lt;/h1&gt;\n&lt;p&gt;\n    {{#if messages}}\n        You have {{messages}} new messages.\n    {{else}}\n        You no messages.\n    {{/messages}}\n&lt;/p&gt;\n\nvar data = new can.Observe({\n    user: 'Tina Fey',\n    messages: 0\n});\n\nvar template = can.view(\"#template\", data);\n</code></pre>\n\n<p>The template evaluates the <code>messages</code> and adds the hooks for living-binding automatically. <br />\nSince we have no message it will render:</p>\n\n<pre><code>&lt;h1&gt;Welcome Tina Fey!&lt;/h1&gt;\n&lt;p&gt;You no messages.&lt;/p&gt;\n</code></pre>\n\n<p>Now say we have a request that updates\nthe <code>messages</code> attribute to have <code>5</code> messages.  We \ncall the <a href=\"can.Observe.prototype.attr\">attr</a> method on the <a href=\"can.Observe\">can.Observe</a> to update\nthe attribute to the new value.</p>\n\n<pre><code>data.attr('message', 5)\n</code></pre>\n\n<p>After <a href=\"can.Observe\">can.Observe</a> recieves this update, it will automatically\nupdate the paragraph tag to reflect the new value.</p>\n\n<pre><code>&lt;p&gt;You have 5 new message.&lt;/p&gt;\n</code></pre>\n\n<p>For more information visit the <a href=\"can.Observe\">can.Observe</a>.</p>",
        "title": "Live Binding",
        "parent": "can.Mustache.pages",
        "order": 5,
        "src": "can/view/mustache/doc/livebinding.md",
        "id": 154
    },
    "can/view/mustache/doc/mustache.md": {
        "type": "script",
        "name": "can/view/mustache/doc/mustache.md"
    },
    "can.Mustache": {
        "type": "constructor",
        "name": "can.Mustache",
        "body": "",
        "description": "<p>can.Mustache provides logic-less templates with live binding \nwhen used with <a href=\"#can_observe\">can.Observes</a>. It currently ships as a plugin,\nand you can view the <a href=\"http://canjs.us/release/latest/docs/can.view.mustache.html\">annotated source</a>.</p>\n\n<p><a href=\"https://github.com/janl/mustache.js/\">Mustache</a> and <a href=\"http://handlebarsjs.com/\">Handlebar</a> \ntemplates are compatible with can.Mustache, so you can import existing templates.</p>\n\n<h2>Getting Started</h2>\n\n<p>Mustache templates looks similar to normal HTML except\nthey contain contain keys for inserting data into the template\nand <a href=\"#Sections\">sections</a> to enumerate and/or filter the enclosed template blocks.</p>\n\n<p>For example, the following renders a welcome header for\na user and displays the number of messages.</p>\n\n<p><strong>Mustache Template</strong></p>\n\n<pre><code>&lt;script id=\"template\" type=\"text/mustache\"&gt;\n    &lt;h1&gt;Welcome {{user}}!&lt;/h1&gt;\n    &lt;p&gt;You have {{messages}} messages.&lt;/p&gt;\n&lt;/script&gt;\n</code></pre>\n\n<p>The Mustache sytax is the <code>{{  }}</code> magic tags above.</p>\n\n<p><strong>JavaScript</strong></p>\n\n<pre><code>var data = new can.Observe({\n    user: 'Tina Fey',\n    messages: 0\n});\n\nvar template = can.view(\"#template\", data)\ncan.$(document.body).append(template);\n</code></pre>\n\n<p><strong>HTML</strong></p>\n\n<pre><code>&lt;h1&gt;Welcome Tina Fey!&lt;/h1&gt;\n&lt;p&gt;You have 0 messages.&lt;/p&gt;\n</code></pre>\n\n<p>To update your template using live-binding:</p>\n\n<pre><code>data.attr('message', 5)\n</code></pre>\n\n<p>which will re-render the paragraph tag to say:</p>\n\n<pre><code>&lt;p&gt;You have 5 messages.&lt;/p&gt;\n</code></pre>\n\n<p>can.Mustache provides a lot more functionality such as:</p>\n\n<ul>\n<li><a href=\"#Basics\">Context and Path Basics</a></li>\n<li><a href=\"#Sections\">Sections</a></li>\n<li><a href=\"#Partials\">Partials</a></li>\n<li><a href=\"#Acquisition\">Acquiring Templates</a></li>\n<li><a href=\"#Helpers\">Helpers</a></li>\n<li><a href=\"#Binding\">Live Binding</a></li>\n</ul>\n\n<h2>Demos</h2>\n\n<ul>\n<li><a href=\"http://addyosmani.github.com/todomvc/architecture-examples/canjs/\">TodoMVC</a> is a project which offers the same Todo application implemented using MV* concepts in most of the popular JavaScript MV* frameworks of today. <a href=\"https://github.com/addyosmani/todomvc/tree/gh-pages/architecture-examples/canjs\">Source Code</a></li>\n</ul>",
        "title": "",
        "parent": "canjs",
        "comment": "undefined@group can.Mustache.pages Pages\n",
        "test": "can/view/mustache/test/qunit.html",
        "plugin": "can/view/mustache",
        "download": "http://canjs.us/release/latest/can.view.mustache.js",
        "src": "can/view/mustache/doc/mustache.md",
        "id": 155
    },
    "can/view/mustache/doc/partials.md": {
        "type": "script",
        "name": "can/view/mustache/doc/partials.md"
    },
    "can.Mustache.Partials": {
        "type": "page",
        "name": "can.Mustache.Partials",
        "body": "<p>Partials are templates embedded in other templates.  Partials begin with a greater than sign, like <code>{{&gt;my_partial}}</code>.  Partials inherit the calling context.  </p>\n\n<p>Partials render at runtime, so recursive partials are possible but make sure you avoid infinite loops.</p>\n\n<p>For example, this template and partial:</p>\n\n<p><strong>base.mustache</strong></p>\n\n<pre><code class=\"lang-javascript\">&lt;h2>Names&lt;/h2>\n{{#names}}\n    {{>user.mustache}}\n{{/names}}</code></pre>\n\n<p><strong>user.mustache</strong></p>\n\n<pre><code class=\"lang-javascript\">&lt;strong>{{name}}&lt;/strong></code></pre>\n\n<p>The resulting expanded template at render time would look like:</p>\n\n<pre><code class=\"lang-javascript\">&lt;h2>Names&lt;/h2>\n{{#names}}\n    &lt;strong>{{name}}&lt;/strong>\n{{/names}}</code></pre>\n\n<h2>Acquiring Partials</h2>\n\n<p><strong>Referencing Files</strong></p>\n\n<p>Partials can reference a file path and file name in the template.</p>\n\n<p>The following template uses a relative path (relative to the current page):</p>\n\n<pre><code class=\"lang-javascript\">&lt;script id=\"template\" type=\"text/mustache\">\n    {{>views/test_template.mustache}}\n&lt;/script></code></pre>\n\n<p>The following template uses an absolute path (rooted to steal's root directory):</p>\n\n<pre><code class=\"lang-javascript\">&lt;script id=\"template\" type=\"text/mustache\">\n    {{>//myapp/accordion/views/test_template.mustache}}\n&lt;/script></code></pre>\n\n<p><strong>Referencing by ID</strong></p>\n\n<p>Partials can reference templates that exist in script tags on the page by \nreferencing the <code>id</code> of the partial in the template.  For example:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script id=\"mytemplate\" type=\"text/mustache\">\n    {{>mypartial}}\n&lt;/script></code></pre>\n\n<pre><code class=\"lang-javascript\">&lt;script id=\"mypartial\" type=\"text/mustache\">\n     I am a partial.\n&lt;/script></code></pre>\n\n<pre><code class=\"lang-javascript\">var template = can.view(\"#mytemplate\", {});</code></pre>\n\n<p><strong>Manually Registering</strong></p>\n\n<p>Partials can be manually registered by calling <code>can.view.registerView</code> \nand passing an identifier and content.  For example:</p>\n\n<pre><code class=\"lang-javascript\">can.view.registerView('myTemplate', \"My body lies over {{.}}\")</code></pre>\n\n<p>in the template, you reference the template by the identifer you registered:</p>\n\n<pre><code class=\"lang-javascript\">{{>myTemplate}}</code></pre>\n\n<p>resulting in the template rendering with the current context applied to the partial.</p>\n\n<h2>Passing Partials in Options</h2>\n\n<p>Partials can resolve the context object that contain partial identifiers in them.\nFor example:</p>\n\n<pre><code class=\"lang-javascript\">var template = can.view(\"#template\", { \n    items: []\n    itemsTemplate: \"test_template.mustache\" \n});\n\ncan.$(document.body).append(template);</code></pre>\n\n<p>then reference the partial in the template just like:</p>\n\n<pre><code class=\"lang-javascript\">&lt;ul>\n{{#items}}\n    &lt;li>{{>itemsTemplate}}&lt;/li>\n{{/items}}\n&lt;/ul></code></pre>",
        "description": "",
        "title": "Partials",
        "parent": "can.Mustache.pages",
        "order": 2,
        "comment": " ",
        "src": "can/view/mustache/doc/partials.md",
        "id": 156
    },
    "can/view/mustache/doc/sections.md": {
        "type": "script",
        "name": "can/view/mustache/doc/sections.md"
    },
    "can.Mustache.Sections": {
        "type": "page",
        "name": "can.Mustache.Sections",
        "body": "",
        "description": "<p>Sections contain text blocks and evaluate whether to render it or not.  If\nthe object evaluates to an array it will iterate over it and render the block\nfor each item in the array.  There are four different types of sections.</p>\n\n<h2>Falseys or Empty Arrays</h2>\n\n<p>If the value returns a <code>false</code>, <code>undefined</code>, <code>null</code>, <code>\"\"</code> or <code>[]</code> we consider\nthat a <em>falsey</em> value.</p>\n\n<p>If the value is falsey, the section will <strong>NOT</strong> render the block.</p>\n\n<pre><code>{ \n    friends: false\n}\n\n{{#friends}}\n    Never shown!\n{{/friends}}\n</code></pre>\n\n<h2>Arrays</h2>\n\n<p>If the value is a non-empty array, sections will iterate over the \narray of items, rendering the items in the block.</p>\n\n<p>For example, a list of friends will iterate\nover each of those items within a section.</p>\n\n<pre><code>{ \n    friends: [ \n        { name: \"Austin\" }, \n        { name: \"Justin\" } \n    ] \n}\n\n&lt;ul&gt;\n    {{#friends}}\n        &lt;li&gt;{{name}}&lt;/li&gt;\n    {{/friends}}\n&lt;/ul&gt;\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;Austin&lt;/li&gt;\n    &lt;li&gt;Justin&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>Reminder: Sections will reset the current context to the value for which its iterating.\nSee the <a href=\"#Basics\">basics of contexts</a> for more information.</p>\n\n<h2>Truthys</h2>\n\n<p>When the value is a non-falsey object but not a list, it is considered truthy and will be used \nas the context for a single rendering of the block.</p>\n\n<pre><code>{\n    friends: { name: \"Jon\" }\n}\n\n{{#friends}}\n    Hi {{name}}\n{{/friends}}\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>Hi Jon!\n</code></pre>\n\n<h2>Inverted</h2>\n\n<p>Inverted sections match falsey values. An inverted section \nsyntax is similar to regular sections except it begins with a caret \nrather than a pound. If the value referenced is falsey, the section will render.</p>\n\n<pre><code>{\n    friends: []\n}\n\n&lt;ul&gt;\n    {{#friends}}\n        &lt;/li&gt;{{name}}&lt;/li&gt;\n    {{/friends}}\n    {{^friends}}\n        &lt;li&gt;No friends.&lt;/li&gt;\n    {{/friends}}\n&lt;/ul&gt;\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;No friends.&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<h2>Comments</h2>\n\n<p>Comments, which do not appear in template output, begin a bang (!).</p>\n\n<pre><code>&lt;h1&gt;My friend is {{!Brian}}&lt;/h1&gt;\n</code></pre>\n\n<p>would render:</p>\n\n<pre><code>&lt;h1&gt;My friend is &lt;/h1&gt;\n</code></pre>",
        "title": "Sections",
        "parent": "can.Mustache.pages",
        "order": 1,
        "src": "can/view/mustache/doc/sections.md",
        "id": 157
    },
    "can/view/mustache/mustache.js": {
        "type": "script",
        "name": "can/view/mustache/mustache.js"
    },
    "isObserve": {
        "name": "isObserve",
        "type": "constructor",
        "body": "",
        "description": "<p>Checks whether an object is a can.Observe.</p>",
        "params": [{
                "types": [{
                        "type": "["
                    }
                ],
                "name": "observable",
                "description": ""
            }
        ],
        "returns": {
            "types": [{
                    "type": "Boolean"
                }
            ],
            "description": "<p>returns if the object is an observable.</p>"
        },
        "src": "can/view/mustache/mustache.js",
        "line": 34,
        "id": 158
    },
    "isArrayLike": {
        "name": "isArrayLike",
        "type": "constructor",
        "body": "",
        "description": "<p>Tries to determine if the object passed is an array.</p>",
        "params": [{
                "types": [{
                        "type": "Array"
                    }
                ],
                "name": "obj",
                "description": "<p>The object to check.</p>"
            }
        ],
        "returns": {
            "types": [{
                    "type": "Boolean"
                }
            ],
            "description": "<p>returns if the object is an array.</p>"
        },
        "src": "can/view/mustache/mustache.js",
        "line": 43,
        "id": 159
    },
    "Mustache": {
        "name": "Mustache",
        "type": "constructor",
        "body": "",
        "description": "<p>The Mustache templating engine.</p>",
        "hide": true,
        "params": [{
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "options",
                "description": "<p>Configuration options</p>"
            }
        ],
        "src": "can/view/mustache/mustache.js",
        "line": 53,
        "id": 160
    },
    "can.Mustache.prototype": {
        "type": "prototype",
        "body": "",
        "description": "",
        "name": "can.Mustache.prototype",
        "parent": "can.Mustache",
        "src": "can/view/mustache/mustache.js",
        "line": 88,
        "id": 161
    },
    "can.Mustache.prototype.render": {
        "type": "function",
        "name": "can.Mustache.prototype.render",
        "parent": "can.Mustache.prototype",
        "body": "<p>Renders an object with view helpers attached to the view.</p>\n\n<pre><code> new Mustache({text: \"&lt;%= message %&gt;\"}).render({\n     message: \"foo\"\n })\n</code></pre>",
        "description": "",
        "title": "render",
        "signatures": [{
                "code": "render(data)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "data",
                        "description": "<p>Data to interpolate into the template.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>The template with interpolated data, in string form.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/view/mustache/mustache.js",
        "line": 92,
        "id": 162
    },
    "can.Mustache.prototype.Mustache.txt": {
        "type": "function",
        "name": "can.Mustache.prototype.Mustache.txt",
        "params": [{
                "types": [{
                        "type": "Object"
                    }, {
                        "type": "Array"
                    }
                ],
                "name": "context",
                "description": "<p>The context stack to be used with evaluation.</p>"
            }, {
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "mode",
                "description": "<p>The mode to evaluate the section with: # for truthy, ^ for falsey</p>"
            }, {
                "types": [{
                        "type": "String"
                    }, {
                        "type": "Object"
                    }
                ],
                "name": "name",
                "description": "<p>The string (or sometimes object) to pass to the given helper method.</p>"
            }
        ],
        "parent": "can.Mustache.prototype",
        "body": "",
        "description": "<p>Evaluates the resulting string based on the context/name.</p>",
        "hide": true,
        "src": "can/view/mustache/mustache.js",
        "line": 603,
        "id": 163
    },
    "can.Mustache.prototype.Mustache.get": {
        "type": "function",
        "name": "can.Mustache.prototype.Mustache.get",
        "params": [{
                "types": [{
                        "type": "String"
                    }
                ],
                "name": "ref",
                "description": "<p>The reference to check for on the obj/context.</p>"
            }, {
                "name": "contexts",
                "types": [{
                        "type": "*"
                    }
                ]
            }, {
                "types": [{
                        "type": "Boolean"
                    }
                ],
                "optional": true,
                "name": "isHelper",
                "description": "<p>Whether the reference is a helper.</p>"
            }, {
                "name": "isArgument",
                "types": [{
                        "type": "*"
                    }
                ]
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "obj",
                "description": "<p>The object to use for checking for a reference.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "context",
                "description": "<p>The context to use for checking for a reference if it doesn't exist in the object.</p>"
            }
        ],
        "parent": "can.Mustache.prototype",
        "body": "",
        "description": "<p>Resolves a reference for a given object (and then a context if that fails).\nobj = this\ncontext = { a: true }\nref = 'a.b.c'\n    => obj.a.b.c || context.a.b.c || ''</p>\n\n<p>This implements the following Mustache specs:\n    Deeply Nested Contexts\nAll elements on the context stack should be accessible.\n    {{#bool}}B {{#bool}}C{{/bool}} D{{/bool}}\n    { bool: true }\n    => \"B C D\"\n    Basic Context Miss Interpolation\n    Failed context lookups should default to empty strings.\n     {{cannot}}\n    => \"\"\n    Dotted Names - Broken Chains\n    Any falsey value prior to the last part of the name should yield ''.\n    {{a.b.c}}\n    { a: { d: 1 } }\n    => \"\"</p>",
        "hide": true,
        "src": "can/view/mustache/mustache.js",
        "line": 727,
        "id": 164
    },
    "can.Mustache.prototype.Mustache.resolve": {
        "type": "function",
        "name": "can.Mustache.prototype.Mustache.resolve",
        "params": [{
                "types": [{
                        "type": "Object"
                    }
                ],
                "name": "value",
                "description": "<p>The object to resolve.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "lastValue",
                "description": "<p>Only used with Mustache.get.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "name",
                "description": "<p>Only used with Mustache.get.</p>"
            }, {
                "types": [{
                        "type": "Boolean"
                    }
                ],
                "optional": true,
                "name": "isArgument",
                "description": "<p>Only used with Mustache.get.</p>"
            }
        ],
        "parent": "can.Mustache.prototype",
        "body": "",
        "description": "<p>Resolves an object to its truthy equivalent.</p>",
        "hide": true,
        "returns": {
            "types": [{
                    "type": "Object"
                }
            ],
            "description": "<p>The resolved object.</p>"
        },
        "src": "can/view/mustache/mustache.js",
        "line": 855,
        "id": 165
    },
    "can.Mustache.static": {
        "type": "static",
        "body": "",
        "description": "",
        "name": "can.Mustache.static",
        "parent": "can.Mustache",
        "src": "can/view/mustache/mustache.js",
        "line": 896,
        "id": 166
    },
    "can.Mustache.registerHelper": {
        "type": "function",
        "name": "can.Mustache.registerHelper",
        "parent": "can.Mustache.static",
        "body": "<p>Registers a helper with the Mustache system.\nPass the name of the helper followed by the\nfunction to which Mustache should invoke.\nThese are run at runtime.</p>",
        "description": "<p>Register a helper. </p>",
        "title": "registerHelper",
        "signatures": [{
                "code": "Mustache.registerHelper(name, helper)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "name",
                        "description": "<p>The name of the helper.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "helper",
                        "description": "<p>The helper function.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/view/mustache/mustache.js",
        "line": 920,
        "id": 167
    },
    "can.Mustache.getHelper": {
        "type": "function",
        "name": "can.Mustache.getHelper",
        "parent": "can.Mustache.static",
        "body": "<p>Returns a helper given the name.</p>",
        "description": "<p>Retrieve a helper. </p>",
        "title": "getHelper",
        "signatures": [{
                "code": "Mustache.getHelper(name)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "name",
                        "description": "<p>The name of the helper.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "function",
                            "returns": {
                                "types": [{
                                        "type": "undefined"
                                    }
                                ]
                            },
                            "params": []
                        }, {
                            "type": "null"
                        }
                    ],
                    "description": "<p>The helper, or <code>null</code> if\nno helper by that name is found.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/view/mustache/mustache.js",
        "line": 937,
        "id": 168
    },
    "can.Mustache.static.render": {
        "type": "function",
        "name": "can.Mustache.static.render",
        "parent": "can.Mustache.static",
        "body": "<p><code>Mustache.render</code> is a helper method that calls\ninto <code>can.view.render</code> passing the partial \nand the context object.  </p>\n\n<p>Its purpose is to determine if the partial object \nbeing passed represents a template like:</p>\n\n<pre><code>    partial === \"movember.mustache\"\n</code></pre>\n\n<p>or if the partial is a variable name that represents\na partial on the context object such as:</p>\n\n<pre><code>    context[partial] === \"movember.mustache\"\n</code></pre>",
        "description": "",
        "title": "render",
        "signatures": [{
                "code": "Mustache.render(partial, context)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "partial",
                        "description": ""
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "context",
                        "description": ""
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/view/mustache/mustache.js",
        "line": 961,
        "id": 169
    },
    "if": {
        "type": "function",
        "name": "if",
        "params": [{
                "name": "expr",
                "types": [{
                        "type": "*"
                    }
                ]
            }, {
                "name": "options",
                "types": [{
                        "type": "*"
                    }
                ]
            }
        ],
        "parent": "can.Mustache.Helpers",
        "body": "",
        "description": "<p>Explicit if conditions.</p>\n\n<pre><code>    {{#if expr}}\n      // if\n {{else}}\n     // else\n {{/if}}\n</code></pre>",
        "title": "",
        "src": "can/view/mustache/mustache.js",
        "line": 1003,
        "id": 170
    },
    "unless": {
        "type": "function",
        "name": "unless",
        "params": [{
                "name": "expr",
                "types": [{
                        "type": "*"
                    }
                ]
            }, {
                "name": "options",
                "types": [{
                        "type": "*"
                    }
                ]
            }
        ],
        "parent": "can.Mustache.Helpers",
        "body": "",
        "description": "<p>The <code>unless</code> helper evaluates the inverse of the value\nof the key and renders the block between the helper and the slash.</p>\n\n<pre><code>    {{#unless expr}}\n      // unless\n {{/unless}}\n</code></pre>",
        "title": "",
        "src": "can/view/mustache/mustache.js",
        "line": 1024,
        "id": 171
    },
    "each": {
        "type": "function",
        "name": "each",
        "params": [{
                "name": "expr",
                "types": [{
                        "type": "*"
                    }
                ]
            }, {
                "name": "options",
                "types": [{
                        "type": "*"
                    }
                ]
            }
        ],
        "parent": "can.Mustache.Helpers",
        "body": "",
        "description": "<p>You can use the <code>each</code> helper to itterate over a array \nof items and render the block between the helper and the slash.</p>\n\n<pre><code>    {{#each arr}}\n      // each\n {{/each}}\n</code></pre>",
        "title": "",
        "src": "can/view/mustache/mustache.js",
        "line": 1042,
        "id": 172
    },
    "with": {
        "type": "function",
        "name": "with",
        "params": [{
                "name": "expr",
                "types": [{
                        "type": "*"
                    }
                ]
            }, {
                "name": "options",
                "types": [{
                        "type": "*"
                    }
                ]
            }
        ],
        "parent": "can.Mustache.Helpers",
        "body": "",
        "description": "<p>Mustache typically applies the context passed in the section \nat compiled time.  However, if you want to override this \ncontext you can use the <code>with</code> helper.</p>\n\n<pre><code>    {{#with arr}}\n      // with\n {{/with}}\n</code></pre>",
        "title": "",
        "src": "can/view/mustache/mustache.js",
        "line": 1071,
        "id": 173
    },
    "can/view/modifiers/modifiers.md": {
        "type": "script",
        "name": "can/view/modifiers/modifiers.md"
    },
    "can.view.modifiers": {
        "type": "page",
        "name": "can.view.modifiers",
        "body": "",
        "description": "<p>The can/view/modifiers plugin extends the jQuery view modifiers</p>\n\n<ul>\n<li>[can.prototype.jQuery.fn.after .after()]</li>\n<li>[can.prototype.jQuery.fn.append .append()]</li>\n<li>[can.prototype.jQuery.fn.before .before()]</li>\n<li>[can.prototype.jQuery.fn.html .html()]</li>\n<li>[can.prototype.jQuery.fn.prepend .prepend()]</li>\n<li>[can.prototype.jQuery.fn.replaceWith .replaceWith()]</li>\n<li>[can.prototype.jQuery.fn.text .text()]</li>\n</ul>\n\n<p>to render a [can.view]. When rendering a view you call the view modifier the same way\nas can.view with the view name or id as the first, the data as the second and the optional\nsuccess callback (to load the view asynchronously) as the third parameter.\nFor example, you can render a template from <em>todo/todos.ejs</em> looking like this:</p>\n\n<pre><code>&lt;% for(var i = 0; i &lt; this.length; i++ ){ %&gt;\n  &lt;li&gt;&lt;%= this[i].name %&gt;&lt;/li&gt;\n&lt;% } %&gt;\n</code></pre>\n\n<p>By calling the [can.prototype.jQuery.fn.html html] modifier on the <code>#todos</code> element like this:</p>\n\n<pre><code>can.$('#todos').html('todo/todos.ejs', [\n    { name : 'First Todo' },\n    { name : 'Second Todo' }\n]);\n</code></pre>\n\n<p><strong>Note:</strong> You always have to provide the data (second) argument to render a view, otherwise the standard jQuery\nmodifier will be used. If you have no data to render pass an empty object:</p>\n\n<pre><code>$('#todos').html('todo/todos.ejs', {});\n// Render todo/todos.ejs wit no data\n</code></pre>\n\n<h2>Deferreds</h2>\n\n<p>Additionally it is also possible to pass a [can.Deferred] as a single parameter to any view modifier. Once\nthe deferred resolves the result will be rendered using that modifier. This can be used to easily request\nand render static content. The following example inserts the content of <em>content/info.html</em> after the <code>#todos</code> element:</p>\n\n<pre><code>can.$('#todos').after(can.ajax({\n    url : 'content/info.html'\n}));\n</code></pre>",
        "title": "jQuery modifiers",
        "parent": "can.view.plugins",
        "plugin": "can/view/modifiers",
        "test": "can/view/modifiers/qunit.html",
        "src": "can/view/modifiers/modifiers.md",
        "id": 174
    },
    "can/view/modifiers/modifiers.js": {
        "type": "script",
        "name": "can/view/modifiers/modifiers.js"
    },
    "jQuery.fn.hookup": {
        "type": "function",
        "name": "jQuery.fn.hookup",
        "params": [],
        "parent": "can.view.modifiers",
        "body": "",
        "description": "<p>Called on a jQuery collection that was rendered with can.View with pending hookups.  can.View can render a \n template with hookups, but not actually perform the hookup, because it returns a string without actual DOM \n elements to hook up to.  So hookup performs the hookup and clears the pending hookups, preventing errors in \n future templates.</p>\n\n<pre><code class=\"lang-javascript\">$(can.View('//views/recipes.ejs',recipeData)).hookup()</code></pre> ",
        "title": "",
        "src": "can/view/modifiers/modifiers.js",
        "line": 125,
        "id": 175
    },
    "jQuery.fn.prepend": {
        "type": "function",
        "body": "",
        "description": "<p>Extending the original [http://api.jquery.com/prepend/ jQuery().prepend()]\nto render [can.view] templates inserted at the beginning of each element in the set of matched elements.</p>\n\n<pre><code>$('#test').prepend('path/to/template.ejs', { name : 'canjs' });\n</code></pre>",
        "title": "",
        "name": "jQuery.fn.prepend",
        "parent": "can.view.modifiers",
        "params": [{
                "types": [{
                        "type": "String"
                    }, {
                        "type": "Object"
                    }, {
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "name": "content",
                "description": "<p>A template filename or the id of a view script tag \nor a DOM element, array of elements, HTML string, or can object.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "data",
                "description": "<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "optional": true,
                "name": "callback",
                "description": "<p>A success callback to load the view asynchronously</p>"
            }
        ],
        "returns": {
            "types": [{
                    "type": "jQuery"
                }, {
                    "type": "can.Deferred"
                }
            ],
            "description": "<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"
        },
        "src": "can/view/modifiers/modifiers.js",
        "line": 143,
        "id": 176
    },
    "jQuery.fn.append": {
        "type": "function",
        "body": "",
        "description": "<p>Extending the original [http://api.jquery.com/append/ jQuery().append()]\nto render [can.view] templates inserted at the end of each element in the set of matched elements.</p>\n\n<pre><code>$('#test').append('path/to/template.ejs', { name : 'canjs' });\n</code></pre>",
        "title": "",
        "name": "jQuery.fn.append",
        "parent": "can.view.modifiers",
        "params": [{
                "types": [{
                        "type": "String"
                    }, {
                        "type": "Object"
                    }, {
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "name": "content",
                "description": "<p>A template filename or the id of a view script tag \nor a DOM element, array of elements, HTML string, or can object.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "data",
                "description": "<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "optional": true,
                "name": "callback",
                "description": "<p>A success callback to load the view asynchronously</p>"
            }
        ],
        "returns": {
            "types": [{
                    "type": "jQuery"
                }, {
                    "type": "can.Deferred"
                }
            ],
            "description": "<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"
        },
        "src": "can/view/modifiers/modifiers.js",
        "line": 163,
        "id": 177
    },
    "jQuery.fn.after": {
        "type": "function",
        "body": "",
        "description": "<p>Extending the original [http://api.jquery.com/after/ jQuery().after()]\nto render [can.view] templates inserted after each element in the set of matched elements.</p>\n\n<pre><code>$('#test').after('path/to/template.ejs', { name : 'canjs' });\n</code></pre>",
        "title": "",
        "name": "jQuery.fn.after",
        "parent": "can.view.modifiers",
        "params": [{
                "types": [{
                        "type": "String"
                    }, {
                        "type": "Object"
                    }, {
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "name": "content",
                "description": "<p>A template filename or the id of a view script tag \nor a DOM element, array of elements, HTML string, or can object.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "data",
                "description": "<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "optional": true,
                "name": "callback",
                "description": "<p>A success callback to load the view asynchronously</p>"
            }
        ],
        "returns": {
            "types": [{
                    "type": "jQuery"
                }, {
                    "type": "can.Deferred"
                }
            ],
            "description": "<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"
        },
        "src": "can/view/modifiers/modifiers.js",
        "line": 183,
        "id": 178
    },
    "jQuery.fn.before": {
        "type": "function",
        "body": "",
        "description": "<p>Extending the original [http://api.jquery.com/before/ jQuery().before()]\nto render [can.view] templates inserted before each element in the set of matched elements.</p>\n\n<pre><code>$('#test').before('path/to/template.ejs', { name : 'canjs' });\n</code></pre>",
        "title": "",
        "name": "jQuery.fn.before",
        "parent": "can.view.modifiers",
        "params": [{
                "types": [{
                        "type": "String"
                    }, {
                        "type": "Object"
                    }, {
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "name": "content",
                "description": "<p>A template filename or the id of a view script tag \nor a DOM element, array of elements, HTML string, or can object.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "data",
                "description": "<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "optional": true,
                "name": "callback",
                "description": "<p>A success callback to load the view asynchronously</p>"
            }
        ],
        "returns": {
            "types": [{
                    "type": "jQuery"
                }, {
                    "type": "can.Deferred"
                }
            ],
            "description": "<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"
        },
        "src": "can/view/modifiers/modifiers.js",
        "line": 203,
        "id": 179
    },
    "jQuery.fn.text": {
        "type": "function",
        "body": "",
        "description": "<p>Extending the original [http://api.jquery.com/text/ jQuery().text()]\nto render [can.View] templates as the content of each matched element.\nUnlike [jQuery.fn.html] jQuery.fn.text also works with XML, escaping the provided\nstring as necessary.</p>\n\n<pre><code>$('#test').text('path/to/template.ejs', { name : 'canjs' });\n</code></pre>",
        "title": "",
        "name": "jQuery.fn.text",
        "parent": "can.view.modifiers",
        "params": [{
                "types": [{
                        "type": "String"
                    }, {
                        "type": "Object"
                    }, {
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "name": "content",
                "description": "<p>A template filename or the id of a view script tag \nor a DOM element, array of elements, HTML string, or can object.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "data",
                "description": "<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "optional": true,
                "name": "callback",
                "description": "<p>A success callback to load the view asynchronously</p>"
            }
        ],
        "returns": {
            "types": [{
                    "type": "jQuery"
                }, {
                    "type": "can.Deferred"
                }
            ],
            "description": "<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"
        },
        "src": "can/view/modifiers/modifiers.js",
        "line": 223,
        "id": 180
    },
    "jQuery.fn.html": {
        "type": "function",
        "body": "",
        "description": "<p>Extending the original [http://api.jquery.com/html/ jQuery().html()]\nto render [can.view] templates as the content of each matched element.</p>\n\n<pre><code>$('#test').html('path/to/template.ejs', { name : 'canjs' });\n</code></pre>",
        "title": "",
        "name": "jQuery.fn.html",
        "parent": "can.view.modifiers",
        "params": [{
                "types": [{
                        "type": "String"
                    }, {
                        "type": "Object"
                    }, {
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "name": "content",
                "description": "<p>A template filename or the id of a view script tag \nor a DOM element, array of elements, HTML string, or can object.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "data",
                "description": "<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "optional": true,
                "name": "callback",
                "description": "<p>A success callback to load the view asynchronously</p>"
            }
        ],
        "returns": {
            "types": [{
                    "type": "jQuery"
                }, {
                    "type": "can.Deferred"
                }
            ],
            "description": "<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"
        },
        "src": "can/view/modifiers/modifiers.js",
        "line": 245,
        "id": 181
    },
    "jQuery.fn.replaceWith": {
        "type": "function",
        "body": "",
        "description": "<p>Extending the original [http://api.jquery.com/replaceWith/ jQuery().replaceWith()]\nto render [can.view] templates replacing each element in the set of matched elements.</p>\n\n<pre><code>$('#test').replaceWith('path/to/template.ejs', { name : 'canjs' });\n</code></pre>",
        "title": "",
        "name": "jQuery.fn.replaceWith",
        "parent": "can.view.modifiers",
        "params": [{
                "types": [{
                        "type": "String"
                    }, {
                        "type": "Object"
                    }, {
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "name": "content",
                "description": "<p>A template filename or the id of a view script tag \nor a DOM element, array of elements, HTML string, or can object.</p>"
            }, {
                "types": [{
                        "type": "Object"
                    }
                ],
                "optional": true,
                "name": "data",
                "description": "<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"
            }, {
                "types": [{
                        "type": "function",
                        "returns": {
                            "types": [{
                                    "type": "undefined"
                                }
                            ]
                        },
                        "params": []
                    }
                ],
                "optional": true,
                "name": "callback",
                "description": "<p>A success callback to load the view asynchronously</p>"
            }
        ],
        "returns": {
            "types": [{
                    "type": "jQuery"
                }, {
                    "type": "can.Deferred"
                }
            ],
            "description": "<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"
        },
        "src": "can/view/modifiers/modifiers.js",
        "line": 265,
        "id": 182
    },
    "can/util/util.md": {
        "type": "script",
        "name": "can/util/util.md"
    },
    "can.util": {
        "type": "page",
        "name": "can.util",
        "body": "",
        "description": "<p>Utility methods supported by CanJS</p>",
        "title": "can.util",
        "parent": "canjs",
        "comment": "undefined@group can.util.functions functions\n",
        "src": "can/util/util.md",
        "id": 183
    },
    "can/util/util.js": {
        "type": "script",
        "name": "can/util/util.js"
    },
    "can.isDeferred": {
        "body": "<p><code>can.isDeferred</code> returns if an object is an instance of [can.Deferred].</p>\n\n<h2>Example</h2>\n\n<p>Convert any value to a Deferred:</p>\n\n<pre><code class=\"lang-javascript\">function convertDeferred(dfd) {\n    return can.isDeferred(dfd) ? dfd : can.Deferred(dfd);\n}</code></pre>",
        "description": "<p>Check if an object is a Deferred. </p>",
        "title": "",
        "name": "can.isDeferred",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.isDeferred(subject)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "subject",
                        "description": "<p>The object to check.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Boolean"
                        }
                    ],
                    "description": "<p>Whether <strong>subject</strong> is a Deferred.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 0,
        "id": 184
    },
    "can.trim": {
        "body": "<p><code>can.trim(str)</code> removes leading and trailing whitespace from a string.  It will also\nremove all newlines, spaces including non-breaking, and tabs.  If these occur in the middle\nof the string, then they will be persisted.</p>\n\n<pre><code class=\"lang-javascript\">can.trim(\" foo \") // \"foo\"</code></pre>",
        "description": "<p>Trim whitespace off a string. </p>",
        "title": "",
        "name": "can.trim",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.trim(str)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "str",
                        "description": "<p>The string to trim.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>The trimmed string.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 21,
        "id": 185
    },
    "can.makeArray": {
        "body": "<p><code>can.makeArray(arrLike)</code> converts an array-like object into a array.</p>\n\n<pre><code class=\"lang-javascript\">can.makeArray({0 : \"zero\", 1: \"one\", length: 2}); // [\"zero\",\"one\"]</code></pre>",
        "description": "<p>Convert an array-like object to an Array. </p>",
        "title": "",
        "name": "can.makeArray",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.makeArray(arrLike)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "arrLike",
                        "description": "<p>An array-like object.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Array"
                        }
                    ],
                    "description": "<p>The converted object.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 39,
        "id": 186
    },
    "can.isArray": {
        "body": "<p><code>can.isArray(object)</code> returns if the object is an Array.</p>\n\n<pre><code class=\"lang-javascript\">can.isArray([]);    // true\ncan.isArray(false); // false</code></pre>",
        "description": "<p>Check if an object is an array. </p>",
        "title": "",
        "name": "can.isArray",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.isArray(obj)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "obj",
                        "description": "<p>The object to check.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Boolean"
                        }
                    ],
                    "description": "<p>Whether <strong>obj</strong> is an Array.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 55,
        "id": 187
    },
    "can.each": {
        "body": "<p><code>can.each(collection, callback)</code> iterates through an array or object like\nlike [http://api.jquery.com/jQuery.each/ jQuery.each].</p>\n\n<pre><code class=\"lang-javascript\">can.each([{prop: \"val1\"}, {prop: \"val2\"}],\n function( value, index ) {\n   // function called with\n   // index=0 value={prop: \"val1\"}\n   // index=1 value={prop: \"val2\"}\n }\n);</code></pre>",
        "description": "<p>Iterate through an array or object. </p>",
        "title": "",
        "name": "can.each",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.each(collection, callback)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "collection",
                        "description": "<p>The object to iterate through.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "callback",
                        "description": "<p>A function to call for each item in <strong>collection</strong>.\n<strong>callback</strong> will recieve the item's value first and its key second.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 72,
        "id": 188
    },
    "can.extend": {
        "body": "<p><code>can.extend(target, objectN)</code> merges the contents of two or more objects together into the first object\nsimilarly to [http://api.jquery.com/jQuery.extend/ jQuery.extend].</p>\n\n<pre><code class=\"lang-javascript\">var first = {},\nsecond = {a: \"b\"},\nthird = {c: \"d\"};\n\ncan.extend(first, second, third); //-> first\n\nfirst  //-> {a: \"b\", c: \"d\"}\nsecond //-> {a: \"b\"}\nthird  //-> {c: \"d\"}</code></pre>",
        "description": "<p>Merge objects together. </p>",
        "title": "",
        "name": "can.extend",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.extend(target, ...obj)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "target",
                        "description": "<p>The object to merge properties into.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "obj",
                        "description": "<p>Objects containing properties to merge.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Object"
                        }
                    ],
                    "description": "<p><strong>target</strong>, post-merge.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 96,
        "id": 189
    },
    "can.param": {
        "body": "<p>Parameterizes an object into a query string\nlike [http://api.jquery.com/jQuery.param/ jQuery.param].</p>\n\n<pre><code class=\"lang-javascript\">can.param({a: \"b\", c: \"d\"}) //-> \"a=b&c=d\"</code></pre>",
        "description": "<p>Serialize an object into a query string. </p>",
        "title": "",
        "name": "can.param",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.param(obj)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "obj",
                        "description": "<p>An array or object to serialize.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "description": "<p>The serialized string.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 122,
        "id": 190
    },
    "can.isEmptyObject": {
        "body": "<p><code>can.isEmptyObject(obj)</code> returns if an object has no properties similar to\n[http://api.jquery.com/jQuery.isEmptyObject/ jQuery.isEmptyObject].</p>\n\n<pre><code class=\"lang-javascript\">can.isEmptyObject({})      //-> true\ncan.isEmptyObject({a:\"b\"}) //-> false</code></pre>",
        "description": "<p>Check if an object has no properties. </p>",
        "title": "",
        "name": "can.isEmptyObject",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.isEmptyObject(obj)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "obj",
                        "description": "<p>The object to check.</p>"
                    }, {
                        "types": [{
                                "type": "Boolean"
                            }
                        ],
                        "name": "Whether",
                        "description": "<p>the object is empty.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 139,
        "id": 191
    },
    "can.proxy": {
        "body": "<p><code>can.proxy(fn, context)</code> accepts a function and returns a\nnew one that will always have the context from which it was\ncalled.  This works similar to [http://api.jquery.com/jQuery.proxy/ jQuery.proxy].</p>\n\n<pre><code class=\"lang-javascript\">var func = can.proxy(function(one){\n      return this.a + one\n    }, {a: \"b\"});\nfunc(\"two\") //-> \"btwo\"</code></pre>",
        "description": "<p>Bind a function to its context. </p>",
        "title": "",
        "name": "can.proxy",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.proxy(fn, context)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "fn",
                        "description": "<p>The function to bind to a context.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "context",
                        "description": "<p>The context to bind the function to.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "function",
                            "returns": {
                                "types": [{
                                        "type": "undefined"
                                    }
                                ]
                            },
                            "params": []
                        }
                    ],
                    "description": "<p>A function that calls <strong>fn</strong> in the context of <strong>context</strong>.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 157,
        "id": 192
    },
    "can.isFunction": {
        "body": "<p><code>can.isFunction(object)</code> returns if an object is a function similar to\n[http://api.jquery.com/jQuery.isFunction/ jQuery.isFunction].</p>\n\n<pre><code class=\"lang-javascript\">can.isFunction({})           //-> false\ncan.isFunction(function(){}) //-> true</code></pre>",
        "description": "<p>Check if an Object is a function. </p>",
        "title": "",
        "name": "can.isFunction",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.isFunction(obj)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "obj",
                        "description": "<p>The object to check.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Boolean"
                        }
                    ],
                    "description": "<p>Whether <strong>obj</strong> is a function.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 179,
        "id": 193
    },
    "can.bind": {
        "body": "<p><code>can.bind(eventName, handler)</code> binds a callback handler\non an object for a given event.  It works on:</p>\n\n<ul>\n<li>HTML elements and the window</li>\n<li>Objects</li>\n<li>Objects with bind / unbind methods</li>\n</ul>\n\n<p>The idea is that bind can be used on anything that produces events\nand it will figure out the appropriate way to\nbind to it.  Typically, <code>can.bind</code> is only used internally to\nCanJS; however, if you are making libraries or extensions, use\n<code>can.bind</code> to listen to events independent of the underlying library.</p>\n\n<p><strong>Binding to an object</strong></p>\n\n<pre><code class=\"lang-javascript\">var obj = {};\ncan.bind.call(obj,\"something\", function(ev, arg1, arg){\n     arg1 // 1\n     arg2 // 2\n   })\ncan.trigger(obj,\"something\",[1,2])</code></pre>\n\n<p><strong>Binding to an HTMLElement</strong></p>\n\n<pre><code class=\"lang-javascript\">var el = document.getElementById('foo')\ncan.bind.call(el, \"click\", function(ev){\n   this // el\n });</code></pre>",
        "description": "<p>Listen for events on an object. </p>",
        "title": "",
        "name": "can.bind",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.bind.call(target, eventName, handler)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "target",
                        "description": "<p>The object that emits events.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventName",
                        "description": "<p>The name of the event to listen for.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "handler",
                        "description": "<p>The function to execute when the event occurs.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Object"
                        }
                    ],
                    "description": "<p>The <strong>target</strong>.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 197,
        "id": 194
    },
    "can.unbind": {
        "body": "<p><code>can.unbind(eventName, handler)</code> unbinds a callback handler\nfrom an object for a given event.  It works on:</p>\n\n<ul>\n<li>HTML elements and the window</li>\n<li>Objects</li>\n<li>Objects with bind / unbind methods</li>\n</ul>\n\n<p>The idea is that unbind can be used on anything that produces events\nand it will figure out the appropriate way to\nunbind to it.  Typically, <code>can.unbind</code> is only used internally to\nCanJS; however, if you are making libraries or extensions, use\n<code>can.bind</code> to listen to events independent of the underlying library.</p>\n\n<p><strong>Binding/unbinding to an object</strong></p>\n\n<pre><code class=\"lang-javascript\">var obj = {},\nhandler = function(ev, arg1, arg){\n       arg1 // 1\n       arg2 // 2\n     };\ncan.bind.call(obj,\"something\", handler)\ncan.trigger(obj,\"something\",[1,2])\ncan.unbind.call(obj,\"something\", handler)</code></pre>\n\n<p><strong>Binding/unbinding to an HTMLElement</strong></p>\n\n<pre><code class=\"lang-javascript\">var el = document.getElementById('foo'),\nhandler = function(ev){\n       this // el\n     };\ncan.bind.call(el, \"click\", handler)\ncan.unbind.call(el, \"click\", handler)</code></pre>",
        "description": "<p>Stop listening for events on an object. </p>",
        "title": "",
        "name": "can.unbind",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.unbind.call(target, eventName, handler)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "target",
                        "description": "<p>The object that emits events.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventName",
                        "description": "<p>The name of the event to listen for.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "handler",
                        "description": "<p>The function to unbind.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Object"
                        }
                    ],
                    "description": "<p>The <strong>target</strong>.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 243,
        "id": 195
    },
    "can.delegate": {
        "body": "<p><code>can.delegate(selector, eventName, handler)</code> binds a delegate handler\non an object for a given event.  It works on:</p>\n\n<ul>\n<li>HTML elements and the window</li>\n</ul>\n\n<p>The idea is that delegate can be used on anything that produces delegate events\nand it will figure out the appropriate way to\nbind to it.  Typically, <code>can.delegate</code> is only used internally to\nCanJS; however, if you are making libraries or extensions, use\n<code>can.delegate</code> to listen to events independent of the underlying library.</p>\n\n<p><strong>Delegate binding to an HTMLElement</strong></p>\n\n<pre><code class=\"lang-javascript\">var el = document.getElementById('foo')\ncan.delegate.call(el, \".selector\", \"click\", function(ev){\n   this // el\n})</code></pre>",
        "description": "<p>Listen for events from the children of an element. </p>",
        "title": "",
        "name": "can.delegate",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.delegate.call(element, selector, eventName, handler)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "HTMLElement"
                            }
                        ],
                        "name": "element",
                        "description": "<p>The HTML element to bind to.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "selector",
                        "description": "<p>A selector for delegating downward.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventName",
                        "description": "<p>The name of the event to listen for.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "handler",
                        "description": "<p>The function to execute when the event occurs.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Object"
                        }
                    ],
                    "description": "<p>The <strong>element</strong>.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 292,
        "id": 196
    },
    "can.undelegate": {
        "body": "",
        "description": "<p>Stop listening for events from the children of an element. </p>",
        "title": "",
        "name": "can.undelegate",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.undelegate.call(element, selector, eventName, handler)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "HTMLElement"
                            }
                        ],
                        "name": "element",
                        "description": "<p>The HTML element to unbind from.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "selector",
                        "description": "<p>A selector for delegating downward.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventName",
                        "description": "<p>The name of the event to listen for.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "handler",
                        "description": "<p>The function that was bound.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Object"
                        }
                    ],
                    "description": "<p>The <strong>element</strong>.</p>\n\n<p><code>can.undelegate(selector, eventName, handler)</code> unbinds a delegate handler\non an object for a given event.  It works on:</p>\n\n<ul>\n<li>HTML elements and the window</li>\n</ul>\n\n<p>The idea is that undelegate can be used on anything that produces delegate events\nand it will figure out the appropriate way to\nbind to it.  Typically, <code>can.undelegate</code> is only used internally to\nCanJS; however, if you are making libraries or extensions, use\n<code>can.undelegate</code> to listen to events independent of the underlying library.</p>\n\n<p><strong>Delegate/undelegate binding to an HTMLElement</strong></p>\n\n<pre><code class=\"lang-javascript\">var el = document.getElementById('foo'),\nhandler = function(ev){\n  this // el\n};\ncan.delegate.call(el, \".selector\", \"click\", handler)\ncan.undelegate.call(el, \".selector\", \"click\", handler)</code></pre>"
                }
            }
        ],
        "src": "can/util/util.js",
        "line": 325,
        "id": 197
    },
    "can.trigger": {
        "body": "",
        "description": "<p>Trigger an event. </p>",
        "title": "",
        "name": "can.trigger",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.trigger(target, eventName[, args])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "target",
                        "description": "<p>The object to trigger the event on.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "eventName",
                        "description": "<p>The event to trigger.</p>"
                    }, {
                        "types": [{
                                "type": "Array",
                                "template": [{
                                        "types": [{
                                                "type": "*"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "optional": true,
                        "name": "args",
                        "description": "<p>The event data.</p>\n\n<p>Trigger an event on an element or object.</p>"
                    }
                ]
            }
        ],
        "src": "can/util/util.js",
        "line": 359,
        "id": 198
    },
    "can.ajax": {
        "body": "<p><code>can.ajax( settings )</code> is used to make an asynchronous HTTP (Ajax) request\nsimilar to [http://api.jquery.com/jQuery.ajax/ jQuery.ajax].</p>\n\n<pre><code class=\"lang-javascript\">can.ajax({\n  url: 'ajax/farm/animals',\n    success: function(animals) {\n        can.$('.farm').html(animals);\n    }\n});</code></pre>",
        "description": "<p>Make an AJAX request. </p>",
        "title": "",
        "name": "can.ajax",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.ajax(settings)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "settings",
                        "description": "<p>Configuration options for the AJAX request.\nThe list of configuration options is the same as for <a href=\"http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings\">jQuery.ajax()</a>.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Deferred"
                        }
                    ],
                    "description": "<p>A can.Deferred that resolves to the data.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 371,
        "id": 199
    },
    "can.$": {
        "body": "<p><code>can.$(element)</code> returns the the underlying\nlibrary's NodeList.  It can be passed\na css selector, a HTMLElement or an array of HTMLElements.</p>\n\n<p>The following lists how the NodeList is created by each library:</p>\n\n<ul>\n<li><strong>jQuery</strong> <code>jQuery( HTMLElement )</code></li>\n<li><strong>Zepto</strong> <code>Zepto( HTMLElement )</code></li>\n<li><strong>Dojo</strong> <code>new dojo.NodeList( HTMLElement )</code></li>\n<li><strong>Mootools</strong> <code>$$( HTMLElement )</code></li>\n<li><strong>YUI</strong> <code>Y.all(selector)</code> or <code>Y.NodeList</code></li>\n</ul>",
        "description": "<p>Make a library's nodelist. </p>",
        "title": "",
        "name": "can.$",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.$(element)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }, {
                                "type": "Element"
                            }, {
                                "type": "NodeList"
                            }
                        ],
                        "name": "element",
                        "description": "<p>The selector, HTML element, or nodelist\nto pass to the underlying library.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "NodeList"
                        }
                    ],
                    "description": "<p>The nodelist as constructed by the underlying library.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 394,
        "id": 200
    },
    "can.buildFragment": {
        "body": "<p><code>can.buildFragment(html, node)</code> returns a document fragment for the HTML passed.</p>",
        "description": "<p>Make a document fragment. </p>",
        "title": "",
        "name": "can.buildFragment",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.buildFragment(html, node)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "html",
                        "description": "<p>A string of HTML.</p>"
                    }, {
                        "types": [{
                                "type": "DOM"
                            }, {
                                "type": "Node"
                            }
                        ],
                        "name": "node",
                        "description": "<p>A node used to access a document to make the fragment with.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "DocumentFragment"
                        }
                    ],
                    "description": "<p>A document fragment made from <strong>html</strong>.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 417,
        "id": 201
    },
    "can.append": {
        "body": "<p><code>can.append( wrappedNodeList, html )</code> inserts content to the end of each wrapped node list item(s) passed.</p>\n\n<pre><code class=\"lang-javascript\">// Before\n<div id=\"demo\" />\n\ncan.append( can.$('#demo'), 'Demos are fun!' );\n\n// After\n<div id=\"demo\">Demos are fun!</div></code></pre>",
        "description": "<p>Append content to elements. </p>",
        "title": "",
        "name": "can.append",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.append(nodeList, html)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "NodeList"
                            }
                        ],
                        "name": "nodeList",
                        "description": "<p>A nodelist of the elements to append content to.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "html",
                        "description": "<p>The HTML to append to the end of the elements in <strong>nodeList</strong>.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 430,
        "id": 202
    },
    "can.remove": {
        "body": "<p><code>can.remove( wrappedNodeList )</code> removes the set of matched element(s) from the DOM.</p>\n\n<pre><code class=\"lang-javascript\"><div id=\"wrap\"/>\ncan.remove(can.$('#wrap')) //-> removes 'wrap'</code></pre>",
        "description": "<p>Remove elements from the DOM. </p>",
        "title": "",
        "name": "can.remove",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.remode(nodeList)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "NodeList"
                            }
                        ],
                        "name": "nodeList",
                        "description": "<p>A nodelist of elements to remove.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 452,
        "id": 203
    },
    "can.data": {
        "body": "<p><code>can.data</code> enables the associatation of arbitrary data with DOM nodes and JavaScript objects.</p>\n\n<h3>Setting Data</h3>\n\n<p>can.data( can.$('#elm'), key, value )</p>\n\n<ul>\n<li><strong>wrappedNodeList</strong> node list to associate data to.</li>\n<li><strong>key</strong> string name of the association.</li>\n<li><strong>value</strong> tdata value; it can be any Javascript type including Array or Object.</li>\n</ul>\n\n<h3>Accessing Data</h3>\n\n<p>can.data( can.$('#elm'), key )</p>\n\n<ul>\n<li><strong>wrappedNodeList</strong> node list to retrieve association data from.</li>\n<li><strong>key</strong> string name of the association.</li>\n</ul>\n\n<p>Due to the way browsers security restrictions with plugins and external code,\nthe <em>data</em> method cannot be used on <code>object</code> (unless it's a Flash plugin), <code>applet</code> or <code>embed</code> elements.</p>",
        "description": "<p>Associate data with or retrieve data from DOM nodes. </p>",
        "title": "",
        "name": "can.data",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.data(nodeList, key, value)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "NodeList"
                            }
                        ],
                        "name": "nodeList",
                        "description": "<p>The list of nodes to add this data to.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "key",
                        "description": "<p>The key to store this data under.</p>"
                    }, {
                        "types": [{
                                "type": "*"
                            }
                        ],
                        "name": "value",
                        "description": "<p>The data to store.</p>"
                    }
                ]
            }, {
                "code": "can.data(nodeList, key)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "NodeList"
                            }
                        ],
                        "name": "nodeList",
                        "description": "<p>The list of nodes data was stored under.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "key",
                        "description": "<p>The key to retrieve.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "*"
                        }
                    ],
                    "description": "<p>The data stored under <strong>key</strong>.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 468,
        "id": 204
    },
    "can.addClass": {
        "body": "<p><code>can.addClass( nodelist, className )</code> adds the specified class(es) to\nnodelist's HTMLElements.  It does NOT replace any existing class(es)\nalready defined.</p>\n\n<pre><code class=\"lang-javascript\">// Before\n<div id=\"foo\" class=\"monkey\" />\n\ncan.addClass(can.$(\"#foo\"),\"bar\")\n\n// After\n<div id=\"foo\" class=\"monkey bar\" /></code></pre>\n\n<p>You can also pass multiple class(es) and it will add them to the existing\nset also.</p>\n\n<pre><code class=\"lang-javascript\">// Before\n<div id=\"foo\" class=\"monkey\" />\n\ncan.addClass(can.$(\"#foo\"),\"bar man\")\n\n// After\n<div id=\"foo\" class=\"monkey bar man\" /></code></pre>\n\n<p>This works similarly to [http://api.jquery.com/addClass/ jQuery.fn.addClass].</p>",
        "description": "<p>Add a class to elements. </p>",
        "title": "",
        "name": "can.addClass",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.addClass(nodeList, className)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "NodeList"
                            }
                        ],
                        "name": "nodeList",
                        "description": "<p>The list of HTML elements to add the class to.</p>"
                    }, {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "name": "className",
                        "description": "<p>The class to add.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 504,
        "id": 205
    },
    "can.when": {
        "body": "<p><code>can.when(deferred)</code> provides the ability to execute callback function(s)\ntypically based on a Deferred or AJAX object.</p>\n\n<pre><code class=\"lang-javascript\">can.when( can.ajax('api/farm/animals') ).then(function(animals){\n     alert(animals); //-> alerts the ajax response\n});</code></pre>\n\n<p>You can also use this for regular JavaScript objects.</p>\n\n<pre><code class=\"lang-javascript\">$.when( { animals: [ 'cat' ] } ).done(function(animals){\n    alert(animals[0]); //-> alerts 'cat'\n});</code></pre>",
        "description": "<p>Call a callback when a Deferred resolves. </p>",
        "title": "",
        "name": "can.when",
        "type": "function",
        "parent": "can.util.functions",
        "signatures": [{
                "code": "can.when(deferred)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Deferred"
                            }, {
                                "type": "Object"
                            }
                        ],
                        "name": "deferred",
                        "description": "<p>The Deferred, AJAX, or normal Objects to call the callback on.</p>"
                    }
                ],
                "returns": {
                    "types": [{
                            "type": "Deferred"
                        }
                    ],
                    "description": "<p><strong>deferred</strong> if <strong>deferred</strong> is a Deferred,\notherwise a Deferred that resolves to <strong>deferred</strong>.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 543,
        "id": 206
    },
    "can.Deferred": {
        "body": "",
        "description": "<p><code>can.Deferred</code> is a object that allows users to assign and chain callback\nfunction(s) for the success or failure state of both asynchronous and synchronous function(s).</p>",
        "type": "constructor",
        "name": "can.Deferred",
        "title": "",
        "parent": "canjs",
        "signatures": [{
                "code": "can.Deferred()",
                "description": "",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "can.Deferred"
                        }
                    ],
                    "description": "<p>A new Deferred object.</p>"
                }
            }
        ],
        "src": "can/util/util.js",
        "line": 571,
        "id": 207
    },
    "can.Deferred.prototype": {
        "body": "",
        "description": "",
        "type": "prototype",
        "name": "can.Deferred.prototype",
        "parent": "can.Deferred",
        "src": "can/util/util.js",
        "line": 582,
        "id": 208
    },
    "can.Deferred.prototype.pipe": {
        "body": "<p><code>deferred.pipe(doneCallback, failCallback)</code> is a utility to filter Deferred(s).</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred(),\nfiltered = def.pipe(function(val) {\n        return val + \" is awesome!\";\n    });\n\ndef.resolve('Can');\n\nfiltered.done(function(value) {\n    alert(value); // Alerts: 'Can is awesome!'\n});</code></pre>",
        "description": "<p>Add callbacks to a Deferred. </p>",
        "title": "",
        "name": "can.Deferred.prototype.pipe",
        "type": "function",
        "signatures": [{
                "code": "pipe(doneCallback[, failCallback])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "doneCallback",
                        "description": "<p>A function called when the Deferred is resolved.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "failCallback",
                        "description": "<p>A function called when the Deferred is rejected.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 586,
        "id": 209
    },
    "can.Deferred.prototype.resolveWith": {
        "body": "<p><code>deferred.resolveWith(context, arguments)</code> resolves a Deferred and calls the <code>doneCallbacks</code> with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.resolveWith(this, { animals: [ 'cows', 'monkey', 'panda' ] })</code></pre>",
        "description": "<p>Resolve a Deferred in a particular context. </p>",
        "title": "resolveWith",
        "name": "can.Deferred.prototype.resolveWith",
        "type": "function",
        "parent": "can.Deferred.prototype",
        "signatures": [{
                "code": "resolveWith(context[, arguments])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "context",
                        "description": "<p>Context passed to the <code>doneCallbacks</code> as the <code>this</code> object.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "arguments",
                        "description": "<p>Array of arguments that are passed to the <code>doneCallbacks</code>.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 610,
        "id": 210
    },
    "can.Deferred.prototype.rejectWith": {
        "body": "<p><code>deferred.rejectWith(context, arguments)</code> rejects a Deferred and calls the <code>failCallbacks</code> with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.rejectWith(this, { error: \"Animals are gone.\" })</code></pre>",
        "description": "<p>Reject a Deferred in a particular context. </p>",
        "title": "rejectWith",
        "name": "can.Deferred.prototype.rejectWith",
        "type": "function",
        "parent": "can.Deferred.prototype",
        "signatures": [{
                "code": "rejectWith(context[, arguments])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "name": "context",
                        "description": "<p>Context passed to the <code>failCallbacks</code> as the <code>this</code> object.</p>"
                    }, {
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "arguments",
                        "description": "<p>Array of arguments that are passed to the <code>failCallbacks</code>.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 627,
        "id": 211
    },
    "can.Deferred.prototype.done": {
        "body": "<p><code>deferred.done(doneCallback)</code> adds handler(s) to be called when the Deferred object is resolved.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.done(function(){\n    //- Deferred is done.\n});</code></pre>",
        "description": "<p>Add a callback to be called when a Deferred is resolved. </p>",
        "title": "done",
        "name": "can.Deferred.prototype.done",
        "type": "function",
        "parent": "can.Deferred.prototype",
        "signatures": [{
                "code": "done(doneCallback)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "doneCallback",
                        "description": "<p>A callback to be called when the Deferred is resolved.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 644,
        "id": 212
    },
    "can.Deferred.prototype.always": {
        "body": "<p><code>deferred.always( alwaysCallbacks )</code> adds handler(s) to be called when the Deferred object is either resolved or rejected.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.always( function(){\n    //- Called whether the handler fails or is success.\n});</code></pre>",
        "description": "<p>Add a callback to be unconditionally called. </p>",
        "title": "always",
        "name": "can.Deferred.prototype.always",
        "type": "function",
        "parent": "can.Deferred.prototype",
        "signatures": [{
                "code": "always(alwaysCallback)",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "alwaysCallback",
                        "description": "<p>A callback to be called whether the Deferred is resolved or rejected.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 679,
        "id": 213
    },
    "can.Deferred.prototype.then": {
        "body": "<p><code>deferred.then( doneCallback, failCallback )</code> adds handler(s) to be called when the Deferred object to be called after its resolved.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.then(function(){\n    //- Called when the deferred is resolved.\n}, function(){\n    //- Called when the deferred fails.\n})</code></pre>",
        "description": "<p>Add callbacks to a Deferred. </p>",
        "title": "then",
        "name": "can.Deferred.prototype.then",
        "type": "function",
        "parent": "can.Deferred.prototype",
        "signatures": [{
                "code": "then(doneCallback[, failCallback])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "name": "doneCallback",
                        "description": "<p>A function called when the Deferred is resolved.</p>"
                    }, {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "optional": true,
                        "name": "failCallback",
                        "description": "<p>A function called when the Deferred is rejected.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 697,
        "id": 214
    },
    "can.Deferred.prototype.isResolved": {
        "body": "<p><code>deferred.isResolved()</code> returns whether a Deferred object has been resolved.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\nvar resolved = def.isResolved();</code></pre>",
        "description": "<p>Determine whether a Deferred has been resolved. </p>",
        "title": "isResolved",
        "name": "can.Deferred.prototype.isResolved",
        "type": "function",
        "parent": "can.Deferred.prototype",
        "signatures": [{
                "code": "isResolved()",
                "description": "",
                "params": [],
                "returns": {
                    "types": [{
                            "type": "Boolean"
                        }
                    ],
                    "description": "<p>Whether this Boolean has been resolved.</p>"
                }
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 718,
        "id": 215
    },
    "can.Deferred.prototype.reject": {
        "body": "<p><code>deferred.reject( args )</code> rejects the Deferred object and calls the fail callbacks with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.reject({ error: 'Thats not an animal.' })</code></pre>",
        "description": "<p>Reject a Deferred. </p>",
        "title": "reject",
        "name": "can.Deferred.prototype.reject",
        "type": "function",
        "parent": "can.Deferred.prototype",
        "signatures": [{
                "code": "reject([argument])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "argument",
                        "description": "<p>The argument to call the <code>failCallback</code> with.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 748,
        "id": 216
    },
    "can.Deferred.prototype.resolve": {
        "type": "function",
        "body": "<p><code>deferred.resolve( args )</code> resolves a Deferred object and calls the done callbacks with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.resolve({ animals: [ 'pig', 'cow' ] })</code></pre>",
        "description": "<p>Resolve a Deferred. </p>",
        "title": "resolve",
        "name": "can.Deferred.prototype.resolve",
        "signatures": [{
                "code": "resolve([argument])",
                "description": "",
                "params": [{
                        "types": [{
                                "type": "Object"
                            }
                        ],
                        "optional": true,
                        "name": "argument",
                        "description": "<p>The argument to call the <code>doneCallback</code> with.</p>"
                    }
                ]
            }
        ],
        "comment": " ",
        "src": "can/util/util.js",
        "line": 764,
        "id": 217
    },
    "can/util/fixture/fixture.md": {
        "type": "script",
        "name": "can/util/fixture/fixture.md"
    },
    "can.fixture": {
        "type": "page",
        "name": "can.fixture",
        "body": "",
        "description": "<p><code>can.util.fixture</code> intercepts an AJAX request and simulates\nthe response with a file or function. They are a great technique\nwhen you want to develop JavaScript\nindependently of the backend.</p>\n\n<h2>Types of Fixtures</h2>\n\n<p>There are two common ways of using fixtures.  The first is to\nmap Ajax requests to another file.  The following\nintercepts requests to <code>/tasks.json</code> and directs them\nto <code>fixtures/tasks.json</code>:</p>\n\n<pre><code>can.fixture(\"/tasks.json\", \"fixtures/tasks.json\");\n</code></pre>\n\n<p>The other common option is to generate the Ajax response with\na function.  The following intercepts updating tasks at\n<code>/tasks/ID.json</code> and responds with updated data:</p>\n\n<pre><code>can.fixture(\"PUT /tasks/{id}.json\",\n  function(original, respondWith, settings){\n     respondWith({ updatedAt : new Date().getTime() });\n  })\n</code></pre>\n\n<p>We categorize fixtures into the following types:</p>\n\n<ul>\n<li><strong>Static</strong> - the response is in a file.</li>\n<li><strong>Dynamic</strong> - the response is generated by a function.</li>\n</ul>\n\n<p>There are different ways to lookup static and dynamic fixtures.</p>\n\n<h2>Static Fixtures</h2>\n\n<p>Static fixtures use an alternate url as the response of the Ajax request.</p>\n\n<pre><code>// looks in fixtures/tasks1.json relative to page\ncan.fixture(\"tasks\", \"fixtures/tasks.json\");\n\n// looks absolute to the page\ncan.fixture(\"tasks\", \"//fixtures/tasks.json\");\n</code></pre>\n\n<p>Static fixtures can also be templated, which means that parameters will be\nused in the fixture filename:</p>\n\n<pre><code>// looks in fixtures/tasks1.json relative to page\ncan.fixture(\"tasks/{id}\", \"fixtures/tasks.{id}.json\");\n</code></pre>\n\n<p>A request to <code>tasks/42</code> will look for a <code>fixtures/tasks.42.json</code> file.</p>\n\n<h2>Dynamic Fixtures</h2>\n\n<p>Dynamic Fixtures are functions that get the details of the Ajax request and return the result of the mocked service\nrequest from your server.</p>\n\n<p>For example, the following returns a successful response with JSON data from the server:</p>\n\n<pre><code>can.fixture(\"/foobar.json\",\n  function(original, respondWith, settings){\n    respondWith(200, \"success\", { json: {foo: \"bar\" } }, {})\n  })\n</code></pre>\n\n<p>The fixture function has the following signature:</p>\n\n<pre><code>function( originalOptions, respondWith, options) {\n  respond(status, statusText, responses, responseHeaders);\n}\n</code></pre>\n\n<p>where the fixture function is called with:</p>\n\n<ul>\n<li><code>originalOptions</code> - are the options provided to the ajax method, unmodified,\nand thus, without defaults from ajaxSettings</li>\n<li><code>respondWith</code> - the response callback. It can be called with:\n<ul><li><code>status</code> - the HTTP status code of the response.</li>\n<li><code>statusText</code> - the status text of the response</li>\n<li><code>responses</code> - a map of dataType/value that contains the responses for each data format supported</li>\n<li><code>responseHeaders</code> - response headers</li></ul></li>\n<li><code>options</code> - are the request options</li>\n<li><code>headers</code> - a map of key/value request headers</li>\n</ul>\n\n<p>However, can.fixture handles the common case where you want a successful response with JSON data.\nThe previous can be written like:</p>\n\n<pre><code>can.fixture(\"/foobar.json\",\n  function(original, respondWith, settings){\n    respondWith({ foo: \"bar\" });\n  })\n</code></pre>\n\n<p>Since <code>respondWith</code> is called asynchronously you can also set a custom fixture timeout like this:</p>\n\n<pre><code>can.fixture(\"/foobar.json\",\nfunction(original, respondWith, settings){\n    setTimeout(function() {\n      respondWith({ foo: \"bar\" });\n    }, 1000);\n  })\n</code></pre>\n\n<p>If you want to return an array of data respond like this:</p>\n\n<pre><code>can.fixture(\"/tasks.json\",\n  function(original, respondWith, settings){\n    respondWith([ \"first\", \"second\", \"third\"]);\n  })\n</code></pre>\n\n<p><strong>Note:</strong> A fixture function can also return its response directly like this:</p>\n\n<pre><code>can.fixture(\"/foobar.json\", function() {\n  return { foo: \"bar\" };\n})\n</code></pre>\n\n<p>This is kept for backwards compatibility and should not be used.</p>\n\n<p>can.fixture works closesly with <a href=\"http://api.jquery.com/extending-ajax/\">jQuery's ajaxTransport</a> system.</p>\n\n<h3>Templated Urls</h3>\n\n<p>Often, you want a dynamic fixture to handle urls for multiple resources (for example a REST url scheme).\ncan.fixture's templated urls allow you to match urls with a wildcard.</p>\n\n<p>The following example simulates services that get and update 100 todos.</p>\n\n<pre><code>// create todos\nvar todos = {};\nfor(var i = 0; i &lt; 100; i++) {\n  todos[i] = {\n    id: i,\n    name: \"Todo \"+i\n  }\n}\ncan.fixture(\"GET /todos/{id}\",\n  function(original, respondWith, settings){\n    // return the JSON data\n    // notice that id is pulled from the url and added to data\n    respondWith(todos[orig.data.id]);\n  })\n\ncan.fixture(\"PUT /todos/{id}\",\n  function(original, respondWith, settings){\n    // update the todo's data\n    can.extend(todos[orig.data.id], orig.data );\n    respondWith({});\n  })\n</code></pre>\n\n<p>Notice that data found in templated urls (ex: <code>{id}</code>) is added to the original data object.</p>\n\n<h2>Simulating Errors</h2>\n\n<p>The following simulates an unauthorized request\nto <code>/foo</code>.</p>\n\n<pre><code>can.fixture(\"/foo\",\n  function(original, respondWith, settings) {\n    respondWith(401,\"{type: 'unauthorized'}\");\n  });\n</code></pre>\n\n<p>This could be received by the following Ajax request:</p>\n\n<pre><code>can.ajax({\n  url: '/foo',\n  error : function(jqXhr, status, statusText){\n    // status === 'error'\n    // statusText === \"{type: 'unauthorized'}\"\n  }\n})\n</code></pre>\n\n<h2>Turning off Fixtures</h2>\n\n<p>You can remove a fixture by passing <code>null</code> for the fixture option:</p>\n\n<pre><code>// add a fixture\ncan.fixture(\"GET todos.json\",\"//fixtures/todos.json\");\n\n// remove the fixture\ncan.fixture(\"GET todos.json\", null)\n</code></pre>\n\n<p>You can also set [can.fixture.on] to false:</p>\n\n<pre><code>can.fixture.on = false;\n</code></pre>\n\n<h2>Make</h2>\n\n<p>[can.fixture.store] makes a CRUD service layer that handles sorting, grouping, filtering and more. Use\nit with a [can.Model] like this:</p>\n\n<pre><code>var Todo = can.Model({\n  findAll : 'GET /todos',\n  findOne : 'GET /todos/{id}',\n  create  : 'POST /todos',\n  update  : 'PUT /todos/{id}',\n  destroy : 'DELETE /todos/{id}'\n  }, {});\n\nvar store = can.fixture.store(100, function(i) {\n  return {\n    id : i,\n    name : 'Todo ' + i\n  }\n});\n\ncan.fixture('GET /todos', store.findAll);\ncan.fixture('GET /todos/{id}', store.findOne);\ncan.fixture('POST /todos', store.create);\ncan.fixture('PUT /todos/{id}', store.update);\ncan.fixture('DELETE /todos/{id}', store.destroy);\n</code></pre>\n\n<h2>Testing Performance</h2>\n\n<p>Dynamic fixtures are awesome for performance testing.  Want to see what\n10000 files does to your app's performance?  Make a fixture that returns 10000 items.</p>\n\n<p>What to see what the app feels like when a request takes 5 seconds to return?  Set\n[can.fixture.delay] to 5000.</p>\n\n<h2>Organizing fixture</h2>\n\n<p>The <strong>best</strong> way of organizing fixtures is to have a 'fixtures.js' file that steals\n<code>can/util/fixture</code> and defines all your fixtures.  For example,\nif you have a 'todo' application, you might\nhave <code>todo/fixtures/fixtures.js</code> look like:</p>\n\n<pre><code>steal({\n        path: '//can/util/fixture.js',\n        ignore: true\n      })\n      .then(function(){\n\n  can.fixture({\n      type: 'get',\n      url: '/services/todos.json'\n    },\n    '//todo/fixtures/todos.json');\n\n  can.fixture({\n      type: 'post',\n      url: '/services/todos.json'\n    },\n    function(original, respondWith, settings){\n        respondWith({\n            id: Math.random(),\n            name: settings.data.name\n        })\n    });\n\n})\n</code></pre>\n\n<p><strong>Notice</strong>: We used steal's ignore option to prevent\nloading the fixture plugin in production.</p>\n\n<p>Finally, we steal <code>todo/fixtures/fixtures.js</code> in the\napp file (<code>todo/todo.js</code>) like:</p>\n\n<pre><code>steal({path: '//todo/fixtures/fixtures.js',ignore: true});\n\n//start of your app's steals\nsteal( ... )\n</code></pre>\n\n<p>We typically keep it a one liner so it's easy to comment out.</p>\n\n<h3>Switching Between Sets of Fixtures</h3>\n\n<p>If you are using fixtures for testing, you often want to use different\nsets of fixtures.  You can add something like the following to your fixtures.js file:</p>\n\n<pre><code>if( /fixtureSet1/.test( window.location.search) ){\n  can.fixture(\"/foo\",\"//foo/fixtures/foo1.json');\n} else if(/fixtureSet2/.test( window.location.search)){\n  can.fixture(\"/foo\",\"//foo/fixtures/foo1.json');\n} else {\n  // default fixtures (maybe no fixtures)\n}\n</code></pre>",
        "title": "can.fixture",
        "parent": "canjs",
        "test": "can/util/fixture/qunit.html",
        "src": "can/util/fixture/fixture.md",
        "id": 218
    }
}