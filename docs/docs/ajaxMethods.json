c({"name": "ajaxMethods", "type": "property", "parent": "jQuery.Model", "body": "<div class='demo_wrapper' data-demo-src='jquery/model/list/list.html'></div><div class='demo_wrapper' data-demo-src='jquery/model/list/list-insert.html'></div>", "description": "<p>Model.Lists manage a lists (or arrays) of \nmodel instances.  Similar to [jQuery.Model $.Model], \nthey are used to:</p>\n\n<ul>\n<li>create events when a list changes </li>\n<li>make Ajax requests on multiple instances</li>\n<li>add helper function for multiple instances (ACLs)</li>\n</ul>\n\n<p>The [todo] app demonstrates using a can.Control to \nimplement an interface for a $.Model.List.</p>\n\n<h2>Creating A List Class</h2>\n\n<p>Create a `$.Model.List [jQuery.Class class] for a $.Model\nlike:</p>\n\n<pre><code>$.Model('Todo')\n$.Model.List('Todo.List',{\n  // static properties\n},{\n  // prototype properties\n})\n</code></pre>\n\n<p>This creates a <code>Todo.List</code> class for the <code>Todo</code> \nclass. This creates some nifty magic that we will see soon.</p>\n\n<p><code>static</code> properties are typically used to describe how \na list makes requests.  <code>prototype</code> properties are \nhelper functions that operate on an instance of \na list. </p>\n\n<h2>Make a Helper Function</h2>\n\n<p>Often, a user wants to select multiple items on a\npage and perform some action on them (for example, \ndeleting them). The app\nneeds to indicate if this is possible (for example,\nby enabling a \"DELETE\" button).</p>\n\n<p>If we get todo data back like:</p>\n\n<pre><code>// GET /todos.json -&gt;\n[{\n  \"id\" : 1,\n  \"name\" : \"dishes\",\n  \"acl\" : \"rwd\"\n},{\n  \"id\" : 2,\n  \"name\" : \"laundry\",\n  \"acl\" : \"r\"\n}, ... ]\n</code></pre>\n\n<p>We can add a helper function to let us know if we can \ndelete all the instances:</p>\n\n<pre><code>$.Model.List('Todo.List',{\n\n},{\n   canDelete : function(){\n     return this.grep(function(todo){\n       return todo.acl.indexOf(\"d\") != 0\n     }).length == this.length\n   }\n})\n</code></pre>\n\n<p><code>canDelete</code> gets a list of all todos that have\n<strong>d</strong> in their acl.  If all todos have <strong>d</strong>,\nthen <code>canDelete</code> returns true.</p>\n\n<h2>Get a List Instance</h2>\n\n<p>You can create a model list instance by using\n<code>new Todo.List( instances )</code> like:</p>\n\n<pre><code>var todos = new Todo.List([\n  new Todo({id: 1, name: ...}),\n  new Todo({id: 2, name: ...}),\n]);\n</code></pre>\n\n<p>And call <code>canDelete</code> on it like:</p>\n\n<pre><code>todos.canDelete() //-&gt; boolean\n</code></pre>\n\n<p>BUT! $.Model, [jQuery.fn.models $.fn.models], and $.Model.List are designed \nto work with each other.</p>\n\n<p>When you use <code>Todo.findAll</code>, it will callback with an instance\nof <code>Todo.List</code>:</p>\n\n<pre><code>Todo.findAll({}, function(todos){\n   todos.canDelete() //-&gt; boolean\n})\n</code></pre>\n\n<p>If you are adding the model instance to elements and\nretrieving them back with <code>$().models()</code>, it will \nreturn a instance of <code>Todo.List</code>.  The following\nreturns if the checked <code>.todo</code> elements are\ndeletable:</p>\n\n<pre><code>// get the checked inputs\n$('.todo input:checked')\n   // get the todo elements\n   .closest('.todo')\n   // get the model list\n   .models()\n   // check canDelete\n   .canDelete()\n</code></pre>\n\n<h2>Make Ajax Requests with Lists</h2>\n\n<p>After checking if we can delete the todos,\nwe should delete them from the server. Like \n<code>$.Model</code>, we can add a \nstatic [jQuery.Model.List.static.destroy destroy] url:</p>\n\n<pre><code>$.Model.List('Todo.List',{\n   destroy : 'POST /todos/delete'\n},{\n   canDelete : function(){\n     return this.grep(function(todo){\n       return todo.acl.indexOf(\"d\") != 0\n     }).length == this.length\n   }\n})\n</code></pre>\n\n<p>and call [jQuery.Model.List.prototype.destroy destroy] on\nour list.  </p>\n\n<pre><code>// get the checked inputs\nvar todos = $('.todo input:checked')\n   // get the todo elements\n   .closest('.todo')\n   // get the model list\n   .models()\n\nif( todos.canDelete() ) {\n   todos.destroy()\n}\n</code></pre>\n\n<p>By default, destroy will create an AJAX request to \ndelete these instances on the server, when\nthe AJAX request is successful, the instances are removed\nfrom the list and events are dispatched.</p>\n\n<h2>Listening to events on Lists</h2>\n\n<p>Use [jQuery.Model.List.prototype.bind bind]<code>(eventName, handler(event, data))</code> \nto listen to <strong>add</strong>, <strong>remove</strong>, and <strong>updated</strong> events on a \nlist.  </p>\n\n<p>When a model instance is destroyed, it is removed from\nall lists.  In the todo example, we can bind to remove to know\nwhen a todo has been destroyed.  The following \nremoves all the todo elements from the page when they are removed\nfrom the list:</p>\n\n<pre><code>todos.bind('remove', function(ev, removedTodos){\n  removedTodos.elements().remove();\n})\n</code></pre>\n\n<h2>Demo</h2>\n\n<p>The following demo illustrates the previous features with\na contacts list.  Check\nmultiple Contacts and click \"DESTROY ALL\"</p>\n\n<h2>Other List Features</h2>\n\n<ul>\n<li>Store and retrieve multiple instances</li>\n<li>Fast HTML inserts</li>\n</ul>\n\n<h3>Store and retrieve multiple instances</h3>\n\n<p>Once you have a collection of models, you often want to retrieve and update \nthat list with new instances.  Storing and retrieving is a powerful feature\nyou can leverage to manage and maintain a list of models.</p>\n\n<p>To store a new model instance in a list...</p>\n\n<pre><code>listInstance.push(new Animal({ type: dog, id: 123 }))\n</code></pre>\n\n<p>To later retrieve that instance in your list...</p>\n\n<pre><code>var animal = listInstance.get(123);\n</code></pre>\n\n<h3>Faster Inserts</h3>\n\n<p>The 'easy' way to add a model to an element is simply inserting\nthe model into the view like:</p>\n\n<pre>&lt;div &lt;%= task %>> A task &lt;/div></pre>\n\n<p>And then you can use [jQuery.fn.models $('.task').models()].</p>\n\n<p>This pattern is fast enough for 90% of all widgets.  But it\ndoes require an extra query.  Lists help you avoid this.</p>\n\n<p>The [jQuery.Model.List.prototype.get get] method takes elements and\nuses their className to return matched instances in the list.</p>\n\n<p>To use get, your elements need to have the instance's \nidentity in their className.  So to setup a div to reprsent\na task, you would have the following in a view:</p>\n\n<pre>&lt;div class='task &lt;%= task.identity() %>'> A task &lt;/div></pre>\n\n<p>Then, with your model list, you could use get to get a list of\ntasks:</p>\n\n<pre>taskList.get($('.task'))</pre>\n\n<p>The following demonstrates how to use this technique:</p>", "comment": "undefined@class jQuery.Model.List\n", "download": "http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/model/list/list.js", "test": "jquery/model/list/qunit.html", "plugin": "jquery/model/list", "src": "can/model/list/list.js", "line": 18})