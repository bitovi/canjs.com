c({"name": "prototype.ML", "type": "property", "parent": "canjs", "body": "", "description": "<p>Works exactly like [can.Observe.List] and has all of the same properties,\nevents, and functions as an observable list. The only difference is that \nwhen an item from the list is destroyed, it will automatically get removed\nfrom the list.</p>\n\n<h2>Creating a new Model List</h2>\n\n<p>To create a new model list, just use <code>new {model_name}.List(ARRAY)</code> like:</p>\n\n<pre><code>var todo1 = new Todo( { name: \"Do the dishes\" } ),\n    todo2 = new Todo( { name: \"Wash floors\" } )\nvar todos = new Todo.List( [todo1, todo2] );\n</code></pre>\n\n<h3>Model Lists in <code>can.Model</code></h3>\n\n<p>[can.Model.static.findAll can.Model.findAll] or [can.Model.models] will\nalmost always be used to return a <code>can.Model.List</code> object, even though it\nis possible to create new lists like below:</p>\n\n<pre><code>var todos = Todo.models([\n    new Todo( { name: \"Do the dishes\" } ),\n    new Todo( { name: \"Wash floors\" } )\n])\n\ntodos.constructor // -&gt; can.Model.List\n\n// the most correct way to get a can.Model.List\nTodo.findAll({}, function(todos) {\n    todos.constructor // -&gt; can.Model.List\n})\n</code></pre>\n\n<h3>Extending <code>can.Model.List</code></h3>\n\n<p>Creating custom <code>can.Model.Lists</code> allows you to extend lists with helper\nfunctions for a list of a specific type. So, if you wanted to be able to\nsee how many todos were completed and remaining something could be written\nlike:</p>\n\n<pre><code>Todo.List = can.Model.List({\n    completed: function() {\n        var completed = 0;\n        this.each(function(i, todo) {\n            completed += todo.attr('complete') ? 1 : 0\n        })\n        return completed;\n    },\n    remaining: function() {\n        return this.attr('length') - this.completed();\n    }\n})\n\nTodo.findAll({}, function(todos) {\n    todos.completed() // -&gt; 0\n    todos.remaining() // -&gt; 2\n});\n</code></pre>\n\n<h2>Removing models from model list</h2>\n\n<p>The advantage that <code>can.Model.List</code> has over a traditional <code>can.Observe.List</code>\nis that when you destroy a model, if it is in that list, it will automatically\nbe removed from the list. </p>\n\n<pre><code>// Listen for when something is removed from the todos list.\ntodos.bind(\"remove\", function( ev, oldVals, indx ) {\n    console.log(oldVals[indx].attr(\"name\") + \" removed\")\n})\n\ntodo1.destroy(); // console shows \"Do the dishes removed\"\n</code></pre>", "comment": "undefined@class can.Model.List\n", "inherits": "can.Observe.List", "src": "can/model/model.js", "line": 1169})