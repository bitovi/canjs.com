c({"type": "page", "name": "can.Mustache.Acquisition", "body": "", "description": "<p>There are number of ways to acquire templates such as: raw text,\nURL, or script tags in the markup.</p>\n\n<p><strong>Raw Text</strong></p>\n\n<p>Raw text can by templated by passing an object with a <code>text</code>\nattribute containing your template and Mustache will return a \ndocument fragment back.  For example:</p>\n\n<pre><code>var template = \"My body lies over the {{.}}\";\nvar fragment = new can.Mustache({ text: template })\n                .render('water');\ncan.append(can.$(document.body), can.view.frag(fragment));\n</code></pre>\n\n<p><strong>Script Tags</strong></p>\n\n<p>Inline script tags in your HTML document can be used to render \ntemplates.  Set the <code>type</code> to <code>text/mustache</code> and the <code>id</code> as a unique\nkey Mustache will use for look up.</p>\n\n<pre><code>&lt;script id=\"mytemplate\" type=\"text/mustache\"&gt;\n    My body lies over the {{.}}\n&lt;/script&gt;\n\nvar template = can.view(\"#mytemplate\", 'water');\ncan.$(document.body).append(template);\n</code></pre>\n\n<p><strong>URL</strong></p>\n\n<p>Templates can be defined in its own file and  Mustache will fetch the \nfiles on render.  This is the preferred way since it will keep your application\nnicely organized seperating views from logic code. </p>\n\n<pre><code>var template = can.view('//lib/views/mytemplate.mustache', \n                dataToPass)\ncan.$(document.body).append(template);\n</code></pre>\n\n<p>Since could potentially make several XHR requests, in a big application\nthis could be a performance concern.  Creating a build step to \nconcatenate and include all of the views in one file would be one way to optimize performance. <br />\nIf you are using Steal, it will do this automatically at build for you.</p>", "title": "Template Acquisition", "parent": "can.Mustache", "order": 3, "src": "can/view/mustache/doc/acquisition.md"})