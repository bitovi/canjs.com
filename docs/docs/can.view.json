c({"name": "can.view", "description": "<p>A JavaScript template framework. \n<code>can.view</code> is a JavaScript template framework that provides:</p>\n\n<ul>\n<li>template loading from html elements or external files</li>\n<li>synchronous and asynchronous template loading</li>\n<li>deferred support</li>\n<li>callbacks on elements for functionality like live live-binding</li>\n</ul>\n\n<p>can.view supports other templating languages, but using [can.EJS] is highly encouraged.</p>", "src": "can/view/view.js", "line": 9, "type": "function", "body": "<h2>Use</h2>\n\n<p><code>can.view( idOrUrl, data, helpers )</code> loads template content from an element, a url or a string, renders\nit with data, and converts it to a documentFragment so it can be easily and \nefficiently inserted into the DOM.</p>\n\n<pre><code>document.getElementById('person')\n  .appendChild( can.view('person.ejs', {name: \"Justin\" } ) )\n</code></pre>\n\n<p>This code:</p>\n\n<ol>\n<li><p>Loads the template a 'mytemplate.ejs'. It might look like:\n<pre><code>&lt;h2>&lt;%= name %>&lt;/h2></pre></code></p></li>\n<li><p>Renders it with {message: 'hello world'}, resulting in:\n<pre><code>&lt;div id='foo'>\"&lt;h2>Justin&lt;/h2>&lt;/div></pre></code></p></li>\n<li><p>Inserts the result into the foo element. Foo might look like:\n<pre><code>&lt;div id='person'>&lt;h2>Justin&lt;/h2>&lt;/div></pre></code></p></li>\n</ol>\n\n<h2>Loading Templates</h2>\n\n<p><code>can.view</code> can load templates from a url or from a script.</p>\n\n<h3>Loading templates from a script tag</h3>\n\n<p>To load from a script tag, create a script tag with:</p>\n\n<ul>\n<li>the template contents within the script tag</li>\n<li>an id</li>\n<li><p>a type attribute that specifies the type of template</p>\n\n<script type='text/ejs' id='recipesEJS'>\n<% for(var i=0; i < recipes.length; i++){ %>\n  <li><%=recipes[i].name %></li>\n<%} %>\n</script></li>\n</ul>\n\n<p>Render with this template like:</p>\n\n<pre><code>document.getElementById('recipes')\n  .appendChild( can.view('recipesEJS', recipeData ) )\n</code></pre>\n\n<p>Notice we passed the id of the element we want to render.</p>\n\n<h3>Loading templates from a url</h3>\n\n<p>To load from a url, simply pass the location of the template\nto <code>can.view</code>.  The location of the template needs an extension that\nmatches the type of template:</p>\n\n<pre><code>document.getElementById('recipes')\n  .appendChild( can.view('templates/recipes.ejs', recipeData ) )\n</code></pre>\n\n<h3>Creating templates from strings</h3>\n\n<p>You can also register a view string for a given id programmatically for any registered template engine using\n<code>can.view.&lt;engine&gt;(id, template)</code>:</p>\n\n<pre><code>can.view.ejs('myViewEJS', '&lt;h2&gt;&lt;%= message %&gt;&lt;/h2&gt;');\ncan.view('myView', { message : 'Hello EJS' });\n// -&gt; &lt;h2&gt;Hello EJS&lt;/h2&gt;\n</code></pre>\n\n<h3>Renderer functions</h3>\n\n<p>Additionally to rendering a template immediately it is also possible to retrieve a renderer function by just passing\nthe view name. The renderer function can be called with the template data at a later point in time:</p>\n\n<pre><code>var renderer = can.view('templates/recipes.ejs');\n// Do some things\ndocument.getElementById('recipes')\n  .appendChild( renderer(recipeData ) )\n</code></pre>\n\n<p>It is also possible to get a nameless renderer function when creating a template from a string:</p>\n\n<pre><code>var renderer = can.view.ejs('&lt;strong&gt;&lt;%= message %&gt;&lt;/strong&gt;');\nrenderer({\n  message : 'Message form EJS'\n}); // -&gt; &lt;strong&gt;Message from EJS&lt;/strong&gt;\n\nrenderer = can.view.mustache('&lt;strong&gt;{{message}}&lt;/strong&gt;');\nrenderer({\n  message : 'Message form Mustache'\n}); // -&gt; &lt;strong&gt;Message from Mustache&lt;/strong&gt;\n</code></pre>\n\n<h2>Supported Template Engines</h2>\n\n<p>CanJS supports the following template languages:</p>\n\n<ul>\n<li><p>EmbeddedJS (ejs)</p>\n\n<pre><code>&lt;h2>&lt;%= message %>&lt;/h2></code></pre></li>\n<li><p>Mustache (mustache)</p>\n\n<pre><code>&lt;h2{{message}}&lt/h2></code></pre></li>\n<li><p>JAML (jaml)</p>\n\n<pre><code>h2(data.message);</code></pre></li>\n<li><p>Micro (micro)</p>\n\n<pre><code>&lt;h2>{%= message %}&lt;/h2></code></pre></li>\n<li><p>jQuery.Tmpl (tmpl)</p>\n\n<pre><code>&lt;h2>${message}&lt;/h2></code></pre></li>\n</ul>\n\n<h2>Rendering to strings and sub-templates</h2>\n\n<p>To render to a string, use <code>can.view.render(idOrUrl, data)</code> like:</p>\n\n<pre><code>can.view.render(\"/templates/recipe.ejs\",{recipe: recipe})\n</code></pre>\n\n<p>To render a sub-template within another template, use render like:</p>\n\n<pre><code>&lt;% $.each(recipes, function(i, recipe){ %&gt;\n  &lt;li&gt;&lt;%== can.view.render(\"/templates/recipe.ejs\",{\n             recipe: recipe\n            }) %&gt;\n  &lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h2>Asynchronous Loading</h2>\n\n<p>By default, retrieving templates is done synchronously. This \nis fine because StealJS packages view templates with your \nJS download.</p>\n\n<p>However, some people might not be using StealJS or want to \ndelay loading templates until necessary. If you have the need, \nyou can provide a callback paramter like:</p>\n\n<pre><code>can.view('recipes',recipeData, function(frag){\n  document.getElementById('recipes')\n    .appendChild(frag)\n});\n</code></pre>\n\n<p>The callback function will be called with the result of \nthe rendered template.</p>\n\n<h2>Deferreds</h2>\n\n<p>If you pass deferreds to can.view it \nwill wait until all deferreds resolve before rendering \nthe view. This makes it a one-liner to make a request and use the \nresult to render a template.</p>\n\n<p>The following makes a request for todos in parallel with the \ntodos.ejs template. Once todos and template have been loaded, \nit with render the view with the todos.</p>\n\n<pre><code>can.view('recipes', Todo.findAll() , function(frag){\n  document.getElementById('recipes')\n    .appendChild(frag)\n})\n</code></pre>", "title": "", "parent": "canjs", "signatures": [{"code": "can.view(view, data, helpers)", "description": "", "params": [{"types": [{"type": "String"}], "name": "view", "description": "<p>The URL to a template or the ID of a template.</p>"}, {"types": [{"type": "Object"}], "name": "data", "description": "<p>Data to populate the template with.</p>"}, {"types": [{"type": "Object", "template": [{"types": [{"type": "String"}]}, {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}]}]}], "name": "helpers", "description": "<p>Helpers referenced in the template.</p>"}], "returns": {"types": [{"type": "String"}], "description": "<p>The template with the data interpolated into it.</p>"}}], "comment": " "})