<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>CanJS - Recipes </title>
	<meta name="description" content="">
	<meta name="author" content="">

	
	<link rel="stylesheet" type="text/css" href="./static/bundles/static.css">
	
	<!--[if lt IE 9]>
   <script type="text/javascript" src="static/html5shiv.js"></script>
    <!--<![endif]-->
</head>

<body class="docs ">
	<header>
		<nav class="container">

			<div class="logo-menu">
				<a class="brand" href="../index.html">CanJS</a>
				<ul class="dropdown-menu">
		          <li><a href="http://javascriptmvc.com">JavaScriptMVC</a></li>
		          <li><a href="http://canjs.com" class="active">CanJS</a></li>
		          <li><a href="http://jquerypp.com">jQuery++</a></li>
		          <li><a href="http://stealjs.com">StealJS</a></li>
		          <li><a href="http://funcunit.com">FuncUnit</a></li>
		          <li><a href="http://documentjs.com">DocumentJS</a></li>
		        </ul>
			</div>
			
			<ul class="nav">
		        <li >
	              <a href="../index.html">Home</a>
                </li>
		       <li class='active'><a href='index.html'>guides</a></li>
		       <li><a href='../docs/index.html'>api</a></li>
		        <li class=" community-menu">
		          <a href="../community.html#!forums">Community</a>
		          <ul class="dropdown-menu">
		            <li><a href="https://forum.javascriptmvc.com/canjs">Forums</a></li>
		            <li><a href="http://webchat.freenode.net/?channels=canjs">IRC</a></li>
		            <li><a href="http://bitovi.bithub.com/canjs/app/">Apps</a></li>
		            <li><a href="http://bitovi.bithub.com/canjs/plugin/">Plugins</a></li>
		            <li><a href="http://bitovi.bithub.com/canjs/article/">Articles</a></li>
		            <li><a href="http://github.com/bitovi/canjs">Github</a></li>
		            <li><a href="http://twitter.com/canjs">Twitter</a></li>
		            <li><a href="http://bitovi.github.io/canjsmeetup/">Meetups</a></li>
		          </ul>
		        </li>
		        <li >
	              <a href="../blog/index.html">Blog</a>
                </li>
		        <li >
	              <a href="../download.html">Download</a>
                </li>
	      	</ul>
			
			<div class="pull-right">
				<div class="bitovi-menu">
					<a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
					<ul class="dropdown-menu">
						<li><a href="http://bitovi.com">Bitovi.com</a></li>
						<li><a href="http://bitovi.com/blog/">Blog</a></li>
						<li><a href="http://bitovi.com/design/">Design</a></li>
						<li><a href="http://bitovi.com/development/">Development</a></li>
						<li><a href="http://bitovi.com/training/">Training</a></li>
						<li><a href="http://bitovi.com/open-source/">Open Source</a></li>
						<li><a href="http://bitovi.com/people/">People</a></li>
						<li><a href="http://bitovi.com/contact/">Contact Us</a></li>
					</ul>
				</div>
			</div>
			
		</nav>
	</header>

	
<div class="container api">

	
	<nav class="sidebar">
		
		<h2 id="version">
	<select id='versions'></select>
</h2>
<ul class="api">
	<!-- First Level -->
	
	   <li class="search-container">
	   		<a href="Tutorial.html" data-search="Getting Started">
				Getting Started
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="Using.html" data-search="Setting up CanJS">
				Setting up CanJS
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="Why.html" data-search="Why CanJS?">
				Why CanJS?
			</a>
			
	   </li>
	
	   <li class="search-container active">
	   		<a href="Recipes.html" data-search="Recipes">
				Recipes
			</a>
			
				
			
	   </li>
	
	   <li class="search-container">
	   		<a href="contributing.html" data-search="How to Contribute">
				How to Contribute
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="changelog.html" data-search="Changelog">
				Changelog
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="license.html" data-search="License">
				License
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="migrating.html" data-search="Migrating to 2.0">
				Migrating to 2.0
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="roadmap.html" data-search="Roadmap">
				Roadmap
			</a>
			
	   </li>
	
</ul>
	</nav>
	
	
	
	<article class="content docs">
	
	
		
		<section class="title">
			<div class="heading">
<h1>Recipes</h1>
	<ul class="tags">
		<li>page</li>
	</ul>
	
	
</div>

<div class="sub-heading">
	
	
		<span class="module">Recipes</span>
	
	
	
	<span class="inherits">&nbsp;</span>
</div>

<ul class="links">
	
	
		<li><a href="https://github.com/bitovi/canjs/tree/master/guides/recipes.md">source</a></li>
	
	
	
</ul>
<br />
		</section>
		
		
		
		<section class="contents">
		</section>
		
		
		

		

		
			
		
		
		
		

		
		<section class="comment">
			<h2>Get Started</h2>
<p>There are a variety of ways to get CanJS.  Read the <a href="http://canjs.com/guides/Using.html">using CanJS guide</a>
for comprehensive list.  For the following recipes, we will load CanJS
with a <code>&lt;script&gt;</code> tag pointed to CanJS's CDN.</p>
<p>Create a file called <code>myapp.html</code> and put the following in it to get started:</p>
<pre><code>&lt;script src=&quot;//code.jquery.com/jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;//canjs.com/release/2.0.4/can.jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/mustache&quot; id=&quot;app-template&quot;&gt;
//Template will go here
&lt;/script&gt;
&lt;script&gt;
//Application code will go here
&lt;/script&gt;

&lt;!-- CanJS needs a place to put your application --&gt;
&lt;div id=&quot;my-app&quot;&gt;&lt;/div&gt;
</code></pre>
<p>To follow along with the other recipes, you can also use
<a href="http://jsfiddle.net/donejs/GE3yf/">this JSFiddle</a> as a template.</p>
<p>You can also <a href="http://canjs.com/download.html">Download CanJS</a>
or follow <a href="http://canjs.com/guides/Tutorial.html">other tutorials</a> to get
started, but for the rest of the examples below, we'll be using this
setup.</p>
<h2>Say &quot;Hello World&quot;</h2>
<p>In CanJS, content is displayed using <em>templates</em>.  Instead of manually
changing elements in the DOM, you create a template and CanJS
automatically updates the page from the data in your application code.</p>
<h3>Template</h3>
<p>In the template section of <code>myapp.html</code>, put the following:</p>
<pre><code>&lt;script type=&quot;text/mustache&quot; id=&quot;app-template&quot;&gt;
&lt;h1&gt;{{message}}&lt;/h1&gt;
&lt;/script&gt;
</code></pre>
<p>This template displays the value of <code>message</code>.</p>
<h3>Pass message to the Template</h3>
<p>Templates are rendered with <a href="../docs/can.view.html">can.view</a>, which takes two arguments: the first is the <code>id</code> of the template,
and the second is the data passed to the template (in this case,
an object with a <code>message</code> property).</p>
<p>Render the template with a <code>message</code> and insert it into the page with:</p>
<pre><code>&lt;script&gt;
// Give message a value
var data = {message: &quot;Hello World!&quot;};

// Pass the id of the template and the data, containing our message to can.view
var frag = can.view(&quot;app-template&quot;, data);

//Load the DocumentFragment in the page
$(&quot;#my-app&quot;).html( frag )
&lt;/script&gt;
</code></pre>
<blockquote>
<p><code>frag</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment">DocumentFragment</a>. A DocumentFragment
is a lightweight container of HTMLElements that can be inserted in the page quickly. They can be used
anywhere a normal HTMLElement is used.</p>
</blockquote>
<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/GE3yf/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>
<h2>Update Text in the Page</h2>
<p>CanJS will update the page automatically when <a href="http://sourcemaking.com/design_patterns/observer">observable</a>
data changes. To make observable data, pass raw data to <a href="../docs/can.Map.html">can.Map</a>,
<a href="../docs/can.List.html">can.List</a> or <a href="../docs/can.compute.html">can.compute</a> like:</p>
<pre><code>var data = new can.Map({message: &quot;Hello World!&quot;});
</code></pre>
<p>To change the message, use the <a href="../docs/can.Map.prototype.attr.html">attr()</a> method of <code>can.Map</code>.</p>
<pre><code>data.attr(&quot;message&quot;, &quot;Goodbye World!&quot;)
</code></pre>
<p>When the button is clicked in the example below, the message is
changed with <code>data.attr()</code>.</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/quTtE/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>
<h3>Show a List in a Template</h3>
<p>To make an Array observable, pass it to <a href="../docs/can.List.html">can.List</a>.</p>
<pre><code>var people = new can.List([
    {firstname: &quot;John&quot;, lastname: &quot;Doe&quot;},
    {firstname: &quot;Emily&quot;, lastname: &quot;Dickinson&quot;}
])

var frag = can.view(&quot;app-template&quot;, {people: people})
$(&quot;#my-app&quot;).html(frag);
</code></pre>
<p>To show a list of data within a mustache template, use the <code>#each</code> operator.</p>
<pre><code>&lt;ul&gt;
{{#each people}}
  &lt;li&gt;
    {{lastname}}, {{firstname}}
  &lt;li&gt;
{{/each}}
&lt;/ul&gt;
</code></pre>
<p>Inside the <code>#each</code> block, the attributes are scoped to individual
objects in the list of <code>people</code>.</p>
<p>To make changes to the list, use an Array method such as
<a href="/docs/can.List.prototype.push.html">push</a>
or <a href="/docs/can.List.prototype.pop.html">pop</a>.</p>
<pre><code>// adds a new person
people.push({firstname: &quot;Paul&quot;, lastname: &quot;Newman&quot;})
// removes the last person
people.pop()
</code></pre>
<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/Pgbpa/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>
<h3>Show and Hide Elements</h3>
<p>Instead of showing and hiding elements by changing the DOM
directly like:</p>
<pre><code>$(&quot;h1&quot;).show()
$(&quot;h1&quot;).hide()
</code></pre>
<p>Make the template show or hide those elements when a value
changes.</p>
<pre><code>{{#if visible}}
  &lt;h1&gt;{{message}}&lt;/h1&gt;
{{/if}}
</code></pre>
<p>When the button is clicked, change the observable value.</p>
<pre><code>data.attr(&quot;visible&quot;, !data.attr(&quot;visible&quot;))
</code></pre>
<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/eFss4/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>
<h4>Application State</h4>
<p>Typically, it's not a good idea to mix view state and application data.
In the previous example, the <code>message</code> is application data, while the
<code>visible</code> property represents view state. In CanJS, state and data
should be separated using different observables.</p>
<pre><code>var data = new can.Map({message: &quot;Hello World!&quot;}),
    state = new can.Map({visible: true});

var frag = can.view(&quot;app-template&quot;, {
  data: data,
  state: state
})
</code></pre>
<p>As an application gets more complex, separating state from data
makes things more maintainable.</p>
<h3>Create a Live Timestamp</h3>
<p>This recipe demonstrates how to generate a 'live' timestamp
that displays in a human-readable format. This means handling
application state that changes over time, as well as making
information rendered in a template human-readable using a helper function.</p>
<p>First, we'll add a <code>createdAt</code> property to the data like:</p>
<pre><code> var data = new can.Map({
   message: &quot;Hello World&quot;,
   createdAt: new Date()
 })
</code></pre>
<p>On the page, this should be displayed as a human readable
timestamp:</p>
<pre><code> &lt;h1&gt;Hello World &lt;i&gt;created just now&lt;/i&gt;&lt;/h1&gt;
</code></pre>
<p><strong>and</strong> as time passes, the timestamp will update to:</p>
<pre><code>&lt;h1&gt;Hello World &lt;i&gt;created a few seconds ago&lt;/i&gt;&lt;/h1&gt;
</code></pre>
<p><strong>and</strong> then update to &quot;some seconds ago&quot; and so forth.</p>
<p>To accomplish this, create a <code>prettyDate</code> <a href="../docs/can.mustache.helper.html">mustache helper</a> that converts
dates into a human readable format.  A helper function is called from within the template where its result
will be displayed.  The following calls <code>prettyDate</code> with an observable value of <code>createdAt</code>.</p>
<pre><code>&lt;h1&gt;
  {{message}}
  &lt;i&gt;created {{prettyDate createdAt}}&lt;/i&gt;
&lt;/h1&gt;
</code></pre>
<p>To call a function from a template, <a href="../docs/can.mustache.registerHelper.html">register</a> it with <code>can.view</code>.
The third argument passed to <code>can.view</code> is an object with helper functions, so the <code>dateHelper</code> function
can be registered as <code>prettyView</code>.</p>
<pre><code>    var dateHelper = function ( date ) {
        //helper function
    }

var frag = can.view(&quot;app-template&quot;, data, {prettyDate: dateHelper});
</code></pre>
<p>In this helper, <code>date</code> is not a Date object, instead it is an observable <a href="../docs/can.compute.html">can.compute</a> that
contains the <code>createdAt</code> value.  A <code>can.compute</code> is an observable that contains a single value.  To read the value,
call the compute like you would any other function:</p>
<pre><code>date() //-&gt; Date
</code></pre>
<p>We need to compare <code>date</code> with the current time. The current time
will be represented by a compute:</p>
<pre><code>var now = can.compute( new Date() )
</code></pre>
<p>As the current time changes, we update <code>now</code> with the new time. To change the value of a <code>can.compute</code>,
call it with its new value as an argument:</p>
<pre><code>// update that property every second
setTimeout(function(){
    now( new Date() );
    setTimeout(arguments.callee, 1000);
},1000)
</code></pre>
<p>The <code>prettyDate</code> helper will read and compare the <code>date</code> and <code>now</code> compute to
get the time elapsed in seconds:</p>
<pre><code>var timeElapsed = ( now() - date() ) / 1000
</code></pre>
<p>Using the <code>timeElapsed</code>, <code>prettyDate</code> returns human readable timestamps:</p>
<pre><code>  if(timeElapsed &lt; 1.2){
    return &quot;just now&quot;
  } else if (timeElapsed &lt; 10) {
    return &quot;a couple seconds ago&quot;
  }
  ...
  else {
    return Math.round(difference/60)+&quot; minutes ago&quot;
  }
</code></pre>
<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/VQNSH/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>
<h2>Handle User Interaction</h2>
<p>When a user does something, such as clicking, an <code>event</code> occurs. Event handlers specify
how <a href="http://bitovi.com/blog/2010/10/a-crash-course-in-how-dom-events-work.html">JavaScript should respond to an event</a>.</p>
<p>This recipe will introduce handling a click event using a <a href="http://canjs.com/docs/can.Control"><code>can.Control</code></a>.
Using a list of people like previous recipes, clicking any individual person's name
will remove that person from the list.</p>
<p>Previous examples have used jQuery's event handlers:</p>
<pre><code>$(&quot;#push&quot;).click(function(){
  //handle the event
})
</code></pre>
<p>CanJS provides a few different ways to respond to events. As well as
making application code simpler, using CanJS to handle events can help to
automatically prevent <a href="http://bitovi.com/blog/2012/04/zombie-apocolypse.html">memory leaks</a>.</p>
<p>To handle events, extend <code>can.Control</code>.</p>
<pre><code>var PeopleList = can.Control.extend({
    //behavior
});
</code></pre>
<p>You create a <code>can.Control</code> by <a href="http://canjs.com/docs/can.Control.html#sig_newcan_Control_element_options_">calling it as a constructor function</a>.
The first argument is the element the control will be created on.
The second argument is an object of options.</p>
<pre><code>new PeopleList('#my-app', {people: people});
</code></pre>
<p>A <code>can.Control</code> handles events with functions declared with two arguments: an
element or list of elements (using a jQuery-style selector) and a specific event.
Below, this is 'li click', meaning when any <code>li</code> elements that are <code>clicked</code> the
function will be called to handle the click event.</p>
<pre><code>var PeopleList = can.Control.extend({
  init: function( element, options ){
       this.people = new can.List(options.people);
       this.element.html( can.view('app-template', {
             //defines people in the template as the observable can.List
           people: this.people
      }));
  },
    'li click': function( li, event ){
        //Handle the click event
    }
}
</code></pre>
<p>When the constructor function is called and the <code>can.Control</code>
is instantiated:</p>
<ol>
<li><p>The <code>init</code> method is called</p></li>
<li><p>An observable <code>can.List</code> is created from <code>people</code></p></li>
<li><p>The list is rendered using <code>can.view</code> so when the list changes, so will the view</p>
<pre><code> var people = [
     {firstname: &quot;John&quot;, lastname: &quot;Doe&quot;},
     {firstname: &quot;Emily&quot;, lastname: &quot;Dickinson&quot;},
     {firstname: &quot;William&quot;, lastname: &quot;Adams&quot;},
     {firstname: &quot;Stevie&quot;, lastname: &quot;Nicks&quot;},
     {firstname: &quot;Bob&quot;, lastname: &quot;Barker&quot;}
 ];
</code></pre></li>
</ol>
<p>When the event handler for a <code>click</code> runs, it needs a way
to access the object associated with the <code>li</code> that was clicked.
With the <a href="http://canjs.com/docs/can.mustache.helpers.data.html"><code>data</code></a> helper,
the element will retain a reference
to the object it is associated with (in this case, a <code>person</code>).</p>
<pre><code>&lt;ul&gt;
{{#each people}}
    &lt;li {{data 'person'}}&gt;
        {{lastname}}, {{firstname}}
    &lt;/li&gt;
{{/each}}
&lt;/ul&gt;  
</code></pre>
<p>Finally, the event handler must be defined. In a <code>can.Control</code>,
an event handler function <a href="http://canjs.com/docs/can.Control.html#section_Listeningtoevents">can be defined with a string containing
a selector and an event</a>.
In this case, these are <code>li</code> and <code>click</code>, recpectively,
since we want to handle click events on each list item.</p>
<pre><code>var PeopleList = can.Control.extend({
  init: function(){
    ...
  },
  'li click': function( li, event ) {
         var people = this.options.people;
         var person = li.data('person');
         var index = people.indexOf(person);
         people.splice(index, 1);
  }
});
</code></pre>
<p>When a user clicks a list item:</p>
<ol>
<li>The function bound to <code>li click</code> is called</li>
<li>The object associated with that list item is accessed using the <code>data</code> helper</li>
<li>That 'person's data is removed from the observable list of <code>people</code></li>
<li>The template updates automatically</li>
</ol>
<p>As a reminder, though event handlers respond to actions on the page,
they should <em>change application state or data</em> (e.g. make a change to a <code>can.Map</code>)
rather than modifying the DOM directly (e.g. toggling a class).
This will update the page automatically, keeping code manageable.</p>
<p>This is <em>one</em> way to handle events. Others will be covered
in the following recipes while building widgets.</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/F9kzt/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>
<h2>Build Widgets/UI Elements</h2>
<p>Previous recipes have demonstrated how to change page content and introduced
event handling. The following recipes will introduce <code>can.Component</code>,
which allows for straightforward widget construction by packaging
template, state, and event handling code in one place.</p>
<p>While similar <em>behavior</em> can be accomplished with <code>can.Control</code>,
building a Component enables building reusable widgets using custom
HTML tags.</p>
<h3>Create a Component</h3>
<p>The previous recipe that displays a list of people can instead
be represented as a component.</p>
<pre><code>&lt;people&gt;&lt;/people&gt;
</code></pre>
<p>By specifying <code>people</code> as the tag, a component is created wherever <code>&lt;people&gt;&lt;/people&gt;</code>
appears in a template.</p>
<pre><code>can.Component.extend({
    tag: 'people',
</code></pre>
<p>The <code>scope</code> object on a <code>Component</code> contains the component's state, data,
and behavior. Here, it specifies how to <code>remove</code> a person from the list:</p>
<pre><code>    scope: {
        people: people,
        remove: function( person ) {
            var people = this.attr(&quot;people&quot;);
            var index = people.indexOf(person);
            people.splice(index, 1);
        }
    }
});
</code></pre>
<p>The template for the component itself is passed via the <code>template</code>
property. This can either be an external file or a string.
Each <code>li</code> uses <code>can-click</code>, <a href="http://canjs.com/docs/can.view.bindings.can-EVENT.html">which declares an event binding.</a>
Here, <code>remove</code> inside the component's
scope will be called with the relevant <code>people</code> object
as an argument.</p>
<pre><code>scope: {
    template: '&lt;ul&gt;' +
                '{{#each people}}' +
                '&lt;li can-click=&quot;remove&quot;&gt;' +
                    '{{lastname}}, {{firstname}}' +
                '&lt;/li&gt;' +
                '{{/each}}' +
                '&lt;/ul&gt;',
...
</code></pre>
<p>This behaves similarly to the <code>can.Control</code> from above.
However, the <code>&lt;people&gt;</code> tag can be used without having
any knowledge about the inner workings of the widget.
Using declarative HTML tags, a component can be used
without writing any javascript. The template, state,
and behavior are all combined into one Component.</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/WBM9z/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>
<h3>Build a Tabs Widget</h3>
<p>A tabs widget could be instantiated with the following HTML:</p>
<pre><code>&lt;tabs&gt;
    &lt;panel title=&quot;Fruit&quot;&gt;Oranges, Apples, Pears&lt;/panel&gt;
    &lt;panel title=&quot;Vegetable&quot;&gt;Carrot, Lettuce, Rutabega&lt;/panel&gt;
    &lt;panel title=&quot;Grains&quot;&gt;Bread, Pasta, Rice&lt;/panel&gt;
&lt;/tabs&gt;
</code></pre>
<p>A designer that understands HTML can put together a template for a <code>tabs</code>
widget without understanding anything other than the syntax.
This is one of the most useful features of components.</p>
<h3>Tabs Widget Behavior</h3>
<p>Before implementing the component itself, we'll
define an observable <em>view model</em>--the <code>scope</code> object
of the UI element. This makes the code modular and easier
to manage (and also allows for unit testing).</p>
<p>In order to accurately represent a tabs widget,
a <code>TabsViewModel</code> needs:</p>
<ul>
<li>An observable list of panels</li>
<li>A state variable with the active panel</li>
<li>Helper methods to add, remove, and activate panels</li>
</ul>
<p>Since TabsViewModel is a <code>can.Map</code>, the <code>panels</code> property is
automatically converted to a <code>can.List</code>.
The <code>active</code> property references the <code>panel</code> object
that should currently be displayed.</p>
<pre><code>var TabsViewModel = can.Map.extend({
    panels: [],
    active: null,
    addPanel: function( panel ){
        var panels = this.attr(&quot;panels&quot;);
        panels.push(panel);
        panel.attr(&quot;visible&quot;, false);
        //activate panel if it is the first one
        if ( panels.attr(&quot;length&quot;) === 1 ){
            this.activate( panel );
        }
    },
    removePanel: function( panel ){
        var panels = this.attr(&quot;panels&quot;);
        var index = panels.indexOf(panel);
        panels.splice(index, 1);
        //activate a new panel if panel being removed was the active panel
        if( this.attr(&quot;active&quot;) === panel ){
            panels.attr(&quot;length&quot;) ? this.activate(panels[0]) : this.attr(&quot;active&quot;, null)
        }
    },
    activate: function( panel ){
        var active = this.attr(&quot;active&quot;)
        if( active !== panel ){
            active &amp;&amp; active.attr(&quot;visible&quot;, false);
            this.attr(&quot;active&quot;, panel.attr(&quot;visible&quot;, true));
        }
    }
})
</code></pre>
<h4>Tabs Widget Component</h4>
<p>Now that the view model is defined, making a component is simply
a matter of defining the way the tabs widget is displayed.</p>
<p>The template for a <code>tabs</code> component needs a list of panel titles
that will <code>activate</code> that panel when clicked. By calling <code>activate</code>
with a panel as the argument, the properties of the <code>panel</code> can
be manipulated. By changing the <code>visible</code> property of a panel,
a template can be used to display or hide the panel accordingly.</p>
<p>For this component, our template should look something like this:</p>
<pre><code>&lt;tabs&gt;
    &lt;panel title=&quot;Fruits&quot;&gt;Apples, Oranges&lt;/panel&gt;
    &lt;panel title=&quot;Vegetables&quot;&gt;Carrots, Celery&lt;/panel&gt;
&lt;/tabs&gt;
</code></pre>
<p>A designer can create a <code>tabs</code> component with <code>panel</code> components inside it.
The <code>template</code> object on the tabs component's scope needs to be able to render
the content that is inside of the <code>&lt;tabs&gt;</code> tag. To do this, we simply use the
<code>&lt;content&gt;</code> tag, which will render everything within the component's tags:</p>
<pre><code>can.Component.extend({
    tag: &quot;tabs&quot;,
    scope: TabsViewModel,
    template: &quot;&lt;ul&gt;\
                {{#each panels}}\
                    &lt;li can-click='activate'&gt;{{title}}&lt;/li&gt;\
                {{/each}}\
                &lt;/ul&gt;\
                &lt;content /&gt;&quot;
});
</code></pre>
<p>The <code>tabs</code> component contains panels, which are also defined
as components. The tabs template contains the logic for whether
the panel is visible (<code>visible</code> is controlled by the tabs
component's <code>activate</code> method).</p>
<p>Each panel's <code>scope</code> contains a title, which should be
taken from the <code>title</code> attribute in the <code>&lt;panel&gt;</code> tag.
If you want to set the string value of a Component's
attribute as a <code>scope</code> variable, use  <code>@'</code>.</p>
<pre><code>can.Component.extend({
tag: &quot;panel&quot;,
template: &quot;{{#if visible}}&lt;content /&gt;{{/if}}&quot;,
scope: {
    title: &quot;@&quot;
},
...
</code></pre>
<p>In addition to the <code>scope</code> property, a component has an
<a href="http://canjs.com/docs/can.Component.prototype.events.html"><code>events</code> property</a>.
This <code>events</code> property uses a <code>can.Control</code> instantiated inside
the component to handle events.</p>
<p>Since we defined behavior for adding panels on the parent
<code>tabs</code> component, we should use this method whenever a <code>panel</code>
is inserted into the page (and an <code>inserted</code> event is triggered).
To add the panel to the <code>tabs</code> component's scope, we call the
<code>addPanel</code> method by accessing the parent scope with <code>this.element.parent().scope()</code>:</p>
<pre><code>...
    events: {
        inserted: function() {
            this.element.parent().scope().addPanel( this.scope )
        },
        removed: function() {
            this.element.parent().scope().addPanel( this.scope )
        }
    }
});
</code></pre>
<p>With this component, any time a <code>&lt;tabs&gt;</code> element with
<code>&lt;panel&gt;</code> elements is put in a page, a tabs widget will
automatically be created. This allows application behavior
and design to be compartmentalized from each other.</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/x6TJK/2/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>
<h2>Build an Application with Data from a Server</h2>
<p>In CanJS, <code>can.Model</code> adds functionality to <code>can.Map</code> to
work with data on a server.  It enables you to:</p>
<ul>
<li>Get and modify data from a server</li>
<li>Listen to changes made to the data on the server</li>
<li>Unify service data with other objects in your application</li>
</ul>
<p><code>can.Model</code> allows you to access data from a server
easily:</p>
<pre><code>var Todo = can.Model.extend({
  findAll: 'GET /todos',
  findOne: 'GET /todos/{id}',
  create:  'POST /todos',
  update:  'PUT /todos/{id}',
  destroy: 'DELETE /todos/{id}'
},{});
</code></pre>
<p>Using <em>any</em> server with a <a href="http://blog.mashape.com/post/60820526317/list-of-40-tutorials-on-how-to-create-an-api"><em>REST</em> interface</a>,
<code>can.Model</code> enables create, read, update, and destroy functionality.</p>
<h3>Create a Chat Application</h3>
<p>To put together a chat application, we'll use two methods
from <code>can.Model</code> to fetch the messages and create new ones:</p>
<pre><code>var Message = can.Model({
    findAll : 'GET ' + myServerUrl + '/messages',
    create : 'POST ' + myServerUrl + '/messages'
},{});
</code></pre>
<p>In a chat component's scope, we will use the <code>Message</code> model to
save new messages and observe changes to the Model.
<a href="http://canjs.com/docs/can.Model.List.html#sig_newcan_Model_List__models__"><code>new Message.List({})</code></a> is a shortcut to perform
the <a href="http://canjs.com/docs/can.Model.findAll.html"><code>findAll</code></a> operation on a <code>can.Model</code> and
return a <code>can.List</code>.</p>
<pre><code>...
    scope: {
            messages: new Message.List({}),
            newMessage: &quot;&quot;
...
</code></pre>
<p>The tabs Component used <code>can-click</code> to listen for click events.
Since this chat application uses a <code>&lt;form&gt;</code> for sending messages, we'll use
<code>can-submit</code> to specify an event handler.</p>
<p>There's one more helper used in the template: <a href="http://canjs.com/docs/can.view.bindings.can-value.html"><code>can-value</code></a>.
This automatically two-way binds the value of an input field to an observable
property on the <code>scope</code> of the component (in this case, <code>newMessage</code>).</p>
<pre><code>can.Component.extend({
  tag: 'chat',
  template: '&lt;ul id=&quot;messages&quot;&gt;' +
              '{{#each messages}}' +
              '&lt;li&gt;{{body}}&lt;/li&gt;' +
              '{{/each}}' +
            '&lt;/ul&gt;' +
            '&lt;form id=&quot;create-message&quot; action=&quot;&quot; can-submit=&quot;submitMessage&quot;&gt;' +
                '&lt;input type=&quot;text&quot; id=&quot;body&quot; placeholder=&quot;type message here...&quot;' +
                'can-value=&quot;newMessage&quot; /&gt;' +
            '&lt;/form&gt;',
...
</code></pre>
<p>When <code>submitMessage</code> is called, a new <code>Message</code> is created
with <code>new Message()</code>. Since <code>can-value</code> was declared on the <code>input</code> element, <code>newMessage</code> will
always be the current text in the <code>input</code> field.
The body of the message is fetched from
the Component's <code>newMessage</code> attribute when a user submits the form.</p>
<p>To save the new message to the server, call <code>save()</code>.</p>
<pre><code>submitMessage: function(scope, el, ev){
    ev.preventDefault();
    new Message({body: this.attr(&quot;newMessage&quot;)}).save();
    this.attr(&quot;newMessage&quot;, &quot;&quot;);
}
</code></pre>
<p>Finally, when a new <code>Message</code> is created, the <code>messages</code> list
must be updated.</p>
<pre><code>events: {
    '{Message} created': function(construct, ev, message){
        this.scope.attr('messages').push(message);
    }
}
</code></pre>
<p>There are two ways that messages are added: from the current user,
or from another user. In the next section, we demonstrate how to use
<a href="http://socket.io/">socket.io</a> to update the <code>Message</code> model with messages
from other users in real time. Binding to the <code>created</code> event for <strong>all</strong>
messages allows us to create a single entry point that pushes new messages
to the <code>scope</code>, <a href="http://canjs.com/docs/can.Model.html#section_Listentochangesindata">regardless of where those messages are from.</a></p>
<p>When the chat Component is loaded, messages are loaded from the server
using <code>can.Model</code> and <code>new Message.List({})</code>.  When a new message is
submitted:</p>
<ol>
<li><code>submitMessage</code> is called via the event handler bound by the <code>can-submit</code> attribute</li>
<li>a new <code>Message</code> is created and saved to the server</li>
<li><code>'{Message} created'</code> detects this change and adds the new message to <code>messages</code></li>
<li>The template is automatically updated since <code>messages</code> is an observable <code>can.List</code></li>
</ol>
<h3>Add real-time functionality</h3>
<p>This example uses <a href="http://socket.io/">socket.io</a>
to enable real-time functionality. This guide won't go
into detail on how to use <code>socket.io</code>, but for real-time
chat the application needs two more things.</p>
<p>When a message is created on another chat client, <code>socket.io</code>
will notify this client by triggering the <code>message-created</code> event,
wich will render the new message in the page by adding it to the
<code>Message</code> model.</p>
<pre><code>var socket = io.connect(myServerUrl)
socket.on('message-created', function(message){
    new Message(message).created();
})
</code></pre>
<p>To keep the <code>created</code> event from firing
twice, we modify the <code>create</code> function in the model.
If there was simply a <code>return</code> statement, <code>Model</code> would
create and fire a <code>create</code> event, which <code>socket</code> is already
doing. By returning a <code>Deferred</code>, we prevent firing of
one of these events.</p>
<pre><code>var Message = can.Model({
findAll : 'GET ' + myServerUrl + '/messages',
create : function(attrs) {
    $.post(myServerUrl + '/messages', attrs);
    //keep '{Message} created' from firing twice
    return $.Deferred();
}
},{});
</code></pre>
<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/afC94/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>
<h2>Add my own recipe</h2>
<p>To add your own recipe, simply <a href="https://github.com/bitovi/canjs/edit/gh-pages/recipes.md">edit this file</a>. To
help create a JSFiddle, we've created the following fiddles you can fork:</p>
<ul>
<li><a href="http://jsfiddle.net/donejs/qYdwR/">jQuery and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/7Yaxk/">Zepto and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/9x96n/">Dojo and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/w6m73/">YUI and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/mnNJX/">Mootools and CanJS</a></li>
</ul>
<h2>Request a Recipe</h2>
<p>To request a new recipe or vote on an upcoming one, <a href="https://github.com/bitovi/canjs.com/issues">submit an issue</a>
to the <code>canjs.com</code> respository on GitHub.</p>

		</section>
		
		

		
	
	
	</article>
	
	

</div>





	
	
	<footer>
		<nav class="container">
			<a class="brand" href="index.html"></a>
			<ul class='nav'>
				<li >
	              <a href="../index.html">Home</a>
	            </li>
		        <li class='active'><a href='index.html'>guides</a></li>
		        <li><a href='../docs/index.html'>api</a></li>
		        <li class="">
		          <a href="../community.html#!forums">Community</a>
		        </li>
		        <li >
	              <a href="../blog/index.html">Blog</a>
	            </li>
		        <li >
	              <a href="../download.html">Download</a>
	            </li>
            </ul>
		</nav>
	</footer>
	

    
    <script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-2302003-11']);
	  _gaq.push(['_setDomainName', 'canjs.com']);
	  _gaq.push(['_setAllowLinker', true]);
	  _gaq.push(['_trackPageview']);
	
	  (function() {
	  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();
	
	</script>
	
	<script type="text/javascript">
		var docObject = {"type":"page","name":"Recipes","src":"guides/recipes.md","description":"","title":"Recipes","parent":"guides","order":4,"comment":" ","ignoreTemplateRender":true,"templates":"/Users/justin/dev/canjs.com/theme/templates","static":"/Users/justin/dev/canjs.com/theme/static","versionsSelectText":"CanJS v<%= version %>","glob":{"pattern":"{guides/*.md,*.md}","ignore":"{node_modules,bower_components}/**/*","cwd":"/Users/justin/dev/canjs.com/can"},"dest":"/Users/justin/dev/canjs.com/guides","generators":["html"],"urls":{"builderData":"https://bitbuilder.herokuapp.com/canjs","builder":"https://bitbuilder.herokuapp.com/can.custom.js","bithub":"http://bitovi.bithub.com/api/v1/events/","cdn":"//canjs.com/release/","github":"https://github.com/bitovi/canjs.com"},"versions":[{"branch":"master","number":"2.1"},{"number":"2.0"},{"number":"1.1"}],"defaultDownloadVersion":"2.2.4","docConfigDest":"../documentjs.json","project":{"version":"2.2","name":"canjs","source":"git://github.com/bitovi/canjs#master"}};
	</script>
	
	
		<script>
		  steal = {
		    instantiated: {
		      "bundles/static.css!$css" : null
		    }
		  }
		</script>
		<script type='text/javascript' 
				data-main="static"
				data-config="./static/config.js"
				src="./static/steal.production.js"
		    		bundles-path="bundles"></script>
	
	
</body>

</html>