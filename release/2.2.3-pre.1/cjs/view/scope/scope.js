/*!
 * CanJS - 2.2.3-pre.0
 * http://canjs.com/
 * Copyright (c) 2015 Bitovi
 * Thu, 02 Apr 2015 20:20:11 GMT
 * Licensed MIT
 */

/*can@2.2.3-pre.0#view/scope/scope*/
var can = require('../../util/util.js');
require('../../construct/construct.js');
require('../../map/map.js');
require('../../list/list.js');
require('../view.js');
require('../../compute/compute.js');
var escapeReg = /(\\)?\./g, escapeDotReg = /\\\./g, getNames = function (attr) {
        var names = [], last = 0;
        attr.replace(escapeReg, function (first, second, index) {
            if (!second) {
                names.push(attr.slice(last, index).replace(escapeDotReg, '.'));
                last = index + first.length;
            }
        });
        names.push(attr.slice(last).replace(escapeDotReg, '.'));
        return names;
    };
var Scope = can.Construct.extend({ read: can.compute.read }, {
        init: function (context, parent) {
            this._context = context;
            this._parent = parent;
            this.__cache = {};
        },
        attr: function (key, value) {
            var previousReads = can.__clearReading(), options = {
                    isArgument: true,
                    returnObserveMethods: true,
                    proxyMethods: false
                }, res = this.read(key, options);
            if (arguments.length === 2) {
                var lastIndex = key.lastIndexOf('.'), readKey = lastIndex !== -1 ? key.substring(0, lastIndex) : '.', obj = this.read(readKey, options).value;
                if (lastIndex !== -1) {
                    key = key.substring(lastIndex + 1, key.length);
                }
                can.compute.set(obj, key, value, options);
            }
            can.__setReading(previousReads);
            return res.value;
        },
        add: function (context) {
            if (context !== this._context) {
                return new this.constructor(context, this);
            } else {
                return this;
            }
        },
        computeData: function (key, options) {
            options = options || { args: [] };
            var self = this, rootObserve, rootReads, computeData = {
                    compute: can.compute(function (newVal) {
                        if (arguments.length) {
                            if (rootObserve.isComputed) {
                                rootObserve(newVal);
                            } else if (rootReads.length) {
                                var last = rootReads.length - 1;
                                var obj = rootReads.length ? can.compute.read(rootObserve, rootReads.slice(0, last)).value : rootObserve;
                                can.compute.set(obj, rootReads[last], newVal, options);
                            }
                        } else {
                            if (rootObserve) {
                                return can.compute.read(rootObserve, rootReads, options).value;
                            }
                            var data = self.read(key, options);
                            rootObserve = data.rootObserve;
                            rootReads = data.reads;
                            computeData.scope = data.scope;
                            computeData.initialValue = data.value;
                            computeData.reads = data.reads;
                            computeData.root = rootObserve;
                            return data.value;
                        }
                    })
                };
            return computeData;
        },
        compute: function (key, options) {
            return this.computeData(key, options).compute;
        },
        read: function (attr, options) {
            var stopLookup;
            if (attr.substr(0, 2) === './') {
                stopLookup = true;
                attr = attr.substr(2);
            } else if (attr.substr(0, 3) === '../') {
                return this._parent.read(attr.substr(3), options);
            } else if (attr === '..') {
                return { value: this._parent._context };
            } else if (attr === '.' || attr === 'this') {
                return { value: this._context };
            }
            var names = attr.indexOf('\\.') === -1 ? attr.split('.') : getNames(attr), context, scope = this, defaultObserve, defaultReads = [], defaultPropertyDepth = -1, defaultComputeReadings, defaultScope, currentObserve, currentReads;
            while (scope) {
                context = scope._context;
                if (context !== null) {
                    var data = can.compute.read(context, names, can.simpleExtend({
                            foundObservable: function (observe, nameIndex) {
                                currentObserve = observe;
                                currentReads = names.slice(nameIndex);
                            },
                            earlyExit: function (parentValue, nameIndex) {
                                if (nameIndex > defaultPropertyDepth) {
                                    defaultObserve = currentObserve;
                                    defaultReads = currentReads;
                                    defaultPropertyDepth = nameIndex;
                                    defaultScope = scope;
                                    defaultComputeReadings = can.__clearReading();
                                }
                            },
                            executeAnonymousFunctions: true
                        }, options));
                    if (data.value !== undefined) {
                        return {
                            scope: scope,
                            rootObserve: currentObserve,
                            value: data.value,
                            reads: currentReads
                        };
                    }
                }
                can.__clearReading();
                if (!stopLookup) {
                    scope = scope._parent;
                } else {
                    scope = null;
                }
            }
            if (defaultObserve) {
                can.__setReading(defaultComputeReadings);
                return {
                    scope: defaultScope,
                    rootObserve: defaultObserve,
                    reads: defaultReads,
                    value: undefined
                };
            } else {
                return {
                    names: names,
                    value: undefined
                };
            }
        }
    });
can.view.Scope = Scope;
module.exports = Scope;
