<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Recipes - CanJS Guides</title>
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="shortcut icon" type="image/png" href="/canjs-logo-32x32.png"/>
  
  <link rel="stylesheet" type="text/css" 
    
      href='./static/production.css'
     />
  <!--[if lt IE 9]>
   <script type="text/javascript" src="../scripts/static/lib/html5shiv.js"></script>
    <!--<![endif]-->
</head>

<body class="guides">
  <header>
    <nav class="container">

      <div class="logo-menu">
        <a class="brand canjs" href="../../index.html">CanJS</a>
        <ul class="dropdown-menu">
          <li><a href="http://javascriptmvc.com">JavaScriptMVC</a></li>
          <li class="active"><a href="../../index.html">CanJS</a></li>
          <li><a href="http://jquerypp.com">jQuery++</a></li>
          <li><a href="http://javascriptmvc.com/docs.html#!stealjs">StealJS</a></li>
          <li><a href="http://funcunit.com">FuncUnit</a></li>
          <li><a href="http://javascriptmvc.com/docs.html#!DocumentJS">DocumentJS</a></li>
        </ul>
      </div>
      <ul class="nav">
        <li class=""><a href="../../index.html">Home</a></li>
        <li class="active"><a href="../guides/index.html">Guides</a></li>
        <li class=""><a href="../docs/index.html">Api</a></li>
        <li class=" community-menu">
          <a href="../../community.html#!forums">Community</a>
          <ul class="dropdown-menu">
            <li><a href="https://forum.javascriptmvc.com/canjs">Forums</a></li>
            <li><a href="http://webchat.freenode.net/?channels=canjs">IRC</a></li>
            <li><a href="http://bitovi.bithub.com/canjs/app/">Apps</a></li>
            <li><a href="http://bitovi.bithub.com/canjs/plugin/">Plugins</a></li>
            <li><a href="http://bitovi.bithub.com/canjs/article/">Articles</a></li>
            <li><a href="http://github.com/bitovi/canjs">Github</a></li>
            <li><a href="http://twitter.com/canjs">Twitter</a></li>
            <li><a href="http://bitovi.github.io/canjsmeetup/">Meetups</a></li>
          </ul>
        </li>
        <li class=""><a href="../../blog/index.html">Blog</a></li>
        <li class=""><a href="../../download.html">Download</a></li>
      </ul>
      <div class="pull-right">
        <div class="bitovi-menu">
          <a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
          <ul class="dropdown-menu">
            <li><a href="http://bitovi.com">Bitovi.com</a></li>
            <li><a href="http://bitovi.com/blog/">Blog</a></li>
            <li><a href="http://bitovi.com/consulting/">Consulting</a></li>
            <li><a href="http://bitovi.com/training/">Training</a></li>
            <li><a href="http://bitovi.com/open-source/">Open Source</a></li>
            <li><a href="http://bitovi.com/people/">People</a></li>
            <li><a href="http://bitovi.com/contact/">Contact Us</a></li>
          </ul>
        </div>
      </div>
    </nav>
  </header>

  <div class="container api">
	<nav class="sidebar">
		
		<div class="search-wrapper">
			<div class="search">
				<input type="text"/>
			</div>
		</div>
		
		<h2 id="version">
<select id="versions">
	<option value="">CanJS v2.1</option>
</select>
</h2>
<ul class="api">
	<!-- First Level -->
	
	   <li class="search-container">
	   		<a href="Tutorial.html" data-search="Getting Started">
				Getting Started
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="Using.html" data-search="Setting up CanJS">
				Setting up CanJS
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="Why.html" data-search="Why CanJS?">
				Why CanJS?
			</a>
			
	   </li>
	
	   <li class="search-container active">
	   		<a href="Recipes.html" data-search="Recipes">
				Recipes
			</a>
			
				
			
	   </li>
	
	   <li class="search-container">
	   		<a href="contributing.html" data-search="How to Contribute">
				How to Contribute
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="changelog.html" data-search="Changelog">
				Changelog
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="license.html" data-search="License">
				License
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="migrating.html" data-search="Migrating to 2.0">
				Migrating to 2.0
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="roadmap.html" data-search="Roadmap">
				Roadmap
			</a>
			
	   </li>
	
</ul>
	</nav>
	<article class="content docs">
		<section class="title">
			<div class="heading">
<h1>Recipes</h1>
	<ul class="tags">
		<li>page</li>
	</ul>
	
	
	
		<span class="module">Recipes</span>
	
	
	
	
</div>

<div class="sub-heading">
	
	<span class="inherits">&nbsp;</span>
</div>

<ul class="links">
    
	
		<li><a href="https://github.com/bitovi/canjs/wiki/can/guides/recipes">source</a></li>
	
	
		
	
	
</ul>
<br />
		</section>

		<section class="contents">
		</section>

		

		<section class="description">
			
		</section>

		

		
		
		
		

		
		<section class="comment">
			<h2>Get Started</h2>

<p>There are a variety of ways to get CanJS.  Read the <a href="http://canjs.com/guides/Using.html">using CanJS guide</a>
for comprehensive list.  For the following recipes, we will load CanJS
with a <code>&lt;script&gt;</code> tag pointed to CanJS's CDN.</p>

<p>Create a file called <code>myapp.html</code> and put the following in it to get started:</p>

<pre><code>&lt;script src="//code.jquery.com/jquery-1.10.1.min.js"&gt;&lt;/script&gt;
&lt;script src="//canjs.com/release/2.0.4/can.jquery.js"&gt;&lt;/script&gt;
&lt;script type="text/mustache" id="app-template"&gt;
//Template will go here
&lt;/script&gt;
&lt;script&gt;
//Application code will go here
&lt;/script&gt;

&lt;!-- CanJS needs a place to put your application --&gt;
&lt;div id="my-app"&gt;&lt;/div&gt;
</code></pre>

<p>To follow along with the other recipes, you can also use
<a href="http://jsfiddle.net/donejs/GE3yf/">this JSFiddle</a> as a template.</p>

<p>You can also <a href="http://canjs.com/download.html">Download CanJS</a>
or follow <a href="http://canjs.com/guides/Tutorial.html">other tutorials</a> to get
started, but for the rest of the examples below, we'll be using this
setup.</p>

<h2>Say "Hello World"</h2>

<p>In CanJS, content is displayed using <em>templates</em>.  Instead of manually
changing elements in the DOM, you create a template and CanJS
automatically updates the page from the data in your application code.</p>

<h3>Template</h3>

<p>In the template section of <code>myapp.html</code>, put the following:</p>

<pre><code>&lt;script type="text/mustache" id="app-template"&gt;
&lt;h1&gt;{{message}}&lt;/h1&gt;
&lt;/script&gt;
</code></pre>

<p>This template displays the value of <code>message</code>.</p>

<h3>Pass message to the Template</h3>

<p>Templates are rendered with <a href="../docs/can.view.html">can.view</a>, which takes two arguments: the first is the <code>id</code> of the template,
and the second is the data passed to the template (in this case,
an object with a <code>message</code> property).</p>

<p>Render the template with a <code>message</code> and insert it into the page with:</p>

<pre><code>&lt;script&gt;
// Give message a value
var data = {message: "Hello World!"};

// Pass the id of the template and the data, containing our message to can.view
var frag = can.view("app-template", data);

//Load the DocumentFragment in the page
$("#my-app").html( frag )
&lt;/script&gt;
</code></pre>

<blockquote>
  <p><code>frag</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment">DocumentFragment</a>. A DocumentFragment
  is a lightweight container of HTMLElements that can be inserted in the page quickly. They can be used
  anywhere a normal HTMLElement is used.</p>
</blockquote>

<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/GE3yf/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>

<h2>Update Text in the Page</h2>

<p>CanJS will update the page automatically when <a href="http://sourcemaking.com/design_patterns/observer">observable</a>
data changes. To make observable data, pass raw data to <a href="../docs/can.Map.html">can.Map</a>,
<a href="../docs/can.List.html">can.List</a> or <a href="../docs/can.compute.html">can.compute</a> like:</p>

<pre><code>var data = new can.Map({message: "Hello World!"});
</code></pre>

<p>To change the message, use the <a href="../docs/can.Map.prototype.attr.html">attr()</a> method of <code>can.Map</code>.</p>

<pre><code>data.attr("message", "Goodbye World!")
</code></pre>

<p>When the button is clicked in the example below, the message is
changed with <code>data.attr()</code>.</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/quTtE/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>

<h3>Show a List in a Template</h3>

<p>To make an Array observable, pass it to <a href="../docs/can.List.html">can.List</a>.</p>

<pre><code>var people = new can.List([
    {firstname: "John", lastname: "Doe"},
    {firstname: "Emily", lastname: "Dickinson"}
])

var frag = can.view("app-template", {people: people})
$("#my-app").html(frag);
</code></pre>

<p>To show a list of data within a mustache template, use the <code>#each</code> operator.</p>

<pre><code>&lt;ul&gt;
{{#each people}}
  &lt;li&gt;
    {{lastname}}, {{firstname}}
  &lt;li&gt;
{{/each}}
&lt;/ul&gt;
</code></pre>

<p>Inside the <code>#each</code> block, the attributes are scoped to individual
objects in the list of <code>people</code>.</p>

<p>To make changes to the list, use an Array method such as
<a href="/docs/can.List.prototype.push.html">push</a>
or <a href="/docs/can.List.prototype.pop.html">pop</a>.</p>

<pre><code>// adds a new person
people.push({firstname: "Paul", lastname: "Newman"})
// removes the last person
people.pop()
</code></pre>

<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/Pgbpa/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>

<h3>Show and Hide Elements</h3>

<p>Instead of showing and hiding elements by changing the DOM
directly like:</p>

<pre><code>$("h1").show()
$("h1").hide()
</code></pre>

<p>Make the template show or hide those elements when a value
changes.  </p>

<pre><code>{{#if visible}}
  &lt;h1&gt;{{message}}&lt;/h1&gt;
{{/if}}
</code></pre>

<p>When the button is clicked, change the observable value.</p>

<pre><code>data.attr("visible", !data.attr("visible"))
</code></pre>

<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/eFss4/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>

<h4>Application State</h4>

<p>Typically, it's not a good idea to mix view state and application data.
In the previous example, the <code>message</code> is application data, while the
<code>visible</code> property represents view state. In CanJS, state and data
should be separated using different observables.</p>

<pre><code>var data = new can.Map({message: "Hello World!"}),
    state = new can.Map({visible: true});

var frag = can.view("app-template", {
  data: data,
  state: state
})
</code></pre>

<p>As an application gets more complex, separating state from data
makes things more maintainable.</p>

<h3>Create a Live Timestamp</h3>

<p>This recipe demonstrates how to generate a 'live' timestamp
that displays in a human-readable format. This means handling
application state that changes over time, as well as making
information rendered in a template human-readable using a helper function.</p>

<p>First, we'll add a <code>createdAt</code> property to the data like:</p>

<pre><code> var data = new can.Map({
   message: "Hello World",
   createdAt: new Date()
 })
</code></pre>

<p>On the page, this should be displayed as a human readable
timestamp:</p>

<pre><code> &lt;h1&gt;Hello World &lt;i&gt;created just now&lt;/i&gt;&lt;/h1&gt;
</code></pre>

<p><strong>and</strong> as time passes, the timestamp will update to:</p>

<pre><code>&lt;h1&gt;Hello World &lt;i&gt;created a few seconds ago&lt;/i&gt;&lt;/h1&gt;
</code></pre>

<p><strong>and</strong> then update to "some seconds ago" and so forth.</p>

<p>To accomplish this, create a <code>prettyDate</code> <a href="../docs/can.mustache.helper.html">mustache helper</a> that converts
dates into a human readable format.  A helper function is called from within the template where its result
will be displayed.  The following calls <code>prettyDate</code> with an observable value of <code>createdAt</code>.</p>

<pre><code>&lt;h1&gt;
  {{message}}
  &lt;i&gt;created {{prettyDate createdAt}}&lt;/i&gt;
&lt;/h1&gt;
</code></pre>

<p>To call a function from a template, <a href="../docs/can.mustache.registerHelper.html">register</a> it with <code>can.view</code>.
The third argument passed to <code>can.view</code> is an object with helper functions, so the <code>dateHelper</code> function
can be registered as <code>prettyView</code>.</p>

<pre><code>    var dateHelper = function ( date ) {
        //helper function
    }

var frag = can.view("app-template", data, {prettyDate: dateHelper});
</code></pre>

<p>In this helper, <code>date</code> is not a Date object, instead it is an observable <a href="../docs/can.compute.html">can.compute</a> that
contains the <code>createdAt</code> value.  A <code>can.compute</code> is an observable that contains a single value.  To read the value,
call the compute like you would any other function:</p>

<pre><code>date() //-&gt; Date
</code></pre>

<p>We need to compare <code>date</code> with the current time. The current time
will be represented by a compute:</p>

<pre><code>var now = can.compute( new Date() )
</code></pre>

<p>As the current time changes, we update <code>now</code> with the new time. To change the value of a <code>can.compute</code>,
call it with its new value as an argument:</p>

<pre><code>// update that property every second
setTimeout(function(){
    now( new Date() );
    setTimeout(arguments.callee, 1000);
},1000)
</code></pre>

<p>The <code>prettyDate</code> helper will read and compare the <code>date</code> and <code>now</code> compute to
get the time elapsed in seconds:</p>

<pre><code>var timeElapsed = ( now() - date() ) / 1000
</code></pre>

<p>Using the <code>timeElapsed</code>, <code>prettyDate</code> returns human readable timestamps:</p>

<pre><code>  if(timeElapsed &lt; 1.2){
    return "just now"
  } else if (timeElapsed &lt; 10) {
    return "a couple seconds ago"
  }
  ...
  else {
    return Math.round(difference/60)+" minutes ago"
  }
</code></pre>

<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/VQNSH/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>

<h2>Handle User Interaction</h2>

<p>When a user does something, such as clicking, an <code>event</code> occurs. Event handlers specify
how <a href="http://bitovi.com/blog/2010/10/a-crash-course-in-how-dom-events-work.html">JavaScript should respond to an event</a>.</p>

<p>This recipe will introduce handling a click event using a <a href="http://canjs.com/docs/can.Control"><code>can.Control</code></a>.
Using a list of people like previous recipes, clicking any individual person's name
will remove that person from the list.</p>

<p>Previous examples have used jQuery's event handlers:</p>

<pre><code>$("#push").click(function(){
  //handle the event
})
</code></pre>

<p>CanJS provides a few different ways to respond to events. As well as
making application code simpler, using CanJS to handle events can help to
automatically prevent <a href="http://bitovi.com/blog/2012/04/zombie-apocolypse.html">memory leaks</a>.</p>

<p>To handle events, extend <code>can.Control</code>.</p>

<pre><code>var PeopleList = can.Control.extend({
    //behavior
});
</code></pre>

<p>You create a <code>can.Control</code> by <a href="http://canjs.com/docs/can.Control.html#sig_newcan_Control_element_options_">calling it as a constructor function</a>.
The first argument is the element the control will be created on.
The second argument is an object of options.</p>

<pre><code>new PeopleList('#my-app', {people: people});
</code></pre>

<p>A <code>can.Control</code> handles events with functions declared with two arguments: an
element or list of elements (using a jQuery-style selector) and a specific event.
Below, this is 'li click', meaning when any <code>li</code> elements that are <code>clicked</code> the
function will be called to handle the click event. </p>

<pre><code>var PeopleList = can.Control.extend({
  init: function( element, options ){
       this.people = new can.List(options.people);
       this.element.html( can.view('app-template', {
             //defines people in the template as the observable can.List
           people: this.people
      }));
  },
    'li click': function( li, event ){
        //Handle the click event
    }
}
</code></pre>

<p>When the constructor function is called and the <code>can.Control</code>
is instantiated:</p>

<ol>
<li>The <code>init</code> method is called</li>
<li>An observable <code>can.List</code> is created from <code>people</code></li>
<li><p>The list is rendered using <code>can.view</code> so when the list changes, so will the view</p>

<pre><code>var people = [
    {firstname: "John", lastname: "Doe"},
    {firstname: "Emily", lastname: "Dickinson"},
    {firstname: "William", lastname: "Adams"},
    {firstname: "Stevie", lastname: "Nicks"},
    {firstname: "Bob", lastname: "Barker"}
];
</code></pre></li>
</ol>

<p>When the event handler for a <code>click</code> runs, it needs a way
to access the object associated with the <code>li</code> that was clicked.
With the <a href="http://canjs.com/docs/can.mustache.helpers.data.html"><code>data</code></a> helper,
the element will retain a reference
to the object it is associated with (in this case, a <code>person</code>).</p>

<pre><code>&lt;ul&gt;
{{#each people}}
    &lt;li {{data 'person'}}&gt;
        {{lastname}}, {{firstname}}
    &lt;/li&gt;
{{/each}}
&lt;/ul&gt;  
</code></pre>

<p>Finally, the event handler must be defined. In a <code>can.Control</code>,
an event handler function <a href="http://canjs.com/docs/can.Control.html#section_Listeningtoevents">can be defined with a string containing
a selector and an event</a>.
In this case, these are <code>li</code> and <code>click</code>, recpectively,
since we want to handle click events on each list item.</p>

<pre><code>var PeopleList = can.Control.extend({
  init: function(){
    ...
  },
  'li click': function( li, event ) {
         var people = this.options.people;
         var person = li.data('person');
         var index = people.indexOf(person);
         people.splice(index, 1);
  }
});
</code></pre>

<p>When a user clicks a list item:</p>

<ol>
<li>The function bound to <code>li click</code> is called</li>
<li>The object associated with that list item is accessed using the <code>data</code> helper</li>
<li>That 'person's data is removed from the observable list of <code>people</code></li>
<li>The template updates automatically</li>
</ol>

<p>As a reminder, though event handlers respond to actions on the page,
they should <em>change application state or data</em> (e.g. make a change to a <code>can.Map</code>)
rather than modifying the DOM directly (e.g. toggling a class).
This will update the page automatically, keeping code manageable.</p>

<p>This is <em>one</em> way to handle events. Others will be covered
in the following recipes while building widgets.</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/F9kzt/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>

<h2>Build Widgets/UI Elements</h2>

<p>Previous recipes have demonstrated how to change page content and introduced
event handling. The following recipes will introduce <code>can.Component</code>,
which allows for straightforward widget construction by packaging
template, state, and event handling code in one place.</p>

<p>While similar <em>behavior</em> can be accomplished with <code>can.Control</code>,
building a Component enables building reusable widgets using custom
HTML tags.</p>

<h3>Create a Component</h3>

<p>The previous recipe that displays a list of people can instead
be represented as a component.</p>

<pre><code>&lt;people&gt;&lt;/people&gt;
</code></pre>

<p>By specifying <code>people</code> as the tag, a component is created wherever <code>&lt;people&gt;&lt;/people&gt;</code>
appears in a template.</p>

<pre><code>can.Component.extend({
    tag: 'people',
</code></pre>

<p>The <code>scope</code> object on a <code>Component</code> contains the component's state, data,
and behavior. Here, it specifies how to <code>remove</code> a person from the list:</p>

<pre><code>    scope: {
        people: people,
        remove: function( person ) {
            var people = this.attr("people");
            var index = people.indexOf(person);
            people.splice(index, 1);
        }
    }
});
</code></pre>

<p>The template for the component itself is passed via the <code>template</code>
property. This can either be an external file or a string.
Each <code>li</code> uses <code>can-click</code>, <a href="http://canjs.com/docs/can.view.bindings.can-EVENT.html">which declares an event binding.</a>
Here, <code>remove</code> inside the component's
scope will be called with the relevant <code>people</code> object
as an argument.</p>

<pre><code>scope: {
    template: '&lt;ul&gt;' +
                '{{#each people}}' +
                '&lt;li can-click="remove"&gt;' +
                    '{{lastname}}, {{firstname}}' +
                '&lt;/li&gt;' +
                '{{/each}}' +
                '&lt;/ul&gt;',
...
</code></pre>

<p>This behaves similarly to the <code>can.Control</code> from above.
However, the <code>&lt;people&gt;</code> tag can be used without having
any knowledge about the inner workings of the widget.
Using declarative HTML tags, a component can be used
without writing any javascript. The template, state,
and behavior are all combined into one Component.</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/WBM9z/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>

<h3>Build a Tabs Widget</h3>

<p>A tabs widget could be instantiated with the following HTML:</p>

<pre><code>&lt;tabs&gt;
    &lt;panel title="Fruit"&gt;Oranges, Apples, Pears&lt;/panel&gt;
    &lt;panel title="Vegetable"&gt;Carrot, Lettuce, Rutabega&lt;/panel&gt;
    &lt;panel title="Grains"&gt;Bread, Pasta, Rice&lt;/panel&gt;
&lt;/tabs&gt;
</code></pre>

<p>A designer that understands HTML can put together a template for a <code>tabs</code>
widget without understanding anything other than the syntax.
This is one of the most useful features of components. </p>

<h3>Tabs Widget Behavior</h3>

<p>Before implementing the component itself, we'll
define an observable <em>view model</em>--the <code>scope</code> object
of the UI element. This makes the code modular and easier
to manage (and also allows for unit testing).</p>

<p>In order to accurately represent a tabs widget,
a <code>TabsViewModel</code> needs:</p>

<ul>
<li>An observable list of panels</li>
<li>A state variable with the active panel</li>
<li>Helper methods to add, remove, and activate panels</li>
</ul>

<p>Since TabsViewModel is a <code>can.Map</code>, the <code>panels</code> property is
automatically converted to a <code>can.List</code>.
The <code>active</code> property references the <code>panel</code> object
that should currently be displayed.</p>

<pre><code>var TabsViewModel = can.Map.extend({
    panels: [],
    active: null,
    addPanel: function( panel ){
        var panels = this.attr("panels");
        panels.push(panel);
        panel.attr("visible", false);
        //activate panel if it is the first one
        if ( panels.attr("length") === 1 ){
            this.activate( panel );
        }
    },
    removePanel: function( panel ){
        var panels = this.attr("panels");
        var index = panels.indexOf(panel);
        panels.splice(index, 1);
        //activate a new panel if panel being removed was the active panel
        if( this.attr("active") === panel ){
            panels.attr("length") ? this.activate(panels[0]) : this.attr("active", null)
        }
    },
    activate: function( panel ){
        var active = this.attr("active")
        if( active !== panel ){
            active &amp;&amp; active.attr("visible", false);
            this.attr("active", panel.attr("visible", true));
        }
    }
})
</code></pre>

<h4>Tabs Widget Component</h4>

<p>Now that the view model is defined, making a component is simply
a matter of defining the way the tabs widget is displayed.</p>

<p>The template for a <code>tabs</code> component needs a list of panel titles
that will <code>activate</code> that panel when clicked. By calling <code>activate</code>
with a panel as the argument, the properties of the <code>panel</code> can
be manipulated. By changing the <code>visible</code> property of a panel,
a template can be used to display or hide the panel accordingly.</p>

<p>For this component, our template should look something like this:</p>

<pre><code>&lt;tabs&gt;
    &lt;panel title="Fruits"&gt;Apples, Oranges&lt;/panel&gt;
    &lt;panel title="Vegetables"&gt;Carrots, Celery&lt;/panel&gt;
&lt;/tabs&gt;
</code></pre>

<p>A designer can create a <code>tabs</code> component with <code>panel</code> components inside it.
The <code>template</code> object on the tabs component's scope needs to be able to render
the content that is inside of the <code>&lt;tabs&gt;</code> tag. To do this, we simply use the
<code>&lt;content&gt;</code> tag, which will render everything within the component's tags:</p>

<pre><code>can.Component.extend({
    tag: "tabs",
    scope: TabsViewModel,
    template: "&lt;ul&gt;\
                {{#each panels}}\
                    &lt;li can-click='activate'&gt;{{title}}&lt;/li&gt;\
                {{/each}}\
                &lt;/ul&gt;\
                &lt;content /&gt;"
});
</code></pre>

<p>The <code>tabs</code> component contains panels, which are also defined
as components. The tabs template contains the logic for whether
the panel is visible (<code>visible</code> is controlled by the tabs
component's <code>activate</code> method).</p>

<p>Each panel's <code>scope</code> contains a title, which should be
taken from the <code>title</code> attribute in the <code>&lt;panel&gt;</code> tag.
If you want to set the string value of a Component's
attribute as a <code>scope</code> variable, use  <code>@'</code>.</p>

<pre><code>can.Component.extend({
tag: "panel",
template: "{{#if visible}}&lt;content /&gt;{{/if}}",
scope: {
    title: "@"
},
...
</code></pre>

<p>In addition to the <code>scope</code> property, a component has an
<a href="http://canjs.com/docs/can.Component.prototype.events.html"><code>events</code> property</a>.
This <code>events</code> property uses a <code>can.Control</code> instantiated inside
the component to handle events.</p>

<p>Since we defined behavior for adding panels on the parent
<code>tabs</code> component, we should use this method whenever a <code>panel</code>
is inserted into the page (and an <code>inserted</code> event is triggered).
To add the panel to the <code>tabs</code> component's scope, we call the
<code>addPanel</code> method by accessing the parent scope with <code>this.element.parent().scope()</code>:</p>

<pre><code>...
    events: {
        inserted: function() {
            this.element.parent().scope().addPanel( this.scope )
        },
        removed: function() {
            this.element.parent().scope().addPanel( this.scope )
        }
    }
});
</code></pre>

<p>With this component, any time a <code>&lt;tabs&gt;</code> element with
<code>&lt;panel&gt;</code> elements is put in a page, a tabs widget will
automatically be created. This allows application behavior
and design to be compartmentalized from each other.</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/x6TJK/2/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>

<h2>Build an Application with Data from a Server</h2>

<p>In CanJS, <code>can.Model</code> adds functionality to <code>can.Map</code> to
work with data on a server.  It enables you to:</p>

<ul>
<li>Get and modify data from a server</li>
<li>Listen to changes made to the data on the server</li>
<li>Unify service data with other objects in your application</li>
</ul>

<p><code>can.Model</code> allows you to access data from a server
easily:</p>

<pre><code>var Todo = can.Model.extend({
  findAll: 'GET /todos',
  findOne: 'GET /todos/{id}',
  create:  'POST /todos',
  update:  'PUT /todos/{id}',
  destroy: 'DELETE /todos/{id}'
},{});
</code></pre>

<p>Using <em>any</em> server with a <a href="http://blog.mashape.com/post/60820526317/list-of-40-tutorials-on-how-to-create-an-api"><em>REST</em> interface</a>,
 <code>can.Model</code> enables create, read, update, and destroy functionality.</p>

<h3>Create a Chat Application</h3>

<p>To put together a chat application, we'll use two methods
from <code>can.Model</code> to fetch the messages and create new ones:</p>

<pre><code>var Message = can.Model({
    findAll : 'GET ' + myServerUrl + '/messages',
    create : 'POST ' + myServerUrl + '/messages'
},{});
</code></pre>

<p>In a chat component's scope, we will use the <code>Message</code> model to
save new messages and observe changes to the Model.
<a href="http://canjs.com/docs/can.Model.List.html#sig_newcan_Model_List__models__"><code>new Message.List({})</code></a> is a shortcut to perform
the <a href="http://canjs.com/docs/can.Model.findAll.html"><code>findAll</code></a> operation on a <code>can.Model</code> and
return a <code>can.List</code>.</p>

<pre><code>...
    scope: {
            messages: new Message.List({}),
            newMessage: ""
...
</code></pre>

<p>The tabs Component used <code>can-click</code> to listen for click events.
Since this chat application uses a <code>&lt;form&gt;</code> for sending messages, we'll use
<code>can-submit</code> to specify an event handler.</p>

<p>There's one more helper used in the template: <a href="http://canjs.com/docs/can.view.bindings.can-value.html"><code>can-value</code></a>.
This automatically two-way binds the value of an input field to an observable
property on the <code>scope</code> of the component (in this case, <code>newMessage</code>).</p>

<pre><code>can.Component.extend({
  tag: 'chat',
  template: '&lt;ul id="messages"&gt;' +
              '{{#each messages}}' +
              '&lt;li&gt;{{body}}&lt;/li&gt;' +
              '{{/each}}' +
            '&lt;/ul&gt;' +
            '&lt;form id="create-message" action="" can-submit="submitMessage"&gt;' +
                '&lt;input type="text" id="body" placeholder="type message here..."' +
                'can-value="newMessage" /&gt;' +
            '&lt;/form&gt;',
...
</code></pre>

<p>When <code>submitMessage</code> is called, a new <code>Message</code> is created
with <code>new Message()</code>. Since <code>can-value</code> was declared on the <code>input</code> element, <code>newMessage</code> will
always be the current text in the <code>input</code> field.
The body of the message is fetched from
the Component's <code>newMessage</code> attribute when a user submits the form.</p>

<p>To save the new message to the server, call <code>save()</code>.</p>

<pre><code>submitMessage: function(scope, el, ev){
    ev.preventDefault();
    new Message({body: this.attr("newMessage")}).save();
    this.attr("newMessage", "");
}
</code></pre>

<p>Finally, when a new <code>Message</code> is created, the <code>messages</code> list
must be updated.</p>

<pre><code>events: {
    '{Message} created': function(construct, ev, message){
        this.scope.attr('messages').push(message);
    }
}
</code></pre>

<p>There are two ways that messages are added: from the current user,
or from another user. In the next section, we demonstrate how to use
<a href="http://socket.io/">socket.io</a> to update the <code>Message</code> model with messages
from other users in real time. Binding to the <code>created</code> event for <strong>all</strong>
messages allows us to create a single entry point that pushes new messages
to the <code>scope</code>, <a href="http://canjs.com/docs/can.Model.html#section_Listentochangesindata">regardless of where those messages are from.</a></p>

<p>When the chat Component is loaded, messages are loaded from the server
using <code>can.Model</code> and <code>new Message.List({})</code>.  When a new message is
submitted:</p>

<ol>
<li><code>submitMessage</code> is called via the event handler bound by the <code>can-submit</code> attribute</li>
<li>a new <code>Message</code> is created and saved to the server</li>
<li><code>'{Message} created'</code> detects this change and adds the new message to <code>messages</code></li>
<li>The template is automatically updated since <code>messages</code> is an observable <code>can.List</code></li>
</ol>

<h3>Add real-time functionality</h3>

<p>This example uses <a href="http://socket.io/">socket.io</a>
to enable real-time functionality. This guide won't go
into detail on how to use <code>socket.io</code>, but for real-time
chat the application needs two more things.</p>

<p>When a message is created on another chat client, <code>socket.io</code>
will notify this client by triggering the <code>message-created</code> event,
wich will render the new message in the page by adding it to the
<code>Message</code> model.</p>

<pre><code>var socket = io.connect(myServerUrl)
socket.on('message-created', function(message){
    new Message(message).created();
})
</code></pre>

<p>To keep the <code>created</code> event from firing
twice, we modify the <code>create</code> function in the model.
If there was simply a <code>return</code> statement, <code>Model</code> would
create and fire a <code>create</code> event, which <code>socket</code> is already
doing. By returning a <code>Deferred</code>, we prevent firing of
one of these events.</p>

<pre><code>var Message = can.Model({
findAll : 'GET ' + myServerUrl + '/messages',
create : function(attrs) {
    $.post(myServerUrl + '/messages', attrs);
    //keep '{Message} created' from firing twice
    return $.Deferred();
}
},{});
</code></pre>

<iframe width="100%" height="300" src="http://jsfiddle.net/donejs/afC94/embedded/result,html,js/" allowfullscreen="allowfullscreen" frameborder="0"> </iframe>

<h2>Add my own recipe</h2>

<p>To add your own recipe, simply <a href="https://github.com/bitovi/canjs/edit/gh-pages/recipes.md">edit this file</a>. To
help create a JSFiddle, we've created the following fiddles you can fork:</p>

<ul>
<li><a href="http://jsfiddle.net/donejs/qYdwR/">jQuery and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/7Yaxk/">Zepto and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/9x96n/">Dojo and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/w6m73/">YUI and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/mnNJX/">Mootools and CanJS</a></li>
</ul>

<h2>Request a Recipe</h2>

<p>To request a new recipe or vote on an upcoming one, <a href="https://github.com/bitovi/canjs.com/issues">submit an issue</a>
to the <code>canjs.com</code> respository on GitHub.</p>
		</section>
		

		
	</article>
</div>

<script type="text/javascript">
	var docData = {"type":"page","name":"Recipes","description":"","title":"Recipes","parent":"guides","order":4,"comment":" ","src":"can/guides/recipes.md","id":17};

	console.log(docData);
</script>



  <footer>
    <nav class="container">
      <a class="brand javascriptmvc" href="index.html"></a>
      <ul class="nav">
        <li class=""><a href="../../index.html">Home</a></li>
        <li class="active"><a href="../guides/index.html">Guides</a></li>
        <li class=""><a href="../docs/index.html">Api</a></li>
        <li class=""><a href="../../community.html#!forums">Community</a></li>
        <li class=""><a href="../blog/index.html">Blog</a></li>
        <li class=""><a href="../../download.html">Download</a></li>
      </ul>
    </nav>
  </footer>
  <script type="text/javascript">
    window.docConfig = {"debug":false,"enableSearch":true,"parent":"guides","layout":"documentjs/site/templates/page.mustache","docs":"documentjs/site/templates/docs.mustache","root":"..","out":"2.1/guides","page":"guides","markdown":["can/guides","can/changelog.md","can/contributing.md","can/license.md"],"package":{"name":"CanJS","description":"MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy.","version":"2.1.3","author":{"name":"Bitovi","email":"contact@bitovi.com","web":"http://bitovi.com/"},"homepage":"http://canjs.us/","repository":{"type":"git","url":"git@github.com:bitovi/canjs.git","github":"https://github.com/bitovi/canjs"},"devDependencies":{"grunt":"~0.4.0","grunt-string-replace":"~0.2.2","grunt-contrib-qunit":"~0.5.1","grunt-contrib-connect":"~0.3.0","bitovi-tools":"https://github.com/bitovi/bitovi-tools/tarball/master","steal":"https://github.com/bitovi/steal-build/tarball/master","grunt-contrib-uglify":"~0.2.1","grunt-contrib-clean":"~0.5.0","grunt-shell":"~0.5.0","grunt-release-steps":"~0.3.7","bower":"~1.3.8","grunt-contrib-jshint":"~0.8.0","grunt-jsbeautifier":"~0.2.6","grunt-docco2":"git://github.com/shcarrico/grunt-docco.git#e4de54886ed5c421b2e26e7a2aeba1f73e889733","grunt-plato":"~0.2.1"},"scripts":{"test":"grunt test","install":"node node_modules/bower/bin/bower install"},"demos":["http://canjs.us/#examples","http://canjs.us/recipes"],"licenses":[{"type":"MIT","url":"http://opensource.org/licenses/mit-license.php"}],"dependencies":{"grunt-cli":"~0.1.7"}},"self":{"name":"canjs.com","description":"We can do JS better.","version":"0.2.0","homepage":"http://canjs.com","author":{"name":"Bitovi","url":"http://bitovi.com/"},"repository":{"type":"git","url":"git://github.com/bitovi/canjs.com.git","github":"https://github.com/bitovi/canjs.com"},"bugs":{"url":"https://github.com/bitovi/canjs.com/issues"},"licenses":[{"type":"MIT","url":"https://github.com/bitovi/canjs.com/blob/master/LICENSE-MIT"}],"engines":{"node":">= 0.10.0"},"devDependencies":{"grunt":"~0.4.1","grunt-contrib-watch":"~0.3.1","grunt-contrib-less":"~0.5.0","documentjs":"https://github.com/bitovi/documentjs/tarball/node-generator","grunt-contrib-clean":"~0.4.1","grunt-docco2":"git://github.com/shcarrico/grunt-docco.git#options-passing","grunt-plato":"~0.2.1","grunt-jsbeautifier":"~0.2.6","grunt-shell":"~0.6.4","sqlite3":"~2.2.3","q":"~1.0.1"}},"builder":{"filename":"can.custom.js","banner":"/*!\n * <%= pkg.title || pkg.name %> - <%= pkg.version %>\n * <%= pkg.homepage %>\n * Copyright (c) <%= new Date().getFullYear() %> <%= pkg.author.name %>\n * <%= new Date().toUTCString() %>\n * Licensed <%= pkg.licenses[0].type %><% if(typeof url !== \"undefined\") { %>\n * Includes: <%= ids %>\n * Download from: <%= url %>\n<% } %> */\n","modules":{"can/component":{"name":"can.Component","description":"Custom elements and widgets","type":"core","isDefault":true},"can/construct":{"name":"can.Construct","description":"Inheritable constructor functions","type":"core","isDefault":true},"can/map":{"name":"can.Map","description":"Observables and key-value bindings","type":"core","isDefault":true},"can/list":{"name":"can.List","description":"Observables lists","type":"core","isDefault":true},"can/list/promise":{"name":"can.List.promise","description":"Promises on lists","type":"plugin"},"can/observe":{"name":"can.Observe","description":"Observables and key-value bindings","type":"core","isDefault":true,"hidden":true},"can/compute":{"name":"can.compute","description":"can.compute lets you make observable values","type":"core","isDefault":true},"can/model":{"name":"can.Model","description":"Observes connected to a RESTful JSON interface","type":"core","isDefault":true},"can/view":{"name":"can.view","description":"Template loading, caching, rendering","type":"core","isDefault":true},"can/view/ejs":{"name":"can.ejs","description":"Live-binding Embedded JavaScript","type":"plugin"},"can/view/stache":{"name":"can.stache","description":"High performance Mustache templates","type":"plugin"},"can/control":{"name":"can.Control","description":"Declarative event bindings","type":"core","isDefault":true},"can/route":{"name":"can.route","description":"Back button and bookmarking support","type":"core","isDefault":true},"can/control/route":{"name":"can.Control.route","description":"Declare routes in your Control","type":"core","isDefault":true},"can/view/mustache":{"name":"can.mustache","description":"Live-binding Handlebars and Mustache views","type":"core","isDefault":true},"can/route/pushstate":{"name":"can.route.pushstate","description":"can.route with pushstate","type":"plugin"},"can/model/queue":{"name":"can.Model.Queue","type":"plugin","description":"Queued requests to the server."},"can/construct/super":{"name":"can.Construct.super","type":"plugin","description":"Call super methods"},"can/construct/proxy":{"name":"can.Construct.proxy","type":"plugin","description":"Proxy construct methods"},"can/map/lazy":{"name":"can.Map.Lazy","type":"plugin","description":"Lazy initializing maps and lists"},"can/map/delegate":{"name":"can.Map.delegate","type":"plugin","description":"Listen to Observe attributes"},"can/map/setter":{"name":"can.Map.setter","type":"plugin","description":"Use setter methods on can.Map"},"can/map/attributes":{"name":"can.Map.attributes","type":"plugin","deprecated":true,"description":"Define Observe attributes"},"can/map/validations":{"name":"can.Map.validations","type":"plugin","description":"Validate Observe attributes"},"can/map/backup":{"name":"can.Map.backup","type":"plugin","description":"Backup and restore an Observes state"},"can/map/list":{"name":"can.Map.List","type":"plugin","description":"Live-updating mapped and filtered observe lists"},"can/map/define":{"name":"can.Map.define","type":"plugin","description":"Define rich attribute behavior"},"can/map/sort":{"name":"can.List.Sort","type":"plugin","description":"Sort observable lists"},"can/control/plugin":{"name":"can.Control.plugin","type":"plugin","description":"Registers a jQuery plugin function for Controls","configurations":["jquery","jquery-2"]},"can/view/modifiers":{"name":"can.view.modifiers","type":"plugin","description":"Use jQuery modifiers to render views","configurations":["jquery","jquery-2"]},"can/util/object":{"name":"can.Object","type":"plugin","description":"Helper methods for object comparison"},"can/util/fixture":{"name":"can.fixture","type":"plugin","description":"Intercepts an AJAX request and simulates the response with a file or function"},"can/view/bindings":{"name":"can.view.bindings","type":"core","isDefault":true,"hidden":true},"can/view/live":{"name":"can.view.live","type":"core","isDefault":true,"hidden":true},"can/view/scope":{"name":"can.view.Scope","type":"core","isDefault":true,"hidden":true},"can/util/string":{"name":"can.util.string","type":"core","isDefault":true,"hidden":true},"can/util/attr":{"name":"can.util.attr","type":"core","isDefault":true,"hidden":true}},"types":{"core":"CanJS core","plugin":"Plugins"},"pluginify":{"shim":{"can/lib/jquery.2.0.3.js":"jQuery","can/lib/jquery.1.10.2.js":"jQuery","can/bower_components/zepto/zepto.js":"Zepto","can/lib/mootools-core-1.4.5.js":"{}","can/util/dojo/dojo-1.8.1.js":"{}","can/lib/yui-3.7.3.js":"YUI"},"exports":{"can/util/can.js":"can"}},"configurations":{"jquery":{"description":"jQuery","isDefault":true,"library":"lib/jquery.1.10.2.js","steal":{"map":{"*":{"can/util/util.js":"can/util/jquery/jquery.js","jquery/jquery.js":"can/lib/jquery.1.10.2.js"}}}},"jquery-2":{"description":"jQuery (2.x)","hidden":true,"library":"lib/jquery.2.0.3.js","steal":{"map":{"*":{"can/util/util.js":"can/util/jquery/jquery.js","jquery/jquery.js":"can/lib/jquery.2.0.3.js"}}}},"zepto":{"description":"Zepto","library":"bower_components/zepto/zepto.js","steal":{"map":{"*":{"can/util/util.js":"can/util/zepto/zepto.js","zepto/zepto.js":"can/bower_components/zepto/zepto.js"}}}},"mootools":{"description":"Mootools","library":"lib/mootools-core-1.4.5.js","steal":{"map":{"*":{"can/util/util.js":"can/util/mootools/mootools.js","mootools/mootools.js":"can/lib/mootools-core-1.4.5.js"}}}},"yui":{"description":"YUI","library":"lib/yui-3.7.3.js","steal":{"map":{"*":{"can/util/util.js":"can/util/yui/yui.js","yui/yui.js":"can/lib/yui-3.7.3.js"}}}},"dojo":{"description":"Dojo","library":"util/dojo/dojo-1.8.1.js","steal":{"map":{"*":{"can/util/util.js":"can/util/dojo/dojo.js","dojo/dojo.js":"can/util/dojo/dojo-1.8.1.js"}}}}}},"url":{"builderData":"http://bitbuilder.herokuapp.com/canjs","builder":"http://bitbuilder.herokuapp.com/can.custom.js","bithub":"http://bitovi.bithub.com/api/v1/events/","cdn":"//canjs.com/release/"},"static":"scripts/static","templates":"scripts/templates","forceBuild":false,"minifyBuild":true,"versionsSrc":"../../versions.json","version":"2.1","isVersioned":true,"versions":[{"number":"2.1","branch":"master"},{"number":"2.0"},{"number":"1.1"}]};
    window.Bitovi = {
      URL: {
        BUILDER: 'http://bitbuilder.herokuapp.com/can.custom.js',
        BUILDER_DATA: 'http://bitbuilder.herokuapp.com/canjs',
        BITHUB: 'http://bitovi.bithub.com/api/v1/events/',
        CDN: '//canjs.com/release/'
      }
    }
    steal = {
      productionId: "production.js",
      executed: ["documentjs/site/static/build/production.css"]
    }
  </script>
  <script 
  
    src="./static/steal.production.js"
  
    ></script>
  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2302003-11']);
  _gaq.push(['_setDomainName', 'canjs.com']);
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);

  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  </script>
</body>

</html>
