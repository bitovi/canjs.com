<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>API - CanJS</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <link rel="stylesheet" type="text/css" 
    
      href='./static/production.css'
     />
  <!--[if lt IE 9]>
   <script type="text/javascript" src="../scripts/static/lib/html5shiv.js"></script>
    <!--<![endif]-->
</head>

<body class="docs">
  <header>
    <nav class="container">

      <div class="logo-menu">
        <a class="brand canjs" href="../../index.html">CanJS</a>
        <ul class="dropdown-menu">
          <li><a href="http://javascriptmvc.com">JavaScriptMVC</a></li>
          <li class="active"><a href="../../index.html">CanJS</a></li>
          <li><a href="http://jquerypp.com">jQuery++</a></li>
          <li><a href="http://javascriptmvc.com/docs.html#!stealjs">StealJS</a></li>
          <li><a href="http://funcunit.com">FuncUnit</a></li>
          <li><a href="http://javascriptmvc.com/docs.html#!DocumentJS">DocumentJS</a></li>
        </ul>
      </div>
      <ul class="nav">
        <li class=""><a href="../../index.html">Home</a></li>
        <li class=""><a href="../guides/index.html">Guides</a></li>
        <li class="active"><a href="../docs/index.html">Api</a></li>
        <li class=" community-menu">
          <a href="../../community.html#!forums">Community</a>
          <ul class="dropdown-menu">
            <li><a href="https://forum.javascriptmvc.com/canjs">Forums</a></li>
            <li><a href="http://webchat.freenode.net/?channels=canjs">IRC</a></li>
            <li><a href="http://bithub.com/canjs/app/">Apps</a></li>
            <li><a href="http://bithub.com/canjs/plugin/">Plugins</a></li>
            <li><a href="http://bithub.com/canjs/article/">Articles</a></li>
            <li><a href="http://github.com/bitovi/canjs">Github</a></li>
            <li><a href="http://twitter.com/canjs">Twitter</a></li>
            <li><a href="http://bitovi.github.io/canjsmeetup/">Meetups</a></li>
          </ul>
        </li>
        <li class=""><a href="../../download.html">Download</a></li>
      </ul>
      <div class="pull-right">
        <div class="bitovi-menu">
          <a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
          <ul class="dropdown-menu">
            <li><a href="http://bitovi.com">Bitovi.com</a></li>
            <li><a href="http://bitovi.com/blog/">Blog</a></li>
            <li><a href="http://bitovi.com/consulting/">Consulting</a></li>
            <li><a href="http://bitovi.com/training/">Training</a></li>
            <li><a href="http://bitovi.com/open-source/">Open Source</a></li>
            <li><a href="http://bitovi.com/people/">People</a></li>
            <li><a href="http://bitovi.com/contact/">Contact Us</a></li>
          </ul>
        </div>
      </div>
    </nav>
  </header>

  <div class="container api">
	<nav class="sidebar">
		
		<div class="search-wrapper">
			<div class="search">
				<input type="text"/>
			</div>
		</div>
		
		<h2 id="version">
<select id="versions">
	<option value="">CanJS v2.1</option>
</select>
</h2>
<ul class="api">
	<!-- First Level -->
	
	   <li class="search-container">
	   		<a href="can.Component.html" data-search="can.Component">
				can.Component
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Construct.html" data-search="can.Construct">
				can.Construct
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Control.html" data-search="can.Control">
				can.Control
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.List.html" data-search="can.List">
				can.List
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Map.html" data-search="can.Map">
				can.Map
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Model.html" data-search="can.Model">
				can.Model
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.Model.List.html" data-search="can.Model.List">
				can.Model.List
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.compute.html" data-search="can.compute">
				can.compute
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.ejs.html" data-search="can.ejs">
				can.ejs
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.event.html" data-search="can.event">
				can.event
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.fixture.html" data-search="can.fixture">
				can.fixture
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.mustache.html" data-search="can.mustache">
				can.mustache
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.route.html" data-search="can.route">
				can.route
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.stache.html" data-search="can.stache">
				can.stache
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.util.html" data-search="can.util">
				can.util
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.view.html" data-search="can.view">
				can.view
			</a>
			
	   </li>
	
	   <li class="search-container">
	   		<a href="can.view.bindings.html" data-search="can.view.bindings">
				can.view.bindings
			</a>
			
	   </li>
	
</ul>
	</nav>
	<article class="content docs">
		<section class="title">
			<div class="heading">
<h1>CanJS</h1>
	<ul class="tags">
		<li>page</li>
	</ul>
	
	
	
		<span class="module">canjs</span>
	
	
	
	
</div>

<div class="sub-heading">
	
	<span class="inherits">&nbsp;</span>
</div>

<ul class="links">
    
	
		<li><a href="https://github.com/bitovi/canjs/tree/v2.1.1/can.md">source</a></li>
	
	
		
	
	
</ul>
<br />
		</section>

		<section class="contents">
		</section>

		

		<section class="description">
			
		</section>

		

		
		
		
		

		
		<section class="comment">
			<p>This is the detailed documentation of the API for CanJS 2.1, a framework for building
web applications that provides a lightweight inheritance system, observable
objects and values, and a powerful MVC core with live-bound templates, among other
resources. </p>

<p>If you are just starting with CanJS, you may want to try our <a href="../guides/Tutorial.html">getting started guide</a>.</p>

<p>CanJS is composed of modules on the left. The following are typically distributed as part of the core
framework:</p>

<ul>
<li><a href="can.Component.html">can.Component</a> - widgets built on custom tags</li>
<li><a href="can.Construct.html">can.Construct</a> - inheritable constructor functions</li>
<li><a href="can.Control.html">can.Control</a> - declarative event bindings</li>
<li><a href="can.Map.html">can.Map</a>, <a href="can.List.html">can.List</a>, <a href="can.compute.html">can.compute</a> - observable objects, list, and values.</li>
<li><a href="can.Model.html">can.Model</a> -  observes connected to a RESTful JSON interface</li>
<li><a href="can.view.html">can.view</a> - template loading, caching, rendering</li>
<li><a href="can.mustache.html">can.mustache</a> - Live binding Handlebars and Mustache templates</li>
<li><a href="can.route.html">can.route</a> -  back button and bookmarking support</li>
</ul>

<p>The following modules are typically distributed as plugins:</p>

<ul>
<li><a href="can.ejs.html">can.ejs</a> - live binding templates</li>
<li><a href="can.Construct.proxy.html">can.Construct.proxy</a> - Proxy construct methods</li>
<li><a href="can.Construct.super.html">can.Construct.super</a> - Call super methods</li>
<li><a href="can.Map.delegate.html">can.Map.delegate</a> - Listen to Observe attributes</li>
<li>[can.Map::setter] - Use setter methods on Map</li>
<li><a href="can.Map.attributes.html">can.Map.attributes</a> - Define Observe attributes</li>
<li><a href="can.Map.validations.html">can.Map.validations</a> - Validate attributes</li>
<li><a href="can.Map.backup.html">can.Map.backup</a> - Backup and restore an Observe's state</li>
<li><a href="can.Control.plugin.html">can.Control.plugin</a> - Registers a jQuery plugin function for Controls[1]</li>
<li><a href="can.view.modifiers.html">View modifiers</a> - Use jQuery modifiers to render views[1]</li>
</ul>

<p>You can use it out of the box on top of jQuery, Zepto, YUI, and Mootools,
and it's only about 20K.</p>
		</section>
		

		
		<section class="api">
			<div class='group_0'><div class='small-signature'><a href="can.Component.html" class="sig"><code class='prettyprint'>< TAG [ATTR-NAME=KEY|ATTR-VALUE] ></code></a><p>Create an instance of a component on a particular 
tag in a <a href="can.mustache.html">can.mustache</a> template.</p></div><div class='small-signature'><a href="can.Component.html" class="sig"><code class='prettyprint'>< TAG [ATTR-NAME="{KEY}|ATTR-VALUE"] ></code></a><p>Create an instance of a component on a particular 
tag in a <a href="can.stache.html">can.stache</a> template.</p></div><div class='group_1'><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.Component.extend.html" class="sig"><code class='prettyprint'>can.Component.extend(proto)</code></a><p>Extends the <a href="can.Component.html">can.Component</a> constructor function with prototype 
properties and methods.</p></div></div></div></div><div class='group_0'><div class='small-signature'><a href="can.Construct.html" class="sig"><code class='prettyprint'>new can.Construct([args..])</code></a><p>Create a new instance of a constructor function. </p></div><div class='small-signature'><a href="can.Construct.html" class="sig"><code class='prettyprint'>can.Construct([name,] [staticProperties,] instanceProperties)</code></a><p>Creates a new extended constructor function. </p></div><div class='small-signature'><a href="can.Construct.html" class="sig"><code class='prettyprint'>can.Construct([args...])</code></a><p>Create a new instance of a constructor function if
<a href="can.Construct.constructorExtends.html">constructorExtends</a> is 
false. </p></div><div class='group_1'><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.Construct.prototype.init.html" class="sig"><code class='prettyprint'>construct.init(...args)</code></a><p>Called when a new instance of a can.Construct is created. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Construct.prototype.setup.html" class="sig"><code class='prettyprint'>construct.setup(...args)</code></a><p>A setup function for the instantiation of a constructor function.</p></div></div></div><div class='group_1'><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.Construct.extend.html" class="sig"><code class='prettyprint'>can.Construct.extend([name,] [staticProperties,] instanceProperties)</code></a><p>Extends can.Construct, or constructor functions derived from can.Construct,
to create a new constructor function. </p></div></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.Construct.newInstance.html" class="sig"><code class='prettyprint'>can.Construct.newInstance([...args])</code></a><p>Returns an instance of can.Construct. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Construct.setup.html" class="sig"><code class='prettyprint'>can.Construct.setup(base, fullName, staticProps, protoProps)</code></a><p>A static setup method provides inheritable setup functionality
for a Constructor function. </p></div></div><div class='group_2'></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.Construct.proxy.html" class="sig"><code class='prettyprint'>can.Construct.proxy(callback, [...args])</code></a><p>Creates a static callback function that has this set to the constructor
function.</p></div><div class='small-signature'><a href="can.Construct.proxy.html" class="sig"><code class='prettyprint'>construct.proxy(callback, [...args])</code></a><p>Creates a static callback function that has this set to an instance of the constructor
function.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.Construct.super.html" class="sig"><code class='prettyprint'>construct._super([...args])</code></a><p>Calls the base constructor function's method.</p></div></div></div></div><div class='group_0'><div class='small-signature'><a href="can.Control.html" class="sig"><code class='prettyprint'>can.Control( [staticProperties,] instanceProperties )</code></a><p>Create a new, extended, control constructor 
function. </p></div><div class='small-signature'><a href="can.Control.html" class="sig"><code class='prettyprint'>new can.Control( element, options )</code></a><p>Create an instance of a control. </p></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.Control.prototype.destroy.html" class="sig"><code class='prettyprint'>control.destroy()</code></a><p>Prepares a control for garbage collection and is a place to
reset any changes the control has made.</p></div></div><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.Control.prototype.on.html" class="sig"><code class='prettyprint'>control.on([el,] selector, eventName, func)</code></a><p>Bind an event handler to a Control, or rebind all event handlers on a Control. </p></div><div class='small-signature'><a href="can.Control.prototype.on.html" class="sig"><code class='prettyprint'>control.on()</code></a><p>Rebind all of a control's event handlers.</p></div></div><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.Control.prototype.setup.html" class="sig"><code class='prettyprint'>control.setup(element, options)</code></a><p>Perform pre-initialization logic for control instances and classes. </p></div></div></div><div class='group_1'><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.Control.extend.html" class="sig"><code class='prettyprint'>can.Control.extend( [staticProperties,] instanceProperties )</code></a><p>Create a new, extended, control constructor 
function.</p></div></div><div class='group_2'></div></div><div class='group_1'><div class='group_2'><div class='group_3'><div class='small-signature'><a href="can.Control.plugin.prototype.update.html" class="sig"><code class='prettyprint'>update(newOptions)</code></a><p>Reconfigure a control. </p></div></div><div class='group_3'></div><div class='group_3'><div class='small-signature'><a href="jQuery.fn.control.html" class="sig"><code class='prettyprint'>jQuery.fn.control([type])</code></a><p>Get the Control associated with elements. </p></div></div><div class='group_3'><div class='small-signature'><a href="jQuery.fn.controls.html" class="sig"><code class='prettyprint'>jQuery.fn.controls([type])</code></a><p>Get the Controls associated with elements. </p></div></div></div><div class='group_2'></div></div></div><div class='group_0'><div class='small-signature'><a href="can.List.html" class="sig"><code class='prettyprint'>new can.List([array])</code></a><p>Create an observable array-like object.</p></div><div class='small-signature'><a href="can.List.html" class="sig"><code class='prettyprint'>new can.List(deferred)</code></a><p></p></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.List.prototype.attr.html" class="sig"><code class='prettyprint'>list.attr()</code></a><p>Gets an array of all the elements in this can.List.</p></div><div class='small-signature'><a href="can.List.prototype.attr.html" class="sig"><code class='prettyprint'>list.attr(index)</code></a><p>Reads an element from this can.List.</p></div><div class='small-signature'><a href="can.List.prototype.attr.html" class="sig"><code class='prettyprint'>list.attr(index, value)</code></a><p>Assigns value to the index index on this can.List, expanding the list if necessary.</p></div><div class='small-signature'><a href="can.List.prototype.attr.html" class="sig"><code class='prettyprint'>list.attr(elements[, replaceCompletely])</code></a><p>Merges the members of elements into this List, replacing each from the beginning in order. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.concat.html" class="sig"><code class='prettyprint'>list.concat(...args)</code></a><p>Merge many collections together into a List. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.each.html" class="sig"><code class='prettyprint'>list.each( callback(item, index) )</code></a><p>each iterates through the Map, calling a function
for each element.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.filter.html" class="sig"><code class='prettyprint'>list.filter(filterFunc, context)</code></a><p>Filter the elements of a List, returning a new List instance with just filtered items. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.forEach.html" class="sig"><code class='prettyprint'>list.forEach(callback[, thisArg])</code></a><p>Call a function for each element of a List. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.indexOf.html" class="sig"><code class='prettyprint'>list.indexOf(item)</code></a><p>indexOf finds the position of a given item in the List.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.join.html" class="sig"><code class='prettyprint'>list.join(separator)</code></a><p>join turns a List into a string by inserting separator between the string representations
of all the elements of the List.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.pop.html" class="sig"><code class='prettyprint'>list.pop()</code></a><p>push removes an element from the end of a List.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.push.html" class="sig"><code class='prettyprint'>list.push(...elements)</code></a><p>push adds elements onto the end of a List.]</p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.replace.html" class="sig"><code class='prettyprint'>list.replace(collection)</code></a><p>Replace all the elements of a List. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.reverse.html" class="sig"><code class='prettyprint'>list.reverse()</code></a><p>reverse reverses the elements of the List in place.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.shift.html" class="sig"><code class='prettyprint'>list.shift()</code></a><p>shift removes an element from the beginning of a List.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.slice.html" class="sig"><code class='prettyprint'>list.slice([start[, end]])</code></a><p>slice creates a copy of a portion of the List.</p></div></div><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.splice.html" class="sig"><code class='prettyprint'>list.splice(index[, howMany[, ...newElements]])</code></a><p>Insert and remove elements from a List. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.List.prototype.unshift.html" class="sig"><code class='prettyprint'>list.unshift(...elements)</code></a><p>unshift adds elements onto the beginning of a List.</p></div></div></div><div class='group_1'><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="extend.html" class="sig"><code class='prettyprint'>can.List.extend([name,] [staticProperties,] instanceProperties)</code></a><p>Creates a new extended constructor function. </p></div></div></div><div class='group_1'><div class='group_2'><div class='group_3'><div class='small-signature'><a href="can.List.prototype.always.html" class="sig"><code class='prettyprint'>list.always( alwaysCallback )</code></a><p>Add handlers to be called when the list is either resolved or 
rejected. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.List.prototype.done.html" class="sig"><code class='prettyprint'>list.done( doneCallback )</code></a><p>Add handlers to be called when the list is resolved. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.List.prototype.fail.html" class="sig"><code class='prettyprint'>list.fail( failCallback )</code></a><p>Add handlers to be called when the list is rejected. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.List.prototype.isPending.html" class="sig"><code class='prettyprint'>list.isPending()</code></a><p>Returns if the <a href="can.List.prototype.state.html">state</a> of the list is pending.</p></div></div><div class='group_3'><div class='small-signature'><a href="can.List.prototype.isRejected.html" class="sig"><code class='prettyprint'>list.isRejected()</code></a><p>Returns if the <a href="can.List.prototype.state.html">state</a> of the list is rejected.</p></div></div><div class='group_3'><div class='small-signature'><a href="can.List.prototype.isResolved.html" class="sig"><code class='prettyprint'>list.isResolved()</code></a><p>Returns if the <a href="can.List.prototype.state.html">state</a> of the list is resolved.</p></div></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'><div class='small-signature'><a href="can.List.prototype.then.html" class="sig"><code class='prettyprint'>list.then( doneFilter, [failFilter] )</code></a><p>Add handlers to be called when the list 
is resolved or rejected. </p></div></div></div></div></div><div class='group_0'><div class='small-signature'><a href="can.Map.html" class="sig"><code class='prettyprint'>new can.Map([props])</code></a><p>Creates a new instance of can.Map.</p></div><div class='small-signature'><a href="can.Map.html" class="sig"><code class='prettyprint'>can.Map([name,] [staticProperties,] instanceProperties)</code></a><p>Creates a new extended constructor function. </p></div><div class='group_1'><div class='group_2'></div><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.Map.prototype.attr.html" class="sig"><code class='prettyprint'>map.attr()</code></a><p>Gets a collection of all the properties in this can.Map.</p></div><div class='small-signature'><a href="can.Map.prototype.attr.html" class="sig"><code class='prettyprint'>map.attr(key)</code></a><p>Reads a property from this can.Map.</p></div><div class='small-signature'><a href="can.Map.prototype.attr.html" class="sig"><code class='prettyprint'>map.attr(key, value)</code></a><p>Assigns value to a property on this can.Map called key.</p></div><div class='small-signature'><a href="can.Map.prototype.attr.html" class="sig"><code class='prettyprint'>map.attr(obj[, removeOthers])</code></a><p>Assigns each value in obj to a property on this can.Map named after the
corresponding key in obj, effectively merging obj into the Map.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.Map.prototype.bind.html" class="sig"><code class='prettyprint'>map.bind(eventType, handler)</code></a><p>Bind event handlers to an Map. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Map.prototype.compute.html" class="sig"><code class='prettyprint'>map.compute(attrName)</code></a><p>Make a can.compute from an observable property. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Map.prototype.each.html" class="sig"><code class='prettyprint'>map.each( callback(item, propName ) )</code></a><p>each iterates through the Map, calling a function
for each property value and key.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.Map.prototype.removeAttr.html" class="sig"><code class='prettyprint'>map.removeAttr(attrName)</code></a><p>Remove a property from an Map. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Map.prototype.serialize.html" class="sig"><code class='prettyprint'>map.serialize()</code></a><p>Get the serialized Object form of the map. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Map.prototype.unbind.html" class="sig"><code class='prettyprint'>map.unbind(eventType[, handler])</code></a><p>Unbind event handlers from an Map. </p></div></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.Map.keys.html" class="sig"><code class='prettyprint'>can.Map.keys(map)</code></a><p>Iterate over the keys of an Map. </p></div></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.LazyMap.html" class="sig"><code class='prettyprint'>new can.LazyLazyMap([props])</code></a><p>Creates a new instance of can.LazyMap.</p></div></div><div class='group_2'><div class='group_3'><div class='group_4'><div class='small-signature'><a href="can.Map.prototype.attributes.serialize.html" class="sig"><code class='prettyprint'>observe.serialize([attrName])</code></a><p>Serializes the observe's properties using the <a href="can.Map.attributes.html">attribute plugin</a>.</p></div></div></div><div class='group_3'><div class='group_4'></div><div class='group_4'></div><div class='group_4'></div></div></div><div class='group_2'><div class='group_3'><div class='small-signature'><a href="can.Map.backup.prototype.backup.html" class="sig"><code class='prettyprint'>map.backup()</code></a><p>backup backs up the current state of the properties of an Observe and marks
the Observe as clean. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.backup.prototype.isDirty.html" class="sig"><code class='prettyprint'>map.isDirty([deep])</code></a><p>isDirty checks whether any properties have changed value or whether any properties have
been added or removed since the last time the Observe was backed up. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.backup.prototype.restore.html" class="sig"><code class='prettyprint'>map.restore( [deep] )</code></a><p>restore sets the properties of an Observe back to what they were the last time
<a href="can.Map.backup.prototype.backup.html">backup</a> was called. </p></div></div></div><div class='group_2'><div class='group_3'><div class='small-signature'><a href="can.Map.prototype.delegate.html" class="sig"><code class='prettyprint'>observe.delegate( selector, event, handler )</code></a><p>delegate( selector, event, handler(ev,newVal,oldVal,from) ) listen for changes
in a child attribute from the parent. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.prototype.undelegate.html" class="sig"><code class='prettyprint'>observe.undelegate( selector, event, handler )</code></a><p>undelegate( selector, event, handler ) removes a delegated event handler from an observe.
</p></div></div></div><div class='group_2'><div class='group_3'><div class='small-signature'><a href="can.Map.prototype.define.TypeConstructor.html" class="sig"><code class='prettyprint'>constructorFunc</code></a><p>A constructor function can be provided that is called to convert incoming values set on this property, like:

define: {
  prop: {
    Type: Person
  }
}
</p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.prototype.define.ValueConstructor.html" class="sig"><code class='prettyprint'>constructorFunc</code></a><p>A constructor function can be provided that is called to create a default value used for this property, like:

define: {
  prop: {
    Value: Array
  },
  person: {
      Value: Person
  }
}
</p></div></div><div class='group_3'></div><div class='group_3'><div class='small-signature'><a href="can.Map.prototype.define.get.html" class="sig"><code class='prettyprint'>get( )</code></a><p>A get function defines the behavior of what happens when a value is read on a
<a href="can.Map.html">can.Map</a>. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.prototype.define.remove.html" class="sig"><code class='prettyprint'>remover( currentValue )</code></a><p>Called when an attribute is removed.</p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.prototype.define.serialize.html" class="sig"><code class='prettyprint'>serializer( currentValue )</code></a><p>Called when an attribute is removed.</p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.prototype.define.set.html" class="sig"><code class='prettyprint'>set( [newVal,] [setValue] )</code></a><p>A set function defines the behavior of what happens when a value is set on a
<a href="can.Map.html">can.Map</a>. </p></div></div><div class='group_3'></div><div class='group_3'><div class='small-signature'><a href="can.Map.prototype.define.value.html" class="sig"><code class='prettyprint'>defaulter()</code></a><p>A function can be provided that returns the default value used for this property, like:

define: {
  prop: {
    value: function(){ return []; }
  }
}


If the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object. </p></div><div class='small-signature'><a href="can.Map.prototype.define.value.html" class="sig"><code class='prettyprint'>defaulVal</code></a><p>Any value can be provided as the default value used for this property, like:

define: {
  prop: {
    value: 'foo'
  }
}
</p></div></div></div><div class='group_2'><div class='small-signature'><a href="can.Map.setter.html" class="sig"><code class='prettyprint'>setATTR: function(newValue,setValue,setErrors)</code></a><p>Specifies a setter method for the ATTR attribute.</p></div><div class='group_3'><div class='small-signature'><a href="can.classize.html" class="sig"><code class='prettyprint'>can.classize(str)</code></a><p>can.classize splits a string by underscores or
dashes and capitalizes each part before joining
them back together. </p></div></div></div><div class='group_2'><div class='group_3'><div class='small-signature'><a href="can.Map.validations.prototype.errors.html" class="sig"><code class='prettyprint'>observe.errors(attrs, newVal)</code></a><p></p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.validations.static.validate.html" class="sig"><code class='prettyprint'>observe.validate(attrNames, [options,] validateProc)</code></a><p></p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.validations.static.validateFormatOf.html" class="sig"><code class='prettyprint'>observe.validateFormatOf(attrNames, regexp, options)</code></a><p></p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.validations.static.validateInclusionOf.html" class="sig"><code class='prettyprint'>observe.validateInclusionOf(attrNames, inArray, options)</code></a><p>Validates whether the values of the specified attributes are available in a particular
array.
</p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.validations.static.validateLengthOf.html" class="sig"><code class='prettyprint'>observe.validateLengthOf(attrNames, min, max, options)</code></a><p>Validates that the specified attributes' lengths are in the given range.
</p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.validations.static.validatePresenceOf.html" class="sig"><code class='prettyprint'>observe.validatePresenceOf(attrNames, options)</code></a><p>Validates that the specified attributes are not blank.
</p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.validations.static.validateRangeOf.html" class="sig"><code class='prettyprint'>observe.validateRangeOf(attrNames, low, hi, options)</code></a><p>Validates that the specified attributes are in the given numeric range.
</p></div></div><div class='group_3'><div class='small-signature'><a href="can.Map.validations.static.validatesNumericalityOf.html" class="sig"><code class='prettyprint'>observe.validatesNumericalityOf(attrNames)</code></a><p>Validates that the specified attributes is a valid Number.
</p></div></div><div class='group_3'></div></div></div></div><div class='group_0'><div class='small-signature'><a href="can.Model.html" class="sig"><code class='prettyprint'>can.Model([name,] staticProperties, instanceProperties)</code></a><p>Create a can.Model constructor. </p></div><div class='small-signature'><a href="can.Model.html" class="sig"><code class='prettyprint'>new can.Model([options])</code></a><p>Creates a new instance of ModelConstructor.</p></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.Model.prototype.bind.html" class="sig"><code class='prettyprint'>model.bind(eventName, handler)</code></a><p>Listen to events on this Model. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.prototype.destroy.html" class="sig"><code class='prettyprint'>model.destroy([success[, error]])</code></a><p>Destroy a Model on the server. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.prototype.isNew.html" class="sig"><code class='prettyprint'>model.isNew()</code></a><p>Check if a Model has yet to be saved on the server. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.prototype.save.html" class="sig"><code class='prettyprint'>model.save([success[, error]])</code></a><p>Save a model back to the server. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.prototype.unbind.html" class="sig"><code class='prettyprint'>model.unbind(eventName[, handler])</code></a><p>Stop listening to events on this Model. </p></div></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.Model.bind.html" class="sig"><code class='prettyprint'>can.Model.bind(eventType, handler)</code></a><p>Listen for events on a Model class. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.create.html" class="sig"><code class='prettyprint'>can.Model.create: function(serialized) -> deferred</code></a><p>Specify a function to create persistent instances. </p></div><div class='small-signature'><a href="can.Model.create.html" class="sig"><code class='prettyprint'>can.Model.create: "[METHOD] /path/to/resource"</code></a><p>Specify a HTTP method and url to create persistent instances.
</p></div><div class='small-signature'><a href="can.Model.create.html" class="sig"><code class='prettyprint'>can.Model.create: {ajaxSettings}</code></a><p>Specify an options object that is used to make a HTTP request to create
persistent instances.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.destroy.html" class="sig"><code class='prettyprint'>can.Model.destroy: function(id) -> deferred</code></a><p>If you provide a function, the Model will expect you to do your own AJAX requests.</p></div><div class='small-signature'><a href="can.Model.destroy.html" class="sig"><code class='prettyprint'>can.Model.destroy: "[METHOD] /path/to/resource"</code></a><p>If you provide a URL, the Model will send a request to that URL using
the method specified (or DELETE if none is specified) when deleting an
instance on the server. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.findAll.html" class="sig"><code class='prettyprint'>can.Model.findAll( params[, success[, error]] )</code></a><p>Retrieve multiple resources from a server.</p></div><div class='small-signature'><a href="can.Model.findAll.html" class="sig"><code class='prettyprint'>can.Model.findAll: findAllData( params ) -> deferred</code></a><p>Implements findAll with a <a href="can.Model.findAllData.html">function</a>. </p></div><div class='small-signature'><a href="can.Model.findAll.html" class="sig"><code class='prettyprint'>can.Model.findAll: "[METHOD] /path/to/resource"</code></a><p>Implements findAll with a HTTP method and url to retrieve instance data.
</p></div><div class='small-signature'><a href="can.Model.findAll.html" class="sig"><code class='prettyprint'>can.Model.findAll: {ajaxSettings}</code></a><p>Implements findAll with a [can.AjaxSettings ajax settings object].
</p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.findOne.html" class="sig"><code class='prettyprint'>can.Model.findOne( params[, success[, error]] )</code></a><p>Retrieve a single instance from the server.</p></div><div class='small-signature'><a href="can.Model.findOne.html" class="sig"><code class='prettyprint'>can.Model.findOne: findOneData( params ) -> deferred</code></a><p>Implements findOne with a <a href="can.Model.findOneData.html">function</a>. </p></div><div class='small-signature'><a href="can.Model.findOne.html" class="sig"><code class='prettyprint'>can.Model.findOne: "[METHOD] /path/to/resource"</code></a><p>Implements findOne with a HTTP method and url to retrieve an instance's data.
</p></div><div class='small-signature'><a href="can.Model.findOne.html" class="sig"><code class='prettyprint'>can.Model.findOne: {ajaxSettings}</code></a><p>Implements findOne with a [can.AjaxSettings ajax settings object].
</p></div></div><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.Model.makeFindAll.html" class="sig"><code class='prettyprint'>can.Model.makeFindAll: function(findAllData) -> findAll</code></a><p>Returns the external findAll method given the implemented <a href="can.Model.findAllData.html">findAllData</a> function.
</p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.makeFindOne.html" class="sig"><code class='prettyprint'>can.Model.makeFindOne: function(findOneData) -> findOne</code></a><p>Returns the external findOne method given the implemented <a href="can.Model.findOneData.html">findOneData</a> function.
</p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.model.html" class="sig"><code class='prettyprint'>can.Model.model(data)</code></a><p>Convert raw data into a can.Model instance. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.models.html" class="sig"><code class='prettyprint'>can.Model.models(data[, oldList])</code></a><p>Convert raw data into can.Model instances. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.parseModel.html" class="sig"><code class='prettyprint'>can.Model.parseModel( data, xhr )</code></a><p>Convert raw data into an object that can be used to create a <a href="can.Model.html">can.Model</a> instance.</p></div><div class='small-signature'><a href="can.Model.parseModel.html" class="sig"><code class='prettyprint'>parseModel: "PROPERTY"</code></a><p>Creates a parseModel function that looks for the attributes object in the PROPERTY
property of raw instance data.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.parseModels.html" class="sig"><code class='prettyprint'>can.Model.parseModels(data, xhr)</code></a><p>Convert raw xhr data into an array or object that can be used to create a <a href="can.Model.List.html">can.Model.List</a>.</p></div><div class='small-signature'><a href="can.Model.parseModels.html" class="sig"><code class='prettyprint'>parseModels: "PROPERTY"</code></a><p>Creates a parseModels function that looks for the array of instance data in the PROPERTY
property of the raw response data of <a href="can.Model.findAll.html">can.Model.findAll</a>.</p></div></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.Model.unbind.html" class="sig"><code class='prettyprint'>can.Model.unbind(eventType, handler)</code></a><p>Stop listening for events on a Model class. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.Model.update.html" class="sig"><code class='prettyprint'>can.Model.update: "[METHOD] /path/to/resource"</code></a><p>If you provide a URL, the Model will send a request to that URL using
the method specified (or PUT if none is specified) when updating an
instance on the server. </p></div><div class='small-signature'><a href="can.Model.update.html" class="sig"><code class='prettyprint'>can.Model.update: function(id, serialized) -> can.Deffered</code></a><p>If you provide a function, the Model will expect you to do your own AJAX requests.</p></div></div></div></div><div class='group_0'><div class='small-signature'><a href="can.Model.List.html" class="sig"><code class='prettyprint'>new can.Model.List( [models] )</code></a><p>Create a model list with the provided model instances.</p></div><div class='small-signature'><a href="can.Model.List.html" class="sig"><code class='prettyprint'>new can.Model.List( params )</code></a><p>Create an initially empty model list, but use the model's <a href="can.Model.findAll.html">findAll</a>
to get a list of models and add it to this empty list.</p></div></div><div class='group_0'><div class='small-signature'><a href="can.compute.html" class="sig"><code class='prettyprint'>can.compute( getterSetter[, context] )</code></a><p>Create a compute that derives its value from <a href="can.Map.html">can.Map</a>s and other <a href="can.computed.html">can.compute</a>s.</p></div><div class='small-signature'><a href="can.compute.html" class="sig"><code class='prettyprint'>can.compute( initialValue [, settings] )</code></a><p>Creates a compute from a value and optionally specifies how to read, update, and 
listen to changes in dependent values. </p></div><div class='small-signature'><a href="can.compute.html" class="sig"><code class='prettyprint'>can.compute( initialValue, setter(newVal,oldVal) )</code></a><p>Create a compute that has a setter that can adjust incoming new values.
</p></div><div class='small-signature'><a href="can.compute.html" class="sig"><code class='prettyprint'>can.compute( object, propertyName [, eventName] )</code></a><p>Create a compute from an object's property value. </p></div><div class='group_1'><div class='small-signature'><a href="can.computed.html" class="sig"><code class='prettyprint'>compute( [newVal] )</code></a><p></p></div></div><div class='group_1'><div class='small-signature'><a href="can.computed.bind.html" class="sig"><code class='prettyprint'>compute.bind(eventType, handler)</code></a><p>Bind an event handler to a compute. </p></div></div><div class='group_1'></div><div class='group_1'><div class='small-signature'><a href="computed.unbind.html" class="sig"><code class='prettyprint'>compute.unbind(eventType[, handler])</code></a><p>Unbind an event handler from a compute. </p></div></div></div><div class='group_0'><div class='small-signature'><a href="can.ejs.html" class="sig"><code class='prettyprint'>can.ejs( [id,] template )</code></a><p>Creates an instance of an EJS template.</p></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.ejs.tags.scriptlet.html" class="sig"><code class='prettyprint'><% CODE %></code></a><p>Runs JavaScript Code.
</p></div></div><div class='group_2'><div class='small-signature'><a href="can.ejs.tags.escaped.html" class="sig"><code class='prettyprint'><%= CODE %></code></a><p>Runs JS Code and writes the escaped result into the result of the template. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.ejs.tags.unescaped.html" class="sig"><code class='prettyprint'><%== CODE %></code></a><p>Runs JS Code and writes the unescaped result into the result of the template.
</p></div></div><div class='group_2'><div class='small-signature'><a href="can.ejs.tags.templated.html" class="sig"><code class='prettyprint'><%% CODE %></code></a><p>Renders &lt;% CODE %> as text in result of the template rather than running CODE itself. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.ejs.tags.comment.html" class="sig"><code class='prettyprint'><%# CODE %></code></a><p>Used for explicitly for comments. </p></div></div></div><div class='group_1'></div></div><div class='group_0'><div class='small-signature'><a href="can.event.html" class="sig"><code class='prettyprint'>can.extend(YourClass.prototype, can.event)</code></a><p>Adds event functionality to YourClass objects. </p></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.event.propagate.html" class="sig"><code class='prettyprint'>can.extend(YourClass.prototype, can.event, { propagate: "parent" })</code></a><p>Adds event functionality with event propagation to YourClass objects. </p></div></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.event.addEvent.html" class="sig"><code class='prettyprint'>obj.addEvent( event, handler )</code></a><p>Add a basic event listener to an object.</p></div><div class='small-signature'><a href="can.event.addEvent.html" class="sig"><code class='prettyprint'>can.event.addEvent.call( obj, event, handler )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.bind.html" class="sig"><code class='prettyprint'>obj.bind( event, handler )</code></a><p>Add a basic event listener to an object.
</p></div><div class='small-signature'><a href="can.event.bind.html" class="sig"><code class='prettyprint'>can.event.bind.call( obj, event, handler )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.dispatch.html" class="sig"><code class='prettyprint'>obj.dispatch( event, args )</code></a><p>Dispatches/triggers a basic event on an object.</p></div><div class='small-signature'><a href="can.event.dispatch.html" class="sig"><code class='prettyprint'>can.event.dispatch.call( obj, event, args )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.listenTo.html" class="sig"><code class='prettyprint'>obj.listenTo( other, event, handler )</code></a><p>Listens for an event on another object.
</p></div><div class='small-signature'><a href="can.event.listenTo.html" class="sig"><code class='prettyprint'>can.event.listenTo.call( obj, other, event, handler )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.off.html" class="sig"><code class='prettyprint'>obj.off( event, handler )</code></a><p>Removes a basic event listener from an object.
</p></div><div class='small-signature'><a href="can.event.off.html" class="sig"><code class='prettyprint'>can.event.off.call( obj, event, handler )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.on.html" class="sig"><code class='prettyprint'>obj.on( event, handler )</code></a><p>Add a basic event listener to an object.
</p></div><div class='small-signature'><a href="can.event.on.html" class="sig"><code class='prettyprint'>can.event.on.call( obj, event, handler )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.one.html" class="sig"><code class='prettyprint'>obj.one( event, handler )</code></a><p>Adds a basic event listener that listens to an event once and only once.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.removeEvent.html" class="sig"><code class='prettyprint'>obj.removeEvent( event, handler )</code></a><p>Removes a basic event listener from an object.</p></div><div class='small-signature'><a href="can.event.removeEvent.html" class="sig"><code class='prettyprint'>can.event.removeEvent.call( obj, event, handler )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.stopListening.html" class="sig"><code class='prettyprint'>obj.stopListening( other, event, handler )</code></a><p>Stops listening for an event on another object.</p></div><div class='small-signature'><a href="can.event.stopListening.html" class="sig"><code class='prettyprint'>can.event.stopListening.call( obj, other, event, handler )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.trigger.html" class="sig"><code class='prettyprint'>obj.trigger( event, args )</code></a><p>Dispatches/triggers a basic event on an object.
</p></div><div class='small-signature'><a href="can.event.trigger.html" class="sig"><code class='prettyprint'>can.event.trigger.call( obj, event, args )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.unbind.html" class="sig"><code class='prettyprint'>obj.unbind( event, handler )</code></a><p>Removes a basic event listener from an object.
</p></div><div class='small-signature'><a href="can.event.unbind.html" class="sig"><code class='prettyprint'>can.event.unbind.call( obj, event, handler )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.event.undelegate.html" class="sig"><code class='prettyprint'>obj.undelegate( selector, event, handler )</code></a><p>Provides a compatibility layer for removing delegate event listeners.
</p></div><div class='small-signature'><a href="can.event.undelegate.html" class="sig"><code class='prettyprint'>can.event.undelegate.call( obj, selector, event, handler )</code></a><p>This syntax can be used for objects that don't include the can.event mixin.</p></div></div></div></div><div class='group_0'><div class='small-signature'><a href="can.fixture.html" class="sig"><code class='prettyprint'>can.fixture( url, toUrl )</code></a><p>Trap requests from one url and redirect them from another.</p></div><div class='small-signature'><a href="can.fixture.html" class="sig"><code class='prettyprint'>can.fixture( url, handler(request, response, requestHeaders) )</code></a><p>Trap requests to a url and provide the response with a
callback function.</p></div><div class='small-signature'><a href="can.fixture.html" class="sig"><code class='prettyprint'>can.fixture(fixtures)</code></a><p>Configures multiple ajax traps.</p></div><div class='group_1'></div><div class='group_1'><div class='group_2'><div class='group_3'><div class='small-signature'><a href="can.fixture.types.Store.create.html" class="sig"><code class='prettyprint'>store.create(request, callback)</code></a><p>Simulate creating a Model with a fixture. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.fixture.types.Store.destroy.html" class="sig"><code class='prettyprint'>store.destroy(request, callback)</code></a><p>Simulate destroying a Model on a fixture. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.fixture.types.Store.find.html" class="sig"><code class='prettyprint'>store.find(settings)</code></a><p>Get an item from the store by ID. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.fixture.types.Store.findAll.html" class="sig"><code class='prettyprint'>store.findAll(request)</code></a><p>store.findAll(request) simulates a request to
get a list items from the server. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.fixture.types.Store.findOne.html" class="sig"><code class='prettyprint'>store.findOne(request, response)</code></a><p>Simulate a findOne request on a fixture. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.fixture.types.Store.reset.html" class="sig"><code class='prettyprint'>store.reset()</code></a><p>Reset the fixture store. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.fixture.types.Store.update.html" class="sig"><code class='prettyprint'>store.update(request, callback)</code></a><p>Simulate an update on a fixture. </p></div></div></div><div class='group_2'></div><div class='group_2'></div></div><div class='group_1'><div class='small-signature'><a href="can.fixture.rand.html" class="sig"><code class='prettyprint'>can.fixture.rand([min,] max)</code></a><p>Create a random number or selection. </p></div><div class='small-signature'><a href="can.fixture.rand.html" class="sig"><code class='prettyprint'>can.fixture.rand(choices, min[ ,max])</code></a><p>Create a random number or selection. </p></div></div><div class='group_1'></div><div class='group_1'></div><div class='group_1'><div class='small-signature'><a href="can.fixture.store.html" class="sig"><code class='prettyprint'>can.fixture.store(count, make[, filter])</code></a><p>Make a store of objects to use when making requests against fixtures. </p></div></div></div><div class='group_0'><div class='small-signature'><a href="can.mustache.html" class="sig"><code class='prettyprint'>can.mustache( [id,] template )</code></a><p>Creates an instance of a mustache template.</p></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.mustache.registerHelper.html" class="sig"><code class='prettyprint'>Mustache.registerHelper(name, helper)</code></a><p>Register a helper. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.safeString.html" class="sig"><code class='prettyprint'>can.mustache.safeString(str)</code></a><p></p></div></div></div><div class='group_1'><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div></div><div class='group_1'><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.mustache.tags.escaped.html" class="sig"><code class='prettyprint'>{{key}}</code></a><p>Insert the value of the <a href="can.mustache.key.html">key</a> into the output of the template.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.tags.unescaped.html" class="sig"><code class='prettyprint'>{{{key}}}</code></a><p>Behaves just like <a href="can.mustache.tags.escaped.html">{{key}}</a> and <a href="can.mustache.helpers.helper.html">{{helper}}</a> but does not
escape the result.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.tags.unescaped2.html" class="sig"><code class='prettyprint'>{{&key}}</code></a><p>The {{&amp;key}} tag is an alias for <a href="can.mustache.tags.unescaped.html">{{{key}}}</a>, behaving just
like <a href="can.mustache.tags.escaped.html">{{key}}</a> and <a href="can.mustache.helpers.helper.html">{{helper}}</a> but does not
escape the result.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.section.html" class="sig"><code class='prettyprint'>{{#key}}BLOCK{{/key}}</code></a><p>Render blocks of text one or more times, depending
on the value of the key in the current context.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.close.html" class="sig"><code class='prettyprint'>{{/key}}</code></a><p>Ends a <a href="can.mustache.helpers.section.html">{{#key}}</a> or <a href="can.mustache.helpers.sectionHelper.html">{{#helper}}</a>
block.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.inverse.html" class="sig"><code class='prettyprint'>{{^key}}BLOCK{{/key}}</code></a><p>Render blocks of text if the value of the key
is falsey. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.partial.html" class="sig"><code class='prettyprint'>{{>key}}</code></a><p>Render another template within the current template.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.tags.comment.html" class="sig"><code class='prettyprint'>{{!key}}</code></a><p>The comment tag operates similarly to a &lt;!-- --&gt; tag in HTML. </p></div></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.helper.html" class="sig"><code class='prettyprint'>{{helper [args...] [hashProperty=hashValue...]}}</code></a><p>Calls a mustache helper function or a function. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.sectionHelper.html" class="sig"><code class='prettyprint'>{{#helper [args...] [hashName=hashValue...]}}BLOCK{{/helper}}</code></a><p>Calls a mustache helper function or a function with a block to
render.
</p></div><div class='small-signature'><a href="can.mustache.helpers.sectionHelper.html" class="sig"><code class='prettyprint'>{{#helper [args...] [hashName=hashValue...]}}BLOCK{{else}}INVERSE{{/helper}}</code></a><p>Calls a mustache helper function or a function with a fn and inverse block to
render.
</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.if.html" class="sig"><code class='prettyprint'>{{#if key}}BLOCK{{/if}}</code></a><p>Renders the BLOCK template within the current template.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.else.html" class="sig"><code class='prettyprint'>{{#helper}}BLOCK{{else}}INVERSE{{/helper}}</code></a><p>Creates an inverse block for a <a href="can.mustache.helper.html">helper function</a>'s
<a href="can.mustache.helperOptions.html">options argument</a>'s inverse property.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.unless.html" class="sig"><code class='prettyprint'>{{#unless key}}BLOCK{{/unless}}</code></a><p>Render the block of text if the key's value is falsey.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.each.html" class="sig"><code class='prettyprint'>{{#each key}}BLOCK{{/each}}</code></a><p>Render the block of text for each item in key's value.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.with.html" class="sig"><code class='prettyprint'>{{#with key}}BLOCK{{/with}}</code></a><p>Changes the context within a block.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.data.html" class="sig"><code class='prettyprint'>{{data name}}</code></a><p>Adds the current <a href="can.mustache.context.html">context</a> to the
element's <a href="can.data.html">can.data</a>.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.elementCallback.html" class="sig"><code class='prettyprint'>{{(el) -> CODE}}</code></a><p>Executes an element callback with the inline code on the element.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.log.html" class="sig"><code class='prettyprint'>{{#log [message]}}</code></a><p>Logs the context of the current block with an optional message.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.index.html" class="sig"><code class='prettyprint'>{{@index [offset]}}</code></a><p>Insert the index of an Array or can.List we are iterating on with #each</p></div></div><div class='group_2'><div class='small-signature'><a href="can.mustache.helpers.key.html" class="sig"><code class='prettyprint'>{{@key}}</code></a><p>Insert the property name of an Object or attribute name of a can.Map that we iterate over with #each</p></div></div></div></div><div class='group_0'><div class='small-signature'><a href="can.route.html" class="sig"><code class='prettyprint'>can.route( template [, defaults] )</code></a><p>Create a route matching rule.</p></div><div class='group_1'><div class='group_2'></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.route.current.html" class="sig"><code class='prettyprint'>can.route.current( data )</code></a><p>Check if data represents the current route.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.route.deparam.html" class="sig"><code class='prettyprint'>can.route.deparam( url )</code></a><p>Extract data from a route path. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.route.link.html" class="sig"><code class='prettyprint'>can.route.link( innerText, data, props [, merge] )</code></a><p>Make an anchor tag (&lt;A&gt;) that when clicked on will update can.route's properties
to match those in data.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.route.map.html" class="sig"><code class='prettyprint'>can.route.map(mapConstructor)</code></a><p>Assign a can.Map instance that acts as can.route's internal can.Map. </p></div><div class='small-signature'><a href="can.route.map.html" class="sig"><code class='prettyprint'>can.route.map(mapInstance)</code></a><p>Assign a can.Map instance that acts as can.route's internal can.Map. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.route.param.html" class="sig"><code class='prettyprint'>can.route.param( data )</code></a><p>Get a route path from given data. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.route.ready.html" class="sig"><code class='prettyprint'>can.route.ready()</code></a><p>Sets up the two-way binding between the hash and the can.route observable map and
sets the can.route map to its initial values.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.route.url.html" class="sig"><code class='prettyprint'>can.route.url( data [, merge] )</code></a><p>Make a URL fragment that when set to window.location.hash will update can.route's properties
to match those in data.</p></div></div></div></div><div class='group_0'><div class='small-signature'><a href="can.stache.html" class="sig"><code class='prettyprint'>can.stache(template)</code></a><p>Processes the template and returns a <a href="can.view.renderer.html">can.view.renderer</a> function that renders the template
with data and local helpers.</p></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.stache.registerHelper.html" class="sig"><code class='prettyprint'>can.stache.registerHelper(name, helper)</code></a><p>Register a helper. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.safeString.html" class="sig"><code class='prettyprint'>can.stache.safeString(str)</code></a><p></p></div></div></div><div class='group_1'><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div></div><div class='group_1'><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.stache.tags.escaped.html" class="sig"><code class='prettyprint'>{{key}}</code></a><p>Insert the value of the <a href="can.stache.key.html">key</a> into the output of the template.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.tags.unescaped.html" class="sig"><code class='prettyprint'>{{{key}}}</code></a><p>Behaves just like <a href="can.stache.tags.escaped.html">{{key}}</a> and <a href="can.stache.helpers.helper.html">{{helper}}</a> but does not
escape the result.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.tags.unescaped2.html" class="sig"><code class='prettyprint'>{{&key}}</code></a><p>The {{&amp;key}} tag is an alias for <a href="can.stache.tags.unescaped.html">{{{key}}}</a>, behaving just
like <a href="can.stache.tags.escaped.html">{{key}}</a> and <a href="can.stache.helpers.helper.html">{{helper}}</a> but does not
escape the result.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.tags.section.html" class="sig"><code class='prettyprint'>{{#key}}BLOCK{{/key}}</code></a><p>Render blocks of text one or more times, depending
on the value of the key in the current context.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.tags.close.html" class="sig"><code class='prettyprint'>{{/key}}</code></a><p>Ends a <a href="can.stache.tags.section.html">{{#key}}</a> or [can.stache.tags.sectionHelper {{#helper}}]
block.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.tags.inverse.html" class="sig"><code class='prettyprint'>{{^key}}BLOCK{{/key}}</code></a><p>Render blocks of text if the value of the key
is falsey. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.partial.html" class="sig"><code class='prettyprint'>{{>key}}</code></a><p>Render another template within the current template.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.tags.comment.html" class="sig"><code class='prettyprint'>{{!key}}</code></a><p>The comment tag operates similarly to a &lt;!-- --&gt; tag in HTML. </p></div></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.helper.html" class="sig"><code class='prettyprint'>{{helper [args...] [hashProperty=hashValue...]}}</code></a><p>Calls a stache helper function or a function. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.sectionHelper.html" class="sig"><code class='prettyprint'>{{#helper [args...] [hashName=hashValue...]}}BLOCK{{/helper}}</code></a><p>Calls a stache helper function or a function with a block to
render.
</p></div><div class='small-signature'><a href="can.stache.helpers.sectionHelper.html" class="sig"><code class='prettyprint'>{{#helper [args...] [hashName=hashValue...]}}BLOCK{{else}}INVERSE{{/helper}}</code></a><p>Calls a stache helper function or a function with a fn and inverse block to
render.
</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.if.html" class="sig"><code class='prettyprint'>{{#if key}}BLOCK{{/if}}</code></a><p>Renders the BLOCK template within the current template.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.else.html" class="sig"><code class='prettyprint'>{{#helper}}BLOCK{{else}}INVERSE{{/helper}}</code></a><p>Creates an inverse block for a <a href="can.stache.helper.html">helper function</a>'s
<a href="can.stache.helperOptions.html">options argument</a>'s inverse property.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.unless.html" class="sig"><code class='prettyprint'>{{#unless key}}BLOCK{{/unless}}</code></a><p>Render the block of text if the key's value is falsey.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.each.html" class="sig"><code class='prettyprint'>{{#each key}}BLOCK{{/each}}</code></a><p>Render the block of text for each item in key's value.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.with.html" class="sig"><code class='prettyprint'>{{#with key}}BLOCK{{/with}}</code></a><p>Changes the context within a block.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.data.html" class="sig"><code class='prettyprint'>{{data name}}</code></a><p>Adds the current <a href="can.stache.context.html">context</a> to the
element's <a href="can.data.html">can.data</a>.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.log.html" class="sig"><code class='prettyprint'>{{#log [message]}}</code></a><p>Logs the context of the current block with an optional message.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.index.html" class="sig"><code class='prettyprint'>{{@index [offset]}}</code></a><p>Insert the index of an Array or can.List we are iterating on with #each</p></div></div><div class='group_2'><div class='small-signature'><a href="can.stache.helpers.key.html" class="sig"><code class='prettyprint'>{{@key}}</code></a><p>Insert the property name of an Object or attribute name of a can.Map that we iterate over with #each</p></div></div></div></div><div class='group_0'><div class='group_1'><div class='small-signature'><a href="can.$.html" class="sig"><code class='prettyprint'>can.$(element)</code></a><p>Make a library's nodelist. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.Deferred.html" class="sig"><code class='prettyprint'>can.Deferred()</code></a><p>can.Deferred is a object that allows users to assign and chain callback function(s) for the success or failure state of both asynchronous and synchronous function(s).</p></div><div class='group_2'><div class='group_3'><div class='small-signature'><a href="can.Deferred.prototype.always.html" class="sig"><code class='prettyprint'>deferred.always(alwaysCallbacks)</code></a><p>Add one or more callbacks to be unconditionally called when a Deferred is resolved or rejected. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Deferred.prototype.done.html" class="sig"><code class='prettyprint'>deferred.done(doneCallbacks)</code></a><p>Add one or more callbacks to be called when a Deferred is resolved. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Deferred.prototype.fail.html" class="sig"><code class='prettyprint'>deferred.fail(failCallbacks)</code></a><p>Add a callback to be called when a Deferred is rejected. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Deferred.prototype.isResolved.html" class="sig"><code class='prettyprint'>deferred.isResolved()</code></a><p>Determine whether a Deferred has been resolved. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Deferred.prototype.reject.html" class="sig"><code class='prettyprint'>deferred.reject([argument])</code></a><p>Reject a Deferred. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Deferred.prototype.rejectWith.html" class="sig"><code class='prettyprint'>deferred.rejectWith(context[, arguments])</code></a><p>Reject a Deferred in a particular context. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Deferred.prototype.resolve.html" class="sig"><code class='prettyprint'>deferred.resolve([argument])</code></a><p>Resolve a Deferred. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Deferred.prototype.resolveWith.html" class="sig"><code class='prettyprint'>deferred.resolveWith(context[, arguments])</code></a><p>Resolve a Deferred in a particular context. </p></div></div><div class='group_3'><div class='small-signature'><a href="can.Deferred.prototype.then.html" class="sig"><code class='prettyprint'>deferred.then(doneCallback[, failCallback])</code></a><p>Add callbacks to a Deferred. </p></div></div></div></div><div class='group_1'><div class='small-signature'><a href="can.Object.same.html" class="sig"><code class='prettyprint'>can.Object.same(a, b, compares, aParent, bParent, deep)</code></a><p>Checks if two objects are the same. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.Object.subset.html" class="sig"><code class='prettyprint'>can.Object.subset(subset, set, compares)</code></a><p>Compares if subset is a subset of set. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.Object.subsets.html" class="sig"><code class='prettyprint'>can.Object.subsets(checkSet, sets, compares)</code></a><p>Returns the sets in 'sets' that are a subset of checkSet 

can.Object.subsets({userId: 20},
[
{userId: 20, limit: 30},
{userId: 5},
{}
]) //-> [{userId: 20, limit: 30}]</p></div></div><div class='group_1'><div class='small-signature'><a href="can.addClass.html" class="sig"><code class='prettyprint'>can.addClass(nodeList, className)</code></a><p>Add a class to elements. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.ajax.html" class="sig"><code class='prettyprint'>can.ajax(settings)</code></a><p>Make an AJAX request. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.append.html" class="sig"><code class='prettyprint'>can.append(nodeList, html)</code></a><p>Append content to elements. </p></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.batch.start.html" class="sig"><code class='prettyprint'>can.batch.start([batchStopHandler])</code></a><p>Begin an event batch. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.batch.stop.html" class="sig"><code class='prettyprint'>can.batch.stop([force[, callStart]])</code></a><p>End an event batch. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.batch.trigger.html" class="sig"><code class='prettyprint'>can.batch.trigger(item, event [, args])</code></a><p>Trigger an event to be added to the current batch. </p></div></div></div><div class='group_1'><div class='small-signature'><a href="can.bind.html" class="sig"><code class='prettyprint'>can.bind.call(target, eventName, handler)</code></a><p>Listen for events on an object. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.buildFragment.html" class="sig"><code class='prettyprint'>can.buildFragment(html, node)</code></a><p>Make a document fragment. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.capitalize.html" class="sig"><code class='prettyprint'>can.capitalize(str)</code></a><p>Capitalize the first letter of a string. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.data.html" class="sig"><code class='prettyprint'>can.data(nodeList, key, value)</code></a><p>Associate data with or retrieve data from DOM nodes. </p></div><div class='small-signature'><a href="can.data.html" class="sig"><code class='prettyprint'>can.data(nodeList, key)</code></a><p>Associate data with or retrieve data from DOM nodes. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.delegate.html" class="sig"><code class='prettyprint'>can.delegate.call(element, selector, eventName, handler)</code></a><p>Listen for events from the children of an element. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.deparam.html" class="sig"><code class='prettyprint'>can.deparam(params)</code></a><p>Takes a string of name value pairs and returns a Object literal that represents those params. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.each.html" class="sig"><code class='prettyprint'>can.each(collection, callback)</code></a><p>Iterate through an array or object. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.esc.html" class="sig"><code class='prettyprint'>can.esc(str)</code></a><p>Escapes a string for insertion into HTML. </p></div></div><div class='group_1'><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div></div><div class='group_1'><div class='small-signature'><a href="can.extend.html" class="sig"><code class='prettyprint'>can.extend(target, ...obj)</code></a><p>Merge objects together. </p></div></div><div class='group_1'></div><div class='group_1'><div class='small-signature'><a href="can.getObject.html" class="sig"><code class='prettyprint'>can.getObject(name, roots, add)</code></a><p>Gets an object from a string.</p></div></div><div class='group_1'><div class='small-signature'><a href="can.isArray.html" class="sig"><code class='prettyprint'>can.isArray(obj)</code></a><p>Check if an object is an array. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.isDeferred.html" class="sig"><code class='prettyprint'>can.isDeferred(subject)</code></a><p>Check if an object is a Deferred. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.isEmptyObject.html" class="sig"><code class='prettyprint'>can.isEmptyObject(obj)</code></a><p>Check if an object has no properties. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.isFunction.html" class="sig"><code class='prettyprint'>can.isFunction(obj)</code></a><p>Check if an Object is a function. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.makeArray.html" class="sig"><code class='prettyprint'>can.makeArray(arrLike)</code></a><p>Convert an array-like object to an Array. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.off.html" class="sig"><code class='prettyprint'>can.off.call(target, eventName, handler)</code></a><p>Stop listening for events on an object. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.on.html" class="sig"><code class='prettyprint'>can.on.call(target, eventName, handler)</code></a><p>Listen for events on an object. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.param.html" class="sig"><code class='prettyprint'>can.param(obj)</code></a><p>Serialize an object into a query string. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.proxy.html" class="sig"><code class='prettyprint'>can.proxy(fn, context)</code></a><p>Bind a function to its context. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.remove.html" class="sig"><code class='prettyprint'>can.remode(nodeList)</code></a><p>Remove elements from the DOM. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.sub.html" class="sig"><code class='prettyprint'>can.sub(str, data, remove, s)</code></a><p>Returns a string with {param} replaced values from data. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.trigger.html" class="sig"><code class='prettyprint'>can.trigger(target, eventName[, args])</code></a><p>Trigger an event on an object. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.trim.html" class="sig"><code class='prettyprint'>can.trim(str)</code></a><p>Trim whitespace off a string. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.unbind.html" class="sig"><code class='prettyprint'>can.unbind.call(target, eventName, handler)</code></a><p>Stop listening for events on an object. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.undelegate.html" class="sig"><code class='prettyprint'>can.undelegate.call(element, selector, eventName, handler)</code></a><p>Stop listening for events from the children of an element. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.underscore.html" class="sig"><code class='prettyprint'>can.underscore(str)</code></a><p>Takes a CamelCase or mixedCase string and underscores the string on the capital letter. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.when.html" class="sig"><code class='prettyprint'>can.when(deferred)</code></a><p>Call a callback when a Deferred resolves. </p></div></div></div><div class='group_0'><div class='small-signature'><a href="can.view.html" class="sig"><code class='prettyprint'>can.view( idOrUrl, data[, helpers] )</code></a><p>Loads a template, renders it with data and helper functions and returns 
the HTML of the template within 
a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment">documentFragment</a>.
</p></div><div class='small-signature'><a href="can.view.html" class="sig"><code class='prettyprint'>can.view( idOrUrl )</code></a><p>Registers or loads a template and returns a <a href="can.view.renderer.html">renderer</a> function that can be used to
render the template with data and helpers.
</p></div><div class='group_1'><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'></div></div><div class='group_1'><div class='group_2'><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div></div></div><div class='group_1'><div class='group_2'><div class='small-signature'><a href="can.view.Options.html" class="sig"><code class='prettyprint'>new can.view.Options(options, [parent])</code></a><p>Create a helper lookup node  for <a href="can.mustache.key.html">keys</a>. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.view.Scope.html" class="sig"><code class='prettyprint'>new can.view.Scope(context, [parent])</code></a><p>Create a lookup node for <a href="can.mustache.key.html">keys</a>. </p></div><div class='group_3'><div class='group_4'></div><div class='group_4'></div><div class='group_4'><div class='small-signature'><a href="can.view.Scope.compute.html" class="sig"><code class='prettyprint'>scope.compute( key, [options] )</code></a><p></p></div></div><div class='group_4'></div><div class='group_4'></div><div class='group_4'></div></div><div class='group_3'><div class='group_4'><div class='small-signature'><a href="can.view.Scope.read.html" class="sig"><code class='prettyprint'>Scope.read(parent, reads, options)</code></a><p></p></div></div></div><div class='group_3'><div class='group_4'></div></div></div><div class='group_2'><div class='small-signature'><a href="can.view.attr.html" class="sig"><code class='prettyprint'>can.view.attr( attributeName, attrHandler(el, attrData) )</code></a><p>Register custom behavior for an attribute.</p></div></div><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.view.ejs.html" class="sig"><code class='prettyprint'>can.view.ejs( [id,] template )</code></a><p>Register an EJS template string and create a renderer function.
</p></div></div><div class='group_2'></div><div class='group_2'></div><div class='group_2'><div class='small-signature'><a href="can.view.hook.html" class="sig"><code class='prettyprint'>can.view.hook(callback)</code></a><p>Create a hookup to insert into templates. </p></div></div><div class='group_2'><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div></div><div class='group_2'><div class='small-signature'><a href="can.view.mustache.html" class="sig"><code class='prettyprint'>can.mustache( [id,] template )</code></a><p>Register a Mustache template string and create a renderer function.
</p></div></div><div class='group_2'><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div><div class='group_3'></div></div><div class='group_2'><div class='small-signature'><a href="can.view.register.html" class="sig"><code class='prettyprint'>can.view.register(info)</code></a><p>Register a templating language. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.view.render.html" class="sig"><code class='prettyprint'>can.view.render(template[, callback])</code></a><p>Render a template. </p></div><div class='small-signature'><a href="can.view.render.html" class="sig"><code class='prettyprint'>can.view.render(template, data[, [helpers,] callback])</code></a><p>Render a template. </p></div></div><div class='group_2'><div class='small-signature'><a href="can.view.tag.html" class="sig"><code class='prettyprint'>can.view.tag( tagName, tagHandler(el, tagData) )</code></a><p>Registers the tagHandler callback when tagName is found 
in a template.</p></div></div></div></div><div class='group_0'><div class='group_1'><div class='small-signature'><a href="can.view.bindings.can-EVENT.html" class="sig"><code class='prettyprint'>can-EVENT='KEY'</code></a><p>Specify a callback function to be called on a particular event. </p></div></div><div class='group_1'><div class='small-signature'><a href="can.view.bindings.can-value.html" class="sig"><code class='prettyprint'>can-value='KEY'</code></a><p>Binds the element's value or checked property to the value specified by
key. </p></div><div class='group_2'><div class='small-signature'><a href="can.view.bindings.can-value-checkbox.html" class="sig"><code class='prettyprint'><input type='checkbox' can-value='KEY' can-true-value='TRUEVALUE' can-false-value='FALSEVALUE'/></code></a><p>Cross binds the checked property to a true or false value.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.view.bindings.can-value-radio.html" class="sig"><code class='prettyprint'><input type='radio' can-value='KEY' value='VALUE'/></code></a><p>If the radio element is checked, sets the observable specified by can-value to match the value of 
value attribute.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.view.bindings.can-value-select.html" class="sig"><code class='prettyprint'><select can-value='KEY'/></code></a><p>Cross binds the selected option value with an observable value.</p></div></div><div class='group_2'><div class='small-signature'><a href="can.view.bindings.can-value-select-multiple.html" class="sig"><code class='prettyprint'><select multiple can-value='KEY'/></code></a><p>Cross binds the selected option values with an observable value.</p></div></div></div></div>
		</section>
		
	</article>
</div>

<script type="text/javascript">
	var docData = {"type":"page","name":"canjs","description":"","title":"CanJS","parent":"javascriptmvc","order":0,"comment":" ","api":"canjs","src":"can/can.md","id":0,"children":[{"type":"constructor","name":"can.Component","description":"<p>Create widgets that use a template, a view-model  and custom tags.</p>","title":"","download":"can/component","test":"can/component/test.html","parent":"canjs","release":"2.0","links":[{"href":"../docco/component/component.html","title":"docco"}],"deprecated":[{"version":"2.1","description":"<p>To pass data from the scope, you must wrap your attribute \nvalue with <code>{}</code>. In 3.0, [can.mustache]\nwill use [can.stache]'s method.</p>"}],"signatures":[{"code":"< TAG [ATTR-NAME=KEY|ATTR-VALUE] >","description":"<p>Create an instance of a component on a particular \ntag in a [can.mustache] template.</p>","params":[{"types":[{"type":"String"}],"name":"TAG","description":"<p>An HTML tag name that matches the [can.Component::tag tag]\nproperty of the component.</p>"},{"types":[{"type":"String"}],"name":"ATTR-NAME","description":"<p>An HTML attribute name. Any attribute name is\nvalid. Any attributes added to the element are added as properties to the\ncomponent's [can.Component::scope scope].</p>"},{"types":[{"type":"can.mustache.key"}],"optional":true,"name":"ATTR-VALUE","description":"<p>Specifies the value of a property passed to\nthe component instance's [can.Component::scope scope]. By default <code>ATTR-VALUE</code>\nvalues are looked up in the [can.view.Scope can.mustache scope]. If the string value\nof the <code>ATTR-NAME</code> is desired, this can be specified like: </p>\n\n<pre><code>ATTR-NAME: \"@\"\n</code></pre>"},{"types":[{"type":"can.mustache.key"}],"optional":true,"name":"KEY","description":"<p>Specifies the value of a property passed to\nthe component instance's [can.Component::scope scope] that will be looked\nup in the [can.view.Scope can.stache scope].</p>"}]},{"code":"< TAG [ATTR-NAME=\"{KEY}|ATTR-VALUE\"] >","description":"<p>Create an instance of a component on a particular \ntag in a [can.stache] template.</p>","params":[{"types":[{"type":"String"}],"name":"TAG","description":"<p>An HTML tag name that matches the [can.Component::tag tag]\nproperty of the component.</p>"},{"types":[{"type":"String"}],"name":"ATTR-NAME","description":"<p>An HTML attribute name. Any attribute name is\nvalid. Any attributes added to the element are added as properties to the\ncomponent's [can.Component::scope scope]. In the DOM, attribute names\nare case insensitive.  To pass a camelCase attribute to the component's scope,\nhypenate the attribute name like:</p>\n\n<pre><code>&lt;tag attr-name=\"{key}\"&gt;&lt;/tag&gt;\n</code></pre>\n\n<p>This will set <code>attrName</code> on the component's scope.</p>"},{"types":[{"type":"can.stache.key"}],"optional":true,"name":"KEY","description":"<p>Specifies the value of a property passed to\nthe component instance's [can.Component::scope scope] that will be looked\nup in the [can.view.Scope can.stache scope].</p>"},{"types":[{"type":"can.stache.key"}],"optional":true,"name":"ATTR-VALUE","description":"<p>If the attribute value is not\nwrapped with <code>{}</code>, the string value of the attribute will be\nset on the component's scope.</p>"}],"release":"2.1"}],"comment":" ","src":"can/component/component.md","id":2,"children":[{"type":"static","description":"","name":"can.Component.static","parent":"can.Component","src":"can/component/component.js","line":23,"id":285,"children":[{"type":"function","name":"can.Component.extend","description":"<p>Extends the [can.Component] constructor function.</p>","title":"","parent":"can.Component.static","signatures":[{"code":"can.Component.extend(proto)","description":"<p>Extends the [can.Component] constructor function with prototype \nproperties and methods.</p>","params":[{"types":[{"type":"Object","options":[{"name":"tag","description":"<p>Defines the\ntag on which instances of the component constructor function will be\ncreated.</p>","types":[{"type":"can.Component.prototype.tag"}]},{"name":"events","description":"<p>Defines events on\ndom elements or observable objects the component listens to.</p>","types":[{"type":"can.Component.prototype.events"}],"optional":true},{"name":"helpers","description":"<p>Specifies mustache helpers\nused to render the component's template.</p>","types":[{"type":"can.Component.prototype.helpers"}],"optional":true},{"name":"scope","description":"<p>Specifies an object\nthat is is used to render the component's template.</p>","types":[{"type":"can.Component.prototype.scope"}],"optional":true},{"name":"template","description":"<p>Specifies the template\nrendered within the custom element.</p>","types":[{"type":"can.Component.prototype.tempate"}],"optional":true}]}],"name":"proto","description":"<p>An object set as the prototype of the \nconstructor function. You will typically provide the following values\non the prototype object.</p>"}]}],"types":[],"src":"can/component/extend.md","id":4}]},{"type":"prototype","description":"","name":"can.Component.prototype","parent":"can.Component","src":"can/component/component.js","line":91,"id":286,"children":[{"type":"property","name":"can.Component.prototype.events","description":"<p>Listen to events on elements and observables.</p>","types":[{"type":"Object","options":[],"description":"<p>An object of event names and methods \nthat handle the event. For example:</p>\n\n<pre><code>can.Component({\n  events: {\n    \".next click\": function(){\n      this.scope.next()\n    }\n  },\n  scope: {\n    next: function(){\n      this.attr(\"offset\", this.offset + this.limit);\n    }\n  }\n})\n</code></pre>\n\n<p>A component's events object is used as the prototype of a [can.Control]. The control gets created on the component's\nelement. The component's scope is available within event handlers as <code>this.scope</code>.</p>","template":[{"types":[{"type":"can.Control.eventDescription"}]},{"types":[{"type":"can.Control.eventHandler"}]}]}],"title":"","parent":"can.Component.prototype","comment":" ","src":"can/component/events.md","id":3},{"type":"property","name":"can.Component.prototype.helpers","description":"<p>Helper functions used with the component's template.</p>","types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"can.mustache.helper"}]}],"description":"<p>An object of [can.mustache] helper names and methods. The helpers are only\navailable within the component's template and source html. The helper's\nare always called back with <code>this</code> as the [can.Component::scope scope].</p>"}],"title":"","parent":"can.Component.prototype","comment":" ","src":"can/component/helpers.md","id":5},{"type":"property","name":"can.Component.prototype.scope","description":"<p>Provides or describes a [can.Map] constructor function or can.Map instance that will be \nused to retrieve values found in the component's [can.Component::template template]. The map \ninstance is initialized with values specified by the component element's attributes.</p>","types":[{"type":"Object","description":"<p>A plain JavaScript object that is used to define the prototype methods and properties of \n[can.Construct constructor function] that extends can.Map. For example:</p>\n\n<pre><code>can.Component.extend({\n  tag: \"my-paginate\",\n  scope: {\n    offset: 0,\n    limit: 20,\n    next: function(){\n      this.attr(\"offset\", this.offset + this.limit);\n    }\n  }\n})\n</code></pre>\n\n<p>Prototype properties that have values of <code>\"@\"</code> are not looked up in the current scope, instead\nthe literal string value of the relevant attribute is used (like pass by value instead of pass by reference).  For example:</p>\n\n<pre><code>can.Component.extend({\n  tag: \"my-tag\",\n  scope: {\n    title: \"@\"\n  },\n  template: \"&lt;h1&gt;{{title}}&lt;/h1&gt;\"\n});\n</code></pre>\n\n<p>With source HTML like:</p>\n\n<pre><code>&lt;my-tag title=\"hello\"&gt;&lt;/my-tag&gt;\n</code></pre>\n\n<p>Results in:</p>\n\n<pre><code>&lt;my-tag&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;/my-tag&gt;\n</code></pre>","options":[]},{"type":"can.Map","description":"<p>A can.Map constructor function will be used to create an instance of the observable\ncan.Map placed at the head of the template's scope.  For example:</p>\n\n<pre><code>var Paginate = can.Map.extend({\n  offset: 0,\n  limit: 20,\n  next: function(){\n    this.attr(\"offset\", this.offset + this.limit);\n  }\n})\ncan.Component.extend({\n  tag: \"my-paginate\",\n  scope: Paginate\n})\n</code></pre>"},{"type":"function","returns":{"types":[{"type":"can.Map","description":"<p>If an instance of <code>can.Map</code> is returned, that instance is placed\non top of the scope and used to render the component's template.</p>"},{"type":"Object","options":[],"description":"<p>If a plain JavaScript object is returned, that is used as a prototype\ndefinition used to extend <code>can.Map</code>.  A new instance of the extended Map is created.</p>"}],"description":"<p>Specifies one of the following:</p>\n\n<ul>\n<li>The data used to render the component's template.</li>\n<li>The prototype of a <code>can.Map</code> that will be used to render the component's template.</li>\n</ul>"},"params":[{"types":[{"type":"Object","options":[]}],"name":"attrs","description":"<p>An object of values specified by the custom element's attributes. For example,\na template rendered like:</p>\n\n<pre><code>can.mustache(\"&lt;my-element title=\"name\"&gt;&lt;/my-element&gt;\")({\n  name: \"Justin\"\n})\n</code></pre>\n\n<p>Creates an instance of following control:</p>\n\n<pre><code>can.Component.extend({\n    tag: \"my-element\",\n    scope: function(attrs){\n      attrs.title //-&gt; \"Justin\";\n      return new can.Map(attrs);\n    }\n})\n</code></pre>\n\n<p>And calls the scope function with <code>attrs</code> like <code>{title: \"Justin\"}</code>.</p>"},{"types":[{"type":"can.view.Scope"}],"name":"parentScope","description":"<p>The scope the custom tag was found within.  By default, any attribute's values will\nbe looked up within the current scope, but if you want to add values without needing\nthe user to provide an attribute, you can set this up here.  For example:</p>\n\n<pre><code>can.Component.extend({\n    tag: \"my-element\",\n    scope: function(attrs, parentScope){\n      return new can.Map({title: parentScope.attr('name')});\n    }\n});\n</code></pre>\n\n<p>Notice how the attribute's value is looked up in <code>my-element</code>'s parent scope.</p>"},{"types":[{"type":"HTMLElement"}],"name":"element","description":"<p>The element the can.Component is going to be placed on. If you want \nto add custom attribute handling, you can do that here.  For example:</p>\n\n<pre><code>can.Component.extend({\n    tag: \"my-element\",\n    scope: function(attrs, parentScope, el){\n      return new can.Map({title: el.getAttribute('title')});\n    }\n});\n</code></pre>"}],"description":"<p>Returns the instance or constructor function of the object that will be added\nto the scope.</p>"}],"title":"","parent":"can.Component.prototype","deprecated":[{"version":"2.1","description":"<p>In 2.1, [can.stache] and [can.mustache] pass values to the \nscope differently. To pass data from the scope, you must wrap your attribute \nvalue with <code>{}</code>. In 3.0, [can.mustache]\nwill use [can.stache]'s syntax.</p>"}],"comment":" ","src":"can/component/scope.md","id":6},{"type":"property","name":"can.Component.prototype.tag","description":"<p>Specifies the HTML tag (or node-name) the can.Component will be created on.</p>","types":[{"type":"String","description":"<p>The tag name the can.Component \nwill be created on.  Tag names are typically lower cased and\nhypenated like: \"foo-bar\".  Component's register their\ntag with [can.view.tag].</p>"}],"title":"","parent":"can.Component.prototype","src":"can/component/tag.md","id":7},{"type":"property","name":"can.Component.prototype.template","description":"<p>Provides a template to render directly within the component's tag. The template is rendered with the\ncomponent's [can.Component::scope scope].  <code>&lt;content&gt;</code> elements within the template are replaced by \nthe source elements within the component's tag.</p>","types":[{"type":"String","description":"<p>The string contents of a [can.mustache] template.  For example:</p>\n\n<pre><code>can.Component({\n  tag: \"my-tabs\",\n  template: \"&lt;ul&gt;{{#panels}}&lt;li&gt;{{title}}&lt;/li&gt; ...\"\n})\n</code></pre>"},{"type":"can.view.renderer","description":"<p>A [can.view.renderer] returned by [can.mustache] or \n[can.view]. For example:</p>\n\n<pre><code>can.Component({\n  tag: \"my-tabs\",\n  template: can.view(\"/ui/components/my-tabs.mustache\")\n})\n</code></pre>"}],"title":"","parent":"can.Component.prototype","comment":" ","src":"can/component/template.md","id":8}]}]},{"type":"function","name":"can.compute","description":"<p>Create an observable value. \nof the compute.</p>\n\n<p>A function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can.computed compute] and the current value. If\n<code>set</code> returns a value, it is used to compare to the current value of the compute. Otherwise,\n<code>get</code> is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.</p>\n\n<p>when the computes value needs to be updated.</p>","title":"","parent":"canjs","release":"1.1","links":[{"href":"../docco/compute/compute.html","title":"docco"}],"signatures":[{"code":"can.compute( getterSetter[, context] )","description":"<p>Create a compute that derives its value from [can.Map]s and other [can.computed can.compute]s.</p>","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*+"}],"name":"newVal"},{"types":[{"type":"*+"}],"name":"oldVal"}]}],"name":"getterSetter","description":"<p>A function that gets and optionally sets the value of the compute.\nWhen called with no parameters, <em>getterSetter</em> should return the current value of the compute. When\ncalled with a single parameter, <em>getterSetter</em> should arrange things so that the next read of the compute\nproduces that value. This compute will automatically update its value when any [can.Map observable]\nvalues are read via [can.Map.prototype.attr].</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"context","description":"<p>The <code>this</code> to use when calling the <code>getterSetter</code> function.</p>"}],"returns":{"types":[{"type":"can.computed"}],"description":"<p>A new compute.</p>"}},{"code":"can.compute( initialValue [, settings] )","description":"<p>Creates a compute from a value and optionally specifies how to read, update, and \nlisten to changes in dependent values. This form of can.compute can be used to \ncreate a compute that derives its value from any source.</p>","params":[{"types":[{"type":"*"}],"name":"initialValue","description":"<p>The initial value of the compute. If <code>settings</code> is\nnot provided, the compute simply updates its value to whatever the first argument \nto the compute is.</p>\n\n<pre><code>var age = can.compute(30);\nage() //-&gt; 30\nage(31) //-&gt; fires a \"change\" event\n</code></pre>"},{"types":[{"type":"Object","options":[{"name":"get","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"set","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"on","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"off","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]}]}],"optional":true,"name":"settings","description":"<p>Configures all behaviors of the [can.computed compute]. The following cross\nbinds an input element to a compute:</p>\n\n<pre><code>var input = document.getElementById(\"age\")\nvar value = can.compute(\"\",{\n    get: function(){\n        return input.value;\n    },\n    set: function(newVal){\n        input.value = newVal;\n    },\n    on: function(updated){\n        input.addEventListener(\"change\", updated, false);\n    },\n    off: function(updated){\n        input.removeEventListener(\"change\", updated, false);\n    }\n})\n</code></pre>"}],"returns":{"types":[{"type":"can.computed"}],"description":"<p>The new compute.</p>"}},{"code":"can.compute( initialValue, setter(newVal,oldVal) )","description":"<p>Create a compute that has a setter that can adjust incoming new values.</p>\n\n<pre><code>var age = can.compute(6,function(newVal, oldVal){\n  if(!isNaN(+newVal)){\n    return +newVal;\n  } else {\n    return oldVal;\n  }\n})\n</code></pre>","params":[{"types":[{"type":"*"}],"name":"initialValue","description":"<p>The initial value of the compute.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"*"}]},"params":[{"types":[{"type":"*"}],"name":"newVal"},{"types":[{"type":"*"}],"name":"oldVal"}]}],"name":"setter","description":"<p>A function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can.computed compute] and the current value. If\n<code>set</code> returns a value, it is used to compare to the current value of the compute. Otherwise,\n<code>get</code> is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.</p>"}],"returns":{"types":[{"type":"can.computed"}],"description":"<p>A new compute.</p>"}},{"code":"can.compute( object, propertyName [, eventName] )","description":"<p>Create a compute from an object's property value. This short-cut\nsignature lets you create a compute on objects that have events\nthat be listened to with [can.bind].</p>\n\n<pre><code>var input = document.getElementById('age')\nvar age = can.compute(input,\"value\",\"change\");\n\nvar me = new can.Map({name: \"Justin\"});\nvar name = can.compute(me,\"name\")\n</code></pre>","params":[{"types":[{"type":"Object","options":[]}],"name":"object","description":"<p>An object that either has a <code>bind</code> method or\na has events dispatched on it via [can.trigger].</p>"},{"types":[{"type":"String"}],"name":"propertyName","description":"<p>The property value to read on <code>object</code>.  The\nproperty will be read via <code>object.attr(propertyName)</code> or <code>object[propertyame]</code>.</p>"},{"types":[{"type":"String"}],"optional":true,"name":"eventName","defaultValue":"propertyName","description":"<p>Specifies the event name to listen\nto on <code>object</code> for <code>propertyName</code> updates.</p>"}],"returns":{"types":[{"type":"can.computed"}],"description":"<p>A new compute.</p>"}}],"types":[],"comment":" ","src":"can/compute/compute.md","id":11,"children":[{"type":"function","name":"can.compute.async","description":"<p>Create a compute that can set its value after the computed function has been called.</p>","title":"","parent":"can.compute","release":"2.1","hide":true,"signatures":[{"code":"can.compute.async(initialValue, computed(currentValue, setValue(newValue) )","description":"","params":[{"types":[{"type":"*"}],"name":"The","description":"<p>initial value of the compute.</p>"},{"types":[{"type":"can.compute.asyncComputer"}],"name":"computed","description":"<p>A function \nthat returns the current value of the compute and can optionally later call \nits <code>setValue</code> callback to update the value.</p>"}],"returns":{"types":[{"type":"can.computed"}],"description":"<p>Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.</p>"}}],"comment":" ","src":"can/compute/async.md","id":9},{"type":"typedef","name":"can.compute.asyncComputer","description":"<p>A function that determines a value for an [can.compute.async async compute].</p>","title":"","types":[{"type":"function","returns":{"types":[{"type":"*"}],"description":"<p>If a <code>setVal</code> argument is not provided, the return value\nis set as the current value of the compute.  If <code>setVal</code> is provided and\nundefined is returned, the current value remains until <code>setVal</code> is called.</p>"},"params":[{"types":[{"type":"*"}],"optional":true,"name":"currentVal","description":"<p>The current value of the compute.  This should be returned\nif you are doing an in-place compute.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"newVal"}]}],"optional":true,"name":"setVal","description":"<p>Called to update the value \nof the compute at a later time.</p>"}],"description":"<p>The function callback to [can.compute.async] that determines\nthe value of the compute.</p>"}],"parent":"can.compute","release":"2.1","hide":true,"src":"can/compute/async_computer.md","id":10},{"type":"function","name":"can.computed","description":"","title":"compute","parent":"can.compute","signatures":[{"code":"compute( [newVal] )","description":"","params":[{"types":[{"type":"*"}],"optional":true,"name":"newVal","description":"<p>If <code>compute</code> is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a \n<code>\"change\"</code> event that can be listened for with [can.computed.bind].</p>\n\n<p>If the compute is called without any arguments (<code>compute()</code>), it simply returns\nthe current value of the compute.</p>"}],"returns":{"types":[{"type":"*"}],"description":"<p>The current value of the compute.</p>"}}],"src":"can/compute/computed.md","id":12},{"name":"can.computed.isComputed","type":"property","parent":"can.compute","description":"<p>Whether the value of the compute has been computed yet.</p>","types":[{"type":"Boolean"}],"title":"compute.isComputed","src":"can/compute/compute.js","line":462,"id":465},{"name":"can.computed.bind","type":"function","parent":"can.compute","description":"<p>Bind an event handler to a compute. </p>","title":"compute.bind","signatures":[{"code":"compute.bind(eventType, handler)","description":"","params":[{"types":[{"type":"String"}],"name":"eventType","description":"<p>The event to bind this handler to.\nThe only event type that computes emit is <em>change</em>.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"Object","options":[{"name":"Object"}]}]},{"types":[{"type":"Object","options":[{"name":"*"}]}]},{"types":[{"type":"Object","options":[{"name":"*"}]}]}]}],"name":"handler","description":"<p>The handler to call when the event happens.\nThe handler should have three parameters:</p>\n\n<ul>\n<li><em>event</em> is the event object.</li>\n<li><em>newVal</em> is the newly-computed value of the compute.</li>\n<li><em>oldVal</em> is the value of the compute before it changed.</li>\n</ul>\n\n<p><code>bind</code> lets you listen to a compute to know when it changes. It works just like\ncan.Map's <code>[can.Map.prototype.bind bind]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var tally = can.compute(0);\ntally.bind('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'</code></pre>"}]}],"src":"can/compute/compute.js","line":481,"id":466},{"name":"computed.unbind","type":"function","parent":"can.compute","description":"<p>Unbind an event handler from a compute. </p>","title":"compute.unbind","signatures":[{"code":"compute.unbind(eventType[, handler])","description":"","params":[{"types":[{"type":"String"}],"name":"eventType","description":"<p>The type of event to unbind.\nThe only event type available for computes is <em>change</em>.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"handler","description":"<p>If given, the handler to unbind.\nIf <em>handler</em> is not supplied, all handlers bound to <em>eventType</em>\nwill be removed.</p>"}]}],"src":"can/compute/compute.js","line":508,"id":467}]},{"type":"constructor","name":"can.Construct","description":"<p>Provides a way to easily use the power of prototypal inheritance \nwithout worrying about hooking up all the particulars yourself. Use\n[can.Construct.extend can.Construct.extend] to create a inheritable\nconstructor function of your own.</p>","title":"","download":"can/construct","test":"can/construct/test.html","parent":"canjs","links":[{"href":"../docco/construct/construct.html","title":"docco"}],"signatures":[{"code":"new can.Construct([args..])","description":"<p>Create a new instance of a constructor function. <code>new</code> is not\nused with <code>can.Construct</code> directly. Instead, it is used with a constructor \nfunction returned by [can.Construct.extend can.Construct.extend]. For\nexample:</p>\n\n<pre><code>Animal = can.Construct.extend({\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n})\nvar animal = new Animal()\nanimal.sayHi();\n</code></pre>\n\n<p>Any arguments passed to the construction function are passed \nto [can.Construct.prototype.setup setup] and [can.Construct.prototype.init init].</p>","params":[]},{"code":"can.Construct([name,] [staticProperties,] instanceProperties)","description":"<p>Creates a new extended constructor function. Example:</p>\n\n<pre><code>Animal = can.Construct({\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n})\n</code></pre>\n\n<p>This is deprecated. In CanJS 1.2, by default, calling the constructor function\nwithout <code>new</code> will create a <code>new</code> instance.  This behavior is controlled\nby the [can.Construct.constructorExtends constructorExtends] property.</p>\n\n<p>Use [can.Construct.extend can.Construct.extend] \ninstead of calling the constructor to extend.</p>","params":[]},{"code":"can.Construct([args...])","description":"<p>Create a new instance of a constructor function if\n[can.Construct.constructorExtends constructorExtends] is \nfalse. <code>can.Construct([args...])</code> is not used with <code>can.Construct</code>\ndirectly. Instead it is used on constructor functions\nextended from [can.Construct].</p>\n\n<pre><code>Animal = can.Construct.extend({\n   constructorExtends: false\n},{\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n})\nvar animal = Animal();\n</code></pre>\n\n<p>This will be the default behavior in CanJS 1.2.</p>","params":[]}],"comment":" ","src":"can/construct/construct.md","id":14,"children":[{"name":"can.Construct.plugins","title":"plugins","type":"group","parent":"can.Construct","description":"","order":0,"id":13,"children":[{"type":"page","name":"can.Construct.proxy","description":"<p>Creates callback functions that have <code>this</code> set correctly. </p>","parent":"can.Construct.plugins","test":"can/construct/proxy/test.html","download":"http://donejs.com/can/dist/can.construct.proxy.js","signatures":[{"code":"can.Construct.proxy(callback, [...args])","description":"<p>Creates a static callback function that has <code>this</code> set to the constructor\nfunction.</p>","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"String"},{"type":"Array","template":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"String"}]}]}],"name":"callback","description":"<p>the function or functions to proxy</p>"},{"variable":true,"types":[{"type":"["}],"name":"args","description":"<p>parameters to curry into the proxied functions</p>"}],"returns":{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"description":"<p>a function that calls <code>callback</code> with the same context as the current context</p>"}},{"code":"construct.proxy(callback, [...args])","description":"<p>Creates a static callback function that has <code>this</code> set to an instance of the constructor\nfunction.</p>","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"String"},{"type":"Array","template":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"String"}]}]}],"name":"callback","description":"<p>the function or functions to proxy.</p>"},{"variable":true,"types":[{"type":"["}],"name":"args","description":"<p>parameters to curry into the proxied functions</p>"}],"returns":{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"description":"<p>a function that calls <code>callback</code> with the same context as the current context</p>"}}],"comment":" ","src":"can/construct/proxy/proxy.md","id":15},{"type":"page","name":"can.Construct.super","description":"<p>can.Construct.super is a plugin that makes it easier to call base\nfunctions from inside inheriting functions.</p>","parent":"can.Construct.plugins","plugin":"can/construct/super","test":"can/construct/super/test.html","download":"http://donejs.com/can/dist/can.construct.super.js","signatures":[{"code":"construct._super([...args])","description":"<p>Calls the base constructor function's method.</p>","params":[{"variable":true,"types":[{"type":"["}],"name":"args","description":"<p>parameters to pass to the base function</p>"}]}],"comment":" ","src":"can/construct/super/super.md","id":16}]},{"type":"static","description":"","name":"can.Construct.static","parent":"can.Construct","src":"can/construct/construct.js","line":18,"id":287,"children":[{"name":"can.Construct.constructorExtends","type":"property","parent":"can.Construct.static","description":"<p>Toggles the behavior of a constructor function called\nwithout <code>new</code> to extend the constructor function or\ncreate a new instance.</p>","types":[{"type":"Boolean"}],"title":"constructorExtends","comment":" ","src":"can/construct/construct.js","line":22,"id":288},{"type":"function","name":"can.Construct.newInstance","parent":"can.Construct.static","description":"<p>Returns an instance of <code>can.Construct</code>. This method can be overridden to return a cached instance.</p>","title":"newInstance","signatures":[{"code":"can.Construct.newInstance([...args])","description":"","params":[{"types":[{"type":"*"}],"optional":true,"name":"args","description":"<p>arguments that get passed to [can.Construct::setup] and [can.Construct::init]. Note\nthat if [can.Construct::setup] returns an array, those arguments will be passed to [can.Construct::init]\ninstead.</p>"}],"returns":{"types":[{"type":"class"}],"description":"<p>instance of the class</p>"}}],"comment":" ","src":"can/construct/construct.js","line":43,"id":289},{"type":"function","name":"can.Construct.setup","parent":"can.Construct.static","description":"<p>Perform initialization logic for a constructor function. </p>","title":"setup","signatures":[{"code":"can.Construct.setup(base, fullName, staticProps, protoProps)","description":"<p>A static <code>setup</code> method provides inheritable setup functionality\nfor a Constructor function. The following example\ncreates a Group constructor function.  Any constructor\nfunctions that inherit from Group will be added to\n<code>Group.childGroups</code>.</p>\n\n<pre><code>Group = can.Construct.extend({\n  setup: function(Construct, fullName, staticProps, protoProps){\n    this.childGroups = [];\n    if(Construct !== can.Construct){\n      this.childGroups(Construct)\n    }\n    Construct.setup.apply(this, arguments)\n  }\n},{})\nvar Flock = Group.extend(...)\nGroup.childGroups[0] //-&gt; Flock\n</code></pre>","params":[{"types":[{"type":"constructor"}],"name":"base","description":"<p>The base constructor that is being inherited from.</p>"},{"types":[{"type":"String"}],"name":"fullName","description":"<p>The name of the new constructor.</p>"},{"types":[{"type":"Object","options":[]}],"name":"staticProps","description":"<p>The static properties of the new constructor.</p>"},{"types":[{"type":"Object","options":[]}],"name":"protoProps","description":"<p>The prototype properties of the new constructor.</p>"}]}],"comment":" ","src":"can/construct/construct.js","line":111,"id":290},{"type":"function","name":"can.Construct.extend","parent":"can.Construct.static","description":"","title":"extend","signatures":[{"code":"can.Construct.extend([name,] [staticProperties,] instanceProperties)","description":"<p>Extends <code>can.Construct</code>, or constructor functions derived from <code>can.Construct</code>,\nto create a new constructor function. Example:</p>\n\n<pre><code>Animal = can.Construct.extend({\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n})\nvar animal = new Animal()\nanimal.sayHi();\n</code></pre>","params":[{"types":[{"type":"String"}],"optional":true,"name":"name","description":"<p>Creates the necessary properties and\nobjects that point from the <code>window</code> to the created constructor function. The following:</p>\n\n<pre><code>can.Construct.extend(\"company.project.Constructor\",{})\n</code></pre>\n\n<p>creates a <code>company</code> object on window if it does not find one, a\n<code>project</code> object on <code>company</code> if it does not find one, and it will set the\n<code>Constructor</code> property on the <code>project</code> object to point to the constructor function.</p>\n\n<p>Finally, it sets \"company.project.Constructor\" as [can.Construct.fullName fullName]\nand \"Constructor\" as [can.Construct.shortName shortName].</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"staticProperties","description":"<p>Properties that are added the constructor\nfunction directly. For example:</p>\n\n<pre><code>Animal = can.Construct.extend({\n  findAll: function(){\n    return can.ajax({url: \"/animals\"})\n  }\n},{});\n\nAnimal.findAll().then(function(json){ ... })\n</code></pre>\n\n<p>The [can.Construct.setup static setup] method can be used to\nspecify inheritable behavior when a Constructor function is created.</p>"},{"types":[{"type":"Object","options":[]}],"name":"instanceProperties","description":"<p>Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's <code>prototype</code> object. Example:</p>\n\n<pre><code>Animal = can.Construct.extend({\n  init: function(name){\n    this.name = name;\n  },\n  sayHi: function(){\n    console.log(this.name,\"says hi\")\n  }\n})\nvar animal = new Animal()\nanimal.sayHi();\n</code></pre>\n\n<p>The [can.Construct::init init] and [can.Construct::setup setup] properties\nare used for initialization.</p>"}],"returns":{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"description":"<p>The constructor function.</p>"}}],"src":"can/construct/construct.js","line":207,"id":291},{"name":"can.Construct.namespace","type":"property","parent":"can.Construct.static","description":"<p>The <code>namespace</code> property returns the namespace your constructor is in.\nThis provides a way organize code and ensure globally unique types. The\n<code>namespace</code> is the [can.Construct.fullName fullName] you passed without the [can.Construct.shortName shortName].</p>","types":[{"type":"String"}],"title":"namespace","src":"can/construct/construct.js","line":340,"id":292},{"name":"can.Construct.shortName","type":"property","parent":"can.Construct.static","description":"<p>If you pass a name when creating a Construct, the <code>shortName</code> property will be set to the\nname you passed without the [can.Construct.namespace namespace].</p>","types":[{"type":"String"}],"title":"shortName","src":"can/construct/construct.js","line":356,"id":293},{"name":"can.Construct.fullName","type":"property","parent":"can.Construct.static","description":"<p>If you pass a name when creating a Construct, the <code>fullName</code> property will be set to\nthe name you passed. The <code>fullName</code> consists of the [can.Construct.namespace namespace] and\nthe [can.Construct.shortName shortName].</p>","types":[{"type":"String"}],"title":"fullName","src":"can/construct/construct.js","line":371,"id":294}]},{"type":"prototype","description":"","name":"can.Construct.prototype","parent":"can.Construct","src":"can/construct/construct.js","line":401,"id":295,"children":[{"description":"<p>A reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.</p>","types":[{"type":"Object","options":[]}],"title":"constructor","name":"can.Construct.prototype.constructor","type":"property","parent":"can.Construct.prototype","src":"can/construct/construct.js","line":405,"id":296},{"type":"function","name":"can.Construct.prototype.setup","parent":"can.Construct.prototype","description":"","title":"setup","signatures":[{"code":"construct.setup(...args)","description":"<p>A setup function for the instantiation of a constructor function.</p>","params":[{"types":[{"type":"*"}],"name":"args","description":"<p>The arguments passed to the constructor.</p>"}],"returns":{"types":[{"type":"Array"},{"type":"undefined"}],"description":"<p>If an array is returned, the array's items are passed as\narguments to [can.Construct::init init]. The following example always makes\nsure that init is called with a jQuery wrapped element:</p>\n\n<pre><code>WidgetFactory = can.Construct.extend({\n    setup: function(element){\n        return [$(element)]\n    }\n})\n\nMyWidget = WidgetFactory.extend({\n    init: function($el){\n        $el.html(\"My Widget!!\")\n    }\n})\n</code></pre>\n\n<p>Otherwise, the arguments to the\nconstructor are passed to [can.Construct::init] and the return value of <code>setup</code> is discarded.</p>"}}],"comment":" ","src":"can/construct/construct.js","line":431,"id":297},{"type":"function","name":"can.Construct.prototype.init","parent":"can.Construct.prototype","description":"<p>Called when a new instance of a can.Construct is created. </p>","title":"init","signatures":[{"code":"construct.init(...args)","description":"","params":[{"types":[{"type":"*"}],"name":"args","description":"<p>the arguments passed to the constructor (or the items of the array returned from [can.Construct::setup])</p>"}]}],"comment":" ","src":"can/construct/construct.js","line":499,"id":298}]}]},{"type":"constructor","name":"can.Control","description":"<p>Create organized, memory-leak free, rapidly performing, stateful controls with declarative event binding. Use <code>can.Control</code> to create UI \ncontrols like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.</p>","title":"","parent":"canjs","download":"can/route","test":"can/control/test.html","inherits":"can.Construct","links":[{"href":"../docco/control/control.html","title":"docco"}],"signatures":[{"code":"can.Control( [staticProperties,] instanceProperties )","description":"<p>Create a new, extended, control constructor \nfunction. This functionality is inherited from [can.Construct] and is deprecated in favor of using \n[can.Control.extend].</p>","params":[{"types":[{"type":"Object","options":[]}],"optional":true,"name":"staticProperties","description":"<p>An object of properties and methods that are added the control constructor \nfunction directly. The most common property to add is [can.Control.defaults].</p>"},{"types":[{"type":"Object","options":[]}],"name":"instanceProperties","description":"<p>An object of properties and methods that belong to \ninstances of the <code>can.Control</code> constructor function. These properties are added to the\ncontrol's <code>prototype</code> object. Properties that\nlook like event handlers (ex: <code>\"click\"</code> or <code>\"li mouseenter\"</code>) are setup\nas event handlers (see <a href=\"#section_Listeningtoevents\">Listening to events</a>).</p>"}],"returns":{"types":[{"type":"function","constructs":{"types":[{"type":"can.Construct"}]},"returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"element"}]},{"types":[{"type":"options"}]}]}],"description":"<p>A control constructor function that has been\nextended with the provided <code>staticProperties</code> and <code>instanceProperties</code>.</p>"}},{"code":"new can.Control( element, options )","description":"<p>Create an instance of a control. [can.Control.prototype.setup] processes\nthe arguments and sets up event binding. Write your initialization\ncode in [can.Control.prototype.init]. Note, you never call <code>new can.Control()</code> directly,\ninstead, you call it on constructor functions extended from <code>can.Control</code>.</p>","params":[{"types":[{"type":"HTMLElement"},{"type":"can.NodeList"},{"type":"CSSSelectorString"}],"name":"element","description":"<p>Specifies the element the control \nwill be created on.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Option values merged with [can.Control.defaults can.Control.defaults]\nand set as [can.Control.prototype.options this.options].</p>"}],"returns":{"types":[{"type":"can.Control"}],"description":"<p>A new instance of the constructor function extending can.Control.</p>"}}],"comment":" ","src":"can/control/control.md","id":20,"children":[{"name":"can.Control.plugins","title":"plugins","type":"group","parent":"can.Control","description":"","order":0,"id":19,"children":[{"type":"page","name":"can.Control.plugin","description":"<p>The <code>can.Control.plugin</code> extension is a plugin for creating and accessing \ncontrols with jQuery helper methods.  It uses the control's [can.Construct.fullName fullName] \nor a static [can.Control.plugin.static.pluginName pluginName] attribute for the name of the control.</p>","title":"jQuery plugin","parent":"can.Control.plugins","plugin":"can/control/plugin","test":"can/control/plugin/test.html","download":"http://donejs.com/can/dist/can.control.plugin.js","src":"can/control/plugin/plugin.md","id":31,"children":[{"name":"can.Control.plugin.static.pluginName","type":"property","parent":"can.Control.plugin","description":"<p>Allows you to define the name of the jQuery plugin.</p>","types":[{"type":"String"}],"title":"pluginName","comment":" ","src":"can/control/plugin/plugin.js","line":19,"id":302},{"type":"function","name":"jQuery.fn.controls","parent":"can.Control.plugin","description":"<p>Get the Controls associated with elements. </p>","title":"jQuery.fn.controls","signatures":[{"code":"jQuery.fn.controls([type])","description":"","params":[{"types":[{"type":"String"},{"type":"can.Control"}],"optional":true,"name":"control","description":"<p>The type of Controls to find.</p>"}],"returns":{"types":[{"type":"can.Control"}],"description":"<p>The controls associated with the given elements.</p>"}}],"comment":" ","src":"can/control/plugin/plugin.js","line":58,"id":303},{"type":"function","name":"jQuery.fn.control","parent":"can.Control.plugin","description":"<p>Get the Control associated with elements. </p>","title":"jQuery.fn.control","signatures":[{"code":"jQuery.fn.control([type])","description":"","params":[{"types":[{"type":"String"},{"type":"can.Control"}],"optional":true,"name":"control","description":"<p>The type of Control to find.</p>"}],"returns":{"types":[{"type":"can.Control"}],"description":"<p>The first control found.</p>"}}],"comment":" ","src":"can/control/plugin/plugin.js","line":113,"id":304},{"type":"function","name":"can.Control.plugin.prototype.update","parent":"can.Control.plugin","description":"<p>Reconfigure a control. </p>","title":"update","signatures":[{"code":"update(newOptions)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"newOptions","description":"<p>Options to merge into the current options.</p>"},{"types":[{"type":"Object","options":[]}],"name":"options","description":"<p>A list of options to merge with\n[can.Control.prototype.options this.options].  Often this method\nis called by the [can.Control.plugin jQuery helper function].</p>"}]}],"comment":" ","src":"can/control/plugin/plugin.js","line":166,"id":305}]},{"type":"page","name":"can.Control.route","description":"","parent":"can.Control.plugins","plugin":"can/control/route","test":"can/control/view/test.html","download":"http://donejs.com/can/dist/can.control.route.js","comment":" ","src":"can/control/route/route.md","id":32}]},{"type":"page","name":"can.Control.view","description":"<p><strong>DEPRECATED</strong></p>","hide":true,"parent":"can.Control","plugin":"can/control/view","test":"can/control/view/test.html","download":"http://donejs.com/can/dist/can.control.view.js","src":"can/control/view/view.md","id":33},{"type":"static","description":"","name":"can.Control.static","parent":"can.Control","src":"can/control/control.js","line":53,"id":299,"children":[{"type":"function","name":"can.Control.extend","description":"","title":"","parent":"can.Control.static","signatures":[{"code":"can.Control.extend( [staticProperties,] instanceProperties )","description":"<p>Create a new, extended, control constructor \nfunction.</p>","params":[{"types":[{"type":"Object","options":[]}],"optional":true,"name":"staticProperties","description":"<p>An object of properties and methods that are added the control constructor \nfunction directly. The most common property to add is [can.Control.defaults].</p>"},{"types":[{"type":"Object","options":[]}],"name":"instanceProperties","description":"<p>An object of properties and methods that belong to \ninstances of the <code>can.Control</code> constructor function. These properties are added to the\ncontrol's <code>prototype</code> object. Properties that\nlook like event handlers (ex: <code>\"click\"</code> or <code>\"li mouseenter\"</code>) are setup\nas event handlers.</p>"}],"returns":{"types":[{"type":"function","constructs":{"types":[{"type":"can.Construct"}]},"returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"element"}]},{"types":[{"type":"options"}]}]}],"description":"<p>A control constructor function that has been\nextended with the provided <code>staticProperties</code> and <code>instanceProperties</code>.</p>"}}],"comment":" ","src":"can/control/control.extend.md","id":18},{"type":"property","name":"can.Control.defaults","description":"<p>Default values for the Control's options. </p>","types":[{"type":"Object","options":[]}],"title":"defaults","parent":"can.Control.static","comment":" ","src":"can/control/doc/defaults.md","id":22},{"type":"property","name":"can.Control.processors","description":"<p>A collection of hookups for custom events on Controls. </p>","types":[{"type":"Object","template":[{"types":[{"type":"can.Control.processor"}]}]}],"title":"processors","parent":"can.Control.static","comment":" ","src":"can/control/doc/processors.md","id":27}]},{"type":"prototype","description":"","name":"can.Control.prototype","parent":"can.Control","src":"can/control/control.js","line":157,"id":300,"children":[{"type":"function","name":"can.Control.prototype.destroy","description":"<p>Remove a Control from an element and clean up the Control. </p>","title":"destroy","parent":"can.Control.prototype","signatures":[{"code":"control.destroy()","description":"<p>Prepares a control for garbage collection and is a place to\nreset any changes the control has made.</p>","params":[]}],"comment":" ","src":"can/control/doc/destroy.md","id":23},{"type":"property","name":"can.Control.prototype.element","description":"<p>The element passed to the Control when creating a new instance. </p>","types":[{"type":"can.NodeList"}],"title":"element","parent":"can.Control.prototype","comment":" ","src":"can/control/doc/element.md","id":24},{"type":"function","name":"can.Control.prototype.on","description":"<p>Bind an event handler to a Control, or rebind all event handlers on a Control. </p>","title":"on","parent":"can.Control.prototype","signatures":[{"code":"control.on([el,] selector, eventName, func)","description":"","params":[{"types":[{"type":"HTMLElement"},{"type":"jQuery"},{"type":"collection"},{"type":"Object","options":[]}],"optional":true,"name":"el","defaultValue":"this.element","description":"<p>The element to be bound.  If no element is provided, the control's element is used instead.</p>"},{"types":[{"type":"CSSSelectorString"}],"name":"selector","description":"<p>A CSS selector for event delegation.</p>"},{"types":[{"type":"String"}],"name":"eventName","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"String"}],"name":"func","description":"<p>A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind.</p>"}],"returns":{"types":[{"type":"Number"}],"description":"<p>The id of the binding in this._bindings.</p>\n\n<p><code>on(el, selector, eventName, func)</code> binds an event handler for an event to a selector under the scope of the given element.</p>"}},{"code":"control.on()","description":"<p>Rebind all of a control's event handlers.</p>","params":[],"returns":{"types":[{"type":"Number"}],"description":"<p>The number of handlers bound to this Control.</p>"}}],"comment":" ","src":"can/control/doc/on.md","id":25},{"type":"property","name":"can.Control.prototype.options","description":"<p>Options used to configure a control. </p>","types":[{"type":"Object","options":[]}],"title":"options","parent":"can.Control.prototype","comment":" ","src":"can/control/doc/options.md","id":26},{"type":"function","name":"can.Control.prototype.setup","description":"<p>Perform pre-initialization logic for control instances and classes.  </p>","title":"setup","parent":"can.Control.prototype","signatures":[{"code":"control.setup(element, options)","description":"","params":[{"types":[{"type":"HTMLElement"},{"type":"NodeList"},{"type":"String"}],"name":"element","description":"<p>The element as passed to the constructor.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>option values for the control.  These get added to\nthis.options and merged with [can.Control.static.defaults defaults].</p>"}],"returns":{"types":[{"type":"undefined"},{"type":"Array","options":[]}],"description":"<p>return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.</p>"}}],"comment":" ","src":"can/control/doc/setup.md","id":28}]}]},{"type":"page","name":"can.event","description":"<p>Add event functionality into your objects.</p>\n\n<p>The <code>can.event</code> object provides a number of methods for handling events in objects. This functionality is best used by mixing the <code>can.event</code> object into an object or prototype. However, event listeners can still be used even on objects that don't include <code>can.event</code>.</p>\n\n<p>All methods provided by <code>can.event</code> assume that they are mixed into an object -- <code>this</code> should be the object dispatching the events.</p>","title":"can.event","parent":"canjs","test":"can/event/test.html","links":[{"href":"../docco/event.html","title":"docco"}],"release":"2.1","signatures":[{"code":"can.extend(YourClass.prototype, can.event)","description":"<p>Adds event functionality to <code>YourClass</code> objects. This can also be applied to normal objects: <code>can.extend(someObject, can.event)</code>.</p>","params":[]}],"comment":" ","src":"can/event/event.md","id":37,"children":[{"name":"can.event.plugins","title":"plugins","type":"group","parent":"can.event","description":"","order":0,"id":35,"children":[{"type":"page","name":"can.event.namespace","description":"","hide":true,"parent":"can.event.plugins","plugin":"can/event/namespace","test":"can/event/namespace/test.html","download":"http://donejs.com/can/dist/can.event.namespace.js","src":"can/event/namespace/namespace.md","id":38},{"type":"page","name":"can.event.propagate","description":"<p>This changes [can.event.dispatch can.event.dispatch] to add support for propagating events to parent objects.</p>\n\n<p>This is implemented similarly to how events work in the DOM: Events dispatched on an object will be dispatched on their parent object, all the way up until no more parent objects are defined.</p>","parent":"can.event.plugins","plugin":"can/event/propagate","test":"can/event/propagate/test.html","download":"http://donejs.com/can/dist/can.event.propagate.js","signatures":[{"code":"can.extend(YourClass.prototype, can.event, { propagate: \"parent\" })","description":"<p>Adds event functionality with event propagation to <code>YourClass</code> objects. This can also be applied to normal objects: <code>can.extend(someObject, can.event, { propagate: \"parent\" })</code>.</p>\n\n<p>The extra object, <code>{ propagate: \"parent\" }</code>, is used to define which object property is that object's parent. With the <code>propagate</code> property set to <code>\"parent\"</code>, any event dispatched on the <code>YourClass</code> instances will also be dispatched on <code>instance.parent</code> if it exists.</p>\n\n<h2>Using propagation</h2>\n\n<p>In order to add propagation to an object or prototype, mix it into the object using <code>can.extend</code> along with whatever property should be considered the propagation property.</p>\n\n<pre><code class=\"lang-javascript\">var SomeClass = can.Construct(\"SomeClass\", {\n    init: function() {\n        this.value = 0;\n    },\n    setParent: function(obj) {\n        this.parent = obj;\n        this.dispatch(\"parent\", [this, obj]);\n    }\n});\ncan.extend(SomeClass.prototype, can.event, { propagate: \"parent\" });</code></pre>\n\n<p>Now that propagation has been added, events will be dispatched up the tree for as long as a valid propagate property exists.</p>\n\n<pre><code class=\"lang-javascript\">var instance = new SomeClass();\nvar root = new SomeClass();\n\nroot.on(\"parent\", function(ev, obj, parent) {\n    // obj has set root as its parent\n});\n\n// This triggers the \"parent\" event on instance\n// The \"parent\" event then propagates and triggers on root as well!\ninstance.setParent(root);</code></pre>\n\n<h2>Stopping propagation</h2>\n\n<p>When using the propagate plugin, <code>stopPropagation()</code> and <code>isPropagationStopped()</code> methods will be added to the event object. These methods can be used to prevent the event from propagating further up the tree.</p>\n\n<pre><code class=\"lang-javascript\">SomeClass.prototype.setParent = function(obj) {\n    this.parent = obj;\n    var event = this.dispatch(\"parent\", [this, obj]);\n\n    console.log(event.isPropagationStopped()); // => true\n};\n\ninstance.on(\"parent\", function(ev, obj, parent) {\n    // Don't let this propagate past this object\n    ev.stopPropagation();\n});\n\nroot.on(\"parent\", function(ev, obj, parent) {\n    // This code is never reached\n});\n\n// This will execute the instance listener, but not the\n// root listener, because propagation has been stopped.\ninstance.setParent(root);</code></pre>\n\n<h2>Preventing default functionality</h2>\n\n<p>When using the propagate plugin, <code>preventDefault()</code> and <code>isDefaultPrevented()</code> methods will be added to the event object. An object might implement some logic that will be executed after an event is dispatched. In the case that this logic should be optional dependent on the event handlers, default prevention can be used.</p>\n\n<pre><code class=\"lang-javascript\">SomeClass.prototype.setParent = function(obj) {\n    this.parent = obj;\n    var event = this.dispatch(\"parent\", [this, obj]);\n\n    // Only execute this code if the default isn't prevented\n    if (!event.isDefaultPrevented()) {\n        this.parent.children = this.parent.children || [];\n        this.parent.children.push(this);\n    }\n};\n\ninstance.on(\"parent\", function(ev, obj, parent) {\n    // Don't let the default functionality execute\n    ev.preventDefault();\n});</code></pre>","params":[]}],"src":"can/event/propagate/propagate.md","id":39}]},{"name":"can.event.static","title":"static","type":"group","parent":"can.event","description":"","order":0,"id":36,"children":[{"type":"function","name":"can.event.delegate","description":"","hide":true,"parent":"can.event.static","plugin":"can/event/delegate","test":"can/event/delegate/test.html","src":"can/event/delegate/delegate.md","signatures":[{"code":"obj.delegate( selector, event, handler )","description":"<p>Provides a compatibility layer for adding delegate event listeners.\nThis doesn't actually implement delegates, but rather allows \nlogic that assumes a delegate to still function.</p>\n\n<p>Therefore, this is essentially an alias of [can.event.addEvent addEvent] with the selector ignored.</p>","params":[{"types":[{"type":"String"}],"name":"selector","description":"<p>The <strong>ignored</strong> selector to use for the delegate.</p>"},{"types":[{"type":"String"}],"name":"event","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The handler that will be executed to handle the event.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>this</p>"}},{"code":"can.event.delegate.call( obj, selector, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"id":34},{"type":"function","name":"can.event.addEvent","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.addEvent( event, handler )","description":"<p>Add a basic event listener to an object.</p>","params":[{"types":[{"type":"String"}],"name":"event","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The handler that will be executed to handle the event.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>this</p>"}},{"code":"can.event.addEvent.call( obj, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":19,"id":429},{"type":"function","name":"can.event.listenTo","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.listenTo( other, event, handler )","description":"<p>Listens for an event on another object.\nThis is similar to concepts like event namespacing, except that the namespace \nis the scope of the calling object.</p>","params":[{"types":[{"type":"Object","options":[]}],"name":"other","description":"<p>The object to listen for events on.</p>"},{"types":[{"type":"String"}],"name":"event","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The handler that will be executed to handle the event.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>this</p>"}},{"code":"can.event.listenTo.call( obj, other, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":54,"id":430},{"type":"function","name":"can.event.stopListening","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.stopListening( other, event, handler )","description":"<p>Stops listening for an event on another object.</p>","params":[{"types":[{"type":"Object","options":[]}],"name":"other","description":"<p>The object to listen for events on.</p>"},{"types":[{"type":"String"}],"name":"event","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The handler that will be executed to handle the event.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>this</p>"}},{"code":"can.event.stopListening.call( obj, other, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":103,"id":431},{"type":"function","name":"can.event.removeEvent","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.removeEvent( event, handler )","description":"<p>Removes a basic event listener from an object.</p>","params":[{"types":[{"type":"String"}],"name":"event","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The handler that will be executed to handle the event.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"__validate","description":"<p>An extra function that can validate an event handler \n                               as a match. This is an internal parameter and only used \n                               for <code>can/event</code> plugins.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>this</p>"}},{"code":"can.event.removeEvent.call( obj, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":176,"id":432},{"type":"function","name":"can.event.dispatch","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.dispatch( event, args )","description":"<p>Dispatches/triggers a basic event on an object.</p>","params":[{"types":[{"type":"String"},{"type":"Object","options":[]}],"name":"event","description":"<p>The event to dispatch</p>"},{"types":[{"type":"Array","options":[]}],"optional":true,"name":"args","description":"<p>Additional arguments to pass to event handlers</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>event The resulting event object</p>"}},{"code":"can.event.dispatch.call( obj, event, args )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":218,"id":433},{"type":"function","name":"can.event.one","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.one( event, handler )","description":"<p>Adds a basic event listener that listens to an event once and only once.</p>","params":[{"types":[{"type":"String"}],"name":"event","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The handler that will be executed to handle the event.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>this</p>"}}],"src":"can/event/event.js","line":262,"id":434},{"type":"function","name":"can.event.on","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.on( event, handler )","description":"<p>Add a basic event listener to an object.</p>\n\n<p>This is an alias of [can.event.addEvent addEvent].</p>","params":[]},{"code":"can.event.on.call( obj, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":289,"id":435},{"type":"function","name":"can.event.off","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.off( event, handler )","description":"<p>Removes a basic event listener from an object.</p>\n\n<p>This is an alias of [can.event.removeEvent removeEvent].</p>","params":[]},{"code":"can.event.off.call( obj, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":311,"id":436},{"name":"can.event.bind","type":"function","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.bind( event, handler )","description":"<p>Add a basic event listener to an object.</p>\n\n<p>This is an alias of [can.event.addEvent addEvent].</p>","params":[]},{"code":"can.event.bind.call( obj, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":333,"id":437},{"name":"can.event.unbind","type":"function","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.unbind( event, handler )","description":"<p>Removes a basic event listener from an object.</p>\n\n<p>This is an alias of [can.event.removeEvent removeEvent].</p>","params":[]},{"code":"can.event.unbind.call( obj, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":347,"id":438},{"type":"function","name":"can.event.undelegate","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.undelegate( selector, event, handler )","description":"<p>Provides a compatibility layer for removing delegate event listeners.\nThis doesn't actually implement delegates, but rather allows \nlogic that assumes a delegate to still function.</p>\n\n<p>Therefore, this is essentially an alias of [can.event.removeEvent removeEvent] with the selector ignored.</p>","params":[{"types":[{"type":"String"}],"name":"selector","description":"<p>The <strong>ignored</strong> selector to use for the delegate.</p>"},{"types":[{"type":"String"}],"name":"event","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The handler that will be executed to handle the event.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>this</p>"}},{"code":"can.event.undelegate.call( obj, selector, event, handler )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":384,"id":439},{"name":"can.event.trigger","type":"function","parent":"can.event.static","description":"","title":"","signatures":[{"code":"obj.trigger( event, args )","description":"<p>Dispatches/triggers a basic event on an object.\nThis is an alias of [can.event.dispatch dispatch].</p>","params":[]},{"code":"can.event.trigger.call( obj, event, args )","description":"<p>This syntax can be used for objects that don't include the <code>can.event</code> mixin.</p>","params":[]}],"src":"can/event/event.js","line":407,"id":440}]}]},{"type":"constructor","name":"can.List","description":"","title":"","inherits":"can.Map","download":"can/list","test":"can/list/test.html","parent":"canjs","release":"2.0","links":[{"href":"../docco/list/list.html","title":"docco"}],"signatures":[{"code":"new can.List([array])","description":"<p>Create an observable array-like object.</p>","params":[{"types":[{"type":"Array","options":[]}],"optional":true,"name":"array","description":"<p>Items to seed the List with.</p>"}],"returns":{"types":[{"type":"can.List"}],"description":"<p>An instance of <code>can.List</code> with the elements from <em>array</em>.</p>"}},{"code":"new can.List(deferred)","description":"","params":[{"types":[{"type":"can.Deferred"}],"name":"deferred","description":"<p>A deferred that resolves to an \narray.  When the deferred resolves, its values will be added to the list.</p>"}],"returns":{"types":[{"type":"can.List"}],"description":"<p>An initially empty <code>can.List</code>.</p>"}}],"comment":" ","src":"can/list/doc/list.md","id":45,"children":[{"name":"can.List.prototype","title":"Prototype","type":"prototype","parent":"can.List","description":"","order":0,"id":42,"children":[{"type":"function","name":"can.List.prototype.attr","description":"<p>Get or set elements in a List. </p>","title":"attr","parent":"can.List.prototype","signatures":[{"code":"list.attr()","description":"<p>Gets an array of all the elements in this <code>can.List</code>.</p>","params":[],"returns":{"types":[{"type":"Array","options":[]}],"description":"<p>An array with all the elements in this List.</p>"}},{"code":"list.attr(index)","description":"<p>Reads an element from this <code>can.List</code>.</p>","params":[{"types":[{"type":"Number"}],"name":"index","description":"<p>The element to read.</p>"}],"returns":{"types":[{"type":"*"}],"description":"<p>The value at <em>index</em>.</p>"}},{"code":"list.attr(index, value)","description":"<p>Assigns <em>value</em> to the index <em>index</em> on this <code>can.List</code>, expanding the list if necessary.</p>","params":[{"types":[{"type":"Number"}],"name":"index","description":"<p>The element to set.</p>"},{"types":[{"type":"*"}],"name":"value","description":"<p>The value to assign at <em>index</em>.</p>"}],"returns":{"types":[{"type":"can.List"}],"description":"<p>This list, for chaining.</p>"}},{"code":"list.attr(elements[, replaceCompletely])","description":"<p>Merges the members of <em>elements</em> into this List, replacing each from the beginning in order. If\n<em>elements</em> is longer than the current List, the current List will be expanded. If <em>elements</em>\nis shorter than the current List, the extra existing members are not affected (unless\n<em>replaceCompletely</em> is <code>true</code>). To remove elements without replacing them, use <code>[can.Map::removeAttr removeAttr]</code>.</p>","params":[{"types":[{"type":"Array","options":[]}],"name":"elements","description":"<p>An array of elements to merge in.</p>"},{"types":[{"type":"bool"}],"optional":true,"name":"replaceCompletely","defaultValue":"false","description":"<p>whether to completely replace the elements of List\nIf <em>replaceCompletely</em> is <code>true</code> and <em>elements</em> is shorter than the List, the existing\nextra members of the List will be removed.</p>"}],"returns":{"types":[{"type":"can.List"}],"description":"<p>This list, for chaining.</p>"}}],"comment":" ","src":"can/list/doc/prototype.attr.md","id":47},{"type":"function","name":"can.List.prototype.each","description":"<p>Call a function on each element of a List. </p>","title":"each","parent":"can.List.prototype","signatures":[{"code":"list.each( callback(item, index) )","description":"<p><code>each</code> iterates through the Map, calling a function\nfor each element.</p>","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}]},{"types":[{"type":"Number"}]}]}],"name":"callback","description":"<p>the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.</p>"}],"returns":{"types":[{"type":"can.List"}],"description":"<p>this List, for chaining</p>"}}],"comment":" ","src":"can/list/doc/prototype.each.md","id":48},{"type":"function","name":"can.List.prototype.reverse","description":"<p>Reverse the order of a List. </p>","title":"reverse","parent":"can.List.prototype","signatures":[{"code":"list.reverse()","description":"<p><code>reverse</code> reverses the elements of the List in place.</p>","params":[],"returns":{"types":[{"type":"can.List"}],"description":"<p>the List, for chaining</p>"}}],"comment":" ","src":"can/list/doc/prototype.reverse.md","id":49},{"type":"function","name":"can.List.prototype.splice","description":"<p>Insert and remove elements from a List. </p>","title":"splice","parent":"can.List.prototype","signatures":[{"code":"list.splice(index[, howMany[, ...newElements]])","description":"","params":[{"types":[{"type":"Number"}],"name":"index","description":"<p>where to start removing or inserting elements</p>"},{"types":[{"type":"Number"}],"optional":true,"name":"howMany","description":"<p>the number of elements to remove\nIf <em>howMany</em> is not provided, <code>splice</code> will all elements from <code>index</code> to the end of the List.</p>"},{"types":[{"type":"*"}],"name":"newElements","description":"<p>elements to insert into the List</p>"}],"returns":{"types":[{"type":"Array","options":[]}],"description":"<p>the elements removed by <code>splice</code></p>"}}],"comment":" ","src":"can/list/doc/prototype.splice.md","id":50},{"type":"function","name":"can.List.prototype.filter","description":"<p>Filter the elements of a List, returning a new List instance with just filtered items. </p>","title":"filter","parent":"can.List.prototype","signatures":[{"code":"list.filter(filterFunc, context)","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"Boolean"}]},"params":[{"types":[{"type":"*"}],"name":"item"},{"types":[{"type":"Number"}],"name":"index"},{"types":[{"type":"can.List"}],"name":"list"}],"context":{"types":[{"type":"*"}]}}],"name":"filterFunc","description":"<p>A function to call with each element of the list. Returning <code>false</code> will remove the index.</p>"},{"types":[{"type":"Object","options":[]}],"name":"context","description":"<p>The object to use as <code>this</code> inside the callback.</p>"}]}],"comment":" ","src":"can/list/docs/filter.md","id":51},{"type":"page","name":"can.List.prototype.sort","description":"<p><code>list.sort(sortfunc)</code></p>","parent":"can.List.prototype","plugin":"can/map/sort","test":"can/map/sort/test.html","src":"can/map/sort/sort.md","id":105},{"type":"function","name":"can.List.prototype.serialize","params":[],"parent":"can.List.prototype","description":"<p>Returns the serialized form of this list.</p>","hide":true,"src":"can/list/list.js","line":164,"id":308},{"name":"can.List.prototype.push","type":"function","parent":"can.List.prototype","description":"<p>Add elements to the end of a list. </p>","title":"push","signatures":[{"code":"list.push(...elements)","description":"<p><code>push</code> adds elements onto the end of a List.]</p>","params":[{"types":[{"type":"*"}],"name":"elements","description":"<p>the elements to add to the List</p>"}],"returns":{"types":[{"type":"Number"}],"description":"<p>the new length of the List</p>"}}],"comment":" ","src":"can/list/list.js","line":603,"id":309},{"name":"can.List.prototype.unshift","type":"function","parent":"can.List.prototype","description":"<p>Add elements to the beginning of a List. </p>","title":"unshift","signatures":[{"code":"list.unshift(...elements)","description":"<p><code>unshift</code> adds elements onto the beginning of a List.</p>","params":[{"types":[{"type":"*"}],"name":"elements","description":"<p>the elements to add to the List</p>"}],"returns":{"types":[{"type":"Number"}],"description":"<p>the new length of the List</p>"}}],"comment":" ","src":"can/list/list.js","line":645,"id":310},{"name":"can.List.prototype.pop","type":"function","parent":"can.List.prototype","description":"<p>Remove an element from the end of a List. </p>","title":"pop","signatures":[{"code":"list.pop()","description":"<p><code>push</code> removes an element from the end of a List.</p>","params":[],"returns":{"types":[{"type":"*"}],"description":"<p>the element just popped off the List, or <code>undefined</code> if the List was empty</p>"}}],"comment":" ","src":"can/list/list.js","line":720,"id":311},{"name":"can.List.prototype.shift","type":"function","parent":"can.List.prototype","description":"<p>Remove en element from the front of a list. </p>","title":"shift","signatures":[{"code":"list.shift()","description":"<p><code>shift</code> removes an element from the beginning of a List.</p>","params":[],"returns":{"types":[{"type":"*"}],"description":"<p>the element just shifted off the List, or <code>undefined</code> if the List is empty</p>"}}],"comment":" ","src":"can/list/list.js","line":755,"id":312},{"type":"function","name":"can.List.prototype.indexOf","parent":"can.List.prototype","description":"<p>Look for an item in a List. </p>","title":"indexOf","signatures":[{"code":"list.indexOf(item)","description":"<p><code>indexOf</code> finds the position of a given item in the List.</p>","params":[{"types":[{"type":"*"}],"name":"item","description":"<p>the item to find</p>"}],"returns":{"types":[{"type":"Number"}],"description":"<p>the position of the item in the List, or -1 if the item is not found.</p>"}}],"comment":" ","src":"can/list/list.js","line":816,"id":313},{"type":"function","name":"can.List.prototype.join","parent":"can.List.prototype","description":"<p>Join a List's elements into a string. </p>","title":"join","signatures":[{"code":"list.join(separator)","description":"<p><code>join</code> turns a List into a string by inserting <em>separator</em> between the string representations\nof all the elements of the List.</p>","params":[{"types":[{"type":"String"}],"name":"separator","description":"<p>the string to seperate elements with</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>the joined string</p>"}}],"comment":" ","src":"can/list/list.js","line":847,"id":314},{"type":"function","name":"can.List.prototype.slice","parent":"can.List.prototype","description":"<p>Make a copy of a part of a List. </p>","title":"slice","signatures":[{"code":"list.slice([start[, end]])","description":"<p><code>slice</code> creates a copy of a portion of the List.</p>","params":[{"types":[{"type":"Number"}],"optional":true,"name":"start","defaultValue":"0","description":"<p>the index to start copying from</p>"},{"types":[{"type":"Number"}],"optional":true,"name":"end","description":"<p>the first index not to include in the copy\nIf <em>end</em> is not supplied, <code>slice</code> will copy until the end of the list.</p>"}],"returns":{"types":[{"type":"can.List"}],"description":"<p>a new <code>can.List</code> with the extracted elements</p>"}}],"comment":" ","src":"can/list/list.js","line":895,"id":315},{"type":"function","name":"can.List.prototype.concat","parent":"can.List.prototype","description":"<p>Merge many collections together into a List. </p>","title":"concat","signatures":[{"code":"list.concat(...args)","description":"","params":[{"types":[{"type":"Array"},{"type":"can.List"},{"type":"*"}],"name":"args","description":"<p>Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.</p>"}]}],"comment":" ","src":"can/list/list.js","line":931,"id":316},{"type":"function","name":"can.List.prototype.forEach","parent":"can.List.prototype","description":"<p>Call a function for each element of a List. </p>","title":"forEach","signatures":[{"code":"list.forEach(callback[, thisArg])","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"element"}]},{"types":[{"type":"index"}]},{"types":[{"type":"list"}]}]}],"name":"callback","description":"<p>a function to call with each element of the List\nThe three parameters that <em>callback</em> gets passed are <em>element</em>, the element at <em>index</em>, <em>index</em> the\ncurrent element of the list, and <em>list</em> the List the elements are coming from.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"thisArg","description":"<p>the object to use as <code>this</code> inside the callback</p>"}]}],"comment":" ","src":"can/list/list.js","line":961,"id":317},{"type":"function","name":"can.List.prototype.replace","parent":"can.List.prototype","description":"<p>Replace all the elements of a List. </p>","title":"replace","signatures":[{"code":"list.replace(collection)","description":"","params":[{"types":[{"type":"Array"},{"type":"can.List"},{"type":"can.Deferred"}],"name":"collection","description":"<p>the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an <code>Array</code> or <code>can.List</code>.\nThe elements of the list are not actually removed until the Deferred resolves.</p>"}]}],"comment":" ","src":"can/list/list.js","line":985,"id":318}]},{"name":"can.List.static","title":"Static","type":"static","parent":"can.List","description":"","order":1,"id":43,"children":[{"type":"function","name":"extend","description":"","title":"","parent":"can.List.static","signatures":[{"code":"can.List.extend([name,] [staticProperties,] instanceProperties)","description":"<p>Creates a new extended constructor function. Learn more at [can.Construct.extend].</p>","params":[{"types":[{"type":"String"}],"optional":true,"name":"name","description":"<p>If provided, adds the extened List constructor function to the window at the given name.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"staticProperties","description":"<p>Properties and methods directly on the constructor function. The most common property to set is [can.List.Map].</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"instanceProperties","description":"<p>Properties and methods on instances of this list type.</p>"}]}],"src":"can/list/doc/extend.md","id":41},{"type":"property","name":"can.List.Map","description":"<p>Specify the Map type used to make objects added to this list observable. </p>","title":"","parent":"can.List.static","types":[{"type":"can.Map","description":"<p>When objects are added to a can.List, those objects are\nconverted into can.Map instances.  For example:</p>\n\n<pre><code>var list = new can.List();\nlist.push({name: \"Justin\"});\n\nvar map = list.attr(0);\nmap.attr(\"name\") //-&gt; \"Justin\"\n</code></pre>\n\n<p>By changing [can.List.Map], you can specify a different type of Map instance to\ncreate. For example:</p>\n\n<pre><code>var User = can.Map.extend({\n  fullName: function(){\n    return this.attr(\"first\")+\" \"+this.attr(\"last\")\n  }\n});\n\nUser.List = can.List.extend({\n  Map: User\n}, {});\n\nvar list = new User.List();\nlist.push({first: \"Justin\", last: \"Meyer\"});\n\nvar user = list.attr(0);\nuser.fullName() //-&gt; \"Justin Meyer\"\n</code></pre>"}],"src":"can/list/doc/Map.md","id":46}]},{"name":"can.List.plugins","title":"plugins","type":"group","parent":"can.List","description":"","order":2,"id":44,"children":[{"type":"function","name":"can.List.plugins.promise","description":"<p>Adds observable promise methods to [can.List].</p>","title":"promise","parent":"can.List.plugins","release":"2.1","src":"can/list/promise/doc/promise.md","id":58,"children":[{"type":"function","name":"can.List.prototype.always","description":"","title":"","parent":"can.List.plugins.promise","signatures":[{"code":"list.always( alwaysCallback )","description":"<p>Add handlers to be called when the list is either resolved or \nrejected. This works very similar \nto <a href=\"http://api.jquery.com/deferred.always/\">jQuery's always</a>.</p>","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"},{"type":"can.List"}],"name":"reasonOrList"}]}],"name":"alwaysCallback","description":"<p>A function that is called when the list's promise is resolved \nor rejected. It will be called with the list if the promise is resolved,\nor the [can.List::reason reason] if the promise is rejected.</p>"}],"returns":{"types":[{"type":"Promise"}],"description":"<p>The list's promise.</p>"}}],"comment":" ","src":"can/list/promise/doc/always.md","id":52},{"type":"function","name":"can.List.prototype.done","description":"","title":"","parent":"can.List.plugins.promise","signatures":[{"code":"list.done( doneCallback )","description":"<p>Add handlers to be called when the list is resolved. This works very similar \nto <a href=\"http://api.jquery.com/deferred.done/\">jQuery's done</a>.</p>","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"can.List"}],"name":"list"}]}],"name":"doneCallback","description":"<p>A function that is called when the list's promise is resolved. \nIt will be called with the list instance.</p>"}],"returns":{"types":[{"type":"Promise"}],"description":"<p>The list's promise.</p>"}}],"comment":" ","src":"can/list/promise/doc/done.md","id":53},{"type":"function","name":"can.List.prototype.fail","description":"","title":"","parent":"can.List.plugins.promise","signatures":[{"code":"list.fail( failCallback )","description":"<p>Add handlers to be called when the list is rejected. This works very similar \nto <a href=\"http://api.jquery.com/deferred.fail/\">jQuery's fail</a>.</p>","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"reason"}]}],"name":"failCallback","description":"<p>A function that is called when the list's promise is rejected. \nIt will be called with the [can.List::reason reason] provided to <code>reject</code>.</p>"}],"returns":{"types":[{"type":"Promise"}],"description":"<p>The list's promise.</p>"}}],"comment":" ","src":"can/list/promise/doc/fail.md","id":54},{"type":"function","name":"can.List.prototype.isPending","description":"","title":"","parent":"can.List.plugins.promise","signatures":[{"code":"list.isPending()","description":"<p>Returns if the [can.List::state state] of the list is pending.</p>","params":[],"returns":{"types":[{"type":"Boolean"}],"description":"<p><code>true</code> if the list is pending. <code>false</code> if otherwise.</p>"}}],"comment":" ","src":"can/list/promise/doc/isPending.md","id":55},{"type":"function","name":"can.List.prototype.isRejected","description":"","title":"","parent":"can.List.plugins.promise","signatures":[{"code":"list.isRejected()","description":"<p>Returns if the [can.List::state state] of the list is rejected.</p>","params":[],"returns":{"types":[{"type":"Boolean"}],"description":"<p><code>true</code> if the list is rejected. <code>false</code> if otherwise.</p>"}}],"comment":" ","src":"can/list/promise/doc/isRejected.md","id":56},{"type":"function","name":"can.List.prototype.isResolved","description":"","title":"","parent":"can.List.plugins.promise","signatures":[{"code":"list.isResolved()","description":"<p>Returns if the [can.List::state state] of the list is resolved.</p>","params":[],"returns":{"types":[{"type":"Boolean"}],"description":"<p><code>true</code> if the list is resolved. <code>false</code> if otherwise.</p>"}}],"comment":" ","src":"can/list/promise/doc/isResolved.md","id":57},{"type":"property","name":"can.List.prototype.reason","description":"","types":[{"type":"*","description":"<p>The reason the list's deferred was rejected.  Read it via\n[can.Map::attr attr].</p>"}],"title":"","parent":"can.List.plugins.promise","comment":" ","src":"can/list/promise/doc/reason.md","id":59},{"type":"property","name":"can.List.prototype.state","description":"","types":[{"type":"String","description":"<p>The state of the list's promise.  Read it via\n[can.Map::attr attr].  It will be one of the following:</p>\n\n<ul>\n<li>undefined - the list does not have a deferred</li>\n<li>\"pending\" - the list's promise is pending</li>\n<li>\"resolved\" - the list's promise was resolved</li>\n<li>\"rejected\" - the list's promise was rejected</li>\n</ul>"}],"title":"","parent":"can.List.plugins.promise","comment":" ","src":"can/list/promise/doc/state.md","id":60},{"type":"function","name":"can.List.prototype.then","description":"","title":"","parent":"can.List.plugins.promise","signatures":[{"code":"list.then( doneFilter, [failFilter] )","description":"<p>Add handlers to be called when the list \nis resolved or rejected. This works very similar \nto <a href=\"http://api.jquery.com/deferred.then/\">jQuery's done</a>.</p>","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"can.List"}],"name":"list"}]}],"name":"doneFilter","description":"<p>A function that is called when the list's promise is resolved. \nIt will be called with the list instance. If\nthe function returns a value it will be used to resolve\nthe promise returned by <code>.then</code>.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"reason"}]}],"optional":true,"name":"failFilter","description":"<p>A function that is called when the list's promise is rejected. \nIt will be called with the reason. If\nthe function returns a value it will be used to reject\nthe promise returned by <code>.then</code>.</p>"}],"returns":{"types":[{"type":"Promise"}],"description":"<p>A new promise that will be resolved and rejected\nbased upon what <code>doneFilter</code> and <code>fileFilter</code> return.</p>"}}],"comment":" ","src":"can/list/promise/doc/then.md","id":61}]}]}]},{"type":"constructor","name":"can.Map","description":"<p>Create observable objects. </p>","title":"","inherits":"can.Construct","parent":"canjs","test":"can/map/test.html","plugin":"can/map","release":"2.0","links":[{"href":"../docco/map/map.html","title":"docco"}],"signatures":[{"code":"new can.Map([props])","description":"<p>Creates a new instance of can.Map.</p>","params":[{"types":[{"type":"Object","options":[]}],"optional":true,"name":"props","description":"<p>Properties and values to seed the Observe with.</p>"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>An instance of <code>can.Map</code> with the properties from <em>props</em>.</p>"}},{"code":"can.Map([name,] [staticProperties,] instanceProperties)","description":"<p>Creates a new extended constructor function. </p>\n\n<p>This is deprecated. In CanJS 1.2, by default, calling the constructor function\nwithout <code>new</code> will create a <code>new</code> instance. Use [can.Construct.extend can.Map.extend] \ninstead of calling the constructor to extend.</p>","params":[]}],"comment":" ","src":"can/map/doc/map.md","id":89,"children":[{"name":"can.Map.prototype","title":"Prototype","type":"prototype","parent":"can.Map","description":"","order":0,"id":86,"children":[{"type":"function","name":"can.Map.prototype.attr","description":"<p>Get or set properties on an Map. </p>","title":"attr","parent":"can.Map.prototype","order":2,"signatures":[{"code":"map.attr()","description":"<p>Gets a collection of all the properties in this <code>can.Map</code>.</p>","params":[],"returns":{"types":[{"type":"Object","template":[{"types":[{"type":"String"}]}]}],"description":"<p>@return {Object<String, } an object with all the properties in this <code>can.Map</code>.</p>"}},{"code":"map.attr(key)","description":"<p>Reads a property from this <code>can.Map</code>.</p>","params":[{"types":[{"type":"String"}],"name":"key","description":"<p>the property to read</p>"}],"returns":{"types":[{"type":"the"},{"type":"value"},{"type":"assigned"},{"type":"to"}],"description":"<p>@return { the value assigned to <em>key</em>.</p>"}},{"code":"map.attr(key, value)","description":"<p>Assigns <em>value</em> to a property on this <code>can.Map</code> called <em>key</em>.</p>","params":[{"types":[{"type":"String"}],"name":"key","description":"<p>the property to set</p>"},{"types":[{"type":"the"},{"type":"value"},{"type":"to"},{"type":"assign"},{"type":"to"}],"name":"_key_.","description":""}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>this Map, for chaining</p>"}},{"code":"map.attr(obj[, removeOthers])","description":"<p>Assigns each value in <em>obj</em> to a property on this <code>can.Map</code> named after the\ncorresponding key in <em>obj</em>, effectively merging <em>obj</em> into the Map.</p>","params":[{"types":[{"type":"Object","template":[{"types":[{"type":"String"}]}]}],"name":"set.","description":"<p>If any properties already exist on the <code>can.Map</code>, they will be overwritten.</p>"},{"types":[{"type":"bool"}],"optional":true,"name":"removeOthers","defaultValue":"false","description":"<p>whether to remove keys not present in <em>obj</em>.\nTo remove keys without setting other keys, use <code>[can.Map::removeAttr removeAttr]</code>.</p>"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>this Map, for chaining</p>"}}],"comment":" ","src":"can/map/doc/prototype.attr.md","id":90},{"type":"function","name":"can.Map.prototype.bind","description":"<p>Bind event handlers to an Map. </p>","title":"bind","parent":"can.Map.prototype","order":3,"signatures":[{"code":"map.bind(eventType, handler)","description":"","params":[{"types":[{"type":"String"}],"name":"eventType","description":"<p>the type of event to bind this handler to</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.</p>"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>this Map, for chaining</p>"}}],"comment":" ","src":"can/map/doc/prototype.bind.md","id":91},{"type":"property","name":"can.Map.prototype.COMPUTE-ATTR","description":"<p>Specify an attribute that is computed from other attributes. </p>","types":[{"type":"can.compute","description":"<p>A compute that reads values on instances of the\nmap and returns a derived value.  The compute may also be a getter-setter\ncompute and able to be passed a value.</p>"}],"title":"","parent":"can.Map.prototype","order":0,"comment":" ","src":"can/map/doc/prototype.compute-attr.md","id":92},{"type":"function","name":"can.Map.prototype.compute","description":"<p>Make a can.compute from an observable property. </p>","title":"compute","parent":"can.Map.prototype","order":4,"signatures":[{"code":"map.compute(attrName)","description":"","params":[{"types":[{"type":"String"}],"name":"attrName","description":"<p>the property to bind to</p>"}],"returns":{"types":[{"type":"can.compute"}],"description":"<p>a [can.compute] bound to <em>attrName</em></p>"}}],"comment":" ","src":"can/map/doc/prototype.compute.md","id":93},{"type":"property","name":"can.Map.prototype.DEFAULT-ATTR","description":"<p>Specify a default property and value. </p>","types":[{"type":"*","description":"<p>A value of any type other than a function that will\nbe set as the <code>DEFAULT-ATTR</code> attribute's value.</p>"}],"title":"","parent":"can.Map.prototype","order":1,"comment":" ","src":"can/map/doc/prototype.default-attr.md","id":94},{"type":"function","name":"can.Map.prototype.each","description":"<p>Call a function on each property of an Map. </p>","title":"each","parent":"can.Map.prototype","order":5,"signatures":[{"code":"map.each( callback(item, propName ) )","description":"<p><code>each</code> iterates through the Map, calling a function\nfor each property value and key.</p>","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"item"},{"types":[{"type":"String"}],"name":"propName"}]}],"name":"callback","description":"<p>the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.</p>"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>this Map, for chaining</p>"}}],"comment":" ","src":"can/map/doc/prototype.each.md","id":95},{"type":"function","name":"can.Map.prototype.removeAttr","description":"<p>Remove a property from an Map. </p>","title":"removeAttr","parent":"can.Map.prototype","order":6,"signatures":[{"code":"map.removeAttr(attrName)","description":"","params":[{"types":[{"type":"String"}],"name":"attrName","description":"<p>the name of the property to remove</p>"}],"returns":{"types":[{"type":"*"}],"description":"<p>the value of the property that was removed</p>"}}],"comment":" ","src":"can/map/doc/prototype.removeAttr.md","id":96},{"type":"function","name":"can.Map.prototype.serialize","description":"<p>Serialize this object to something that can be passed to <code>JSON.stringify</code>. </p>","title":"serialize","parent":"can.Map.prototype","order":7,"signatures":[{"code":"map.serialize()","description":"<p>Get the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.</p>\n\n<p>o.serialize() //-> { name: 'Justin' }</p>\n\n<p>Serialize currently returns the same data\nas [can.Map.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:</p>\n\n<p>new Map({time: new Date()})\n   .serialize() //-> { time: 1319666613663 }</p>","params":[],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>a JavaScript Object that can be\nserialized with <code>JSON.stringify</code> or other methods.</p>"}}],"src":"can/map/doc/prototype.serialize.md","id":97},{"type":"function","name":"can.Map.prototype.unbind","description":"<p>Unbind event handlers from an Map. </p>","title":"unbind","parent":"can.Map.prototype","order":8,"signatures":[{"code":"map.unbind(eventType[, handler])","description":"","params":[{"types":[{"type":"String"}],"name":"eventType","description":"<p>the type of event to unbind, exactly as passed to <code>bind</code></p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"handler","description":"<p>the handler to unbind</p>"}]}],"comment":" ","src":"can/map/doc/prototype.unbind.md","id":98},{"type":"function","name":"can.Map.prototype._attrs","params":[{"types":[{"type":"Object","options":[]}],"name":"props","description":""},{"types":[{"type":"Boolean"}],"name":"remove","description":"<p>true if you should remove properties that are not in props</p>"}],"parent":"can.Map.prototype","description":"<p>Set multiple properties on the observable</p>","hide":true,"src":"can/map/map.js","line":557,"id":464}]},{"name":"can.Map.static","title":"Static","type":"static","parent":"can.Map","description":"","order":1,"params":[],"id":87,"children":[{"type":"function","name":"can.Map.keys","description":"<p>Iterate over the keys of an Map. </p>","title":"keys","parent":"can.Map.static","order":0,"signatures":[{"code":"can.Map.keys(map)","description":"","params":[{"types":[{"type":"can.Map"}],"name":"map","description":"<p>the <code>can.Map</code> to get the keys from</p>"}],"returns":{"types":[{"type":"Array","options":[]}],"description":"<p>array An array containing the keys from <em>map</em>.</p>"}}],"comment":" ","src":"can/map/doc/static.keys.md","id":99},{"type":"function","name":"can.Map.static.keys","params":[{"types":[{"type":"can.Map"}],"name":"map","description":""}],"parent":"can.Map.static","description":"<p>Returns list of keys in a Map</p>","hide":true,"comment":"undefined@returns {Array}\n","src":"can/map/map.js","line":221,"id":462}]},{"name":"can.Map.plugins","title":"Plugins","type":"group","parent":"can.Map","description":"","order":2,"id":88,"children":[{"type":"page","name":"can.Map.attributes","description":"","title":"attributes","parent":"can.Map.plugins","plugin":"can/map/attributes","test":"can/map/attributes/test.html","download":"http://donejs.com/can/dist/can.map.attributes.js","deprecated":[{"version":"2.1","description":"<p>The attributes plugin (and the setter plugin) have been deprecated in \nfavor of the new [can.Map.prototype.define define] plugin, which provides the same \nfunctionality. It will still be maintained up to 3.0 and potentially after. \nProjects using converters or serializers should consider switching to [can.Map.prototype.define.type define's type] \nand [can.Map.prototype.define.serialize define's serialize].</p>"}],"comment":" ","src":"can/map/attributes/doc/attributes.md","id":64,"children":[{"name":"can.Map.attributes.static","title":"static","type":"group","parent":"can.Map.attributes","description":"","order":0,"id":62,"children":[{"type":"property","name":"can.Map.attributes.static.attributes","description":"<p><code>can.Map.attributes</code> is a property that contains key/value pair(s) of an attribute's name and its\nrespective type for using in [can.Map.attributes.static.convert convert] and [can.Map.prototype.serialize serialize].</p>","title":"attributes","parent":"can.Map.attributes.static","order":0,"src":"can/map/attributes/doc/static.attributes.md","id":66},{"type":"property","name":"can.Map.attributes.static.convert","description":"<p>You often want to convert from what the observe sends you to a form more useful to JavaScript.\nFor example, contacts might be returned from the server with dates that look like: \"1982-10-20\".\nWe can observe to convert it to something closer to <code>new Date(1982,10,20)</code>.</p>","title":"convert","parent":"can.Map.attributes.static","order":1,"src":"can/map/attributes/doc/static.convert.md","id":67},{"type":"property","name":"can.Map.attributes.static.serialize","description":"<p><code>can.Map.serialize</code> is an object of name-function pairs that are used to\nserialize attributes.</p>","title":"serialize","parent":"can.Map.attributes.static","order":2,"src":"can/map/attributes/doc/static.serialize.md","id":68}]},{"name":"can.Map.attributes.prototype","title":"prototype","type":"group","parent":"can.Map.attributes","description":"","order":0,"id":63,"children":[{"type":"function","name":"can.Map.prototype.attributes.serialize","description":"<p>Serializes the observe's properties using the [can.Map.attributes attribute plugin].</p>","title":"serialize","parent":"can.Map.attributes.prototype","order":0,"signatures":[{"code":"observe.serialize([attrName])","description":"","params":[{"types":[{"type":"String"}],"optional":true,"name":"attrName","description":"<p>If passed, returns only a serialization of the named attribute.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>A serialization of this Observe.</p>"}}],"comment":" ","src":"can/map/attributes/doc/prototype.serialize.md","id":65}]},{"name":"can.Map.setup","type":"function","description":"<p><code>can.Map.static.setup</code> overrides default <code>can.Map</code> setup to provide\nfunctionality for attributes.</p>","hide":true,"title":"","parent":"can.Map.attributes","src":"can/map/attributes/attributes.js","line":82,"id":325},{"name":"can.Map.prototype.convert","type":"function","description":"","hide":true,"title":"","parent":"can.Map.attributes","src":"can/map/attributes/attributes.js","line":109,"id":326}]},{"type":"page","name":"can.Map.backup","description":"<p>can.Map.backup is a plugin that provides a dirty bit for properties on an Map,\nand lets you restore the original values of an Map's properties after they are changed.</p>","title":"backup","parent":"can.Map.plugins","plugin":"can/map/backup","test":"can/map/backup/test.html","src":"can/map/backup/doc/backup.md","id":69,"children":[{"type":"function","name":"can.Map.backup.prototype.backup","description":"<p>Save the values of the properties of an Map. </p>","title":"backup","plugin":"can/map/backup","parent":"can.Map.backup","order":0,"signatures":[{"code":"map.backup()","description":"<p><code>backup</code> backs up the current state of the properties of an Observe and marks\nthe Observe as clean. If any of the properties change value, the original\nvalues can be restored with [can.Map.backup.prototype.restore restore].</p>","params":[],"returns":{"types":[{"type":"can.Map"}],"description":"<p>The map, for chaining.</p>"}}],"comment":" ","src":"can/map/backup/doc/prototype.backup.md","id":70},{"type":"function","name":"can.Map.backup.prototype.isDirty","description":"<p>Check whether an Observe has changed since the last time it was backed up. </p>","title":"isDirty","plugin":"can/map/backup","parent":"can.Map.backup","order":1,"signatures":[{"code":"map.isDirty([deep])","description":"<p><code>isDirty</code> checks whether any properties have changed value or whether any properties have\nbeen added or removed since the last time the Observe was backed up. If <em>deep</em> is <code>true</code>,\nIf the Observe has never been backed up, <code>isDirty</code> returns <code>undefined</code>.\n<code>isDirty</code> will include nested Observes in its checks.</p>","params":[{"types":[{"type":"bool"}],"optional":true,"name":"deep","defaultValue":"false","description":"<p>whether to check nested Observes</p>"}],"returns":{"types":[{"type":"bool"}],"description":"<p>Whether the Observe has changed since the last time it was [can.Map.backup.prototype.backup backed up].</p>\n\n<pre><code class=\"lang-javascript\">var recipe = new can.Map({\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n\nrecipe.isDirty();     // false\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.isDirty();     // true\nrecipe.restore();\nrecipe.isDirty();   // false\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // true\n\nrecipe.backup();\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // false</code></pre>"}}],"src":"can/map/backup/doc/prototype.isDirty.md","id":71},{"type":"function","name":"can.Map.backup.prototype.restore","description":"<p>Restore saved values of an Observe's properties. </p>","title":"restore","plugin":"can/map/backup","parent":"can.Map.backup","order":2,"signatures":[{"code":"map.restore( [deep] )","description":"<p><code>restore</code> sets the properties of an Observe back to what they were the last time\n[can.Map.backup.prototype.backup backup] was called. If <em>deep</em> is <code>true</code>,\n<code>restore</code> will also restore the properties of nested Observes.</p>\n\n<p><code>restore</code> will not remove properties that were added since the last backup, but it\nwill re-add properties that have been removed.</p>","params":[{"types":[{"type":"bool"}],"optional":true,"name":"deep","defaultValue":"false","description":"<p>whether to restore properties in nested Observes</p>"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>The Observe, for chaining.</p>\n\n<pre><code class=\"lang-javascript\">var recipe = new can.Map({\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.restore();\nrecipe.attr('title'); // 'Pancake Mix'\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.restore();\nrecipe.attr('ingredients.0.quantity'); // '7 cups'\nrecipe.restore(true);\nrecipe.attr('ingredients.0.quantity'); // '6 cups'</code></pre>\n\n<h2>Events</h2>\n\n<p>When <code>restore</code> sets values or re-adds properties, the same events will be fired (including\n<em>change</em>, <em>add</em>, and <em>set</em>) as if the values of the properties had been set using <code>[can.Map.prototype.attr attr]</code>.</p>"}}],"src":"can/map/backup/doc/prototype.restore.md","id":72}]},{"type":"property","name":"can.Map.prototype.define","description":"<p>Defines the\ntype, initial value, get, set, remove, and serialize behavior for attributes \nof a [can.Map].</p>","types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"can.Map.prototype.define.attrDefinition"}]}],"description":"<p>A map of \nattribute names to [can.Map::define.attrDefinition attribute definition]\nobjects.</p>"}],"title":"define","parent":"can.Map.plugins","comment":" ","src":"can/map/define/doc/define.md","id":74,"children":[{"type":"typedef","name":"can.Map.prototype.define.attrDefinition","description":"<p>Defines the type, initial value, and get, set, and remove behavior for an attribute of a [can.Map].</p>","title":"attrDefinition","types":[{"type":"Object","options":[{"name":"value","description":"<p>Specifies the initial value of the attribute or\na function that returns the initial value. For example, a default value of <code>0</code> can be \nspecified like:</p>\n\n<pre><code>define: {\n  prop: {\n    value: 0\n  }\n}\n</code></pre>\n\n<p><code>Object</code> types should not be specified directly on <code>value</code> because that same object will\nbe shared on every instance of the Map.  Instead, a [can.Map::define.value value function] that \nreturns a fresh copy can be provided:</p>\n\n<pre><code>define: {\n  prop: {\n    value: function(){\n      return {foo: \"bar\"}\n    }\n  }\n}\n</code></pre>","types":[{"type":"can.Map.prototype.define.value"},{"type":"*"}]},{"name":"Value","description":"<p>Specifies a function that will be called with <code>new</code> whose result is\nset as the initial value of the attribute. For example, if the default value should be a can.List:</p>\n\n<pre><code>define: {\n  prop: {\n    Value: can.List\n  }\n}\n</code></pre>","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"type","description":"<p>Specifies the type of the \nattribute.  The type can be specified as either a [can.Map.prototype.define.type type function] \nthat returns the type coerced value or one of the following strings:</p>\n\n<ul>\n<li><code>\"string\"</code> - Converts the value to a string.</li>\n<li><code>\"date\"</code> - Converts the value to a date or `null if the date can not be converted.</li>\n<li><code>\"number\"</code> - Passes the value through <code>parseFloat</code>.</li>\n<li><code>\"boolean\"</code> - Converts falsey, <code>\"false\"</code> or <code>\"0\"</code> to <code>false</code> and everything else to true.</li>\n<li><code>\"*\"</code> - Prevents the default type coersion of converting Objects to [can.Map]s and Arrays to [can.List]s.</li>\n</ul>\n\n<p>The following example converts the <code>count</code> property to a number and the <code>items</code> property to an array:</p>\n\n<pre><code> define: {\n   count: {type: \"number\"},\n   items: {\n     type: function(newValue){\n       if(typeof newValue === \"string\") {\n         return newValue.split(\",\")\n       } else if( can.isArray(newValue) ) {\n         return newValue;\n       }\n     }\n   }\n }\n</code></pre>","types":[{"type":"can.Map.prototype.define.type"},{"type":"String"}]},{"name":"Type","description":"<p>A constructor function that takes \nthe value passed to [can.Map::attr attr] as the first argument and called with \nnew. For example, if you want whatever\ngets passed to go through <code>new Array(newValue)</code> you can do that like:</p>\n\n<pre><code>define: {\n  items: {\n    Type: Array\n  }\n}\n</code></pre>\n\n<p>If the value passed to [can.Map::attr attr] is already an Array, it will be left as is.</p>","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"set","description":"<p>A set function that specifies what should happen when an attribute\nis set on a [can.Map]. <code>set</code> is called with the result of <code>type</code> or <code>Type</code>. The following\ndefines a <code>page</code> setter that updates the map's offset:</p>\n\n<pre><code>define: {\n  page: {\n    set: function(newVal){\n      this.attr('offset', (parseInt(newVal) - 1) * \n                           this.attr('limit'));\n    }\n  }\n}\n</code></pre>","types":[{"type":"can.Map.prototype.define.set"}]},{"name":"get","description":"<p>A function that specifies how the value is retrieved.  The get function is \nconverted to an [can.compute.async async compute].  It should derive its value from other values\non the map. The following\ndefines a <code>page</code> getter that reads from a map's offset and limit:</p>\n\n<pre><code>define: {\n  page: {\n    get: function (newVal) {\n      return Math.floor(this.attr('offset') / \n                        this.attr('limit')) + 1;\n    }\n  }\n}\n</code></pre>\n\n<p>A <code>get</code> definition makes the property <strong>computed</strong> which means it will not be serialized by default.</p>","types":[{"type":"can.Map.prototype.define.get"}]},{"name":"remove","description":"<p>A function that specifies what should happen when an attribute is removed\nwith [can.Map::removeAttr removeAttr]. The following removes a <code>modelId</code> when <code>makeId</code> is removed:</p>\n\n<pre><code>define: {\n  makeId: {\n    remove: function(){\n      this.removeAttr(\"modelId\");\n    }\n  }\n}\n</code></pre>","types":[{"type":"can.Map.prototype.define.remove"}]},{"name":"serialize","description":"<p>Specifies the behavior of the \nproperty when [can.Map::serialize serialize] is called. </p>\n\n<p>By default, serialize does not include computed values. Properties with a <code>get</code> definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.</p>\n\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    pageNum: {\n      get: function(){ return this.offset() / 20 }\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {offset: 40}\n</code></pre>\n\n<p>If <code>true</code> is specified, computed properties will be serialized and added to the result.</p>\n\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    pageNum: { \n      get: function(){ return this.offset() / 20 },\n      serialize: true\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {offset: 40, pageNum: 2}\n</code></pre>\n\n<p>If <code>false</code> is specified, non-computed properties will not be added to the result.</p>\n\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    offset: {\n      serialize: false\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {}\n</code></pre>\n\n<p>If a [can.Map.prototype.define.serialize serialize function] is specified, the result\nof the function is added to the result.</p>\n\n<pre><code>Paginate = can.Map.extend({\n  define: {\n    offset: {\n      serialize: function(offset){\n        return (offset / 20)+1\n      }\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-&gt; {offset: 3}\n</code></pre>","types":[{"type":"can.Map.prototype.define.serialize"},{"type":"Boolean"}]}]}],"parent":"can.Map.prototype.define","src":"can/map/define/doc/attrDefinition.md","id":73},{"type":"function","name":"can.Map.prototype.define.get","description":"<p>Specify what happens when a certain property is read on a map.</p>","title":"get","parent":"can.Map.prototype.define","signatures":[{"code":"get( )","description":"<p>A get function defines the behavior of what happens when a value is read on a\n[can.Map]. It is typically used to provide properties that derive their value from other properties of the map.</p>","params":[],"returns":{"types":[{"type":"*"}],"description":"<p>Anything can be returned from a getter.</p>"}}],"comment":" ","src":"can/map/define/doc/get.md","id":75},{"type":"function","name":"can.Map.prototype.define.remove","description":"<p>Called when an attribute is removed.</p>","title":"remove","parent":"can.Map.prototype.define","signatures":[{"code":"remover( currentValue )","description":"","params":[],"returns":{"types":[{"type":"*"},{"type":"false"}],"description":"<p>If <code>false</code> is returned, the value is not removed.</p>"}}],"comment":" ","src":"can/map/define/doc/remove.md","id":76},{"type":"function","name":"can.Map.prototype.define.serialize","description":"<p>Called when an attribute is removed.</p>","title":"serialize","parent":"can.Map.prototype.define","signatures":[{"code":"serializer( currentValue )","description":"","params":[{"types":[{"type":"*"}],"name":"value","description":"<p>The current value of the attribute.</p>"},{"types":[{"type":"String"}],"name":"attr","description":"<p>The name of the attribute being serialized.</p>"}],"returns":{"types":[{"type":"*"},{"type":"undefined"}],"description":"<p>If <code>undefined</code> is returned, the value is not serialized.</p>"},"context":{"types":[{"type":"can.Map"}],"description":"<p>The map instance being serialized.</p>"}}],"comment":" ","src":"can/map/define/doc/serialize.md","id":77},{"type":"function","name":"can.Map.prototype.define.set","description":"<p>Specify what happens when a value is set on a map attribute.</p>","title":"set","parent":"can.Map.prototype.define","signatures":[{"code":"set( [newVal,] [setValue] )","description":"<p>A set function defines the behavior of what happens when a value is set on a\n[can.Map]. It is typically used to:</p>\n\n<ul>\n<li>Add or remove other attributes as side effects</li>\n<li>Coerce the set value into an appropriate action</li>\n</ul>\n\n<p>The behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:</p>\n\n<pre><code>define: {\n  prop: {\n    set: function(){}\n  }\n}\n</code></pre>\n\n<p>behaves differently than:</p>\n\n<pre><code>define: {\n  prop: {\n    set: function(newVal){}\n  }\n}\n</code></pre>","params":[{"types":[{"type":"*"}],"optional":true,"name":"newVal","description":"<p>The [can.Map::define.type type function] coerced value the user intends to set on the\ncan.Map.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"newValue"}]}],"optional":true,"name":"setValue","description":"<p>A callback that can set the value of the property \nasyncronously.</p>"}],"returns":{"types":[{"type":"*"},{"type":"undefined"}],"description":"<p>If a non-undefined value is returned, that value is set as \nthe attribute value. </p>\n\n<p>If an <code>undefined</code> value is returned, the behavior depends on the number of\narguments the setter declares:</p>\n\n<ul>\n<li>If the setter <em>does not</em> specify the <code>newValue</code> argument, the attribute value is set\nto whatever was passed to [can.Map::attr attr].</li>\n<li>If the setter specifies the <code>newValue</code> argument only, the attribute value will be removed.</li>\n<li>If the setter specifies both <code>newValue</code> and <code>setValue</code>, the value of the property will not be \nupdated until <code>setValue</code> is called.</li>\n</ul>"}}],"comment":" ","src":"can/map/define/doc/set.md","id":78},{"type":"function","name":"can.Map.prototype.define.type","description":"<p>Converts a value passed to [can.Map::attr attr] into an appropriate value.</p>","title":"type","parent":"can.Map.prototype.define","params":[{"types":[{"type":"*"}],"name":"newValue","description":"<p>The value passed to <code>attr</code>.</p>"},{"types":[{"type":"String"}],"name":"attrName","description":"<p>The attribute name being set.</p>"}],"context":{"types":[{"type":"can.Map"}],"description":"<p>the instance of the can.Map.</p>"},"returns":{"types":[{"type":"*"}],"description":"<p>The value that should be passed to <code>set</code> or (if there is no <code>set</code> property) the value to set on the map instance.</p>"},"comment":" ","src":"can/map/define/doc/type.md","id":79},{"type":"function","name":"can.Map.prototype.define.TypeConstructor","description":"<p>Provides a constructor function to be used to convert any value passed into [can.Map::attr attr] into an appropriate value</p>","title":"Type","parent":"can.Map.prototype.define","signatures":[{"code":"constructorFunc","description":"<p>A constructor function can be provided that is called to convert incoming values set on this property, like:</p>\n\n<pre><code>define: {\n  prop: {\n    Type: Person\n  }\n}\n</code></pre>","params":[]}],"comment":" ","src":"can/map/define/doc/TypeConstructor.md","id":80},{"type":"function","name":"can.Map.prototype.define.value","description":"<p>Returns the default value for instances of this can.Map.  This is called before <code>init</code>.</p>","title":"value","parent":"can.Map.prototype.define","signatures":[{"code":"defaulter()","description":"<p>A function can be provided that returns the default value used for this property, like:</p>\n\n<pre><code>define: {\n  prop: {\n    value: function(){ return []; }\n  }\n}\n</code></pre>\n\n<p>If the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property <code>value</code> above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).</p>","params":[],"context":{"types":[{"type":"can.Map"}],"description":"<p>the instance of the can.Map.</p>"},"returns":{"types":[{"type":"*"}],"description":"<p>The default value.  This will be passed through setter and type.</p>"}},{"code":"defaulVal","description":"<p>Any value can be provided as the default value used for this property, like:</p>\n\n<pre><code>define: {\n  prop: {\n    value: 'foo'\n  }\n}\n</code></pre>","params":[{"types":[{"type":"*"}],"name":"defaultVal","description":"<p>The default value, which will be passed through setter and type.</p>"}]}],"comment":" ","src":"can/map/define/doc/value.md","id":81},{"type":"function","name":"can.Map.prototype.define.ValueConstructor","description":"<p>Provides a constructor function to be used to provide a default value for a certain property of a can.Map.  This constructor will be invoked with <code>new</code> each time a new instance of the map is created.</p>","title":"Value","parent":"can.Map.prototype.define","signatures":[{"code":"constructorFunc","description":"<p>A constructor function can be provided that is called to create a default value used for this property, like:</p>\n\n<pre><code>define: {\n  prop: {\n    Value: Array\n  },\n  person: {\n      Value: Person\n  }\n}\n</code></pre>","params":[]}],"comment":" ","src":"can/map/define/doc/ValueConstructor.md","id":82}]},{"type":"page","name":"can.Map.delegate","description":"<p>The <strong>delegate</strong> plugin allows you to listen to more specific event changes on \n[can.Map Maps].  It allows you to specify:</p>","title":"delegate","parent":"can.Map.plugins","plugin":"can/map/delegate","test":"can/map/delegate/test.html","src":"can/map/delegate/doc/delegate.md","id":83,"children":[{"type":"function","name":"can.Map.prototype.delegate","description":"","title":"delegate","parent":"can.Map.delegate","order":0,"plugin":"can/map/delegate","signatures":[{"code":"observe.delegate( selector, event, handler )","description":"<p><code>delegate( selector, event, handler(ev,newVal,oldVal,from) )</code> listen for changes\nin a child attribute from the parent. The child attribute\ndoes not have to exist.</p>\n\n<p>// create an observable\n var observe = new can.Map({\n   foo : {\n     bar : \"Hello World\"\n   }\n })</p>\n\n<p>//listen to changes on a property\n observe.delegate(\"foo.bar\",\"change\", function(ev, prop, how, newVal, oldVal){\n   // foo.bar has been added, set, or removed\n   this //->\n });</p>\n\n<p>// change the property\n observe.attr('foo.bar',\"Goodbye Cruel World\")</p>\n\n<h2>Types of events</h2>\n\n<p>Delegate lets you listen to add, set, remove, and change events on property.</p>\n\n<p><strong>add</strong></p>\n\n<p>An add event is fired when a new property has been added.</p>\n\n<p>var o = new can.Control({});\n o.delegate(\"name\",\"add\", function(ev, value){\n   // called once\n   can.$('#name').show()\n })\n o.attr('name',\"Justin\")\n o.attr('name',\"Brian\");</p>\n\n<p>Listening to add events is useful for 'setup' functionality (in this case\nshowing the <code>#name</code> element.</p>\n\n<p><strong>set</strong></p>\n\n<p>Set events are fired when a property takes on a new value.  set events are\nalways fired after an add.</p>\n\n<p>o.delegate(\"name\",\"set\", function(ev, value){\n   // called twice\n   can.$('#name').text(value)\n })\n o.attr('name',\"Justin\")\n o.attr('name',\"Brian\");</p>\n\n<p><strong>remove</strong></p>\n\n<p>Remove events are fired after a property is removed.</p>\n\n<p>o.delegate(\"name\",\"remove\", function(ev){\n   // called once\n   $('#name').text(value)\n })\n o.attr('name',\"Justin\");\n o.removeAttr('name');</p>\n\n<h2>Wildcards - matching multiple properties</h2>\n\n<p>Sometimes, you want to know when any property within some part\nof an observe has changed. Delegate lets you use wildcards to\nmatch any property name.  The following listens for any change\non an attribute of the params attribute:</p>\n\n<p>var o = can.Control({\n   options : {\n     limit : 100,\n     offset: 0,\n     params : {\n       parentId: 5\n     }\n   }\n })\n o.delegate('options.<em>','change', function(){\n   alert('1');\n })\n o.delegate('options.</em>*','change', function(){\n   alert('2');\n })</p>\n\n<p>// alerts 1\n // alerts 2\n o.attr('options.offset',100)</p>\n\n<p>// alerts 2\n o.attr('options.params.parentId',6);</p>\n\n<p>Using a single wildcard (<code><em></code>) matches single level\nproperties.  Using a double wildcard (<code></em>*</code>) matches\nany deep property.</p>\n\n<h2>Listening on multiple properties and values</h2>\n\n<p>Delegate lets you listen on multiple values at once.  The following listens\nfor first and last name changes:</p>\n\n<p>var o = new can.Map({\n   name : {first: \"Justin\", last: \"Meyer\"}\n })</p>\n\n<p>o.bind(\"name.first,name.last\",\n        \"set\",\n        function(ev,newVal,oldVal,from){</p>\n\n<p>})</p>\n\n<h2>Listening when properties are a particular value</h2>\n\n<p>Delegate lets you listen when a property is <strong>set</strong> to a specific value:</p>\n\n<p>var o = new can.Map({\n   name : \"Justin\"\n })</p>\n\n<p>o.bind(\"name=Brian\",\n        \"set\",\n        function(ev,newVal,oldVal,from){</p>\n\n<p>})</p>","params":[{"types":[{"type":"String"}],"name":"selector","description":"<p>The attributes you want to listen for changes in.</p>\n\n<p>Selector should be the property or\nproperty names of the element you are searching.  Examples:</p>\n\n<p>\"name\" - listens to the \"name\" property changing\n \"name, address\" - listens to \"name\" or \"address\" changing\n \"name address\" - listens to \"name\" or \"address\" changing\n \"address.<em>\" - listens to property directly in address\n \"address.</em>*\" - listens to any property change in address\n \"foo=bar\" - listens when foo is \"bar\"</p>"},{"types":[{"type":"String"}],"name":"event","description":"<p>The event name.  One of (\"set\",\"add\",\"remove\",\"change\")</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"name":"ev"},{"name":"newVal"},{"name":"oldVal"},{"name":"prop"}]}],"name":"handler","description":"<p>The callback handler\ncalled with:</p>\n\n<ul>\n<li>newVal - the new value set on the observe</li>\n<li>oldVal - the old value set on the observe</li>\n<li>prop - the prop name that was changed</li>\n</ul>"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>the observe for chaining</p>"}}],"src":"can/map/delegate/doc/prototype.delegate.md","id":84},{"type":"function","name":"can.Map.prototype.undelegate","description":"","title":"undelegate","parent":"can.Map.delegate","order":1,"plugin":"can/map/delegate","signatures":[{"code":"observe.undelegate( selector, event, handler )","description":"<p><code>undelegate( selector, event, handler )</code> removes a delegated event handler from an observe.</p>\n\n<p>observe.undelegate(\"name\",\"set\", handler )</p>","params":[{"types":[{"type":"String"}],"name":"selector","description":"<p>the attribute name of the object you want to undelegate from.</p>"},{"types":[{"type":"String"}],"name":"event","description":"<p>the event name</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>the callback handler</p>"}],"returns":{"types":[{"type":"can.Map"}],"description":"<p>the observe for chaining</p>"}}],"src":"can/map/delegate/doc/prototype.undelegate.md","id":85}]},{"type":"constructor","name":"can.LazyMap","description":"<p>Create observable objects that initialize on demand. </p>","title":"","inherits":"can.Map","parent":"can.Map.plugins","plugin":"can/map/lazy","release":"2.1","test":"can/LazyMap/lazy/test.html","signatures":[{"code":"new can.LazyLazyMap([props])","description":"<p>Creates a new instance of can.LazyMap.</p>","params":[{"types":[{"type":"Object","options":[]}],"optional":true,"name":"props","description":"<p>Properties and values to initialize the Map with.</p>"}],"returns":{"types":[{"type":"can.LazyMap"}],"description":"<p>An instance of <code>can.LazyMap</code> with the properties from <em>props</em>.</p>"}}],"comment":" ","src":"can/map/lazy/lazy.md","id":100},{"type":"function","name":"can.Map.setter","description":"<p>Specify setter methods on [can.Map can.Maps].</p>","title":"setter","parent":"can.Map.plugins","plugin":"can/map/setter","test":"can/map/setter/test.html","deprecated":[{"version":"2.1","description":"<p>The setter plugin (and the attributes plugin) have been deprecated in \nfavor of the new [can.Map.prototype.define define] plugin, which provides the same \nfunctionality. It will still be maintained up to 3.0 and potentially after. \nProjects using setters should consider switching to [can.Map.prototype.define.set define setters].</p>"}],"signatures":[{"code":"setATTR: function(newValue,setValue,setErrors)","description":"<p>Specifies a setter method for the <code>ATTR</code> attribute.</p>","params":[{"types":[{"type":"String"}],"name":"ATTR","description":"<p>The capitalized attribute name this setter will set.</p>"},{"types":[{"type":"*"}],"name":"newValue","description":"<p>The propsed value of the attribute specified by [can.Map::attr].</p>"},{"types":[{"type":"can.Map.setter.setValue"}],"name":"setValue","description":"<p>A callback function that can specify <code>undefined</code> values\nor the value at a later time.</p>"},{"types":[{"type":"can.Map.setter.setErrors"}],"name":"setErrors","description":"<p>A callback function that can specify error data if\nthe proposed value is in error.</p>"}],"returns":{"types":[{"type":"*"}],"description":"<p>If a non-undefined value is returned, that value is set as the attribute's value. If\nundefined is returned, it's assumed that the <code>setValue</code> callback will be called.  Use <code>setValue</code> to\nset undefined values.</p>\n\n<div class='demo_wrapper' data-demo-src='can/map/setter/setter-paginate.html'></div>"}}],"comment":" ","src":"can/map/setter/doc/setter.md","id":102,"children":[{"type":"function","name":"can.classize","description":"<p>Make a string into a class name. </p>","title":"can.classize","parent":"can.Map.setter","order":0,"plugin":"can/map/setter","signatures":[{"code":"can.classize(str)","description":"<p><code>can.classize</code> splits a string by underscores or\ndashes and capitalizes each part before joining\nthem back together. This method is useful for\ntaking HTML class names and getting the original\nControl name from them.</p>\n\n<pre><code class=\"lang-javascript\">can.classize('my_control_name'); // 'MyControlName'</code></pre>","params":[{"types":[{"type":"String"}],"name":"str","description":"<p>The string to transform.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The string as a class name.</p>"}}],"src":"can/map/setter/doc/can.classize.md","id":101}]},{"type":"page","name":"can.Map.validations","description":"<p>The <code>can/map/validations</code> plugin provides validations on maps. Validations\nare set on [can.Map]'s <strong>static</strong> <code>init</code> function.</p>","title":"validations","parent":"can.Map.plugins","plugin":"can/map/validations","test":"can/map/validations/test.html","src":"can/map/validations/doc/validations.md","id":115,"children":[{"type":"function","name":"can.Map.validations.prototype.errors","description":"","title":"errors","parent":"can.Map.validations","order":0,"signatures":[{"code":"observe.errors(attrs, newVal)","description":"","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"optional":true,"name":"attrs","description":"<p>An optional list of attributes to get errors for:</p>\n\n<p>task.errors(['dueDate','name']);</p>\n\n<p>Or it can take a single attr name like:</p>\n\n<p>task.errors('dueDate')</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"newVal","description":"<p>An optional new value to test setting\non the observe.  If <code>newVal</code> is provided,\nit returns the errors on the observe if <code>newVal</code> was set.</p>"}],"returns":{"types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}]}]}],"description":"<p>an object of attributeName : [errors] like:</p>\n\n<p>task.errors() // -> {dueDate: [\"can't be empty\"]}</p>\n\n<p>or <code>null</code> if there are no errors.</p>"}}],"comment":" ","src":"can/map/validations/doc/prototype.errors.md","id":106},{"type":"function","name":"can.Map.validations.static.validate","description":"","title":"validate","parent":"can.Map.validations","order":1,"comment":" ","signatures":[{"code":"observe.validate(attrNames, [options,] validateProc)","description":"","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the\nvalidations.  Valid options include 'message' and 'testIf'.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"*"}],"name":"value"},{"types":[{"type":"String"}],"name":"attrName"}]}],"name":"validateProc","description":"<p>Function used to validate each\ngiven attribute. Returns nothing if valid and an error message\notherwise. Function is called in the instance context and takes the\n<code>value</code> and <code>attrName</code> to validate.</p>\n\n<p><code>validate(attrNames, [options,] validateProc(value, attrName) )</code> validates each of the\nspecified attributes with the given <code>validateProc</code> function.  The function\nshould return a value if there is an error.  By default, the return value is\nthe error message.  Validations should be set in the Constructor's static init method.</p>"}]}],"src":"can/map/validations/doc/static.validate.md","id":107},{"type":"function","name":"can.Map.validations.static.validateFormatOf","description":"","title":"validateFormatOf","parent":"can.Map.validations","order":2,"signatures":[{"code":"observe.validateFormatOf(attrNames, regexp, options)","description":"","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>"},{"types":[{"type":"RegExp"}],"name":"regexp","description":"<p>Regular expression used to match for validation</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"}]}],"comment":" ","src":"can/map/validations/doc/static.validateFormatOf.md","id":108},{"type":"function","name":"can.Map.validations.static.validateInclusionOf","description":"","title":"validateInclusionOf","parent":"can.Map.validations","order":3,"signatures":[{"code":"observe.validateInclusionOf(attrNames, inArray, options)","description":"<p>Validates whether the values of the specified attributes are available in a particular\narray.</p>\n\n<p>init : function(){\n   this.validateInclusionOf([\"salutation\"],[\"Mr.\",\"Mrs.\",\"Dr.\"])\n }</p>","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>"},{"types":[{"type":"Array","options":[]}],"name":"inArray","description":"<p>Array of options to test for inclusion</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"}]}],"src":"can/map/validations/doc/static.validateInclusionOf.md","id":109},{"type":"function","name":"can.Map.validations.static.validateLengthOf","description":"","title":"validateLengthOf","parent":"can.Map.validations","order":4,"signatures":[{"code":"observe.validateLengthOf(attrNames, min, max, options)","description":"<p>Validates that the specified attributes' lengths are in the given range.</p>\n\n<p>init : function(){\n   this.validateInclusionOf([\"suffix\"],3,5)\n }</p>","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>"},{"types":[{"type":"Number"}],"name":"min","description":"<p>Minimum length (inclusive)</p>"},{"types":[{"type":"Number"}],"name":"max","description":"<p>Maximum length (inclusive)</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"}]}],"src":"can/map/validations/doc/static.validateLengthOf.md","id":110},{"type":"function","name":"can.Map.validations.static.validatePresenceOf","description":"","title":"validatePresenceOf","parent":"can.Map.validations","order":5,"signatures":[{"code":"observe.validatePresenceOf(attrNames, options)","description":"<p>Validates that the specified attributes are not blank.</p>\n\n<p>init : function(){\n   this.validatePresenceOf([\"name\"])\n }</p>","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"}]}],"src":"can/map/validations/doc/static.validatePresenceOf.md","id":111},{"type":"function","name":"can.Map.validations.static.validateRangeOf","description":"","title":"validateRangeOf","parent":"can.Map.validations","order":6,"signatures":[{"code":"observe.validateRangeOf(attrNames, low, hi, options)","description":"<p>Validates that the specified attributes are in the given numeric range.</p>\n\n<p>init : function(){\n   this.validateRangeOf([\"age\"],21, 130);\n }</p>","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>"},{"types":[{"type":"Number"}],"name":"low","description":"<p>Minimum value (inclusive)</p>"},{"types":[{"type":"Number"}],"name":"hi","description":"<p>Maximum value (inclusive)</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options for the validations.  Valid options include 'message' and 'testIf'.</p>"}]}],"src":"can/map/validations/doc/static.validateRangeOf.md","id":112},{"type":"function","name":"can.Map.validations.static.validatesNumericalityOf","description":"","title":"validatesNumericalityOf","parent":"can.Map.validations","order":7,"signatures":[{"code":"observe.validatesNumericalityOf(attrNames)","description":"<p>Validates that the specified attributes is a valid Number.</p>\n\n<p>init : function(){\n   this.validatesNumericalityOf([\"age\"]);\n }</p>","params":[{"types":[{"type":"Array"},{"type":"String"}],"name":"attrNames","description":"<p>Attribute name(s) to to validate</p>"}]}],"src":"can/map/validations/doc/static.validatesNumericalityOf.md","id":113},{"type":"property","name":"can.Map.validations.static.validationMessages","description":"<p><code>validationMessages</code> has the default validation error messages that will be returned by the builtin\nvalidation methods. These can be overwritten by assigning new messages\nto <code>can.Map.validationMessages</code> in your application setup.</p>","title":"validationMessages","parent":"can.Map.validations","order":8,"src":"can/map/validations/doc/static.validationMessages.md","id":114}]}]}]},{"type":"constructor","name":"can.Model","description":"","title":"","parent":"canjs","download":"can/model","test":"can/model/test.html","links":[{"href":"../docco/model/model.html","title":"docco"}],"signatures":[{"code":"can.Model([name,] staticProperties, instanceProperties)","description":"<p>Create a can.Model constructor. (See [can.Construct] for more details on this syntax.)</p>","params":[{"types":[{"type":"String"}],"optional":true,"name":"name","description":"<p>If given, this will be the globally-available name of the constructor function.</p>"},{"types":[{"type":"Object","options":[]}],"name":"staticProperties","description":"<p>The static properties of the class. See below for properties with\nspecial meanings to <code>can.Model</code>.</p>"},{"types":[{"type":"Object","options":[]}],"name":"instanceProperties","description":"<p>The instance properties of instances of the class. These will usually\nbe functions.</p>"}],"returns":{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"description":"<p>A can.Model constructor.</p>"}},{"code":"new can.Model([options])","description":"<p>Creates a new instance of <em>ModelConstructor</em>.</p>","params":[{"types":[{"type":"Object","options":[]}],"optional":true,"name":"options","description":"<p>Options to pass to <code>setup</code> or <code>init</code>.</p>"}],"returns":{"types":[{"type":"can.Model"}],"description":"<p>A new instance of <em>ModelConstructor</em>.</p>"}}],"comment":" ","src":"can/model/doc/model.md","id":130,"children":[{"description":"","type":"static","name":"can.Model.static","parent":"can.Model","src":"can/model/model.js","line":242,"id":320,"children":[{"type":"function","name":"can.Model.bind","description":"<p>Listen for events on a Model class. </p>","title":"bind","parent":"can.Model.static","signatures":[{"code":"can.Model.bind(eventType, handler)","description":"","params":[{"types":[{"type":"String"}],"name":"eventType","description":"<p>The type of event.  It must be\n<code>\"created\"</code>, <code>\"updated\"</code>, <code>\"destroyed\"</code>.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>A callback function\nthat gets called with the event and instance that was\ncreated, destroyed, or updated.</p>"}],"returns":{"types":[{"type":"can.Model"}],"description":"<p>The model constructor function.</p>"}}],"comment":" ","src":"can/model/doc/bind.md","id":116},{"type":"function","name":"can.Model.create","description":"<p>Specifies how to create a new resource on the server. <code>create(serialized)</code> is called by [can.Model.prototype.save save] if the model instance [can.Model.prototype.isNew is new].</p>","title":"create","parent":"can.Model.static","signatures":[{"code":"can.Model.create: function(serialized) -> deferred","description":"<p>Specify a function to create persistent instances. The function will\ntypically perform an AJAX request to a service that results in\ncreating a record in a database.</p>","params":[{"types":[{"type":"Object","options":[]}],"name":"serialized","description":"<p>The [can.Map::serialize serialized] properties of\nthe model to create.</p>"}],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A Deferred that resolves to an object of attributes\nthat will be added to the created model instance.  The object <strong>MUST</strong> contain\nan [can.Model.id id] property so that future calls to [can.Model.prototype.save save]\nwill call [can.Model.update].</p>"}},{"code":"can.Model.create: \"[METHOD] /path/to/resource\"","description":"<p>Specify a HTTP method and url to create persistent instances.</p>\n\n<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or POST if none is specified) when saving a\nnew instance on the server. (See below for more details.)</p>","params":[{"types":[{"type":"HttpMethod"}],"name":"METHOD","description":"<p>An HTTP method. Defaults to <code>\"POST\"</code>.</p>"},{"types":[{"type":"STRING"}],"name":"url","description":"<p>The URL of the service to retrieve JSON data.</p>"}]},{"code":"can.Model.create: {ajaxSettings}","description":"<p>Specify an options object that is used to make a HTTP request to create\npersistent instances.</p>","params":[{"types":[{"type":"can.AjaxSettings"}],"name":"ajaxSettings","description":"<p>A settings object that\nspecifies the options available to pass to [can.ajax].</p>"}]}],"comment":" ","src":"can/model/doc/create.md","id":117},{"type":"function","name":"can.Model.model","description":"<p>Convert raw data into a can.Model instance. If data's [can.Model.id id] matches a item in the store's <code>id</code>, <code>data</code> is merged with the instance and the\ninstance is returned.</p>","title":"model","parent":"can.Model.static","deprecated":[{"version":"2.1","description":"<p>Prior to 2.1, <code>.model</code> was used to convert ajax\nresponses into a data format useful for converting them into a can.Model instance\nAND for converting them into that instance. In 2.1, [can.Model.parseModel] should\nbe used to convert the ajax response into a data format useful to [can.Model.model].</p>"}],"signatures":[{"code":"can.Model.model(data)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"data","description":"<p>The data to convert to a can.Model instance.</p>"}],"returns":{"types":[{"type":"can.Model"}],"description":"<p>An instance of can.Model made with the given data.</p>"}}],"comment":" ","src":"can/model/doc/deprecated_model.md","id":118},{"type":"function","name":"can.Model.models","description":"<p>Convert raw data into can.Model instances. Merge data with items in the store if matches are found.</p>","title":"models","parent":"can.Model.static","deprecated":[{"version":"2.1","description":"<p>Prior to 2.1, <code>.models</code> was used to convert the ajax\nresponses into a data format useful for converting them into an observable\nlist AND for converting them into that list. In 2.1, [can.Model.parseModels] should\nbe used to convert the ajax responses into a data format useful to [can.Model.models].</p>"}],"signatures":[{"code":"can.Model.models(data[, oldList])","description":"","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"Object","options":[]}]}]}],"name":"data","description":"<p>The raw data from a <code>[can.Model.findAll findAll()]</code> request.</p>"},{"types":[{"type":"can.Model.List"}],"optional":true,"name":"oldList","description":"<p>If supplied, this List will be updated with the data from\n<strong>data</strong>.</p>"}],"returns":{"types":[{"type":"can.Model.List"}],"description":"<p>A List of Models made from the raw data.</p>"}}],"comment":" ","src":"can/model/doc/deprecated_models.md","id":119},{"type":"function","name":"can.Model.destroy","description":"<p>Destroy a resource on the server. </p>","title":"destroy","parent":"can.Model.static","signatures":[{"code":"can.Model.destroy: function(id) -> deferred","description":"<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>","params":[{"types":[{"type":"*"}],"name":"id","description":"<p>The ID of the resource to destroy.</p>"}],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A Deferred that resolves to the destroyed model.</p>"}},{"code":"can.Model.destroy: \"[METHOD] /path/to/resource\"","description":"<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or DELETE if none is specified) when deleting an\ninstance on the server. (See below for more details.)</p>","params":[],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A Deferred that resolves to the destroyed model.</p>"}}],"comment":" ","src":"can/model/doc/destroy.md","id":120},{"type":"function","name":"can.Model.findAll","description":"<p>Retrieve multiple resources from a server. </p>","title":"findAll","parent":"can.Model.static","signatures":[{"code":"can.Model.findAll( params[, success[, error]] )","description":"<p>Retrieve multiple resources from a server.</p>","params":[{"types":[{"type":"Object","options":[]}],"name":"params","description":"<p>Values to filter the request or results with.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"can.Model.List"}],"name":"list"}]}],"optional":true,"name":"success","description":"<p>A callback to call on successful retrieval. The callback recieves\na can.Model.List of the retrieved resources.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"can.AjaxSettings"}],"name":"xhr"}]}],"optional":true,"name":"error","description":"<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"}],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"}},{"code":"can.Model.findAll: findAllData( params ) -> deferred","description":"<p>Implements <code>findAll</code> with a [can.Model.findAllData function]. This function\nis passed to [can.Model.makeFindAll makeFindAll] to create the external\n<code>findAll</code> method.</p>\n\n<pre><code>findAll: function(params){\n  return $.get(\"/tasks\",params)\n}\n</code></pre>","params":[{"types":[{"type":"can.Model.findAllData"}],"name":"findAllData","description":"<p>A function that accepts parameters\nspecifying a list of instance data to retrieve and returns a [can.Deferred]\nthat resolves to an array of those instances.</p>"}]},{"code":"can.Model.findAll: \"[METHOD] /path/to/resource\"","description":"<p>Implements <code>findAll</code> with a HTTP method and url to retrieve instance data.</p>\n\n<pre><code>findAll: \"GET /tasks\"\n</code></pre>\n\n<p>If <code>findAll</code> is implemented with a string, this gets converted to\na [can.Model.findAllData findAllData function]\nwhich is passed to [can.Model.makeFindAll makeFindAll] to create the external\n<code>findAll</code> method.</p>","params":[{"types":[{"type":"HttpMethod"}],"name":"METHOD","description":"<p>An HTTP method. Defaults to <code>\"GET\"</code>.</p>"},{"types":[{"type":"STRING"}],"name":"url","description":"<p>The URL of the service to retrieve JSON data.</p>"}],"returns":{"types":[{"type":"JSON"}],"description":"<p>The service should return a JSON object like:</p>\n\n<pre><code>{\n  \"data\": [\n    { \"id\" : 1, \"name\" : \"do the dishes\" },\n    { \"id\" : 2, \"name\" : \"mow the lawn\" },\n    { \"id\" : 3, \"name\" : \"iron my shirts\" }\n  ]\n}\n</code></pre>\n\n<p>This object is passed to [can.Model.models] to turn it into instances.</p>\n\n<p><em>Note: .findAll can also accept an array, but you\nprobably <a href=\"http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\">should not be doing that</a>.</em></p>"}},{"code":"can.Model.findAll: {ajaxSettings}","description":"<p>Implements <code>findAll</code> with a [can.AjaxSettings ajax settings object].</p>\n\n<pre><code>findAll: {url: \"/tasks\", dataType: \"json\"}\n</code></pre>\n\n<p>If <code>findAll</code> is implemented with an object, it gets converted to\na [can.Model.findAllData findAllData function]\nwhich is passed to [can.Model.makeFindAll makeFindAll] to create the external\n<code>findAll</code> method.</p>","params":[{"types":[{"type":"can.AjaxSettings"}],"name":"ajaxSettings","description":"<p>A settings object that\nspecifies the options available to pass to [can.ajax].</p>"}]}],"comment":" ","src":"can/model/doc/findAll.md","id":121},{"type":"function","name":"can.Model.findOne","description":"<p>Retrieve a resource from a server. </p>","title":"findOne","parent":"can.Model.static","signatures":[{"code":"can.Model.findOne( params[, success[, error]] )","description":"<p>Retrieve a single instance from the server.</p>","params":[{"types":[{"type":"Object","options":[]}],"name":"params","description":"<p>Values to filter the request or results with.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"can.Model"}],"name":"model"}]}],"optional":true,"name":"success","description":"<p>A callback to call on successful retrieval. The callback recieves\nthe retrieved resource as a can.Model.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"can.AjaxSettings"}],"name":"xhr"}]}],"optional":true,"name":"error","description":"<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"}],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"}},{"code":"can.Model.findOne: findOneData( params ) -> deferred","description":"<p>Implements <code>findOne</code> with a [can.Model.findOneData function]. This function\nis passed to [can.Model.makeFindOne makeFindOne] to create the external\n<code>findOne</code> method.</p>\n\n<pre><code>findOne: function(params){\n  return $.get(\"/task/\"+params.id)\n}\n</code></pre>","params":[{"types":[{"type":"can.Model.findOneData"}],"name":"findOneData","description":"<p>A function that accepts parameters\nspecifying an instance to retreive and returns a [can.Deferred]\nthat resolves to that instance.</p>"}]},{"code":"can.Model.findOne: \"[METHOD] /path/to/resource\"","description":"<p>Implements <code>findOne</code> with a HTTP method and url to retrieve an instance's data.</p>\n\n<pre><code>findOne: \"GET /tasks/{id}\"\n</code></pre>\n\n<p>If <code>findOne</code> is implemented with a string, this gets converted to\na [can.Model.makeFindOne makeFindOne function]\nwhich is passed to [can.Model.makeFindOne makeFindOne] to create the external\n<code>findOne</code> method.</p>","params":[{"types":[{"type":"HttpMethod"}],"name":"METHOD","description":"<p>An HTTP method. Defaults to <code>\"GET\"</code>.</p>"},{"types":[{"type":"STRING"}],"name":"url","description":"<p>The URL of the service to retrieve JSON data.</p>"}]},{"code":"can.Model.findOne: {ajaxSettings}","description":"<p>Implements <code>findOne</code> with a [can.AjaxSettings ajax settings object].</p>\n\n<pre><code>findOne: {url: \"/tasks/{id}\", dataType: \"json\"}\n</code></pre>\n\n<p>If <code>findOne</code> is implemented with an object, it gets converted to\na [can.Model.makeFindOne makeFindOne function]\nwhich is passed to [can.Model.makeFindOne makeFindOne] to create the external\n<code>findOne</code> method.</p>","params":[{"types":[{"type":"can.AjaxSettings"}],"name":"ajaxSettings","description":"<p>A settings object that\nspecifies the options available to pass to [can.ajax].</p>"}]}],"comment":" ","src":"can/model/doc/findOne.md","id":123},{"type":"property","name":"can.Model.id","description":"<p>The name of the id field.  Defaults to <code>'id'</code>. Change this if it is something different.</p>","types":[{"type":"String"}],"title":"id","parent":"can.Model.static","src":"can/model/doc/id.md","id":125},{"type":"property","name":"can.Model.static.List","description":"<p>Specifies the type of List that [can.Model.findAll findAll] should return.</p>","types":[{"type":"can.Model.List","description":"<p>A can.Model's List property is the\ntype of [can.List List] returned\nfrom [can.Model.findAll findAll]. For example:</p>\n\n<pre><code>Task = can.Model.extend({\n  findAll: \"/tasks\"\n},{})\n\nTask.findAll({}, function(tasks){\n  tasks instanceof Task.List //-&gt; true\n})\n</code></pre>\n\n<p>Overwrite a Model's <code>List</code> property to add custom\nbehavior to the lists provided to <code>findAll</code> like:</p>\n\n<pre><code>Task = can.Model.extend({\n  findAll: \"/tasks\"\n},{})\nTask.List = Task.List.extend({\n  completed: function(){\n    var count = 0;\n    this.each(function(task){\n      if( task.attr(\"completed\") ) count++;\n    })\n    return count;\n  }\n})\n\nTask.findAll({}, function(tasks){\n  tasks.completed() //-&gt; 3\n})\n</code></pre>\n\n<p>When [can.Model] is extended,\n[can.Model.List] is extended and set as the extended Model's\n<code>List</code> property. The extended list's [can.List.Map Map] property\nis set to the extended Model.  For example:</p>\n\n<pre><code>Task = can.Model.extend({\n  findAll: \"/tasks\"\n},{})\nTask.List.Map //-&gt; Task\n</code></pre>"}],"title":"List","parent":"can.Model.static","src":"can/model/doc/list.md","id":127},{"type":"function","name":"can.Model.makeFindAll","description":"","title":"","parent":"can.Model.static","signatures":[{"code":"can.Model.makeFindAll: function(findAllData) -> findAll","description":"<p>Returns the external <code>findAll</code> method given the implemented [can.Model.findAllData findAllData] function.</p>\n\n<p>[can.Model.findAll] is implemented with a <code>String</code>, [can.AjaxSettings ajax settings object], or\n[can.Model.findAllData findAllData] function. If it is implemented as\na <code>String</code> or [can.AjaxSettings ajax settings object], those values are used\nto create a [can.Model.findAllData findAllData] function.</p>\n\n<p>The [can.Model.findAllData findAllData] function is passed to <code>makeFindAll</code>. <code>makeFindAll</code>\nshould use <code>findAllData</code> internally to get the raw data for the request.</p>","params":[],"returns":{"types":[{"type":"function","returns":{"types":[{"type":"can.Deferred"}]},"params":[{"types":[{"type":"params"}]},{"types":[{"type":"success"}]},{"types":[{"type":"error"}]}]}],"description":"<p>Returns function that implements the external API of <code>findAll</code>.</p>"}}],"comment":" ","src":"can/model/doc/makeFindAll.md","id":128},{"type":"function","name":"can.Model.makeFindOne","description":"","title":"","parent":"can.Model.static","signatures":[{"code":"can.Model.makeFindOne: function(findOneData) -> findOne","description":"<p>Returns the external <code>findOne</code> method given the implemented [can.Model.findOneData findOneData] function.</p>\n\n<p>[can.Model.findOne] is implemented with a <code>String</code>, [can.AjaxSettings ajax settings object], or\n[can.Model.findOneData findOneData] function. If it is implemented as\na <code>String</code> or [can.AjaxSettings ajax settings object], those values are used\nto create a [can.Model.findOneData findOneData] function.</p>\n\n<p>The [can.Model.findOneData findOneData] function is passed to <code>makeFindOne</code>. <code>makeFindOne</code>\nshould use <code>findOneData</code> internally to get the raw data for the request.</p>","params":[],"returns":{"types":[{"type":"function","returns":{"types":[{"type":"can.Deferred"}]},"params":[{"types":[{"type":"params"}]},{"types":[{"type":"success"}]},{"types":[{"type":"error"}]}]}],"description":"<p>Returns function that implements the external API of <code>findOne</code>.</p>"}}],"comment":" ","src":"can/model/doc/makeFindOne.md","id":129},{"type":"function","name":"can.Model.parseModel","description":"<p>Convert raw data into an object that can be used to create a [can.Model] instance.</p>","title":"parseModel","parent":"can.Model.static","signatures":[{"code":"can.Model.parseModel( data, xhr )","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"data","description":"<p>The data to convert to a can.Model instance.</p>"},{"types":[{"type":"XMLHTTPRequest"}],"name":"xhr","description":"<p>The XMLHTTPRequest object used to make the request.</p>"}],"release":"2.1","returns":{"types":[{"type":"Object","options":[]}],"description":"<p>An object of properties to set at the [can.Model::attr attributes]\nof a model instance.</p>"}},{"code":"parseModel: \"PROPERTY\"","description":"<p>Creates a <code>parseModel</code> function that looks for the attributes object in the PROPERTY\nproperty of raw instance data.</p>","params":[]}],"comment":" ","src":"can/model/doc/parseModel.md","id":135},{"type":"function","name":"can.Model.parseModels","description":"<p>Convert raw xhr data into an array or object that can be used to create a [can.Model.List].</p>","title":"parseModels","parent":"can.Model.static","release":"2.1","signatures":[{"code":"can.Model.parseModels(data, xhr)","description":"","params":[{"types":[{"type":"*"}],"name":"data","description":"<p>The raw data from a <code>[can.Model.findAll findAll()]</code> request.</p>"},{"types":[{"type":"XMLHTTPRequest"}],"optional":true,"name":"xhr","description":"<p>The XMLHTTPRequest object used to make the request.</p>"}],"returns":{"types":[{"type":"Array"},{"type":"Object","options":[]}],"description":"<p>A JavaScript Object or Array that [can.Model.models]\ncan convert into the Model's List.</p>"}},{"code":"parseModels: \"PROPERTY\"","description":"<p>Creates a <code>parseModels</code> function that looks for the array of instance data in the PROPERTY\nproperty of the raw response data of [can.Model.findAll].</p>","params":[]}],"comment":" ","src":"can/model/doc/parseModels.md","id":136},{"type":"property","name":"can.Model.removeAttr","description":"<p>Sets whether model conversion should remove non existing attributes or merge with\nthe existing attributes. The default is <code>false</code>.\nFor example, if <code>Task.findOne({ id: 1 })</code> returns</p>","types":[{"type":"Boolean"}],"title":"removeAttr","parent":"can.Model.static","src":"can/model/doc/removeAttr.md","id":137},{"type":"property","name":"can.Model.resource","description":"<p>Define a restful resource URL. </p>","types":[{"type":"String","description":"<p>A string URL to a restful resource. If the resource\nis specified as <code>\"resource\"</code> and the model's [can.Model.id id] is\n<code>\"id\"</code>, resource will implement [can.Model]'s ajax methods as follows:</p>\n\n<ul>\n<li>[can.Model.findAll] - <code>\"GET resource\"</code></li>\n<li>[can.Model.findOne] - <code>\"GET resource/{id}\"</code></li>\n<li>[can.Model.create] - <code>\"POST resource\"</code></li>\n<li>[can.Model.update] - <code>\"PUT resource/{id}\"</code></li>\n<li>[can.Model.destroy] - <code>\"DELETE resource/{id}\"</code></li>\n</ul>\n\n<p>Setting the <code>resource</code> property will not overwrite other implemented\najax methods.</p>"}],"title":"resource","parent":"can.Model.static","comment":" ","src":"can/model/doc/resource.md","id":138},{"type":"function","name":"can.Model.setup","description":"<p>Configures</p>","hide":true,"title":"","parent":"can.Model.static","src":"can/model/doc/setup.md","params":[{"name":"base","types":[{"type":"*"}]},{"name":"fullName","types":[{"type":"*"}]},{"name":"staticProps","types":[{"type":"*"}]},{"name":"protoProps","types":[{"type":"*"}]}],"id":139},{"type":"function","name":"can.Model.unbind","description":"<p>Stop listening for events on a Model class. </p>","title":"unbind","parent":"can.Model.static","signatures":[{"code":"can.Model.unbind(eventType, handler)","description":"","params":[{"types":[{"type":"String"}],"name":"eventType","description":"<p>The type of event. It must be\n<code>\"created\"</code>, <code>\"updated\"</code>, <code>\"destroyed\"</code>.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>A callback function\nthat was passed to <code>bind</code>.</p>"}],"returns":{"types":[{"type":"can.Model"}],"description":"<p>The model constructor function.</p>"}}],"comment":" ","src":"can/model/doc/unbind.md","id":140},{"type":"function","name":"can.Model.update","description":"<p>Update a resource on the server. </p>","title":"update","parent":"can.Model.static","signatures":[{"code":"can.Model.update: \"[METHOD] /path/to/resource\"","description":"<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or PUT if none is specified) when updating an\ninstance on the server. (See below for more details.)</p>","params":[],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A Deferred that resolves to the updated model.</p>"}},{"code":"can.Model.update: function(id, serialized) -> can.Deffered","description":"<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>","params":[{"types":[{"type":"*"}],"name":"id","description":"<p>The ID of the model to update.</p>"},{"types":[{"type":"Object","options":[]}],"name":"serialized","description":"<p>The [can.Map::serialize serialized] properties of\nthe model to update.</p>"}],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A Deferred that resolves to the updated model.</p>"}}],"comment":" ","src":"can/model/doc/update.md","id":141}]},{"type":"prototype","description":"","name":"can.Model.prototype","parent":"can.Model","src":"can/model/model.js","line":1357,"id":321,"children":[{"type":"function","name":"can.Model.prototype.isNew","description":"<p>Check if a Model has yet to be saved on the server. </p>","title":"isNew","signatures":[{"code":"model.isNew()","description":"","params":[],"returns":{"types":[{"type":"Boolean"}],"description":"<p>Whether an instance has been saved on the server.\n(This is determined by whether <code>id</code> has a value set yet.)</p>"}}],"comment":" ","src":"can/model/doc/isNew.md","parent":"can.Model.prototype","id":126},{"type":"function","name":"can.Model.prototype.bind","description":"<p>Listen to events on this Model. </p>","title":"bind","signatures":[{"code":"model.bind(eventName, handler)","description":"","params":[{"types":[{"type":"String"}],"name":"eventName","description":"<p>The event to bind to.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The function to call when the\nevent occurs. <strong>handler</strong> is passed the event and the\nModel instance.</p>"}],"returns":{"types":[{"type":"can.Model"}],"description":"<p>The Model, for chaining.</p>"}}],"comment":" ","src":"can/model/doc/model_bind.md","parent":"can.Model.prototype","id":131},{"type":"function","name":"can.Model.prototype.destroy","description":"<p>Destroy a Model on the server. </p>","title":"destroy","signatures":[{"code":"model.destroy([success[, error]])","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"success","description":"<p>A callback to call on successful destruction. The callback recieves\nthe can.Model as it was just prior to destruction.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"error","description":"<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"}],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A Deferred that resolves to the Model as it was before destruction.</p>"}}],"comment":" ","src":"can/model/doc/model_destroy.md","parent":"can.Model.prototype","id":132},{"type":"function","name":"can.Model.prototype.save","description":"<p>Save a model back to the server. </p>","title":"save","signatures":[{"code":"model.save([success[, error]])","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"success","description":"<p>A callback to call on successful save. The callback recieves\nthe can.Model after saving.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"error","description":"<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"}],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A Deferred that resolves to the Model after it has been saved.</p>"}}],"comment":" ","src":"can/model/doc/model_save.md","parent":"can.Model.prototype","id":133},{"type":"function","name":"can.Model.prototype.unbind","description":"<p>Stop listening to events on this Model. </p>","title":"unbind","signatures":[{"code":"model.unbind(eventName[, handler])","description":"","params":[{"types":[{"type":"String"}],"name":"eventName","description":"<p>The event to unbind from.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"handler","description":"<p>A handler previously bound with <code>bind</code>.\nIf <strong>handler</strong> is not passed, <code>unbind</code> will remove all handlers\nfor the given event.</p>"}],"returns":{"types":[{"type":"can.Model"}],"description":"<p>The Model, for chaining.</p>"}}],"comment":" ","src":"can/model/doc/model_unbind.md","parent":"can.Model.prototype","id":134}]}]},{"type":"constructor","name":"can.Model.List","description":"<p>A list connected to can.Model's CRUD abilities. </p>","title":"","inherits":"can.List","parent":"canjs","download":"can/model","test":"can/model/qunit.html","signatures":[{"code":"new can.Model.List( [models] )","description":"<p>Create a model list with the provided model instances.</p>","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"can.Model"},{"type":"Object","options":[]}]}]}],"optional":true,"name":"models","description":"<p>An array of [can.Model] instances\nor Objects that will be converted to the list's [can.List.Map Map type].</p>"}]},{"code":"new can.Model.List( params )","description":"<p>Create an initially empty model list, but use the model's [can.Model.findAll findAll]\nto get a list of models and add it to this empty list.</p>","params":[{"types":[{"type":"Object","options":[]}],"name":"params","description":"<p>Params that are passed to \nthe [can.List.Map Map property's] [can.Model.findAll findAll] method.</p>"}]}],"comment":" ","src":"can/model/model_list.md","id":142},{"type":"function","name":"can.route","description":"<p>Manage browser history and client state by synchronizing the window.location.hash with\nan [can.Map].</p>","title":"can.route","inherits":"can.Map","download":"can/route","test":"can/route/test.html","parent":"canjs","links":[{"href":"../docco/route/route.html","title":"docco"}],"signatures":[{"code":"can.route( template [, defaults] )","description":"<p>Create a route matching rule.</p>","params":[{"types":[{"type":"String"}],"name":"template","description":"<p>the fragment identifier to match.  The fragment identifier\nshould start with either a character (a-Z) or colon (:).  Examples:</p>\n\n<pre><code>can.route(\":foo\")\ncan.route(\"foo/:bar\")\n</code></pre>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"defaults","description":"<p>an object of default values</p>"}],"returns":{"types":[{"type":"can.route"}],"description":""}}],"comment":" ","src":"can/route/route.md","id":152,"children":[{"name":"can.route.static","title":"static","type":"group","parent":"can.route","description":"","order":0,"id":150,"children":[{"type":"function","name":"can.route.map","description":"<p>Assign a can.Map instance that acts as can.route's internal can.Map.  The purpose for this is to cross-bind a top level state object (Application State) to the can.route.</p>","title":"map","parent":"can.route.static","signatures":[{"code":"can.route.map(mapConstructor)","description":"","params":[{"types":[{"type":"can.Map"}],"name":"mapConstructor","description":"<p>A can.Map constructor function.  A new can.Map instance will be created and used as the can.Map internal to can.route.</p>"}]},{"code":"can.route.map(mapInstance)","description":"","params":[{"types":[{"type":"can.Map"}],"name":"mapInstance","description":"<p>A can.Map instance, used as the can.Map internal to can.route.</p>"}]}],"comment":" ","src":"can/route/docs/map.md","id":147},{"type":"function","name":"can.route.param","parent":"can.route.static","description":"<p>Get a route path from given data. </p>","title":"param","signatures":[{"code":"can.route.param( data )","description":"","params":[{"types":[{"type":"data"}],"name":"object","description":"<p>The data to populate the route with.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The route, with the data populated in it.</p>"}}],"comment":" ","src":"can/route/route.js","line":168,"id":329},{"type":"function","name":"can.route.deparam","parent":"can.route.static","description":"<p>Extract data from a route path. </p>","title":"deparam","signatures":[{"code":"can.route.deparam( url )","description":"","params":[{"types":[{"type":"String"}],"name":"url","description":"<p>A route fragment to extract data from.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>An object containing the extracted data.</p>"}}],"comment":" ","src":"can/route/route.js","line":256,"id":330},{"type":"function","name":"can.route.ready","parent":"can.route.static","description":"<p>Initialize can.route.</p>","title":"ready","signatures":[{"code":"can.route.ready()","description":"<p>Sets up the two-way binding between the hash and the can.route observable map and\nsets the can.route map to its initial values.</p>","params":[],"returns":{"types":[{"type":"can.route"}],"description":"<p>The <code>can.route</code> object.</p>"}}],"comment":" ","src":"can/route/route.js","line":380,"id":333},{"type":"function","name":"can.route.url","parent":"can.route.static","description":"","title":"url","signatures":[{"code":"can.route.url( data [, merge] )","description":"<p>Make a URL fragment that when set to window.location.hash will update can.route's properties\nto match those in <code>data</code>.</p>","params":[{"types":[{"type":"Object","options":[]}],"name":"data","description":"<p>The data to populate the route with.</p>"},{"types":[{"type":"Boolean"}],"optional":true,"name":"merge","description":"<p>Whether the given options should be merged into the current state of the route.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The route URL and query string.</p>"}}],"comment":" ","src":"can/route/route.js","line":410,"id":334},{"type":"function","name":"can.route.link","parent":"can.route.static","description":"","title":"link","signatures":[{"code":"can.route.link( innerText, data, props [, merge] )","description":"<p>Make an anchor tag (<code>&lt;A&gt;</code>) that when clicked on will update can.route's properties\nto match those in <code>data</code>.</p>","params":[{"types":[{"type":"Object","options":[]}],"name":"innerText","description":"<p>The text inside the link.</p>"},{"types":[{"type":"Object","options":[]}],"name":"data","description":"<p>The data to populate the route with.</p>"},{"types":[{"type":"Object","options":[]}],"name":"props","description":"<p>Properties for the anchor other than <code>href</code>.</p>"},{"types":[{"type":"Boolean"}],"optional":true,"name":"merge","description":"<p>Whether the given options should be merged into the current state of the route.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>A string with an anchor tag that points to the populated route.</p>"}}],"comment":" ","src":"can/route/route.js","line":445,"id":335},{"type":"function","name":"can.route.current","parent":"can.route.static","description":"","title":"current","signatures":[{"code":"can.route.current( data )","description":"<p>Check if data represents the current route.</p>","params":[{"types":[{"type":"Object","options":[]}],"name":"data","description":"<p>Data to check agains the current route.</p>"}],"returns":{"types":[{"type":"Boolean"}],"description":"<p>Whether the data matches the current URL.</p>"}}],"comment":" ","src":"can/route/route.js","line":495,"id":336}]},{"name":"can.route.plugins","title":"plugins","type":"group","parent":"can.route","description":"","order":0,"id":151,"children":[{"type":"property","name":"can.route.pushstate","description":"<p>Changes [can.route] to use <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history\">pushstate</a>\nto change the window's <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.pathname\">pathname</a> instead\nof the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.hash\">hash</a>.</p>","types":[{"type":"Object","options":[],"description":"<p>The pushstate object comprises several properties that configure the behavior of [can.route] to work with <code>history.pushstate</code>.</p>"}],"title":"","download":"can/route/pushstate","test":"can/route/pushstate/test.html","parent":"can.route.plugins","links":[{"href":"../docco/route/pushstate/pushstate.html","title":"docco"}],"comment":" ","src":"can/route/pushstate/pushstate.md","id":149}]}]},{"type":"function","name":"can.fixture","description":"<p>Simulate AJAX requests. </p>\n\n<blockquote>\n  <p>Note: can.fixture depends on the can.object plugin. If you are not using the AMD or Steal version of CanJS you need to include <a href=\"http://canjs.com/release/latest/can.object.js\">can.object.js</a> <strong>before</strong> can.fixture.</p>\n</blockquote>","title":"can.fixture","parent":"canjs","test":"can/util/fixture/test.html","signatures":[{"code":"can.fixture( url, toUrl )","description":"<p>Trap requests from one url and redirect them from another.</p>","params":[{"types":[{"type":"String"}],"name":"url","description":"<p>Trap requests made by [can.ajax] to this url.</p>"},{"types":[{"type":"String"},{"type":"null"}],"name":"toUrl","description":"<p>Redirect requests to this url. If <code>null</code> is provided,\nthis removes a the fixture at <code>url</code>.</p>"}]},{"code":"can.fixture( url, handler(request, response, requestHeaders) )","description":"<p>Trap requests to a url and provide the response with a\ncallback function.</p>","params":[{"types":[{"type":"String"}],"name":"url","description":"<p>Trap requests made \nby [can.ajax] to this url. </p>\n\n<p>The url can be templated with tags that\nlook like <code>{TEMPLATE}</code>. For example: \"/users/{id}\". Any templated\nvalues get added to the <code>handler</code>'s request object's data.</p>"},{"types":[{"type":"can.fixture.types.requestHandler"}],"name":"handler","description":"<p>Specifies the response of the fixture. <code>handler</code> gets called with\nthe [can.ajax] [can.AjaxSettings settings object] and a [can.fixture.types.responseHandler response handler]\nthat is used to specify the response.</p>"}]},{"code":"can.fixture(fixtures)","description":"<p>Configures multiple ajax traps.</p>","params":[{"types":[{"type":"Object","template":[{"types":[{"type":"url"}]},{"types":[{"type":"can.fixture.types.requestHandler"},{"type":"String"}]}]}],"name":"fixtures","description":"<p>An mapping of templated urls to redirect urls\nor [can.fixture.types.requestHandler request handler functions].</p>\n\n<pre><code>can.fixture({\n  \"/tasks\": \"/fixtures/tasks.json\",\n  \"DELETE /tasks/{id}\": function(){\n      return {};\n  }\n})\n</code></pre>"}]}],"comment":" ","src":"can/util/fixture/doc/fixture.md","id":167,"children":[{"type":"property","name":"can.fixture.delay","description":"<p><code>can.fixture.delay</code> indicates the delay in milliseconds between an ajax request is made and\nthe success and complete handlers are called.  This only sets\nfunctional synchronous fixtures that return a result. By default, the delay is 200ms.</p>","types":[{"type":"Number"}],"title":"delay","parent":"can.fixture","src":"can/util/fixture/doc/delay.md","id":161},{"name":"can.fixture.types","title":"Types","type":"group","parent":"can.fixture","description":"","order":0,"id":166,"children":[{"type":"typedef","name":"can.fixture.types.requestHandler","description":"<p>Specifies the response of a fixture. Used in [can.fixture]. </p>","title":"requestHandler","types":[{"type":"function","returns":{"types":[{"type":"*"},{"type":"undefined"}],"description":"<p>If a value is returned, it is used as a JSON\nresponse body. If nothing is returned, it's expected that <code>responseHandler</code>\nwas used.</p>"},"params":[{"types":[{"type":"can.AjaxSettings"}],"name":"request","description":"<p>The ajax settings object that\nwas passed to [can.ajax] or a jQuery ajax method.  Any templated\nportions of the url passed to [can.fixture] are added as\ndata to <code>request.data</code>.  For example, calling:</p>\n\n<pre><code>$.get(\"/todos/5\");\n</code></pre>\n\n<p>With the following fixture:</p>\n\n<pre><code>can.fixture(\"/todos/:id\", function(request, response){ })\n</code></pre>\n\n<p><code>request.data.id</code> will be <code>5</code>.</p>"},{"types":[{"type":"can.fixture.types.responseHandler"}],"optional":true,"name":"response","description":"<p>Optionally called to specify the response of the fixture.</p>"},{"types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"String"}]}]}],"name":"requestHeaders","description":"<p>A map of request headers specified by [can.ajax]'s headers property.</p>"}]}],"parent":"can.fixture.types","comment":" ","src":"can/util/fixture/doc/requestHandler.md","id":170},{"type":"typedef","name":"can.fixture.types.responseHandler","description":"<p>Specifies the response of an AJAX request. </p>","title":"responseHandler","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"Number"}],"name":"status"},{"types":[{"type":"String"}],"name":"statusText"},{"types":[{"type":"Object","template":[{"types":[{"type":"typeName"}]},{"types":[{"type":"*"}]}]}],"name":"responses"},{"types":[{"type":"headers"}],"name":"headers"}]}],"parent":"can.fixture.types","signatures":[{"code":"response(status [,statusText], responses, headers)","description":"<p>Specify a HTTP response.</p>","params":[{"types":[{"type":"Number"}],"name":"status","description":"<p>The <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\">HTTP response code</a>. Ex: <code>200</code>.</p>"},{"types":[{"type":"String"}],"optional":true,"name":"statusText","description":"<p>the status text of the response. Ex: \"success\"\nfor 200.</p>"},{"types":[{"type":"Object","template":[{"types":[{"type":"typeName"}]},{"types":[{"type":"*"}]}]}],"name":"responses","description":"<p>An object of responses by type.  For example:</p>\n\n<pre><code>{\n  text: \"{\\\"age\\\":5}\"\n}\n</code></pre>\n\n<p>If responses does not have a <code>typeName</code> property for the type of request, the\nentire responses object is used as the response data.</p>"},{"types":[{"type":"Object","template":[{"types":[{"type":"headerName"}]},{"types":[{"type":"String"}]}]}],"name":"headers","description":"<p>HTTP response headers and values.</p>"}]},{"code":"response(responses)","description":"<p>Specify the body of a successful HTTP response.</p>","params":[{"types":[{"type":"Object","template":[{"types":[{"type":"typeName"}]},{"types":[{"type":"*"}]}]}],"name":"responses","description":"<p>An object of responses by type.  For example:</p>\n\n<pre><code>{\n  text: \"{\\\"age\\\":5}\"\n}\n</code></pre>\n\n<p>If responses does not have a <code>typeName</code> property for the type of request, the\nentire responses object is used as the response data.</p>"}]}],"src":"can/util/fixture/doc/responseHandler.md","id":172},{"type":"typedef","name":"can.fixture.types.Store","description":"<p>Contains an array of items and methods for \nfinding, adding, updating, and removing items from the store. Many of those\nmethods are designed to work with <code>can.fixture</code> and simulate [can.Model]'s CRUD\nbehavior.</p>","title":"Store","parent":"can.fixture.types","src":"can/util/fixture/doc/storeTypes.md","id":175,"children":[{"type":"function","name":"can.fixture.types.Store.create","description":"<p>Simulate creating a Model with a fixture. </p>","title":"","parent":"can.fixture.types.Store","signatures":[{"code":"store.create(request, callback)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"request","description":"<p>Parameters for the request.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"callback","description":"<p>A function to call with the created item.</p>"}]}],"comment":" ","src":"can/util/fixture/doc/create.md","id":160},{"type":"function","name":"can.fixture.types.Store.destroy","description":"<p>Simulate destroying a Model on a fixture. </p>","title":"","parent":"can.fixture.types.Store","signatures":[{"code":"store.destroy(request, callback)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"request","description":"<p>Parameters for the request.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"callback","description":"<p>A function to call after destruction.</p>"}]}],"comment":" ","src":"can/util/fixture/doc/destroy.md","id":162},{"type":"function","name":"can.fixture.types.Store.find","description":"<p>Get an item from the store by ID. </p>","title":"","parent":"can.fixture.types.Store","signatures":[{"code":"store.find(settings)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"settings","description":"<p>An object containing an <code>id</code> key corresponding to the item to find.</p>"}]}],"comment":" ","src":"can/util/fixture/doc/find.md","id":163},{"type":"function","name":"can.fixture.types.Store.findAll","description":"<p>Simulate a findAll to a fixture. </p>","title":"","parent":"can.fixture.types.Store","signatures":[{"code":"store.findAll(request)","description":"<p><code>store.findAll(request)</code> simulates a request to\nget a list items from the server. It supports the\nfollowing params:</p>\n\n<ul>\n<li>order - <code>order=name ASC</code></li>\n<li>group - <code>group=name</code></li>\n<li>limit - <code>limit=20</code></li>\n<li>offset - <code>offset=60</code></li>\n<li>id filtering - <code>ownerId=5</code></li>\n</ul>","params":[{"types":[{"type":"Object","options":[{"name":"order","description":"<p>The order of the results.\n<code>order: 'name ASC'</code></p>","types":[{"type":"String"}]},{"name":"group","description":"<p>How to group the results.\n<code>group: 'name'</code></p>","types":[{"type":"String"}]},{"name":"limit","description":"<p>A limit on the number to retrieve.\n<code>limit: 20</code></p>","types":[{"type":"String"}]},{"name":"offset","description":"<p>The offset of the results.\n<code>offset: 60</code></p>","types":[{"type":"String"}]},{"name":"id","description":"<p>Filtering by ID.\n<code>id: 5</code></p>","types":[{"type":"String"}]}]}],"name":"request","description":"<p>The ajax request object. The available parameters are:</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>a response object like:</p>\n\n<pre><code>{\n    count: 1000,\n    limit: 20,\n    offset: 60,\n    data: [item1, item2, ...]\n}\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li>count - the number of items that match any filtering before limit and offset is taken into account</li>\n<li>offset - the offset passed</li>\n<li>limit - the limit passed</li>\n<li>data - an array of JS objects with each item's properties</li>\n</ul>"}}],"types":[],"src":"can/util/fixture/doc/findAll.md","id":164},{"type":"function","name":"can.fixture.types.Store.findOne","description":"<p>Simulate a findOne request on a fixture. </p>","title":"","parent":"can.fixture.types.Store","signatures":[{"code":"store.findOne(request, response)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"request","description":"<p>Parameters for the request.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"response","description":"<p>A function to call with the retrieved item.</p>"}]}],"comment":" ","src":"can/util/fixture/doc/findOne.md","id":165},{"type":"function","name":"can.fixture.types.Store.reset","description":"<p>Reset the fixture store. </p>","title":"","parent":"can.fixture.types.Store","signatures":[{"code":"store.reset()","description":"","params":[]}],"comment":" ","src":"can/util/fixture/doc/reset.md","id":171},{"type":"function","name":"can.fixture.types.Store.update","description":"<p>Simulate an update on a fixture. </p>","title":"","parent":"can.fixture.types.Store","signatures":[{"code":"store.update(request, callback)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"request","description":"<p>Parameters for the request.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"callback","description":"<p>A function to call with the updated item and headers.</p>"}]}],"comment":" ","src":"can/util/fixture/doc/update.md","id":176}]}]},{"type":"property","name":"can.fixture.on","description":"<p><code>can.fixture.on</code> lets you programatically turn off fixtures. This is mostly used for testing.</p>","types":[{"type":"Boolean"}],"title":"on","parent":"can.fixture","src":"can/util/fixture/doc/on.md","id":168},{"type":"function","name":"can.fixture.rand","description":"<p>Create a random number or selection. </p>","title":"rand","parent":"can.fixture","signatures":[{"code":"can.fixture.rand([min,] max)","description":"","params":[{"types":[{"type":"Number"}],"optional":true,"name":"min","defaultValue":"0","description":"<p>The lower bound on integers to select.</p>"},{"types":[{"type":"Number"}],"name":"max","description":"<p>The upper bound on integers to select.</p>"}],"returns":{"types":[{"type":"Number"}],"description":"<p>A random integer in the range [<strong>min</strong>, <strong>max</strong>).</p>"}},{"code":"can.fixture.rand(choices, min[ ,max])","description":"","params":[{"types":[{"type":"Array","options":[]}],"name":"choices","description":"<p>An array of things to choose from.</p>"},{"types":[{"type":"Number"}],"name":"min","description":"<p>The minimum number of times to choose from <strong>choices</strong>.</p>"},{"types":[{"type":"Number"}],"optional":true,"name":"max","defaultValue":"min","description":"<p>The maximum number of times to choose from <strong>choices</strong>.</p>"}],"returns":{"types":[{"type":"Array","options":[]}],"description":"<p>An array of between <strong>min</strong> and <strong>max</strong> random choices from <strong>choices</strong>.</p>"}}],"comment":" ","src":"can/util/fixture/doc/rand.md","id":169},{"type":"property","name":"can.fixture.rootUrl","description":"<p><code>can.fixture.rootUrl</code> contains the root URL for fixtures to use.\nIf you are using StealJS it will use the Steal root\nURL by default.</p>","types":[{"type":"String"}],"title":"rootUrl","parent":"can.fixture","src":"can/util/fixture/doc/rootUrl.md","id":173},{"type":"function","name":"can.fixture.store","description":"<p>Make a store of objects to use when making requests against fixtures. </p>","title":"store","parent":"can.fixture","signatures":[{"code":"can.fixture.store(count, make[, filter])","description":"","params":[{"types":[{"type":"Number"}],"name":"count","description":"<p>The number of items to create.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"make","description":"<p>A function that will return the JavaScript object. The\nmake function is called back with the id and the current array of items.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"filter","description":"<p>A function used to further filter results. Used for to simulate\nserver params like searchText or startDate.\nThe function should return true if the item passes the filter,\nfalse otherwise. For example:</p>\n\n<pre><code>function(item, settings){\n    if(settings.data.searchText){\n        var regex = new RegExp(\"^\"+settings.data.searchText)\n        return regex.test(item.name);\n    }\n}\n</code></pre>"}],"returns":{"types":[{"type":"can.fixture.Store"}],"description":"<p>A generator object providing fixture functions for <em>findAll</em>, <em>findOne</em>, <em>create</em>, <em>update</em> and <em>destroy</em>.</p>"}}],"comment":" ","src":"can/util/fixture/doc/store.md","id":174}]},{"type":"page","name":"can.util","description":"<p>Utility methods supported by CanJS</p>","title":"can.util","parent":"canjs","src":"can/util/util.md","id":178,"children":[{"type":"page","name":"can.batch","description":"","parent":"can.util","src":"can/util/batch/batch.md","id":153,"children":[{"type":"function","name":"can.batch.start","parent":"can.batch","description":"<p>Begin an event batch. </p>","title":"","signatures":[{"code":"can.batch.start([batchStopHandler])","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"batchStopHandler","description":"<p>a callback that gets called after all batched events have been called</p>"}]}],"comment":" ","src":"can/util/batch/batch.js","line":10,"id":469},{"type":"function","name":"can.batch.stop","parent":"can.batch","description":"<p>End an event batch. </p>","title":"","signatures":[{"code":"can.batch.stop([force[, callStart]])","description":"","params":[{"types":[{"type":"bool"}],"optional":true,"name":"force","defaultValue":"false","description":"<p>whether to stop batching events immediately</p>"},{"types":[{"type":"bool"}],"optional":true,"name":"callStart","defaultValue":"false","description":"<p>whether to call <code>[can.batch.start can.batch.start]</code> after firing batched events</p>"}]}],"comment":" ","src":"can/util/batch/batch.js","line":114,"id":470},{"type":"function","name":"can.batch.trigger","parent":"can.batch","description":"<p>Trigger an event to be added to the current batch. </p>","title":"","signatures":[{"code":"can.batch.trigger(item, event [, args])","description":"","params":[{"types":[{"type":"can.Map"}],"name":"item","description":"<p>the target of the event</p>"},{"types":[{"type":"String"},{"type":"Object","options":[{"name":"type","types":[{"type":"String"}]}]}],"name":"event","description":"<p>the type of event, or an event object with a type given</p>"},{"types":[{"type":"Array","options":[]}],"optional":true,"name":"args","description":"<p>the parameters to trigger the event with.</p>"}]}],"comment":" ","src":"can/util/batch/batch.js","line":187,"id":471}]},{"type":"function","name":"can.frag","description":"<p>Convert various objects into a documentFragment.</p>","title":"","parent":"can.util","params":[{"types":[{"type":"String"},{"type":"HTMLElement"},{"type":"documentFragment"},{"type":"can.contentArray"}],"name":"item","description":""}],"returns":{"types":[{"type":"documentFragment"}],"description":""},"comment":" ","src":"can/util/doc/frag.md","id":155},{"type":"page","name":"can.events","description":"<p>CanJS adds the following DOM events to the base library:</p>","parent":"can.util","src":"can/util/events/events.md","id":157,"children":[{"type":"typedef","name":"can.events.attributes","description":"<p>The event object dispatched when an attribute changes on an element.</p>","title":"","types":[{"type":"Object","options":[{"name":"attributeName","description":"<p>The name of the attribute that was changed.</p>","types":[{"type":"String"}]},{"name":"oldValue","description":"<p>The old value of the attribute.</p>","types":[{"type":"String"}]},{"name":"target","description":"<p>The attribute that changed.</p>","types":[{"type":"HTMLElement"}]},{"name":"type","description":"<p>The type is always \"attributes\" for an attributes event.</p>","types":[{"type":"String"}],"optional":true,"defaultValue":"\"attributes\""},{"name":"bubbles","description":"<p>Attributes events do not bubble.</p>","types":[{"type":"Boolean"}],"optional":true,"defaultValue":"false"}]}],"parent":"can.events","release":"2.1","comment":" ","src":"can/util/events/attributes.md","id":156},{"type":"typedef","name":"can.events.inserted","description":"<p>The event object dispatched when an element is inserted into the document.</p>","title":"","types":[{"type":"Object","options":[{"name":"target","description":"<p>The attribute that changed.</p>","types":[{"type":"HTMLElement"}]},{"name":"type","description":"<p>The type is always \"inserted\" for an inserted event.</p>","types":[{"type":"String"}],"optional":true,"defaultValue":"\"inserted\""},{"name":"bubbles","description":"<p>Inserted events do not bubble.</p>","types":[{"type":"Boolean"}],"optional":true,"defaultValue":"false"}]}],"parent":"can.events","release":"2.0","comment":" ","src":"can/util/events/inserted.md","id":158},{"type":"typedef","name":"can.events.removed","description":"<p>The event object dispatched when an element is removed from the document.</p>","title":"","types":[{"type":"Object","options":[{"name":"target","description":"<p>The attribute that changed.</p>","types":[{"type":"HTMLElement"}]},{"name":"type","description":"<p>The type is always \"removed\" for an removed event.</p>","types":[{"type":"String"}],"optional":true,"defaultValue":"\"removed\""},{"name":"bubbles","description":"<p>Removed events do not bubble.</p>","types":[{"type":"Boolean"}],"optional":true,"defaultValue":"false"}]}],"parent":"can.events","release":"2.0","comment":" ","src":"can/util/events/removed.md","id":159}]},{"description":"<p>Check if an object is a Deferred. </p>","title":"","name":"can.isDeferred","type":"function","parent":"can.util","signatures":[{"code":"can.isDeferred(subject)","description":"","params":[{"types":[{"type":"*"}],"name":"subject","description":"<p>The object to check.</p>"}],"returns":{"types":[{"type":"Boolean"}],"description":"<p>Whether <strong>subject</strong> is a Deferred.</p>"}}],"comment":" ","src":"can/util/func.js","line":0,"id":377},{"description":"<p>Trim whitespace off a string. </p>","title":"","name":"can.trim","type":"function","parent":"can.util","signatures":[{"code":"can.trim(str)","description":"","params":[{"types":[{"type":"String"}],"name":"str","description":"<p>The string to trim.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The trimmed string.</p>"}}],"comment":" ","src":"can/util/func.js","line":19,"id":378},{"description":"<p>Convert an array-like object to an Array. </p>","title":"","name":"can.makeArray","type":"function","parent":"can.util","signatures":[{"code":"can.makeArray(arrLike)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"arrLike","description":"<p>An array-like object.</p>"}],"returns":{"types":[{"type":"Array","options":[]}],"description":"<p>The converted object.</p>"}}],"comment":" ","src":"can/util/func.js","line":35,"id":379},{"description":"<p>Check if an object is an array. </p>","title":"","name":"can.isArray","type":"function","parent":"can.util","signatures":[{"code":"can.isArray(obj)","description":"","params":[{"types":[{"type":"*"}],"name":"obj","description":"<p>The object to check.</p>"}],"returns":{"types":[{"type":"Boolean"}],"description":"<p>Whether <strong>obj</strong> is an Array.</p>"}}],"comment":" ","src":"can/util/func.js","line":49,"id":380},{"description":"<p>Iterate through an array or object. </p>","title":"","name":"can.each","type":"function","parent":"can.util","signatures":[{"code":"can.each(collection, callback)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"collection","description":"<p>The object to iterate through.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"callback","description":"<p>A function to call for each item in <strong>collection</strong>.\n<strong>callback</strong> will recieve the item's value first and its key second.</p>"}]}],"comment":" ","src":"can/util/func.js","line":69,"id":381},{"description":"<p>Merge objects together. </p>","title":"","name":"can.extend","type":"function","parent":"can.util","signatures":[{"code":"can.extend(target, ...obj)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"target","description":"<p>The object to merge properties into.</p>"},{"types":[{"type":"Object","options":[]}],"name":"obj","description":"<p>Objects containing properties to merge.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p><strong>target</strong>, post-merge.</p>"}}],"comment":" ","src":"can/util/func.js","line":91,"id":382},{"description":"<p>Serialize an object into a query string. </p>","title":"","name":"can.param","type":"function","parent":"can.util","signatures":[{"code":"can.param(obj)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"obj","description":"<p>An array or object to serialize.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The serialized string.</p>"}}],"comment":" ","src":"can/util/func.js","line":115,"id":383},{"description":"<p>Takes a string of name value pairs and returns a Object literal that represents those params. </p>","title":"","name":"can.deparam","type":"function","parent":"can.util","signatures":[{"code":"can.deparam(params)","description":"","params":[{"types":[{"type":"String"}],"name":"params","description":"<p>A string like <code>\"foo=bar&amp;person[age]=3\"</code></p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>A JavaScript Object that represents the params:</p>\n\n<pre><code>{\n  foo: \"bar\",\n  person: {\n    age: \"3\"\n  }\n}\n</code></pre>"}}],"comment":" ","src":"can/util/func.js","line":130,"id":384},{"description":"<p>Check if an object has no properties. </p>","title":"","name":"can.isEmptyObject","type":"function","parent":"can.util","signatures":[{"code":"can.isEmptyObject(obj)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"obj","description":"<p>The object to check.</p>"},{"types":[{"type":"Boolean"}],"name":"Whether","description":"<p>the object is empty.</p>"}]}],"comment":" ","src":"can/util/func.js","line":150,"id":385},{"description":"<p>Bind a function to its context. </p>","title":"","name":"can.proxy","type":"function","parent":"can.util","signatures":[{"code":"can.proxy(fn, context)","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"fn","description":"<p>The function to bind to a context.</p>"},{"types":[{"type":"Object","options":[]}],"name":"context","description":"<p>The context to bind the function to.</p>"}],"returns":{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"description":"<p>A function that calls <strong>fn</strong> in the context of <strong>context</strong>.</p>"}}],"comment":" ","src":"can/util/func.js","line":166,"id":386},{"description":"<p>Check if an Object is a function. </p>","title":"","name":"can.isFunction","type":"function","parent":"can.util","signatures":[{"code":"can.isFunction(obj)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"obj","description":"<p>The object to check.</p>"}],"returns":{"types":[{"type":"Boolean"}],"description":"<p>Whether <strong>obj</strong> is a function.</p>"}}],"comment":" ","src":"can/util/func.js","line":187,"id":387},{"description":"<p>Listen for events on an object. </p>","title":"","name":"can.bind","type":"function","parent":"can.util","signatures":[{"code":"can.bind.call(target, eventName, handler)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"target","description":"<p>The object that emits events.</p>"},{"types":[{"type":"String"}],"name":"eventName","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The function to execute when the event occurs.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>The <strong>target</strong>.</p>"}}],"comment":" ","src":"can/util/func.js","line":203,"id":388},{"description":"<p>Listen for events on an object. </p>","title":"","name":"can.on","type":"function","parent":"can.util","signatures":[{"code":"can.on.call(target, eventName, handler)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"target","description":"<p>The object that emits events.</p>"},{"types":[{"type":"String"}],"name":"eventName","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The function to execute when the event occurs.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>The <strong>target</strong>.</p>"}}],"comment":" ","src":"can/util/func.js","line":245,"id":389},{"description":"<p>Stop listening for events on an object. </p>","title":"","name":"can.unbind","type":"function","parent":"can.util","signatures":[{"code":"can.unbind.call(target, eventName, handler)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"target","description":"<p>The object that emits events.</p>"},{"types":[{"type":"String"}],"name":"eventName","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The function to unbind.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>The <strong>target</strong>.</p>"}}],"comment":" ","src":"can/util/func.js","line":284,"id":390},{"description":"<p>Stop listening for events on an object. </p>","title":"","name":"can.off","type":"function","parent":"can.util","signatures":[{"code":"can.off.call(target, eventName, handler)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"target","description":"<p>The object that emits events.</p>"},{"types":[{"type":"String"}],"name":"eventName","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The function to unbind.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>The <strong>target</strong>.</p>"}}],"comment":" ","src":"can/util/func.js","line":330,"id":391},{"description":"<p>Listen for events from the children of an element. </p>","title":"","name":"can.delegate","type":"function","parent":"can.util","signatures":[{"code":"can.delegate.call(element, selector, eventName, handler)","description":"","params":[{"types":[{"type":"HTMLElement"}],"name":"element","description":"<p>The HTML element to bind to.</p>"},{"types":[{"type":"String"}],"name":"selector","description":"<p>A selector for delegating downward.</p>"},{"types":[{"type":"String"}],"name":"eventName","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The function to execute when the event occurs.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>The <strong>element</strong>.</p>"}}],"comment":" ","src":"can/util/func.js","line":376,"id":392},{"description":"<p>Stop listening for events from the children of an element. </p>","title":"","name":"can.undelegate","type":"function","parent":"can.util","signatures":[{"code":"can.undelegate.call(element, selector, eventName, handler)","description":"","params":[{"types":[{"type":"HTMLElement"}],"name":"element","description":"<p>The HTML element to unbind from.</p>"},{"types":[{"type":"String"}],"name":"selector","description":"<p>A selector for delegating downward.</p>"},{"types":[{"type":"String"}],"name":"eventName","description":"<p>The name of the event to listen for.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"handler","description":"<p>The function that was bound.</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>The <strong>element</strong>.</p>\n\n<p><code>can.undelegate(selector, eventName, handler)</code> unbinds a delegate handler\non an object for a given event.  It works on:</p>\n\n<ul>\n<li>HTML elements and the window</li>\n</ul>\n\n<p>The idea is that undelegate can be used on anything that produces delegate events\nand it will figure out the appropriate way to\nbind to it.  Typically, <code>can.undelegate</code> is only used internally to\nCanJS; however, if you are making libraries or extensions, use\n<code>can.undelegate</code> to listen to events independent of the underlying library.</p>\n\n<p><strong>Delegate/undelegate binding to an HTMLElement</strong></p>\n\n<pre><code>var el = document.getElementById('foo'),\nhandler = function(ev){\n    this // el\n};\ncan.delegate.call(el, \".selector\", \"click\", handler)\ncan.undelegate.call(el, \".selector\", \"click\", handler)\n</code></pre>"}}],"src":"can/util/func.js","line":407,"id":393},{"description":"<p>Trigger an event on an object. </p>","title":"","name":"can.trigger","type":"function","parent":"can.util","signatures":[{"code":"can.trigger(target, eventName[, args])","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"target","description":"<p>The object to trigger the event on.</p>"},{"types":[{"type":"String"}],"name":"eventName","description":"<p>The event to trigger.</p>"},{"types":[{"type":"Array","template":[{"types":[{"type":"*"}]}]}],"optional":true,"name":"args","description":"<p>The event data.</p>"}]}],"comment":" ","src":"can/util/func.js","line":439,"id":394},{"description":"<p>Make an AJAX request. </p>","title":"","name":"can.ajax","type":"function","parent":"can.util","signatures":[{"code":"can.ajax(settings)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"settings","description":"<p>Configuration options for the AJAX request.\nThe list of configuration options is the same as for <a href=\"http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings\">jQuery.ajax()</a>.</p>"}],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A can.Deferred that resolves to the data.</p>"}}],"comment":" ","src":"can/util/func.js","line":463,"id":395},{"description":"<p>Make a library's nodelist. </p>","title":"","name":"can.$","type":"function","parent":"can.util","signatures":[{"code":"can.$(element)","description":"","params":[{"types":[{"type":"String"},{"type":"Element"},{"type":"NodeList"}],"name":"element","description":"<p>The selector, HTML element, or nodelist\nto pass to the underlying library.</p>"}],"returns":{"types":[{"type":"NodeList"}],"description":"<p>The nodelist as constructed by the underlying library.</p>"}}],"comment":" ","src":"can/util/func.js","line":485,"id":396},{"description":"<p>Make a document fragment. </p>","title":"","name":"can.buildFragment","type":"function","parent":"can.util","signatures":[{"code":"can.buildFragment(html, node)","description":"","params":[{"types":[{"type":"String"}],"name":"html","description":"<p>A string of HTML.</p>"},{"types":[{"type":"DOM"},{"type":"Node"}],"name":"node","description":"<p>A node used to access a document to make the fragment with.</p>"}],"returns":{"types":[{"type":"DocumentFragment"}],"description":"<p>A document fragment made from <strong>html</strong>.</p>"}}],"comment":" ","src":"can/util/func.js","line":508,"id":397},{"description":"<p>Append content to elements. </p>","title":"","name":"can.append","type":"function","parent":"can.util","signatures":[{"code":"can.append(nodeList, html)","description":"","params":[{"types":[{"type":"NodeList"}],"name":"nodeList","description":"<p>A nodelist of the elements to append content to.</p>"},{"types":[{"type":"String"}],"name":"html","description":"<p>The HTML to append to the end of the elements in <strong>nodeList</strong>.</p>"}]}],"comment":" ","src":"can/util/func.js","line":521,"id":398},{"description":"<p>Remove elements from the DOM. </p>","title":"","name":"can.remove","type":"function","parent":"can.util","signatures":[{"code":"can.remode(nodeList)","description":"","params":[{"types":[{"type":"NodeList"}],"name":"nodeList","description":"<p>A nodelist of elements to remove.</p>"}]}],"comment":" ","src":"can/util/func.js","line":541,"id":399},{"description":"<p>Associate data with or retrieve data from DOM nodes. </p>","title":"","name":"can.data","type":"function","parent":"can.util","signatures":[{"code":"can.data(nodeList, key, value)","description":"","params":[{"types":[{"type":"NodeList"}],"name":"nodeList","description":"<p>The list of nodes to add this data to.</p>"},{"types":[{"type":"String"}],"name":"key","description":"<p>The key to store this data under.</p>"},{"types":[{"type":"*"}],"name":"value","description":"<p>The data to store.</p>"}]},{"code":"can.data(nodeList, key)","description":"","params":[{"types":[{"type":"NodeList"}],"name":"nodeList","description":"<p>The list of nodes data was stored under.</p>"},{"types":[{"type":"String"}],"name":"key","description":"<p>The key to retrieve.</p>"}],"returns":{"types":[{"type":"*"}],"description":"<p>The data stored under <strong>key</strong>.</p>"}}],"comment":" ","src":"can/util/func.js","line":555,"id":400},{"description":"<p>Add a class to elements. </p>","title":"","name":"can.addClass","type":"function","parent":"can.util","signatures":[{"code":"can.addClass(nodeList, className)","description":"","params":[{"types":[{"type":"NodeList"}],"name":"nodeList","description":"<p>The list of HTML elements to add the class to.</p>"},{"types":[{"type":"String"}],"name":"className","description":"<p>The class to add.</p>"}]}],"comment":" ","src":"can/util/func.js","line":591,"id":401},{"description":"<p>Call a callback when a Deferred resolves. </p>","title":"","name":"can.when","type":"function","parent":"can.util","signatures":[{"code":"can.when(deferred)","description":"","params":[{"types":[{"type":"Deferred"},{"type":"Object","options":[]}],"name":"deferred","description":"<p>The Deferred, AJAX, or normal Objects to call the callback on.</p>"}],"returns":{"types":[{"type":"Deferred"}],"description":"<p><strong>deferred</strong> if <strong>deferred</strong> is a Deferred,\notherwise a Deferred that resolves to <strong>deferred</strong>.</p>"}}],"comment":" ","src":"can/util/func.js","line":626,"id":402},{"description":"<p><code>can.Deferred</code> is a object that allows users to assign and chain callback function(s) for the success or failure state of both asynchronous and synchronous function(s).</p>","type":"constructor","name":"can.Deferred","title":"","parent":"can.util","signatures":[{"code":"can.Deferred()","description":"","params":[],"returns":{"types":[{"type":"can.Deferred"}],"description":"<p>A new Deferred object.</p>"}}],"src":"can/util/func.js","line":650,"id":403,"children":[{"description":"","type":"prototype","name":"can.Deferred.prototype","parent":"can.Deferred","src":"can/util/func.js","line":661,"id":404,"children":[{"description":"<p>Resolve a Deferred in a particular context. </p>","title":"resolveWith","name":"can.Deferred.prototype.resolveWith","type":"function","parent":"can.Deferred.prototype","signatures":[{"code":"deferred.resolveWith(context[, arguments])","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"context","description":"<p>Context passed to the <code>doneCallbacks</code> as the <code>this</code> object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"arguments","description":"<p>Array of arguments that are passed to the <code>doneCallbacks</code>.</p>"}]}],"comment":" ","src":"can/util/func.js","line":687,"id":406},{"description":"<p>Reject a Deferred in a particular context. </p>","title":"rejectWith","name":"can.Deferred.prototype.rejectWith","type":"function","parent":"can.Deferred.prototype","signatures":[{"code":"deferred.rejectWith(context[, arguments])","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"context","description":"<p>Context passed to the <code>failCallbacks</code> as the <code>this</code> object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"arguments","description":"<p>Array of arguments that are passed to the <code>failCallbacks</code>.</p>"}]}],"comment":" ","src":"can/util/func.js","line":702,"id":407},{"description":"<p>Add one or more callbacks to be called when a Deferred is resolved. </p>","title":"done","name":"can.Deferred.prototype.done","type":"function","parent":"can.Deferred.prototype","signatures":[{"code":"deferred.done(doneCallbacks)","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"doneCallbacks","description":"<p>A function, or an array of functions, to be called when the Deferred is resolved.</p>"}]}],"comment":" ","src":"can/util/func.js","line":717,"id":408},{"description":"<p>Add a callback to be called when a Deferred is rejected. </p>","title":"fail","name":"can.Deferred.prototype.fail","type":"function","parent":"can.Deferred.prototype","signatures":[{"code":"deferred.fail(failCallbacks)","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"failCallbacks","description":"<p>A function, or an array of functions, to be called when the Deferred is rejected.</p>"}]}],"comment":" ","src":"can/util/func.js","line":733,"id":409},{"description":"<p>Add one or more callbacks to be unconditionally called when a Deferred is resolved or rejected. </p>","title":"always","name":"can.Deferred.prototype.always","type":"function","parent":"can.Deferred.prototype","signatures":[{"code":"deferred.always(alwaysCallbacks)","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"alwaysCallbacks","description":"<p>A function, or an array of functions, to be called whether the Deferred is resolved or rejected.</p>"}]}],"comment":" ","src":"can/util/func.js","line":749,"id":410},{"description":"<p>Add callbacks to a Deferred. </p>","title":"then","name":"can.Deferred.prototype.then","type":"function","parent":"can.Deferred.prototype","signatures":[{"code":"deferred.then(doneCallback[, failCallback])","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"doneCallback","description":"<p>A function called when the Deferred is resolved.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"failCallback","description":"<p>A function called when the Deferred is rejected.</p>"}]}],"comment":" ","src":"can/util/func.js","line":765,"id":411},{"description":"<p>Determine whether a Deferred has been resolved. </p>","title":"isResolved","name":"can.Deferred.prototype.isResolved","type":"function","parent":"can.Deferred.prototype","signatures":[{"code":"deferred.isResolved()","description":"","params":[],"returns":{"types":[{"type":"Boolean"}],"description":"<p>Whether this Boolean has been resolved.</p>"}}],"comment":" ","src":"can/util/func.js","line":784,"id":412},{"description":"<p>Reject a Deferred. </p>","title":"reject","name":"can.Deferred.prototype.reject","type":"function","parent":"can.Deferred.prototype","signatures":[{"code":"deferred.reject([argument])","description":"","params":[{"types":[{"type":"Object","options":[]}],"optional":true,"name":"argument","description":"<p>The argument to call the <code>failCallback</code> with.</p>"}]}],"comment":" ","src":"can/util/func.js","line":811,"id":413},{"description":"<p>Resolve a Deferred. </p>","title":"resolve","name":"can.Deferred.prototype.resolve","type":"function","parent":"can.Deferred.prototype","signatures":[{"code":"deferred.resolve([argument])","description":"","params":[{"types":[{"type":"Object","options":[]}],"optional":true,"name":"argument","description":"<p>The argument to call the <code>doneCallback</code> with.</p>"}]}],"comment":" ","src":"can/util/func.js","line":825,"id":414}]}]},{"description":"<p>Capitalize the first letter of a string. \n    can.capitalize('candy is fun!'); //-> Returns: 'Candy is fun!'</p>","title":"","name":"can.capitalize","type":"function","parent":"can.util","signatures":[{"code":"can.capitalize(str)","description":"","params":[{"types":[{"type":"String"}],"name":"str","description":"<p>The string to capitalize.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The string with the first letter capitalized.</p>"}}],"src":"can/util/func.js","line":839,"id":415},{"description":"<p>Returns a string with {param} replaced values from data. </p>","title":"","name":"can.sub","type":"function","parent":"can.util","signatures":[{"code":"can.sub(str, data, remove, s)","description":"","params":[{"types":[{"type":"String"}],"name":"str","description":"<p>The string to make substitutes on</p>"},{"types":[{"type":"Object","options":[]}],"name":"data","description":"<p>The data to be used to look for properties.  If it's an array, multiple objects can be used.</p>"},{"types":[{"type":"Boolean"}],"optional":true,"name":"remove","description":"<p>if a match is found, remove the property from the object</p>"},{"types":[{"type":"String"}],"name":"s","description":"<p>The string to replace</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The converted string or <code>null</code> if any data to render are <code>undefined</code> or <code>null</code></p>"}}],"comment":" ","src":"can/util/func.js","line":851,"id":416},{"description":"<p>Takes a CamelCase or mixedCase string and underscores the string on the capital letter. </p>","title":"","name":"can.underscore","type":"function","parent":"can.util","signatures":[{"code":"can.underscore(str)","description":"","params":[{"types":[{"type":"String"}],"name":"str","description":"<p>The string to underscore</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>the underscored string</p>"}}],"comment":" ","src":"can/util/func.js","line":872,"id":417},{"description":"<p>Escapes a string for insertion into HTML. </p>","title":"","name":"can.esc","type":"function","parent":"can.util","signatures":[{"code":"can.esc(str)","description":"","params":[{"types":[{"type":"String"}],"name":"str","description":"<p>The string to escape</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The HTML escaped string.</p>"}}],"comment":" ","src":"can/util/func.js","line":890,"id":418},{"description":"","title":"","name":"can.getObject","type":"function","parent":"can.util","signatures":[{"code":"can.getObject(name, roots, add)","description":"<p>Gets an object from a string.</p>","params":[{"types":[{"type":"String"}],"name":"name","description":"<p>the name of the object to look for</p>"},{"types":[{"type":"Array","options":[]}],"optional":true,"name":"roots","description":"<p>an array of root objects to look for the name.  If roots is not provided, the window is used.</p>"},{"types":[{"type":"Boolean"}],"optional":true,"name":"add","description":"<p>true to add missing objects to the path. false to remove found properties. undefined to not modify the root object</p>"}],"returns":{"types":[{"type":"Object","options":[]}],"description":"<p>The object.</p>"}}],"comment":" ","src":"can/util/func.js","line":905,"id":419},{"name":"can.Object","type":"page","parent":"can.util","description":"","hide":true,"title":"can.Object","comment":" ","src":"can/util/object/object.js","line":2,"id":499},{"type":"function","name":"can.Object.same","parent":"can.util","description":"<p>Checks if two objects are the same. </p>","title":"","signatures":[{"code":"can.Object.same(a, b, compares, aParent, bParent, deep)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"a","description":"<p>An object to compare against <code>b</code>.</p>"},{"types":[{"type":"Object","options":[]}],"name":"b","description":"<p>An object to compare against <code>a</code>.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"compares","description":"<p>An object that specifies how to compare properties.\nThe keys of the <code>compares</code> object are names of properties in the objects to compare,\nand the values are functions that compare those properties. You can also pass <code>'i'</code>\nto compare values as case-insensitive strings, or <code>null</code> not to compare the properties\nat all.</p>"}],"returns":{"types":[{"type":"Object","options":[{"name":"boolean"}]}],"description":"<p>Whether the two objects have the same properties and values.</p>"}}],"comment":" ","src":"can/util/object/object.js","line":36,"id":500},{"type":"function","name":"can.Object.subsets","parent":"can.util","description":"<p>Returns the sets in 'sets' that are a subset of checkSet </p>\n\n<pre><code class=\"lang-javascript\">can.Object.subsets({userId: 20},\n[\n{userId: 20, limit: 30},\n{userId: 5},\n{}\n]) //-> [{userId: 20, limit: 30}]</code></pre>","title":"","signatures":[{"code":"can.Object.subsets(checkSet, sets, compares)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"checkSet","description":""},{"types":[{"type":"Object","options":[]}],"name":"sets","description":""},{"types":[{"type":"Object","options":[]}],"name":"compares","description":""}]}],"src":"can/util/object/object.js","line":140,"id":501},{"type":"function","name":"can.Object.subset","parent":"can.util","description":"<p>Compares if subset is a subset of set. Returns true if an object is a set of another set </p>\n\n<pre><code class=\"lang-javascript\">can.Object.subset({}, {foo: \"bar\"} ) //-> true</code></pre>","title":"","signatures":[{"code":"can.Object.subset(subset, set, compares)","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"subset","description":""},{"types":[{"type":"Object","options":[]}],"name":"set","description":""},{"types":[{"type":"Object","options":[]}],"name":"compares","description":""}]}],"comment":"undefined@returns {Boolean} Whether or not subset is a subset of set\n","src":"can/util/object/object.js","line":169,"id":502}]},{"type":"page","name":"can.view.bindings","description":"<p>Provides template event bindings and two-way bindings. </p>","parent":"canjs","links":[{"href":"../docco/view/bindings/bindings.html","title":"docco"}],"comment":" ","src":"can/view/bindings/doc/bindings.md","id":179,"children":[{"type":"function","name":"can.view.bindings.can-EVENT","description":"","title":"can-EVENT","parent":"can.view.bindings","signatures":[{"code":"can-EVENT='KEY'","description":"<p>Specify a callback function to be called on a particular event. You can create your own special event types.</p>","params":[{"types":[{"type":"String"}],"name":"EVENT","description":"<p>A event name like <code>click</code> or <code>keyup</code>.  If you are\nusing jQuery, you can listen to jQuery special events too.</p>"},{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A named value in the current scope.  The value\nshould be a function.</p>"}]}],"comment":" ","src":"can/view/bindings/doc/can-event.md","id":180},{"type":"function","name":"can.view.bindings.can-value","description":"<p>Sets up two way bindings in a template.</p>","title":"can-value","parent":"can.view.bindings","signatures":[{"code":"can-value='KEY'","description":"<p>Binds the element's value or checked property to the value specified by\nkey. Example:</p>\n\n<pre><code>&lt;input type='text' can-value='first.name'/&gt;\n</code></pre>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A named value in the current scope.</p>"}]}],"comment":" ","src":"can/view/bindings/doc/can-value.md","id":181,"children":[{"type":"function","name":"can.view.bindings.can-value-checkbox","description":"<p>Cross bind a value to a checkbox.</p>","title":"input type=checkbox","parent":"can.view.bindings.can-value","signatures":[{"code":"<input type='checkbox' can-value='KEY' can-true-value='TRUEVALUE' can-false-value='FALSEVALUE'/>","description":"<p>Cross binds the checked property to a true or false value.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"KEY","description":"<p>A named value in the current scope.</p>"},{"types":[{"type":"String"}],"optional":true,"name":"TRUEVALUE","description":"<p>Used to set the checked value of <code>KEY</code>.</p>"},{"types":[{"type":"String"}],"optional":true,"name":"FALSEVALUE","description":"<p>Used to set the unchecked value of <code>KEY</code>.</p>"}]}],"comment":" ","src":"can/view/bindings/doc/input-checkbox.md","id":182},{"type":"function","name":"can.view.bindings.can-value-radio","description":"<p>Cross bind a value to a radio input.</p>","title":"input type=radio","parent":"can.view.bindings.can-value","signatures":[{"code":"<input type='radio' can-value='KEY' value='VALUE'/>","description":"<p>If the radio element is checked, sets the observable specified by <code>can-value</code> to match the value of \n<code>value</code> attribute.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"KEY","description":"<p>A named value in the current scope. It should reference a\na [can.Map] property or a [can.compute].</p>"},{"types":[{"type":"String"}],"name":"VALUE","description":"<p>Used to set the value of <code>KEY</code> when the radio input is checked.</p>"}]}],"comment":" ","src":"can/view/bindings/doc/input-radio.md","id":183},{"type":"function","name":"can.view.bindings.can-value-select-multiple","description":"<p>Cross bind a value to a <code>&lt;select&gt;</code> element with multiple selections permitted.</p>","title":"select multiple","parent":"can.view.bindings.can-value","release":"2.1","signatures":[{"code":"<select multiple can-value='KEY'/>","description":"<p>Cross binds the selected option values with an observable value.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"KEY","description":"<p>A named value in the current \nscope. <code>KEY</code>'s value is cross bound with the selected <code>&lt;option&gt;</code> in\nthe <code>&lt;select&gt;</code>. <code>KEY</code>'s value should be either Array-like, a String,\nor <code>undefined</code>.</p>"}]}],"comment":" ","src":"can/view/bindings/doc/select-multiple.md","id":184},{"type":"function","name":"can.view.bindings.can-value-select","description":"<p>Cross bind a value to a <code>&lt;select&gt;</code> element.</p>","title":"select","parent":"can.view.bindings.can-value","signatures":[{"code":"<select can-value='KEY'/>","description":"<p>Cross binds the selected option value with an observable value.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"KEY","description":"<p>A named value in the current \nscope. <code>KEY</code>'s value is cross bound with the selected <code>&lt;option&gt;</code> in\nthe <code>&lt;select&gt;</code>. <code>KEY</code> should specify either a [can.Map] property or\na [can.compute].</p>"}]}],"comment":" ","src":"can/view/bindings/doc/select.md","id":185}]}]},{"type":"function","name":"can.view","description":"<p>Utilities for  loading, processing, rendering, and live-updating of templates.</p>","title":"","parent":"canjs","links":[{"href":"../docco/view/view.html","title":"docco"}],"signatures":[{"code":"can.view( idOrUrl, data[, helpers] )","description":"<p>Loads a template, renders it with data and helper functions and returns \nthe HTML of the template within \na [https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment documentFragment].</p>\n\n<pre><code>var frag = can.view(\n    \"/contact.ejs\",\n    {first: \"Justin\", last: \"Meyer\"},\n    {\n        fullName: function(first, last){\n            return first +\" \"+ last\n        }\n    });\n\ndocument.getElementById('contacts').appendChild(frag)\n</code></pre>","params":[{"types":[{"type":"String"},{"type":"Object","options":[]}],"name":"idOrUrl","description":"<p>The URL of a template or the id of a template embedded in a script tag or an object containing a <code>url</code> property for the URL to load and an <code>engine</code> property for the view engine (<code>mustache</code> or <code>ejs</code>) if it can't be infered from the file extensions or script tag type.</p>"},{"types":[{"type":"Object","options":[]}],"name":"data","description":"<p>Data to render the template with.</p>"},{"types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]}]}],"name":"helpers","description":"<p>An object of named local helper functions.</p>"}],"returns":{"types":[{"type":"documentFragment"}],"description":"<p>The rendered result of the template converted to \nhtml elements within a [https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment documentFragment].</p>"}},{"code":"can.view( idOrUrl )","description":"<p>Registers or loads a template and returns a [can.view.renderer renderer] function that can be used to\nrender the template with <code>data</code> and <code>helpers</code>.</p>\n\n<pre><code>var renderer = can.view(\"/contact.ejs\");\n\nvar frag = renderer(\n    {first: \"Justin\", last: \"Meyer\"},\n    {\n        fullName: function(first, last){\n            return first +\" \"+ last\n        }\n    })\n\ndocument.getElementById('contacts').appendChild(frag)\n</code></pre>","params":[{"types":[{"type":"String"}],"name":"idOrUrl","description":"<p>The URL of a template or the id of a template embedded in a script tag.</p>"}],"returns":{"types":[{"type":"can.view.renderer"}],"description":"<p>A renderer function that can render the template into a documentFragment.</p>"}}],"comment":" ","src":"can/view/doc/view.md","id":195,"children":[{"name":"can.view.static","title":"static","type":"group","parent":"can.view","description":"","order":0,"id":193,"children":[{"type":"function","name":"can.view.attr","description":"<p>Register custom behavior for an attribute.</p>","title":"","parent":"can.view.static","signatures":[{"code":"can.view.attr( attributeName, attrHandler(el, attrData) )","description":"","params":[{"types":[{"type":"String"},{"type":"RegExp"}],"name":"attributeName","description":"<p>A lower-case attribute name or regular expression\nthat matches attribute names. Examples: <code>\"my-fill\"</code> or <code>/my-\\w/</code>.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"HTMLElement"}],"name":"el"},{"types":[{"type":"can.view.attrData"}],"name":"attrData"}]}],"name":"attrHandler","description":"<p>A function that adds custom behavior to <code>el</code>.</p>"}],"release":"2.1"}],"comment":" ","src":"can/view/doc/attr.md","id":186},{"type":"function","name":"can.view.ejs","description":"","title":"ejs","parent":"can.view.static","deprecated":[{"version":"2.1","description":"<p>Use [can.ejs] instead.</p>"}],"signatures":[{"code":"can.view.ejs( [id,] template )","description":"<p>Register an EJS template string and create a renderer function.</p>\n\n<pre><code>var renderer = can.view.ejs(\"&lt;h1&gt;&lt;%= message %&gt;&lt;/h1&gt;\");\nrenderer({message: \"Hello\"}) //-&gt; docFrag[ &lt;h1&gt;Hello&lt;/h1&gt; ]\n</code></pre>","params":[{"types":[{"type":"String"}],"optional":true,"name":"id","description":"<p>An optional ID to register the template.</p>\n\n<pre><code>can.view.ejs(\"greet\",\"&lt;h1&gt;&lt;%= message %&gt;&lt;/h1&gt;\");\ncan.view(\"greet\",{message: \"Hello\"}) //-&gt; docFrag[&lt;h1&gt;Hello&lt;/h1&gt;]\n</code></pre>"},{"types":[{"type":"String"}],"name":"template","description":"<p>An EJS template in string form.</p>"}],"returns":{"types":[{"type":"can.view.renderer"}],"description":"<p>A renderer function that takes data and helpers.</p>"}}],"comment":" ","src":"can/view/doc/ejs.md","id":188},{"type":"function","name":"can.view.mustache","description":"","title":"mustache","parent":"can.view.static","deprecated":[{"version":"2.1","description":"<p>Use [can.mustache] instead.</p>"}],"signatures":[{"code":"can.mustache( [id,] template )","description":"<p>Register a Mustache template string and create a renderer function.</p>\n\n<pre><code>var renderer = can.mustache(\"&lt;h1&gt;{{message}}&lt;/h1&gt;\");\nrenderer({message: \"Hello\"}) //-&gt; docFrag[ &lt;h1&gt;Hello&lt;/h1&gt; ]\n</code></pre>","params":[{"types":[{"type":"String"}],"optional":true,"name":"id","description":"<p>An optional ID for the template.</p>\n\n<pre><code>can.view.ejs(\"greet\",\"&lt;h1&gt;{{message}}&lt;/h1&gt;\");\ncan.view(\"greet\",{message: \"Hello\"}) //-&gt; docFrag[&lt;h1&gt;Hello&lt;/h1&gt;]\n</code></pre>"},{"types":[{"type":"String"}],"name":"template","description":"<p>A Mustache template in string form.</p>"}],"returns":{"types":[{"type":"can.view.renderer"}],"description":"<p>A renderer function that takes data and helpers.</p>"}}],"comment":" ","src":"can/view/doc/mustache.md","id":189},{"type":"constructor","name":"can.view.Options","description":"<p>Create a helper lookup node  for [can.mustache.key keys].  Options are where mustache helpers,\npartials, local tags, and other non-data objects are found.</p>","title":"","inherits":"can.view.Scope","parent":"can.view.static","signatures":[{"code":"new can.view.Options(options, [parent])","description":"","params":[{"types":[{"type":"Object","options":[]}],"name":"options","description":"<p>An object with at least one of the following properties:</p>\n\n<ul>\n<li><code>helpers</code> - Mustache helpers will be found within this object.</li>\n<li><code>partials</code> - Mustache partials will be found within this object.</li>\n<li><code>tags</code> - Local tag hookups will be found within this object.</li>\n</ul>\n\n<p>If none of these properties are found, the object is assumed to be a \nhelpers object.s</p>"},{"types":[{"type":"can.view.Options"}],"optional":true,"name":"parent","description":"<p>The parent options object. If a <code>key</code> value\nis not found in the current options object, it will then look in the parent\nscope.</p>"}],"release":"2.1","returns":{"types":[{"type":"can.view.Options"}],"description":"<p>Returns a options instance.</p>"}}],"comment":" ","src":"can/view/doc/options.md","id":190},{"type":"function","name":"can.view.tag","description":"<p>Register custom behavior for a given tag.</p>","title":"","parent":"can.view.static","signatures":[{"code":"can.view.tag( tagName, tagHandler(el, tagData) )","description":"<p>Registers the <code>tagHandler</code> callback when <code>tagName</code> is found \nin a template.</p>","params":[{"types":[{"type":"String"}],"name":"tagName","description":"<p>A lower-case, hypenated or colon-seperated html \ntag. Example: <code>\"my-widget\"</code> or <code>\"my:widget\"</code>.  It is considered a best-practice to \nhave a hypen or colon in all custom-tag names.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"can.view.Scope"}]},"params":[{"types":[{"type":"HTMLElement"}],"name":"el"},{"types":[{"type":"can.view.tagData"}],"name":"tagData"}]}],"name":"tagHandler","description":"<p>Adds custom behavior to <code>el</code>.  If <code>tagHandler</code> returns data, it is used to \nrender <code>tagData.subtemplate</code> and the result is inserted as the childNodes of <code>el</code>.</p>"}],"release":"2.1"}],"comment":" ","src":"can/view/doc/tag.md","id":191},{"type":"property","name":"can.view.nodeLists","description":"<p>Stores hierarchical node references.</p>\n\n<h2>Use</h2>\n\n<p><code>can.view.nodeLists</code> is used to make sure \"directly nested\" live-binding\nsections update content correctly.\nConsider a template like:</p>","types":[{"type":"Object","options":[]}],"title":"","parent":"can.view.static","src":"can/view/node_lists/docs/node_lists.md","id":230,"children":[{"type":"function","name":"can.view.nodeLists.first","description":"<p>Return the first HTMLElement in a nodeList, if the first\nelement is a nodeList, returns the first HTMLElement of\nthe child list, etc.</p>","title":"","parent":"can.view.nodeLists","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"HTMLElement"}]}]}],"name":"nodeList","description":"<p>The nodeList to get the first element of.</p>"}],"returns":{"types":[{"type":"HTMLElement"}],"description":"<p>firstElement The first <code>HTMLElement</code> in the list.</p>"},"src":"can/view/node_lists/docs/first.md","id":228},{"type":"function","name":"can.view.nodeLists.last","description":"<p>Return the last HTMLElement in a nodeList, if the last\nelement is a nodeList, returns the last HTMLElement of\nthe child list, etc.</p>","title":"","parent":"can.view.nodeLists","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"HTMLElement"}]}]}],"name":"nodeList","description":"<p>The nodeList to get the last element of.</p>"}],"returns":{"types":[{"type":"HTMLElement"}],"description":"<p>lastElement The last <code>HTMLElement</code> in the list.</p>"},"src":"can/view/node_lists/docs/last.md","id":229},{"type":"function","name":"can.view.nodeLists.register","description":"<p>Unregister's a nodeList and returns the unregistered nodes. <br />\nCall if the nodeList is no longer being updated. This will \nalso unregister all child nodeLists.</p>","title":"","parent":"can.view.nodeLists","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"HTMLElement"}]}]}],"name":"nodeList","description":"<p>The nodeList to unregister.</p>"}],"returns":{"types":[{"type":"Array","template":[{"types":[{"type":"HTMLElement"}]}]}],"description":"<p>nodeList The array of nodes that were unregistered.</p>"},"src":"can/view/node_lists/docs/register.md","id":231},{"type":"function","name":"can.view.nodeLists.update","description":"<p>Updates a nodeList with new items</p>","title":"","parent":"can.view.nodeLists","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"HTMLElement"}]}]}],"name":"nodeList","description":"<p>A registered nodeList.</p>"},{"types":[{"type":"Array","template":[{"types":[{"type":"HTMLElement"}]}]}],"name":"newNodes","description":"<p>HTML nodes that should be placed in the nodeList.</p>"}],"src":"can/view/node_lists/docs/update.md","id":232}]},{"type":"constructor","name":"can.view.Scope","description":"<p>Create a lookup node for [can.mustache.key keys]. </p>","title":"","inherits":"can.Construct","parent":"can.view.static","test":"can/view/scope/test.html","plugin":"can/view/scope","signatures":[{"code":"new can.view.Scope(context, [parent])","description":"","params":[{"types":[{"type":"*"}],"name":"context","description":"<p>A value that represents the \ncurrent context. This is often an object or observable and is the first\nplace</p>"},{"types":[{"type":"can.view.Scope"}],"optional":true,"name":"parent","description":"<p>The parent scope. If a <code>key</code> value\nis not found in the current scope, it will then look in the parent\nscope.</p>"}],"release":"2.0.1","returns":{"types":[{"type":"can.view.Scope"}],"description":"<p>Returns a scope instance.</p>"}}],"comment":" ","src":"can/view/scope/scope.md","id":241,"children":[{"name":"can.view.Scope.types","title":"types","type":"group","parent":"can.view.Scope","description":"","order":0,"id":240,"children":[{"type":"typedef","name":"can.view.Scope.readOptions","description":"<p>An options object used to configure [can.view.Scope.read].</p>","title":"readOptions","types":[{"type":"Object","options":[{"name":"isArgument","types":[{"type":"Boolean"}],"description":"<p>If true, and the last value is a function or compute, returns that \nfunction instead of calling it. </p>\n\n<pre><code>MyMap = can.Map.extend({method: function(){}});\nres = Scope.read( new MyMap(), \n                  [\"method\"],\n                  {isArgument: true, proxyMethods: false} );\nres === MyMap.prototype.method //-&gt; true\n</code></pre>","optional":true},{"name":"foundObservable","description":"<p><code>foundObservable</code> is called \nwhen the first observable is found along the path along the read path.  It's called with\nthe <code>readIndex</code> where the observable was found.</p>\n\n<pre><code>var data = {person : new can.Map({name: \"Justin\"})}\nScope.read( data, \n            [\"person.name\"],\n            {foundObservable: function(observe, readIndex){\n              observe === data.person //-&gt; true\n              readIndex //-&gt; 1\n            }} )\n</code></pre>","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"can.compute"},{"type":"can.Map"}],"name":"observe"},{"types":[{"type":"Number"}],"name":"readIndex"}]}],"optional":true},{"name":"earlyExit","description":"<p>Is called if a value is not found.</p>","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"can.compute"},{"type":"can.Map"}],"name":"observe"},{"types":[{"type":"Number"}],"name":"readIndex"}]}],"optional":true},{"name":"args","description":"<p>An array of arguments to pass to observable prototype methods.</p>","types":[{"type":"Array","options":[]}]},{"name":"returnObserveMethods","description":"<p>If true, returns \nmethods found on an observable.  Otherwise, it will call the function with <code>args</code> as arguments and return the \nvalue.</p>\n\n<pre><code>var Dog = can.Map.extend({\n  age: function(){\n    return this.attr(\"years\")*7\n  }\n})\n\nvar dog = new Dog({years: 3});\n\nScope.read(dog,\"age\",{}) //-&gt; 21\n\nScope.read(dog,\n           \"age\",\n           {returnObserveMethods: true})() //-&gt; 21\n</code></pre>","types":[{"type":"Boolean"}],"optional":true},{"name":"proxyMethods","description":"<p>Set to false to return just the function, preventing returning a function that\nalways calls the original function with this as the parent.</p>","types":[{"type":"Boolean"}],"optional":true,"defaultValue":"true"}]}],"parent":"can.view.Scope.types","src":"can/view/scope/readOptions.md","id":239}]},{"type":"static","description":"","name":"can.view.Scope.static","parent":"can.view.Scope","src":"can/view/scope/scope.js","line":54,"id":473,"children":[{"type":"function","name":"can.view.Scope.read","description":"","title":"read","parent":"can.view.Scope.static","deprecated":[{"version":"2.1","description":"<p>You should use [can.compute.read] instead of this function.</p>"}],"signatures":[{"code":"Scope.read(parent, reads, options)","description":"","params":[{"types":[{"type":"*"}],"name":"parent","description":"<p>A parent object to read properties from.</p>"},{"types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}],"name":"reads","description":"<p>An array of properties to read.</p>"},{"types":[{"type":"can.view.Scope.readOptions"}],"name":"options","description":"<p>Configures\nhow to read properties and values and register callbacks</p>"}],"returns":{"types":[{"type":"Object","options":[{"name":"value","types":[{"type":"*"}],"description":"<p>The value found by reading <code>reads</code> properties.  If\nno value was found, value will be undefined.</p>"},{"name":"parent","types":[{"type":"*"}],"description":"<p>The most immediate parent object of the value specified by <code>key</code>.</p>"}]}],"description":"<p>Returns an object that\nprovides the value and parent object.</p>"}}],"types":[],"comment":" ","src":"can/view/scope/doc/static_read.md","id":238}]},{"type":"prototype","description":"","name":"can.view.Scope.prototype","parent":"can.view.Scope","src":"can/view/scope/scope.js","line":63,"id":474,"children":[{"type":"function","name":"can.view.Scope.add","description":"","title":"add","parent":"can.view.Scope.prototype","params":[{"types":[{"type":"*"}],"name":"context","description":"<p>The context of the new scope object.</p>"}],"returns":{"types":[{"type":"can.view.Scope"}],"description":"<p>A scope object.</p>"},"comment":" ","src":"can/view/scope/doc/add.md","id":234},{"type":"function","name":"can.view.Scope.attr","description":"","title":"attr","parent":"can.view.Scope.prototype","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A dot seperated path.  Use <code>\"\\.\"</code> if you have a\nproperty name that includes a dot.</p>"}],"returns":{"types":[{"type":"*"}],"description":"<p>The found value or undefined if no value is found.</p>"},"comment":" ","src":"can/view/scope/doc/attr.md","id":235},{"type":"function","name":"can.view.Scope.compute","description":"","title":"compute","parent":"can.view.Scope.prototype","signatures":[{"code":"scope.compute( key, [options] )","description":"","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A dot seperated path.  Use <code>\"\\.\"</code> if you have a\nproperty name that includes a dot.</p>"},{"types":[{"type":"can.view.Scope.readOptions"}],"optional":true,"name":"options","description":"<p>Options that configure how the <code>key</code> gets read.</p>"}],"release":"2.1","returns":{"types":[{"type":"can.compute"}],"description":"<p>A compute that can get or set <code>key</code>.</p>"}}],"src":"can/view/scope/doc/compute.md","id":236},{"type":"function","name":"can.view.Scope.computeData","description":"","title":"computeData","parent":"can.view.Scope.prototype","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A dot seperated path.  Use <code>\"\\.\"</code> if you have a\nproperty name that includes a dot.</p>"},{"types":[{"type":"can.view.Scope.readOptions"}],"optional":true,"name":"options","description":"<p>Options that configure how the <code>key</code> gets read.</p>"}],"returns":{"types":[{"type":"Object","options":[{"name":"compute","description":"<p>A compute that returns the\nvalue of <code>key</code> looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.</p>","types":[{"type":"can.compute"}]},{"name":"scope","description":"<p>The scope the key was found within. The key might have\nbeen found in a parent scope.</p>","types":[{"type":"can.view.Scope"}]},{"name":"initialData","description":"<p>The initial value at the key's location.</p>","types":[{"type":"*"}]}]}],"description":"<p>An object with the following values:</p>"},"types":[],"comment":" ","src":"can/view/scope/doc/compute_data.md","id":237},{"type":"function","name":"can.view.Scope.prototype.read","params":[{"types":[{"type":"can.mustache.key"}],"name":"attr","description":"<p>A dot seperated path.  Use <code>\"\\.\"</code> if you have a property name that includes a dot.</p>"},{"types":[{"type":"can.view.Scope.readOptions"}],"name":"options","description":"<p>that configure how this gets read.</p>"}],"parent":"can.view.Scope.prototype","description":"","hide":true,"returns":{"types":[{"type":"Object","options":[{"name":"rootObserve","description":"<p>the first observable to read from.</p>","types":[{"type":"can.Map"},{"type":"can.compute"}]},{"name":"reads","description":"<p>An array of properties that can be used to read from the rootObserve to get the value.</p>","types":[{"type":"Array","template":[{"types":[{"type":"String"}]}]}]},{"name":"value","description":"<p>the found value</p>","types":[{"type":"*"}]}],"description":"<p>parent the value's immediate parent</p>"}],"description":""},"types":[],"src":"can/view/scope/scope.js","line":160,"id":475},{"type":"function","name":"can.view.Scope.prototype.foundObservable","params":[{"name":"observe","types":[{"type":"*"}]},{"name":"nameIndex","types":[{"type":"*"}]}],"parent":"can.view.Scope.prototype","description":"<p>Store found observable, incase we want to set it as the rootObserve. </p>","src":"can/view/scope/scope.js","line":239,"id":476},{"name":"can.view.Scope.prototype.defaultComputeReadings","type":"property","parent":"can.view.Scope.prototype","description":"<p>Clear and save readings so next attempt does not use these readings </p>","src":"can/view/scope/scope.js","line":252,"id":477}]}]},{"type":"function","name":"can.view.frag","params":[{"name":"result","types":[{"type":"*"}]},{"name":"parentNode","types":[{"type":"*"}]}],"parent":"can.view.static","description":"","title":"frag","src":"can/view/view.js","line":209,"id":446},{"type":"function","name":"can.view.hook","parent":"can.view.static","description":"<p>Create a hookup to insert into templates. </p>","title":"hook","signatures":[{"code":"can.view.hook(callback)","description":"","params":[{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"callback","description":"<p>A callback function to be called with the element.</p>"}]}],"comment":" ","src":"can/view/view.js","line":294,"id":449},{"name":"can.view.cache","type":"property","parent":"can.view.static","description":"<p>By default, views are cached on the client.  If you'd like the\nthe views to reload from the server, you can set the <code>cache</code> attribute to <code>false</code>.</p>","types":[{"type":"Boolean"}],"title":"cache","src":"can/view/view.js","line":327,"id":451},{"type":"function","name":"can.view.register","parent":"can.view.static","description":"<p>Register a templating language. </p>","title":"register","signatures":[{"code":"can.view.register(info)","description":"","params":[{"types":[{"type":"Object","options":[{"name":"plugin","description":"<p>The location of the templating language's plugin.</p>","types":[{"type":"String"}]},{"name":"suffix","description":"<p>Files with this suffix will use this templating language's plugin by default.</p>","types":[{"type":"String"}]},{"name":"renderer","description":"<p>A function that returns a function that, given data, will render the template with that data.\nThe <strong>renderer</strong> function receives the id of the template and the text of the template.</p>","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]},{"name":"script","description":"<p>A function that returns the string form of the processed template.</p>","types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]}]}],"name":"info","description":"<p>Information about the templating language.</p>"}]}],"types":[],"comment":" ","src":"can/view/view.js","line":342,"id":452},{"name":"can.view.ext","type":"property","parent":"can.view.static","description":"<p>The default suffix to use if none is provided in the view's url.\nThis is set to <code>.ejs</code> by default.</p>","types":[{"type":"String"}],"title":"ext","src":"can/view/view.js","line":418,"id":453},{"type":"function","description":"<p>Render a template. </p>","title":"render","name":"can.view.render","parent":"can.view.static","signatures":[{"code":"can.view.render(template[, callback])","description":"","params":[{"types":[{"type":"String"},{"type":"Object","options":[]}],"name":"view","description":"<p>The path of the view template or a view object.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"callback","description":"<p>A function executed after the template has been processed.</p>"}],"returns":{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"can.Deferred"}],"description":"<p>A renderer function to be called with data and helpers\nor a Deferred that resolves to a renderer function.</p>"}},{"code":"can.view.render(template, data[, [helpers,] callback])","description":"","params":[{"types":[{"type":"String"},{"type":"Object","options":[]}],"name":"view","description":"<p>The path of the view template or a view object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"data","description":"<p>The data to populate the template with.</p>"},{"types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]}]}],"optional":true,"name":"helpers","description":"<p>Helper methods referenced in the template.</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"callback","description":"<p>A function executed after the template has been processed.</p>"}],"returns":{"types":[{"type":"String"},{"type":"can.Deferred"}],"description":"<p>The template with interpolated data in string form\nor a Deferred that resolves to the template with interpolated data.</p>"}}],"comment":" ","src":"can/view/view.js","line":485,"id":457},{"name":"can.view.live","type":"property","parent":"can.view.static","description":"<p>Setup live-binding between the DOM and a compute manually.</p>","types":[{"type":"Object","options":[],"description":"<p>An object with the live-binding methods:\n[can.view.live.html], [can.view.live.list], [can.view.live.text], \n[can.view.live.attr] and [can.view.live.attrs].</p>"}],"title":"","release":"2.0.4","comment":" ","src":"can/view/live/live.js","line":80,"id":491,"children":[{"type":"function","name":"can.view.live.list","params":[{"types":[{"type":"HTMLElement"}],"name":"el","description":"<p>An html element to replace with the live-section.</p>"},{"name":"compute","types":[{"type":"*"}]},{"types":[{"type":"function","returns":{"types":[{"type":"String"}]},"params":[{"types":[{"type":"*"}],"name":"index"},{"types":[{"type":"index"}],"name":"index"}],"context":{"types":[{"type":"*"}]}}],"name":"render","description":"<p>A function that when called with\nthe incremental item to render and the index of the item in the list.</p>"},{"types":[{"type":"Object","options":[]}],"name":"context","description":"<p>The <code>this</code> the <code>render</code> function will be called with.</p>"},{"types":[{"type":"HTMLElement"}],"optional":true,"name":"parentNode","description":"<p>An overwritable parentNode if <code>el</code>'s parent is\na documentFragment.</p>\n\n<h2>Use</h2>\n\n<p><code>can.view.live.list</code> is used to setup incremental live-binding.</p>\n\n<pre><code>// a compute that change's it's list\nvar todos = can.compute(function(){\n  return new Todo.List({page: can.route.attr(\"page\")})\n})\n\nvar placeholder = document.createTextNode(\" \")\n$(\"ul#todos\").append(placeholder)\n\n\n\ncan.view.live.list(\n  placeholder,\n  todos,\n  function(todo, index){\n    return \"&lt;li&gt;\"+todo.attr(\"name\")+\"&lt;/li&gt;\"\n  })\n</code></pre>"},{"types":[{"type":"can.compute"},{"type":"can.List"}],"name":"list","description":"<p>A [can.List] or [can.compute] whose value is a [can.List].</p>"}],"parent":"can.view.live","description":"<p>Live binds a compute's [can.List] incrementally.</p>","title":"","release":"2.0.4","src":"can/view/live/live.js","line":107,"id":492},{"type":"function","name":"can.view.live.html","params":[{"types":[{"type":"HTMLElement"}],"name":"el","description":"<p>An html element to replace with the live-section.</p>"},{"types":[{"type":"can.compute"}],"name":"compute","description":"<p>A [can.compute] whose value is HTML.</p>"},{"types":[{"type":"HTMLElement"}],"optional":true,"name":"parentNode","description":"<p>An overwritable parentNode if <code>el</code>'s parent is\na documentFragment.</p>\n\n<h2>Use</h2>\n\n<p><code>can.view.live.html</code> is used to setup incremental live-binding.</p>\n\n<pre><code>// a compute that change's it's list\nvar greeting = can.compute(function(){\n  return \"Welcome &lt;i&gt;\"+me.attr(\"name\")+\"&lt;/i&gt;\"\n});\n\nvar placeholder = document.createTextNode(\" \");\n$(\"#greeting\").append(placeholder);\n\ncan.view.live.html( placeholder,  greeting );\n</code></pre>"}],"parent":"can.view.live","description":"<p>Live binds a compute's value to a collection of elements.</p>","title":"","release":"2.0.4","src":"can/view/live/live.js","line":288,"id":493},{"type":"function","name":"can.view.live.replace","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"HTMLElement"}]}]}],"name":"nodes","description":"<p>An array of elements.  There should typically be one element.</p>"},{"types":[{"type":"String"},{"type":"HTMLElement"},{"type":"DocumentFragment"}],"name":"val","description":"<p>The content that should replace\n<code>nodes</code>.  If a string is passed, it will be [can.view.hookup hookedup].</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"teardown","description":"<p>A callback if these elements are torn down.</p>"}],"parent":"can.view.live","description":"<p>Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\ncorrect.</p>","title":"","release":"2.0.4","src":"can/view/live/live.js","line":354,"id":494},{"type":"function","name":"can.view.live.text","params":[{"name":"el","types":[{"type":"*"}]},{"name":"compute","types":[{"type":"*"}]},{"name":"parentNode","types":[{"type":"*"}]}],"parent":"can.view.live","description":"<p>Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\ncorrect.</p>","title":"","release":"2.0.4","src":"can/view/live/live.js","line":383,"id":495},{"type":"function","name":"can.view.live.attrs","params":[{"types":[{"type":"HTMLElement"}],"name":"el","description":"<p>The element whos attributes will be kept live.</p>"},{"types":[{"type":"can.compute"}],"name":"compute","description":"<p>The compute.</p>"},{"name":"currentValue","types":[{"type":"*"}]}],"parent":"can.view.live","description":"<p>Keep attributes live to a [can.compute].</p>","title":"","comment":" ","src":"can/view/live/live.js","line":416,"id":497},{"type":"function","name":"can.view.live.attr","params":[{"types":[{"type":"HTMLElement"}],"name":"el","description":"<p>The element whos attribute will be kept live.</p>"},{"types":[{"type":"String"}],"name":"attributeName","description":"<p>The attribute name.</p>"},{"types":[{"type":"can.compute"}],"name":"compute","description":"<p>The compute.</p>"}],"parent":"can.view.live","description":"<p>Keep an attribute live to a [can.compute].</p>","title":"","comment":" ","src":"can/view/live/live.js","line":523,"id":498}]}]},{"name":"can.view.plugins","title":"plugins","type":"group","parent":"can.view","description":"","order":0,"id":194,"children":[{"type":"page","name":"can.view.modifiers","description":"<p>The can/view/modifiers plugin extends the jQuery view modifiers</p>","title":"jQuery modifiers","parent":"can.view.plugins","plugin":"can/view/modifiers","test":"can/view/modifiers/test.html","src":"can/view/modifiers/modifiers.md","id":207,"children":[{"type":"function","name":"jQuery.fn.hookup","params":[],"parent":"can.view.modifiers","description":"<p>Called on a jQuery collection that was rendered with can.View with pending hookups.  can.View can render a</p>","title":"","src":"can/view/modifiers/modifiers.js","line":110,"id":337},{"type":"function","description":"<p>Extending the original [http://api.jquery.com/prepend/ jQuery().prepend()]\nto render [can.view] templates inserted at the beginning of each element in the set of matched elements.</p>","title":"","name":"jQuery.fn.prepend","parent":"can.view.modifiers","params":[{"types":[{"type":"String"},{"type":"Object"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"content","description":"<p>A template filename or the id of a view script tag\nor a DOM element, array of elements, HTML string, or can object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"data","description":"<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"callback","description":"<p>A success callback to load the view asynchronously</p>"}],"returns":{"types":[{"type":"jQuery"},{"type":"can.Deferred"}],"description":"<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"},"src":"can/view/modifiers/modifiers.js","line":127,"id":338},{"type":"function","description":"<p>Extending the original [http://api.jquery.com/append/ jQuery().append()]\nto render [can.view] templates inserted at the end of each element in the set of matched elements.</p>","title":"","name":"jQuery.fn.append","parent":"can.view.modifiers","params":[{"types":[{"type":"String"},{"type":"Object"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"content","description":"<p>A template filename or the id of a view script tag\nor a DOM element, array of elements, HTML string, or can object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"data","description":"<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"callback","description":"<p>A success callback to load the view asynchronously</p>"}],"returns":{"types":[{"type":"jQuery"},{"type":"can.Deferred"}],"description":"<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"},"src":"can/view/modifiers/modifiers.js","line":147,"id":339},{"type":"function","description":"<p>Extending the original [http://api.jquery.com/after/ jQuery().after()]\nto render [can.view] templates inserted after each element in the set of matched elements.</p>","title":"","name":"jQuery.fn.after","parent":"can.view.modifiers","params":[{"types":[{"type":"String"},{"type":"Object"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"content","description":"<p>A template filename or the id of a view script tag\nor a DOM element, array of elements, HTML string, or can object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"data","description":"<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"callback","description":"<p>A success callback to load the view asynchronously</p>"}],"returns":{"types":[{"type":"jQuery"},{"type":"can.Deferred"}],"description":"<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"},"src":"can/view/modifiers/modifiers.js","line":167,"id":340},{"type":"function","description":"<p>Extending the original [http://api.jquery.com/before/ jQuery().before()]\nto render [can.view] templates inserted before each element in the set of matched elements.</p>","title":"","name":"jQuery.fn.before","parent":"can.view.modifiers","params":[{"types":[{"type":"String"},{"type":"Object"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"content","description":"<p>A template filename or the id of a view script tag\nor a DOM element, array of elements, HTML string, or can object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"data","description":"<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"callback","description":"<p>A success callback to load the view asynchronously</p>"}],"returns":{"types":[{"type":"jQuery"},{"type":"can.Deferred"}],"description":"<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"},"src":"can/view/modifiers/modifiers.js","line":187,"id":341},{"type":"function","description":"<p>Extending the original [http://api.jquery.com/text/ jQuery().text()]\nto render [can.View] templates as the content of each matched element.\nUnlike [jQuery.fn.html] jQuery.fn.text also works with XML, escaping the provided\nstring as necessary.</p>","title":"","name":"jQuery.fn.text","parent":"can.view.modifiers","params":[{"types":[{"type":"String"},{"type":"Object"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"content","description":"<p>A template filename or the id of a view script tag\nor a DOM element, array of elements, HTML string, or can object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"data","description":"<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"callback","description":"<p>A success callback to load the view asynchronously</p>"}],"returns":{"types":[{"type":"jQuery"},{"type":"can.Deferred"}],"description":"<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"},"src":"can/view/modifiers/modifiers.js","line":207,"id":342},{"type":"function","description":"<p>Extending the original [http://api.jquery.com/html/ jQuery().html()]\nto render [can.view] templates as the content of each matched element.</p>","title":"","name":"jQuery.fn.html","parent":"can.view.modifiers","params":[{"types":[{"type":"String"},{"type":"Object"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"content","description":"<p>A template filename or the id of a view script tag\nor a DOM element, array of elements, HTML string, or can object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"data","description":"<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"callback","description":"<p>A success callback to load the view asynchronously</p>"}],"returns":{"types":[{"type":"jQuery"},{"type":"can.Deferred"}],"description":"<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"},"src":"can/view/modifiers/modifiers.js","line":229,"id":343},{"type":"function","description":"<p>Extending the original [http://api.jquery.com/replaceWith/ jQuery().replaceWith()]\nto render [can.view] templates replacing each element in the set of matched elements.</p>","title":"","name":"jQuery.fn.replaceWith","parent":"can.view.modifiers","params":[{"types":[{"type":"String"},{"type":"Object"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"content","description":"<p>A template filename or the id of a view script tag\nor a DOM element, array of elements, HTML string, or can object.</p>"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"data","description":"<p>The data to render the view with.\nIf rendering a view template this parameter always has to be present\n(use the empty object initializer {} for no data).</p>"},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"optional":true,"name":"callback","description":"<p>A success callback to load the view asynchronously</p>"}],"returns":{"types":[{"type":"jQuery"},{"type":"can.Deferred"}],"description":"<p>The jQuery object or a [can.Deferred] if a deferred has\nbeen passed in data.</p>"},"src":"can/view/modifiers/modifiers.js","line":249,"id":344}]}]},{"type":"function","name":"hookup","params":[{"name":"fragment","description":""},{"name":"parentNode","description":""}],"parent":"can.view","description":"<p>hook up a fragment to its parent node</p>","hide":true,"comment":"undefined@returns {*}\n","src":"can/view/view.js","line":251,"id":447},{"name":"hookups","type":"property","parent":"can.view","description":"<p>A list of pending 'hookups'</p>","title":"","hide":true,"src":"can/view/view.js","line":284,"id":448},{"name":"can.view.cached","type":"property","parent":"can.view","description":"<p>Cached are put in this object</p>","hide":true,"types":[{"type":"Object","options":[]}],"title":"view","src":"can/view/view.js","line":317,"id":450},{"type":"function","name":"registerScript","params":[{"types":[{"type":"Object","options":[]}],"name":"type","description":""},{"types":[{"type":"Object","options":[]}],"name":"id","description":""},{"types":[{"type":"Object","options":[]}],"name":"src","description":""}],"parent":"can.view","description":"<p>Returns the text from a script tag</p>","hide":true,"src":"can/view/view.js","line":430,"id":454},{"type":"function","name":"preload","params":[{"types":[{"type":"String"}],"name":"id","description":""},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"renderer","description":""}],"parent":"can.view","description":"<p>Called by a production script to pre-load a fragment renderer function\ninto the view cache.</p>","hide":true,"src":"can/view/view.js","line":441,"id":455},{"type":"function","name":"preloadStringRenderer","params":[{"name":"id","description":""},{"name":"stringRenderer","description":""}],"parent":"can.view","description":"<p>Called by a production script to pre-load a string renderer function\ninto the view cache.</p>","hide":true,"comment":"undefined@returns {*}\n","src":"can/view/view.js","line":461,"id":456},{"type":"function","name":"renderTo","params":[{"types":[{"type":"String"}],"name":"format","description":""},{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"name":"renderer","description":""},{"name":"data","description":""},{"types":[{"type":"Object","options":[]}],"name":"helpers","description":"<p>helper methods for this template</p>"}],"parent":"can.view","description":"","hide":true,"title":"","comment":"undefined@returns {*}\n","src":"can/view/view.js","line":549,"id":458},{"type":"function","name":"renderAs","params":[{"name":"format","description":""},{"name":"view","description":""},{"name":"data","description":""},{"name":"helpers","description":""},{"name":"callback","description":""}],"parent":"can.view","description":"","hide":true,"comment":"undefined@returns {*}\n","src":"can/view/view.js","line":562,"id":459},{"type":"function","name":"registerView","params":[{"types":[{"type":"String"}],"name":"id","description":""},{"types":[{"type":"String"}],"name":"text","description":""},{"types":[{"type":"String"}],"name":"type","description":""},{"types":[{"type":"can.Deferred"}],"name":"def","description":""}],"parent":"can.view","description":"<p>Registers a view with <code>cached</code> object.  This is used\ninternally by this class and Mustache to hookup views.</p>","hide":true,"src":"can/view/view.js","line":676,"id":460},{"name":"can.view.dependency","type":"property","parent":"can.view","description":"<p>should return something like steal(\"dependencies\",function(EJS){\nreturn can.view.preload(\"ID\", options.text)\n})</p>","hide":true,"src":"can/view/view.js","line":719,"id":461},{"name":"can.view.elements","type":"property","parent":"can.view","description":"<p>Provides helper methods for and information about the behavior\nof DOM elements.</p>","types":[{"type":"Object","options":[]}],"title":"","src":"can/view/elements.js","line":6,"id":486,"children":[{"name":"can.view.attr.map","type":"property","parent":"can.view.elements","description":"","types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"String"},{"type":"Boolean"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]}]}],"title":"","hide":true,"src":"can/util/attr/attr.js","line":18,"id":428},{"name":"can.view.elements.attrMap","type":"property","parent":"can.view.elements","description":"","types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"String"},{"type":"Boolean"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}]}]}],"title":"","src":"can/view/elements.js","line":18,"id":487},{"name":"can.view.elements.tagMap","type":"property","parent":"can.view.elements","description":"<p>A mapping of parent node names to child node names that can be inserted within\nthe parent node name.  For example: <code>table: \"tbody\"</code> means that\nif you want a placeholder element within a <code>table</code>, a <code>tbody</code> will be\ncreated.</p>","types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"String"}]}]}],"title":"","src":"can/view/elements.js","line":45,"id":488},{"type":"function","name":"can.view.elements.after","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"HTMLElement"}]}]}],"name":"oldElements","description":""},{"types":[{"type":"DocumentFragment"}],"name":"newFrag","description":""}],"parent":"can.view.elements","description":"<p>Inserts newFrag after oldElements.</p>","title":"","src":"can/view/elements.js","line":95,"id":489},{"type":"function","name":"can.view.elements.replace","params":[{"types":[{"type":"Array","template":[{"types":[{"type":"HTMLElement"}]}]}],"name":"oldElements","description":""},{"types":[{"type":"DocumentFragment"}],"name":"newFrag","description":""}],"parent":"can.view.elements","description":"<p>Replaces <code>oldElements</code> with <code>newFrag</code></p>","title":"","src":"can/view/elements.js","line":113,"id":490}]}]},{"type":"function","name":"can.ejs","description":"<p>EJS provides <strong>live</strong> ERB-style client-side templates. </p>","title":"","parent":"canjs","links":[{"href":"../docco/ejs.html","title":"docco"}],"deprecated":[{"version":"2.1","description":"<p>EJS is incompatable with [can.Component] and should\nbe avoided for new projects. It will still be maintained up to \n3.0 and potentially after. Projects using EJS should consider\nswitching to [can.stache].</p>"}],"signatures":[{"code":"can.ejs( [id,] template )","description":"<p>Creates an instance of an EJS template.</p>","params":[{"types":[{"type":"String"}],"optional":true,"name":"id","description":"<p>If two arguments are passed, the first argument is the id of the \ntemplate that will be registered with [can.view].</p>"},{"types":[{"type":"String"}],"name":"template","description":"<p>The content of the mustache template.</p>"}],"returns":{"types":[{"type":"can.view.renderer"}],"description":"<p>A function that renders the mustache template into\na live documentFragment.</p>"}}],"comment":" ","src":"can/view/ejs/doc/ejs.md","id":197,"children":[{"name":"can.ejs.tags","title":"Tags","type":"group","parent":"can.ejs","description":"","order":1,"id":196,"children":[{"type":"function","name":"can.ejs.tags.comment","description":"","title":"<%# CODE %>","parent":"can.ejs.tags","order":4,"signatures":[{"code":"<%# CODE %>","description":"<p>Used for explicitly for comments.  This will not render anything.</p>\n\n<pre><code>     &lt;%# 'hello world' %&gt;\n</code></pre>","params":[]}],"src":"can/view/ejs/doc/tags.comment.md","id":202},{"type":"function","name":"can.ejs.tags.escaped","description":"","title":"<%= CODE %>","parent":"can.ejs.tags","order":1,"signatures":[{"code":"<%= CODE %>","description":"<p>Runs JS Code and writes the <em>escaped</em> result into the result of the template. This is useful for when you want to show code in your page.</p>\n\n<p>The following results in the user seeing \"my favorite element is &lt;blink>BLINK&lt;blink>\" and not\n<blink>BLINK</blink>.</p>\n\n<pre><code> &lt;div&gt;my favorite element is &lt;%= '&lt;blink&gt;BLINK&lt;/blink&gt;' %&gt;.&lt;/div&gt;\n</code></pre>","params":[]}],"src":"can/view/ejs/doc/tags.escaped.md","id":203},{"type":"function","name":"can.ejs.tags.scriptlet","description":"","title":"<% CODE %>","parent":"can.ejs.tags","order":0,"signatures":[{"code":"<% CODE %>","description":"<p>Runs JavaScript Code.</p>\n\n<p>This type of magic tag does not modify the template but is used for JS control statements \nlike for-loops, if/else, switch, etc.  An example:</p>\n\n<pre><code>&lt;% if( items.attr('length') === 0 ) { %&gt;\n    &lt;tr&gt;&lt;td&gt;You have no items&lt;/td&gt;&lt;/tr&gt;\n&lt;% } else { %&gt;\n    &lt;% items.each(function(item){ %&gt;\n      &lt;tr&gt; .... &lt;/tr&gt;\n    &lt;% }) %&gt;\n&lt;% } %&gt;\n</code></pre>\n\n<p>Variable declarations and control blocks should always be defined in \ntheir own dedicated tags. Live binding leverages this hinting to ensure that logic is declared and executed at its intended scope.</p>\n\n<pre><code>&lt;!-- Each statement has its own dedicated EJS tag --&gt;\n&lt;% var address = person.attr('address') %&gt;\n&lt;% items.each(function(item){ %&gt;\n    &lt;tr&gt; .... &lt;/tr&gt;\n&lt;% }) %&gt;\n&lt;span&gt;&lt;%= address.attr('street') %&gt;&lt;span&gt;\n\n&lt;!-- This won't work! --&gt;\n&lt;%\n  var address = person.attr('address');\n  items.each(function(item) {\n%&gt;\n    &lt;tr&gt; .... &lt;/tr&gt;\n&lt;% }) %&gt;\n&lt;span&gt;&lt;%= address.attr('street') %&gt;&lt;span&gt;\n</code></pre>","params":[]}],"src":"can/view/ejs/doc/tags.scriptlet.md","id":204},{"type":"function","name":"can.ejs.tags.templated","description":"","title":"<%% CODE %>","parent":"can.ejs.tags","order":3,"signatures":[{"code":"<%% CODE %>","description":"<p>Renders &lt;% CODE %> as text in result of the template rather than running CODE itself. This is useful for generators.</p>\n\n<p>The following results in \"&lt;%= 'hello world' %>\" rather than the string \"hello world.\"</p>\n\n<pre><code>     &lt;%%= 'hello world' %&gt;\n</code></pre>","params":[]}],"src":"can/view/ejs/doc/tags.templated.md","id":205},{"type":"function","name":"can.ejs.tags.unescaped","description":"","title":"<%== CODE %>","parent":"can.ejs.tags","order":2,"signatures":[{"code":"<%== CODE %>","description":"<p>Runs JS Code and writes the <em>unescaped</em> result into the result of the template.</p>\n\n<p>The following results in \"my favorite element is <B>B</B>.\". Using <code>&lt;%==</code> is useful\nfor sub-templates.</p>\n\n<pre><code>     &lt;div&gt;my favorite element is &lt;%== '&lt;B&gt;B&lt;/B&gt;' %&gt;.&lt;/div&gt;\n</code></pre>","params":[]}],"src":"can/view/ejs/doc/tags.unescaped.md","id":206}]},{"type":"page","name":"can.ejs.Helpers","description":"","title":"Helpers","parent":"can.ejs","comment":" ","src":"can/view/ejs/doc/helpers.md","id":200}]},{"type":"function","name":"can.mustache","description":"<p>Logic-less [http://mustache.github.io/ mustache] templates with live binding  when used with <a href=\"#can_observe\">can.Maps</a>.</p>","title":"can.mustache","parent":"canjs","release":"2.1","links":[{"href":"../docco/view/mustache/mustache.html","title":"docco"}],"test":"can/view/mustache/test/test.html","plugin":"can/view/mustache","download":"http://canjs.us/release/latest/can.mustache.js","signatures":[{"code":"can.mustache( [id,] template )","description":"<p>Creates an instance of a mustache template.</p>","params":[{"types":[{"type":"String"}],"optional":true,"name":"id","description":"<p>If two arguments are passed, the first argument is the id of the \ntemplate that will be registered with [can.view].</p>"},{"types":[{"type":"String"}],"name":"template","description":"<p>The content of the mustache template.</p>"}],"returns":{"types":[{"type":"can.view.renderer"}],"description":"<p>A function that renders the mustache template into\na live documentFragment.</p>"}}],"comment":" ","api":"can.mustache.tags","src":"can/view/mustache/doc/mustache.md","id":221,"children":[{"name":"can.mustache.methods","title":"Methods","type":"group","parent":"can.mustache","description":"","order":0,"id":216,"children":[{"type":"function","name":"can.mustache.registerHelper","parent":"can.mustache.methods","description":"<p>Register a helper. </p>","title":"registerHelper","signatures":[{"code":"Mustache.registerHelper(name, helper)","description":"","params":[{"types":[{"type":"String"}],"name":"name","description":"<p>The name of the helper.</p>"},{"types":[{"type":"can.mustache.helper"}],"name":"helper","description":"<p>The helper function.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":1622,"id":365},{"type":"function","name":"can.mustache.safeString","parent":"can.mustache.methods","description":"","title":"","signatures":[{"code":"can.mustache.safeString(str)","description":"","params":[{"types":[{"type":"String"}],"name":"str","description":"<p>A string you don't want to become escaped.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>A string flagged by <code>can.mustache</code> as safe, which will\nnot become escaped, even if you use <a href=\"triple slash\">can.mustache.tags.unescaped</a>.</p>"}}],"comment":" ","src":"can/view/mustache/mustache.js","line":1707,"id":368}]},{"name":"can.mustache.pages","title":"Pages","type":"group","parent":"can.mustache","description":"","order":1,"id":217,"children":[{"type":"page","name":"can.mustache.Acquisition","description":"<p>There are number of ways to acquire templates such as: raw text,\nURL, or script tags in the markup.</p>","title":"Template Acquisition","parent":"can.mustache.pages","order":4,"src":"can/view/mustache/doc/acquisition.md","id":208},{"type":"page","name":"can.mustache.Basics","description":"<p>Mustache templates are logic-less templates with a simple syntax. The goal\nwith Mustache is to keep your templates as simple as possible.</p>","title":"Basics","parent":"can.mustache.pages","order":0,"src":"can/view/mustache/doc/basics.md","id":209},{"type":"page","name":"can.mustache.context","description":"<p>When using [can.mustache.Basics tags] in Mustache, the <code>key</code> in <code>[can.mustache.tags.escaped {{key}}]</code> \nreferences a property on the current context object. The default context always points to the data \nobject initially passed to the template.</p>","title":"Paths and Contexts","parent":"can.mustache.pages","order":1,"src":"can/view/mustache/doc/context.md","id":210},{"type":"page","name":"can.mustache.Helpers","description":"<h1>Helpers</h1>","title":"Helpers","parent":"can.mustache.pages","order":3,"src":"can/view/mustache/doc/helpers.md","id":213},{"type":"page","name":"can.mustache.Binding","description":"<p>Live binding refers to templates which update themselves \nas the data used in the mustache tags change.</p>","title":"Live Binding","parent":"can.mustache.pages","order":5,"src":"can/view/mustache/doc/livebinding.md","id":215},{"type":"page","name":"can.mustache.Sections","description":"<p>Sections (<code>[can.mustache.helpers.section {{#key}}]</code> followed by <code>[can.mustache.helpers.close {{/key}}]</code>) have multiple uses \ndepending on what type of object is passed to the section. In all cases, using a section will change \nthe current [can.mustache.context context].</p>","title":"Sections","parent":"can.mustache.pages","order":2,"src":"can/view/mustache/doc/sections.md","id":225}]},{"name":"can.mustache.types","title":"Types","type":"group","parent":"can.mustache","description":"","order":2,"id":218,"children":[{"type":"typedef","name":"can.mustache.helper","description":"<p>A helper function passed to [can.mustache.registerHelper]. </p>","title":"","types":[{"type":"function","returns":{"types":[{"type":"String"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"HTMLElement"}]}]}],"description":"<p>The content to be inserted into\nthe template.</p>"},"params":[{"variable":true,"types":[{"type":"*"}],"optional":true,"name":"arg","description":"<p>Arguments passed from the tag. After the helper\nname, any space seperated [can.mustache.key keys], numbers or \nstrings are passed as arguments. </p>\n\n<p>The following template:</p>\n\n<pre><code>&lt;p&gt;{{madLib \"Lebron James\" verb 4}}&lt;/p&gt;\n</code></pre>\n\n<p>Rendered with</p>\n\n<pre><code>{verb: \"swept\"}\n</code></pre>\n\n<p>Will call a <code>madLib</code> helper with the following arguements.</p>\n\n<pre><code>can.mustache.registerHelper('madLib', \n  function(subject, verb, number){\n    // subject -&gt; \"Lebron James\"\n    // verb -&gt; \"swept\"\n    // number -&gt; 4\n});\n</code></pre>\n\n<p>While keys are normally resolved as basic objects like strings or numbers, \nthere are special cases where they act differently than a normal \ntag. Whenever a [can.compute] or function \nobject is an argument for a helper, the original object is used \nas the argument instead of the value that the function returns.</p>\n\n<p>If a [can.mustache.key] represents a [can.Map] attribute,\nit is converted to a [can.compute] getter/setter \nfunction. This enables 2-way binding helpers.  </p>\n\n<p>For example, the following helper two-way binds an input element's\nvalue to a [can.compute]:</p>\n\n<pre><code>can.mustache.registerHelper('value',function(value){\n    return function(el){\n      value.bind(\"change\",function(ev, newVal){\n        el.value = newVal;\n      })\n      el.onchange = function(){\n        value(this.value);\n      }\n      el.value = value();\n    }\n});\n</code></pre>\n\n<p>And used by the following template:</p>\n\n<pre><code>&lt;input type=\"text\" {{me.value name}}/&gt;\n</code></pre>\n\n<p>And rendered with:</p>\n\n<pre><code>{me: new can.Map({name: \"Payal\"})}\n</code></pre>"},{"types":[{"type":"can.mustache.helperOptions"}],"name":"options","description":"<p>An options object\nthat gets populated with optional:</p>\n\n<ul>\n<li><code>fn</code> and <code>inverse</code> section rendering functions </li>\n<li>a <code>hash</code> object of the maps passed to the helper</li>\n</ul>"}],"context":{"types":[{"type":"can.mustache.context"}],"description":"<p>The context the helper was \ncalled within.</p>"}}],"parent":"can.mustache.types","comment":" ","src":"can/view/mustache/doc/helper.md","id":211},{"type":"typedef","name":"can.mustache.helperOptions","description":"<p>The options argument passed to a [can.mustache.helper helper function]. </p>","title":"helperOptions","types":[{"type":"Object","options":[{"name":"fn","types":[{"type":"can.mustache.sectionRenderer"}],"description":"<p>Provided if a \n[can.mustache.helpers.sectionHelper section helper] is called.  Call <code>fn</code> to\nrender the BLOCK with the specified <code>context</code>.</p>","optional":true},{"name":"inverse","types":[{"type":"can.mustache.sectionRenderer"}],"description":"<p>Provided if a \n[can.mustache.helpers.sectionHelper section helper] is called \nwith [can.mustache.helpers.else {{else}}].  Call <code>inverse</code> to\nrender the INVERSE with the specified <code>context</code>.</p>","optional":true},{"name":"hash","types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"*"},{"type":"String"},{"type":"Number"}]}]}],"description":"<p>An object containing all of the final \narguments listed as <code>name=value</code> pairs for the helper.</p>\n\n<pre><code>{{helper arg1 arg2 name=value other=3 position=\"top\"}}\n\noptions.hash = {\n    name: &lt;context_lookup&gt;.value,\n    other: 3,\n    position: \"top\"\n}\n</code></pre>"},{"name":"context","description":"<p>The current context the mustache helper is called within.</p>\n\n<pre><code>var temp = can.mustache(\n  \"{{#person.name}}{{helper}}{{/person.name}}\");\n\nvar data = {person: {name: {first: \"Justin\"}}};\n\ncan.mustache.registerHelper(\"helper\", function(options){\n\n  options.context === data.person //-&gt; true\n\n})\n\n\ntemp(data);\n</code></pre>","types":[{"type":"*"}]},{"name":"scope","description":"<p>An object that represents the current context and all parent \ncontexts.  It can be used to look up [can.mustache.key key] values in the current scope.</p>\n\n<pre><code>var temp = can.mustache(\n  \"{{#person.name}}{{helper}}{{/person.name}}\");\n\nvar data = {person: {name: {first: \"Justin\"}}};\n\ncan.mustache.registerHelper(\"helper\", function(options){\n\n  options.scope.attr(\"first\")   //-&gt; \"Justin\"\n  options.scope.attr(\"person\")  //-&gt; data.person\n\n})\n\n\ntemp(data);\n</code></pre>","types":[{"type":"can.view.Scope"}]},{"name":"options","description":"<p>An object that represents the local mustache helpers.  It can be used to look \nup [can.mustache.key key] values</p>\n\n<pre><code>var temp = can.mustache(\n  \"{{#person.name}}{{helper}}{{/person.name}}\");\n\nvar data = {person: {name: {first: \"Justin\"}}};\n\ncan.mustache.registerHelper(\"helper\", function(options){\n\n  options.options.attr(\"helpers.specialHelper\")   //-&gt; function(){ ... }\n\n})\n\n\ntemp(data, {\n  specialHelper: function(){ ... }\n});\n</code></pre>","types":[{"type":"can.view.Options"}]}]}],"parent":"can.mustache.types","src":"can/view/mustache/doc/helperOptions.md","id":212},{"type":"typedef","name":"can.mustache.key","description":"<p>A key references a value within the current [can.mustache.context context] of a \ntemplate being rendered. In the following example, the \nkey is <code>name</code>:</p>","title":"key","types":[{"type":"String"}],"parent":"can.mustache.types","src":"can/view/mustache/doc/key.md","id":214},{"type":"typedef","name":"can.mustache.sectionRenderer","description":"<p>Renders a section. These functions are usually provided as <code>.fn</code> and <code>.inverse</code> on a mustache helper's [can.mustache.helperOptions options].</p>","title":"sectionRenderer","types":[{"type":"function","returns":{"types":[{"type":"String"}],"description":"<p>Returns the rendered result of the helper.</p>"},"params":[{"types":[{"type":"*"},{"type":"can.view.Scope"}],"optional":true,"name":"context","description":"<p>Specifies the data the section is rendered \nwith.  If a [can.view.Scope] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current scope as it's parent.  If nothing is provided, the current\nscope is used to render the section.</p>"},{"types":[{"type":"*"},{"type":"can.view.Options"}],"optional":true,"name":"helpers","description":"<p>Specifies the helpers the section is rendered \nwith.  If a [can.view.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.</p>"}]}],"parent":"can.mustache.types","comment":" ","src":"can/view/mustache/doc/sectionRenderer.md","id":224}]},{"name":"can.mustache.tags","title":"Basic Tags","type":"group","parent":"can.mustache","description":"","order":3,"id":219,"children":[{"type":"function","name":"can.mustache.helpers.partial","description":"","title":"{{>key}}","parent":"can.mustache.tags","order":6,"signatures":[{"code":"{{>key}}","description":"<p>Render another template within the current template.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent \n[can.mustache.context context]. If the value is a function or [can.compute], the \nfunction's return value is used.</p>\n\n<p>If the key value is:</p>\n\n<ul>\n<li><p><code>undefined</code> - the key's name (ex: user.mustache in <code>{{&gt;user.mustache}}</code>) is used to\nlook up a template using [can.view].</p></li>\n<li><p><code>string</code> - the string value is used to lookup a view in [can.view].</p></li>\n<li><p><code>function</code> - the function is called with the current scope.</p></li>\n</ul>\n\n<p>[can.view] looks for a template in the following places:</p>\n\n<ol>\n<li>A registered view</li>\n<li>An id of an element</li>\n<li>A url to load the template.</li>\n</ol>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The value of the rendered template is inserted into\nthe page.</p>"}}],"comment":" ","src":"can/view/mustache/doc/partials.md","id":223},{"type":"function","description":"<p>Insert the value of the [can.mustache.key key] into the output of the template.</p>","title":"{{key}}","name":"can.mustache.tags.escaped","parent":"can.mustache.tags","order":0,"signatures":[{"code":"{{key}}","description":"","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references one of the following:</p>\n\n<ul>\n<li>A [can.mustache.registerHelper registered helper].</li>\n<li>A value within the current or parent\n[can.mustache.context context]. If the value is a function or [can.compute], the\nfunction's return value is used.</li>\n</ul>"}],"returns":{"types":[{"type":"String"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"*"}],"description":"<p>After the key's value is found (and set to any function's return value),\nit is passed to [can.view.txt] as the result of a call to its <code>func</code>\nargument. There, if the value is a:</p>\n\n<ul>\n<li><code>null</code> or <code>undefined</code> - an empty string is inserted into the rendered template result.</li>\n<li><code>String</code> or <code>Number</code> - the value is inserted into the rendered template result.</li>\n<li><code>Function</code> - A [can.view.hook hookup] attribute or element is inserted so this function\nwill be called back with the DOM element after it is created.</li>\n</ul>"}}],"comment":" ","src":"can/view/mustache/mustache.js","line":187,"id":350},{"type":"function","description":"<p>A comment that doesn't get inserted into the rendered result. </p>","title":"{{!key}}","name":"can.mustache.tags.comment","parent":"can.mustache.tags","order":7,"signatures":[{"code":"{{!key}}","description":"<p>The comment tag operates similarly to a <code>&lt;!-- --&gt;</code> tag in HTML. It exists in your template but never shows up.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>Everything within this tag is completely ignored.</p>"}],"returns":{"types":[{"type":"String"}],"description":""}}],"src":"can/view/mustache/mustache.js","line":288,"id":351},{"description":"<p>Insert the unescaped value of the [can.mustache.key key] into the output of the template.</p>","title":"{{{key}}}","name":"can.mustache.tags.unescaped","type":"function","parent":"can.mustache.tags","order":1,"signatures":[{"code":"{{{key}}}","description":"<p>Behaves just like [can.mustache.tags.escaped {{key}}] and [can.mustache.helpers.helper {{helper}}] but does not\nescape the result.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's return value is used.</p>"}],"returns":{"types":[{"type":"String"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"*"}],"description":""}}],"src":"can/view/mustache/mustache.js","line":305,"id":352},{"type":"function","description":"<p>Insert the unescaped value of the [can.mustache.key key] into the output of the template.</p>","title":"{{&key}}","name":"can.mustache.tags.unescaped2","parent":"can.mustache.tags","order":2,"signatures":[{"code":"{{&key}}","description":"<p>The <code>{{&amp;key}}</code> tag is an alias for [can.mustache.tags.unescaped {{{key}}}], behaving just\nlike [can.mustache.tags.escaped {{key}}] and [can.mustache.helpers.helper {{helper}}] but does not\nescape the result.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's return value is used.</p>"}],"returns":{"types":[{"type":"String"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"*"}],"description":""}}],"src":"can/view/mustache/mustache.js","line":325,"id":353},{"description":"","title":"{{#key}}","name":"can.mustache.helpers.section","type":"function","parent":"can.mustache.tags","order":3,"signatures":[{"code":"{{#key}}BLOCK{{/key}}","description":"<p>Render blocks of text one or more times, depending\non the value of the key in the current context.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\n[can.mustache.context context]. If the value is a function or [can.compute], the\nfunction's return value is used.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>Depending on the value's type, the following actions happen:</p>\n\n<ul>\n<li><code>Array</code> or [can.List] - the block is rendered for\neach item in the array. The [can.mustache.context context] is set to\nthe item within each block rendering.</li>\n<li>A <code>truthy</code> value - the block is rendered with the [can.mustache.context context]\nset to the value.</li>\n<li>A <code>falsey</code> value - the block is not rendered.</li>\n</ul>\n\n<p>The rendered result of the blocks, block or an empty string is returned.</p>"}}],"comment":" ","src":"can/view/mustache/mustache.js","line":716,"id":355},{"type":"function","description":"","title":"{{^key}}","name":"can.mustache.helpers.inverse","parent":"can.mustache.tags","order":5,"signatures":[{"code":"{{^key}}BLOCK{{/key}}","description":"<p>Render blocks of text if the value of the key\nis falsey.  An inverted section syntax is similar to regular\nsections except it begins with a caret rather than a\npound. If the value referenced is falsey, the section will render.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\n[can.mustache.context context]. If the value is a function or [can.compute], the\nfunction's return value is used.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>Depending on the value's type, the following actions happen:</p>\n\n<ul>\n<li>A <code>truthy</code> value - the block is not rendered.</li>\n<li>A <code>falsey</code> value - the block is rendered.</li>\n</ul>\n\n<p>The rendered result of the block or an empty string is returned.</p>"}}],"comment":" ","src":"can/view/mustache/mustache.js","line":1118,"id":358},{"type":"function","description":"","title":"{{/key}}","name":"can.mustache.helpers.close","parent":"can.mustache.tags","order":4,"signatures":[{"code":"{{/key}}","description":"<p>Ends a [can.mustache.helpers.section {{#key}}] or [can.mustache.helpers.sectionHelper {{#helper}}]\nblock.</p>","params":[{"types":[{"type":"can.mustache.key"}],"optional":true,"name":"key","description":"<p>A key that matches the opening key or helper name. It's also\npossible to simply write <code>{{/}}</code> to end a block.</p>"}]}],"src":"can/view/mustache/mustache.js","line":1188,"id":359}]},{"name":"can.mustache.htags","title":"Helper Tags","type":"group","parent":"can.mustache","description":"","order":4,"id":220,"children":[{"type":"function","description":"","title":"{{data name}}","name":"can.mustache.helpers.data","parent":"can.mustache.htags","order":7,"signatures":[{"code":"{{data name}}","description":"<p>Adds the current [can.mustache.context context] to the\nelement's [can.data].</p>","params":[{"types":[{"type":"String"}],"name":"name","description":"<p>The name of the data attribute to use for the\ncontext.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":426,"id":354},{"description":"<p>Calls a mustache helper function and inserts its return value into the rendered template.</p>","title":"{{helper args hashes}}","name":"can.mustache.helpers.helper","type":"function","parent":"can.mustache.htags","order":0,"signatures":[{"code":"{{helper [args...] [hashProperty=hashValue...]}}","description":"<p>Calls a mustache helper function or a function. For example:</p>\n\n<p>The template:</p>\n\n<pre><code>&lt;p&gt;{{madLib \"Lebron James\" verb 4 foo=\"bar\"}}&lt;/p&gt;\n</code></pre>\n\n<p>Rendered with:</p>\n\n<pre><code>{verb: \"swept\"}\n</code></pre>\n\n<p>Will call a <code>madLib</code> helper with the following arguements:</p>\n\n<pre><code>can.mustache.registerHelper('madLib',\n  function(subject, verb, number, options){\n    // subject -&gt; \"Lebron James\"\n    // verb -&gt; \"swept\"\n    // number -&gt; 4\n    // options.hash.foo -&gt; \"bar\"\n});\n</code></pre>","params":[{"types":[{"type":"can.mustache.key"}],"name":"helper","description":"<p>A key that finds a [can.mustache.helper helper function]\nthat is either [can.mustache.registerHelper registered] or found within the\ncurrent or parent [can.mustache.context context].</p>"},{"variable":true,"types":[{"type":"can.mustache.key"},{"type":"String"},{"type":"Number"}],"optional":true,"name":"args","description":"<p>Space seperated arguments\nthat get passed to the helper function as arguments. If the key's value is a:</p>\n\n<ul>\n<li>[can.Map] - A getter/setter [can.compute] is passed.</li>\n<li>[can.compute] - The can.compute is passed.</li>\n<li><code>function</code> - The function's return value is passed.</li>\n</ul>"},{"types":[{"type":"String"}],"name":"hashProperty","description":"<p>A property name that gets added to a [can.mustache.helperOptions helper options]'s\nhash object.</p>"},{"variable":true,"types":[{"type":"can.mustache.key"},{"type":"String"},{"type":"Number"}],"name":"hashValue","description":"<p>A value that gets\nset as a property value of the [can.mustache.helperOptions helper option argument]'s\nhash object.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":814,"id":356},{"type":"function","description":"<p>Calls a mustache helper function with a block, and optional inverse\nblock.</p>","title":"{{#helper args hashes}}","name":"can.mustache.helpers.sectionHelper","parent":"can.mustache.htags","order":1,"signatures":[{"code":"{{#helper [args...] [hashName=hashValue...]}}BLOCK{{/helper}}","description":"<p>Calls a mustache helper function or a function with a block to\nrender.</p>\n\n<p>The template:</p>\n\n<pre><code>&lt;p&gt;{{countTo number}}{{num}}{{/countTo}}&lt;/p&gt;\n</code></pre>\n\n<p>Rendered with:</p>\n\n<pre><code>{number: 5}\n</code></pre>\n\n<p>Will call the <code>countTo</code> helper:</p>\n\n<pre><code>can.mustache.registerHelper('madLib',\n  function(number, options){\n    var out = []\n    for(var i =0; i &lt; number; i++){\n      out.push( options.fn({num: i+1}) )\n    }\n    return out.join(\" \")\n});\n</code></pre>\n\n<p>Results in:</p>\n\n<pre><code>&lt;p&gt;1 2 3 4 5&lt;/p&gt;\n</code></pre>","params":[{"types":[{"type":"can.mustache.key"}],"name":"helper","description":"<p>A key that finds a [can.mustache.helper helper function]\nthat is either [can.mustache.registerHelper registered] or found within the\ncurrent or parent [can.mustache.context context].</p>"},{"variable":true,"types":[{"type":"can.mustache.key"},{"type":"String"},{"type":"Number"}],"optional":true,"name":"args","description":"<p>Space seperated arguments\nthat get passed to the helper function as arguments. If the key's value is a:</p>\n\n<ul>\n<li>[can.Map] - A getter/setter [can.compute] is passed.</li>\n<li>[can.compute] - The can.compute is passed.</li>\n<li><code>function</code> - The function's return value is passed.</li>\n</ul>"},{"types":[{"type":"String"}],"name":"hashProperty","description":"<p>A property name that gets added to a [can.mustache.helperOptions helper options]'s\nhash object.</p>"},{"variable":true,"types":[{"type":"can.mustache.key"},{"type":"String"},{"type":"Number"}],"name":"hashValue","description":"<p>A value that gets\nset as a property value of the [can.mustache.helperOptions helper option argument]'s\nhash object.</p>"},{"types":[{"type":"mustache"}],"name":"BLOCK","description":"<p>A mustache template that gets compiled and\npassed to the helper function as the [can.mustache.helperOptions options argument's] <code>fn</code>\nproperty.</p>"}]},{"code":"{{#helper [args...] [hashName=hashValue...]}}BLOCK{{else}}INVERSE{{/helper}}","description":"<p>Calls a mustache helper function or a function with a <code>fn</code> and <code>inverse</code> block to\nrender.</p>\n\n<p>The template:</p>\n\n<pre><code>&lt;p&gt;The bed is\n   {{isJustRight firmness}}\n      pefect!\n   {{else}}\n      uncomfortable.\n   {{/justRight}}&lt;/p&gt;\n</code></pre>\n\n<p>Rendered with:</p>\n\n<pre><code>{firmness: 45}\n</code></pre>\n\n<p>Will call the <code>isJustRight</code> helper:</p>\n\n<pre><code>can.mustache.registerHelper('isJustRight',\n  function(number, options){\n    if(number &gt; 50){\n      return options.fn(this)\n    } else {\n      return options.inverse(this)\n    }\n    return out.join(\" \")\n});\n</code></pre>\n\n<p>Results in:</p>\n\n<pre><code>&lt;p&gt;The bed is uncomfortable.&lt;/p&gt;\n</code></pre>","params":[{"types":[{"type":"can.mustache.key"}],"name":"helper","description":"<p>A key that finds a [can.mustache.helper helper function]\nthat is either [can.mustache.registerHelper registered] or found within the\ncurrent or parent [can.mustache.context context].</p>"},{"variable":true,"types":[{"type":"can.mustache.key"},{"type":"String"},{"type":"Number"}],"optional":true,"name":"args","description":"<p>Space seperated arguments\nthat get passed to the helper function as arguments. If the key's value is a:</p>\n\n<ul>\n<li>[can.Map] - A getter/setter [can.compute] is passed.</li>\n<li>[can.compute] - The can.compute is passed.</li>\n<li><code>function</code> - The function's return value is passed.</li>\n</ul>"},{"types":[{"type":"String"}],"name":"hashProperty","description":"<p>A property name that gets added to a [can.mustache.helperOptions helper options]'s\nhash object.</p>"},{"variable":true,"types":[{"type":"can.mustache.key"},{"type":"String"},{"type":"Number"}],"name":"hashValue","description":"<p>A value that gets\nset as a property value of the [can.mustache.helperOptions helper option argument]'s\nhash object.</p>"},{"types":[{"type":"mustache"}],"name":"BLOCK","description":"<p>A mustache template that gets compiled and\npassed to the helper function as the [can.mustache.helperOptions options argument's] <code>fn</code>\nproperty.</p>"},{"types":[{"type":"mustache"}],"name":"INVERSE","description":"<p>A mustache template that gets compiled and\npassed to the helper function as the [can.mustache.helperOptions options argument's] <code>inverse</code>\nproperty.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":979,"id":357},{"type":"function","description":"","title":"{{else}}","name":"can.mustache.helpers.else","parent":"can.mustache.htags","order":3,"signatures":[{"code":"{{#helper}}BLOCK{{else}}INVERSE{{/helper}}","description":"<p>Creates an <code>inverse</code> block for a [can.mustache.helper helper function]'s\n[can.mustache.helperOptions options argument]'s <code>inverse</code> property.</p>","params":[{"types":[{"type":"can.mustache"}],"name":"INVERSE","description":"<p>a mustache template coverted to a\nfunction and set as the [can.mustache.helper helper function]'s\n[can.mustache.helperOptions options argument]'s <code>inverse</code> property.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":1268,"id":360},{"type":"function","name":"can.mustache.helpers.if","parent":"can.mustache.htags","description":"","title":"{{#if key}}","order":2,"signatures":[{"code":"{{#if key}}BLOCK{{/if}}","description":"<p>Renders the <code>BLOCK</code> template within the current template.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's return value is used.</p>"},{"types":[{"type":"can.mustache"}],"name":"BLOCK","description":"<p>A mustache template.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>If the key's value is truthy, the <code>BLOCK</code> is rendered with the\ncurrent context and its value is returned; otherwise, an empty string.</p>"}}],"comment":" ","src":"can/view/mustache/mustache.js","line":1768,"id":369},{"type":"function","name":"can.mustache.helpers.unless","parent":"can.mustache.htags","description":"","title":"{{#unless key}}","order":4,"signatures":[{"code":"{{#unless key}}BLOCK{{/unless}}","description":"<p>Render the block of text if the key's value is falsey.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's\nreturn value is used.</p>"},{"types":[{"type":"can.mustache"}],"name":"BLOCK","description":"<p>A template that is rendered\nif the <code>key</code>'s value is falsey.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":1843,"id":370},{"type":"function","name":"can.mustache.helpers.each","parent":"can.mustache.htags","description":"","title":"{{#each key}}","order":5,"signatures":[{"code":"{{#each key}}BLOCK{{/each}}","description":"<p>Render the block of text for each item in key's value.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's\nreturn value is used.</p>\n\n<p>If the value of the key is a [can.List], the resulting HTML is updated when the\nlist changes. When a change in the list happens, only the minimum amount of DOM\nelement changes occur.</p>\n\n<p>If the value of the key is a [can.Map], the resulting HTML is updated whenever\nattributes are added or removed. When a change in the map happens, only\nthe minimum amount of DOM element changes occur.</p>"},{"types":[{"type":"can.mustache"}],"name":"BLOCK","description":"<p>A template that is rendered for each item in\nthe <code>key</code>'s value. The <code>BLOCK</code> is rendered with the context set to the item being rendered.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":1875,"id":371},{"type":"function","name":"can.mustache.helpers.with","parent":"can.mustache.htags","description":"","title":"{{#with key}}","order":6,"signatures":[{"code":"{{#with key}}BLOCK{{/with}}","description":"<p>Changes the context within a block.</p>","params":[{"types":[{"type":"can.mustache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's\nreturn value is used.</p>"},{"types":[{"type":"can.mustache"}],"name":"BLOCK","description":"<p>A template that is rendered\nwith the context of the <code>key</code>'s value.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":2006,"id":372},{"type":"function","name":"can.mustache.helpers.log","parent":"can.mustache.htags","description":"","title":"{{log}}","order":9,"signatures":[{"code":"{{#log [message]}}","description":"<p>Logs the context of the current block with an optional message.</p>","params":[{"types":[{"type":"*"}],"name":"message","description":"<p>An optional message to log out in addition to the\ncurrent context.</p>"}]}],"src":"can/view/mustache/mustache.js","line":2038,"id":373},{"description":"","title":"{{(el)->CODE}}","name":"can.mustache.helpers.elementCallback","type":"function","parent":"can.mustache.htags","order":8,"signatures":[{"code":"{{(el) -> CODE}}","description":"<p>Executes an element callback with the inline code on the element.</p>","params":[{"types":[{"type":"String"}],"name":"code","description":"<p>The inline code to execute on the element.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":2059,"id":374},{"description":"","title":"{{@index}}","name":"can.mustache.helpers.index","type":"function","parent":"can.mustache.htags","order":10,"signatures":[{"code":"{{@index [offset]}}","description":"<p>Insert the index of an Array or can.List we are iterating on with <a href=\"can.mustache.helpers.each\">#each</a></p>","params":[{"types":[{"type":"Number"}],"name":"offset","description":"<p>The number to optionally offset the index by.</p>"}]}],"comment":" ","src":"can/view/mustache/mustache.js","line":2082,"id":375},{"type":"function","description":"","title":"{{@key}}","name":"can.mustache.helpers.key","parent":"can.mustache.htags","order":11,"signatures":[{"code":"{{@key}}","description":"<p>Insert the property name of an Object or attribute name of a can.Map that we iterate over with <a href=\"can.mustache.helpers.each\">#each</a></p>","params":[]}],"comment":" ","src":"can/view/mustache/mustache.js","line":2122,"id":376}]}]},{"type":"function","name":"can.stache","description":"<p>Logic-less Handlebar and Mustache templates with live binding. </p>","title":"","parent":"canjs","release":"2.1","links":[{"href":"../docco/view/stache/mustache_core.html","title":"docco"}],"test":"can/view/stache/test/test.html","plugin":"can/view/stache","download":"http://canjs.us/release/latest/can.stache.js","signatures":[{"code":"can.stache(template)","description":"<p>Processes the template and returns a [can.view.renderer] function that renders the template\nwith data and local helpers.</p>","params":[{"types":[{"type":"String"}],"name":"template","description":"<p>The text of a mustache template.</p>"}],"returns":{"types":[{"type":"can.view.renderer"}],"description":"<p>A renderer function that returns a live document fragment\nthat can be inserted in the page.</p>"}}],"comment":" ","api":"can.stache.tags","src":"can/view/stache/doc/stashe.md","id":272,"children":[{"name":"can.stache.static","title":"Methods","type":"group","parent":"can.stache","description":"","order":0,"id":267,"children":[{"type":"function","name":"can.stache.registerHelper","description":"<p>Register a helper. </p>","title":"registerHelper","parent":"can.stache.static","signatures":[{"code":"can.stache.registerHelper(name, helper)","description":"","params":[{"types":[{"type":"String"}],"name":"name","description":"<p>The name of the helper.</p>"},{"types":[{"type":"can.stache.helper"}],"name":"helper","description":"<p>The helper function.</p>"}]}],"comment":" ","src":"can/view/stache/doc/helpers/registerHelper.md","id":255},{"type":"function","name":"can.stache.safeString","description":"","title":"","parent":"can.stache.static","signatures":[{"code":"can.stache.safeString(str)","description":"","params":[{"types":[{"type":"String"}],"name":"str","description":"<p>A string you don't want to become escaped.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>A string flagged by <code>can.mustache</code> as safe, which will\nnot become escaped, even if you use <a href=\"triple slash\">can.stache.tags.unescaped</a>.</p>"}}],"comment":" ","src":"can/view/stache/doc/safeString.md","id":264}]},{"name":"can.stache.pages","title":"Pages","type":"group","parent":"can.stache","description":"","order":1,"id":268,"children":[{"type":"page","name":"can.stache.Acquisition","description":"<p>There are number of ways to acquire templates such as: raw text,\nURL, or script tags in the markup.</p>","title":"Template Acquisition","parent":"can.stache.pages","order":4,"src":"can/view/stache/doc/acquisition.md","id":242},{"type":"page","name":"can.stache.Basics","description":"<p>Stache templates are logic-less templates with a simple syntax. The goal\nwith Stache is to keep your templates as simple as possible.</p>","title":"Basics","parent":"can.stache.pages","order":0,"src":"can/view/stache/doc/basics.md","id":243},{"type":"page","name":"can.stache.context","description":"<p>When using [can.stache.Basics tags] in Stache, the <code>key</code> in <code>[can.stache.tags.escaped {{key}}]</code> \nreferences a property on the current context object. The default context always points to the data \nobject initially passed to the template.</p>","title":"Paths and Contexts","parent":"can.stache.pages","order":1,"src":"can/view/stache/doc/context.md","id":244},{"type":"page","name":"can.stache.Helpers","description":"<h1>Helpers</h1>","title":"Helpers","parent":"can.stache.pages","order":3,"src":"can/view/stache/doc/helpers.md","id":259},{"type":"page","name":"can.stache.Binding","description":"<p>Live binding refers to templates which update themselves \nas the data used in the stache tags change.</p>","title":"Live Binding","parent":"can.stache.pages","order":5,"src":"can/view/stache/doc/livebinding.md","id":261},{"type":"page","name":"can.stache.Sections","description":"<p>Sections (<code>[can.stache.tags.section {{#key}}]</code> followed by <code>[can.stache.helpers.close {{/key}}]</code>) have multiple uses \ndepending on what type of object is passed to the section. In all cases, using a section will change \nthe current [can.stache.context context].</p>","title":"Sections","parent":"can.stache.pages","order":2,"src":"can/view/stache/doc/sections.md","id":266}]},{"name":"can.stache.types","title":"Types","type":"group","parent":"can.stache","description":"","order":2,"id":269,"children":[{"type":"typedef","name":"can.stache.helper","description":"<p>A helper function passed to [can.stache.registerHelper]. </p>","title":"","types":[{"type":"function","returns":{"types":[{"type":"documentFragment"},{"type":"String"},{"type":"can.contentArray"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[{"types":[{"type":"HTMLElement"}]}]}],"description":"<p>The content to be inserted into\nthe template.</p>"},"params":[{"variable":true,"types":[{"type":"*"},{"type":"can.compute"}],"optional":true,"name":"arg","description":"<p>Arguments passed from the tag. After the helper\nname, any space seperated [can.stache.key keys], numbers or \nstrings are passed as arguments. [can.stache.key Keys] that \nread an observable value are passed as [can.compute]'s.</p>"},{"types":[{"type":"can.stache.helperOptions"}],"name":"options","description":"<p>An options object\nthat gets populated with optional:</p>\n\n<ul>\n<li><code>fn</code> and <code>inverse</code> section rendering functions </li>\n<li>a <code>hash</code> object of the maps passed to the helper</li>\n</ul>"}],"context":{"types":[{"type":"can.stache.context"}],"description":"<p>The context the helper was \ncalled within.</p>"}}],"parent":"can.stache.types","comment":" ","src":"can/view/stache/doc/helper.md","id":245},{"type":"typedef","name":"can.stache.helperOptions","description":"<p>The options argument passed to a [can.stache.helper helper function]. </p>","title":"helperOptions","types":[{"type":"Object","options":[{"name":"fn","types":[{"type":"can.stache.sectionRenderer"}],"description":"<p>Renders the \"truthy\" subsection \nBLOCK.  <code>options.fn</code> is only available if the helper is called as a \n[can.stache.tags.section section] or [can.stache.tags.inverse inverse section] like:\n<code>{{#helper}}</code> or `{{^helper}}.  The subsection BLOCK's </p>\n\n<p>Available if the helper is called \nas a section or inverse section. \n[can.stache.helpers.sectionHelper section helper] is called.  Call <code>fn</code> to\nrender the BLOCK with the specified <code>context</code>.</p>","optional":true},{"name":"inverse","types":[{"type":"can.stache.sectionRenderer"}],"description":"<p>Provided if a \n[can.stache.helpers.sectionHelper section helper] is called \nwith [can.stache.helpers.else {{else}}].  Call <code>inverse</code> to\nrender the INVERSE with the specified <code>context</code>.</p>","optional":true},{"name":"hash","types":[{"type":"Object","template":[{"types":[{"type":"String"}]},{"types":[{"type":"*"},{"type":"String"},{"type":"Number"}]}]}],"description":"<p>An object containing all of the final \narguments listed as <code>name=value</code> pairs for the helper.</p>\n\n<pre><code>{{helper arg1 arg2 name=value other=3 position=\"top\"}}\n\noptions.hash = {\n    name: &lt;context_lookup&gt;.value,\n    other: 3,\n    position: \"top\"\n}\n</code></pre>"},{"name":"context","description":"<p>The current context the stache helper is called within.</p>\n\n<pre><code>var temp = can.stache(\n  \"{{#person.name}}{{helper}}{{/person.name}}\");\n\nvar data = {person: {name: {first: \"Justin\"}}};\n\ncan.stache.registerHelper(\"helper\", function(options){\n\n  options.context === data.person //-&gt; true\n\n})\n\n\ntemp(data);\n</code></pre>","types":[{"type":"*"}]},{"name":"scope","description":"<p>An object that represents the current context and all parent \ncontexts.  It can be used to look up [can.stache.key key] values in the current scope.</p>\n\n<pre><code>var temp = can.stache(\n  \"{{#person.name}}{{helper}}{{/person.name}}\");\n\nvar data = {person: {name: {first: \"Justin\"}}};\n\ncan.stache.registerHelper(\"helper\", function(options){\n\n  options.scope.attr(\"first\")   //-&gt; \"Justin\"\n  options.scope.attr(\"person\")  //-&gt; data.person\n\n})\n\n\ntemp(data);\n</code></pre>","types":[{"type":"can.view.Scope"}]},{"name":"options","description":"<p>An object that represents the local stache helpers.  It can be used to look \nup [can.stache.key key] values</p>\n\n<pre><code>var temp = can.stache(\"{{#person.name}}{{helper}}{{/person.name}}\");\n\nvar data = {person: {name: \"Justin\"}};\n\ncan.stache.registerHelper(\"helper\", function(options){\n\n  options.options.attr(\"helpers.specialHelper\") //-&gt; function\n\n})\n\n\ntemp(data, {\n  specialHelper: function(){ ... }\n});\n</code></pre>","types":[{"type":"can.view.Options"}]}]}],"parent":"can.stache.types","src":"can/view/stache/doc/helperOptions.md","id":246},{"type":"typedef","name":"can.stache.key","description":"","title":"key","types":[{"type":"String","description":"<p>A key specifies a value in the [can.view.Scope scope] or \n[can.view.Options options] of a template being rendered. The\nkey is used to look up a value in the scope.</p>\n\n<p>What the key looks like changes the behavior of how a value is looked up in \nthe scope. Keys can look like:</p>\n\n<ul>\n<li><code>{{name}}</code> - a single property name.</li>\n<li><code>{{name.first}}</code> - multiple property names.</li>\n<li><code>{{foo\\\\.bar}}</code> - a single property name that includes a dot character.</li>\n<li><code>{{./name}}</code> - looks up a single property in the current context.</li>\n<li><code>{{../name}}</code> - looks up a single property in the parent context.</li>\n<li><code>{{.}}</code> or <code>{{this}}</code> - looks up the current context.</li>\n<li><code>@index</code> - The index of a value in an array or [can.List].</li>\n<li><code>@key</code> - The property name of a value within an object or [can.Map].</li>\n</ul>"}],"parent":"can.stache.types","comment":" ","src":"can/view/stache/doc/key.md","id":260},{"type":"typedef","name":"can.stache.sectionRenderer","description":"<p>Renders a section. These functions are usually provided as <code>.fn</code> and <code>.inverse</code> on a stache helper's [can.stache.helperOptions options].</p>","title":"sectionRenderer","types":[{"type":"function","returns":{"types":[{"type":"documentFragment"},{"type":"String"}],"description":"<p>Returns the rendered result of the helper. If the\nsection is within a tag, like:</p>\n\n<pre><code>&lt;h1 {{#helper}}class='power'{{/helper}}&gt;\n</code></pre>\n\n<p>a String is returned.  </p>\n\n<p>If the section is outside a tag like: </p>\n\n<pre><code>&lt;div&gt; {{#helper}}&lt;h2&gt;Tasks&lt;/h2&gt;{{/helper}} &lt;/div&gt;\n</code></pre>\n\n<p>a documentFragment is returned.</p>"},"params":[{"types":[{"type":"*"},{"type":"can.view.Scope"}],"optional":true,"name":"context","description":"<p>Specifies the data the section is rendered \nwith.  If a [can.view.Scope] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current scope as it's parent.  If nothing is provided, the current\nscope is used to render the section.</p>"},{"types":[{"type":"*"},{"type":"can.view.Options"}],"optional":true,"name":"helpers","description":"<p>Specifies the helpers the section is rendered \nwith.  If a [can.view.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.</p>"}]}],"parent":"can.stache.types","comment":" ","src":"can/view/stache/doc/sectionRenderer.md","id":265}]},{"name":"can.stache.tags","title":"Basic Tags","type":"group","parent":"can.stache","description":"","order":3,"id":270,"children":[{"type":"function","name":"can.stache.helpers.partial","description":"","title":"{{>key}}","parent":"can.stache.tags","order":6,"signatures":[{"code":"{{>key}}","description":"<p>Render another template within the current template.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent \n[can.stache.context context]. If the value is a function or [can.compute], the \nfunction's return value is used.</p>\n\n<p>If the key value is:</p>\n\n<ul>\n<li><p><code>undefined</code> - the key's name (ex: user.stache in <code>{{&gt;user.stache}}</code>) is used to\nlook up a template using [can.view].</p></li>\n<li><p><code>string</code> - the string value is used to lookup a view in [can.view].</p></li>\n<li><p><code>function</code> - the function is called with the current scope.</p></li>\n</ul>\n\n<p>[can.view] looks for a template in the following places:</p>\n\n<ol>\n<li>A registered view</li>\n<li>An id of an element</li>\n<li>A url to load the template.</li>\n</ol>"}],"returns":{"types":[{"type":"String"}],"description":"<p>The value of the rendered template is inserted into\nthe page.</p>"}}],"comment":" ","src":"can/view/stache/doc/partials.md","id":262},{"type":"function","name":"can.stache.tags.close","description":"","title":"{{/key}}","parent":"can.stache.tags","order":4,"signatures":[{"code":"{{/key}}","description":"<p>Ends a [can.stache.tags.section {{#key}}] or [can.stache.tags.sectionHelper {{#helper}}]\nblock.</p>","params":[{"types":[{"type":"can.stache.key"}],"optional":true,"name":"key","description":"<p>A key that matches the opening key or helper name. It's also\npossible to simply write <code>{{/}}</code> to end a block.</p>"}]}],"src":"can/view/stache/doc/tags/close.md","id":273},{"type":"function","name":"can.stache.tags.comment","description":"<p>A comment that doesn't get inserted into the rendered result. </p>","title":"{{!key}}","parent":"can.stache.tags","order":7,"signatures":[{"code":"{{!key}}","description":"<p>The comment tag operates similarly to a <code>&lt;!-- --&gt;</code> tag in HTML. It exists in your template but never shows up.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>Everything within this tag is completely ignored.</p>"}],"returns":{"types":[{"type":"String"}],"description":""}}],"src":"can/view/stache/doc/tags/comment.md","id":274},{"type":"function","name":"can.stache.tags.escaped","description":"<p>Insert the value of the [can.stache.key key] into the output of the template.</p>","title":"{{key}}","parent":"can.stache.tags","order":0,"signatures":[{"code":"{{key}}","description":"","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references one of the following:</p>\n\n<ul>\n<li>A [can.stache.registerHelper registered helper].</li>\n<li>A value within the current or parent\n[can.stache.context context]. If the value is a function or [can.compute], the\nfunction's return value is used.</li>\n</ul>"}],"returns":{"types":[{"type":"String"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"*"}],"description":"<p>After the key's value is found (and set to any function's return value),\nit is passed to [can.view.txt] as the result of a call to its <code>func</code>\nargument. There, if the value is a:</p>\n\n<ul>\n<li><code>null</code> or <code>undefined</code> - an empty string is inserted into the rendered template result.</li>\n<li><code>String</code> or <code>Number</code> - the value is inserted into the rendered template result.</li>\n<li><code>Function</code> - A [can.view.hook hookup] attribute or element is inserted so this function\nwill be called back with the DOM element after it is created.</li>\n</ul>"}}],"comment":" ","src":"can/view/stache/doc/tags/escaped.md","id":275},{"type":"function","name":"can.stache.tags.inverse","description":"","title":"{{^key}}","parent":"can.stache.tags","order":5,"signatures":[{"code":"{{^key}}BLOCK{{/key}}","description":"<p>Render blocks of text if the value of the key\nis falsey.  An inverted section syntax is similar to regular\nsections except it begins with a caret rather than a\npound. If the value referenced is falsey, the section will render.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\n[can.stache.context context]. If the value is a function or [can.compute], the\nfunction's return value is used.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>Depending on the value's type, the following actions happen:</p>\n\n<ul>\n<li>A <code>truthy</code> value - the block is not rendered.</li>\n<li>A <code>falsey</code> value - the block is rendered.</li>\n</ul>\n\n<p>The rendered result of the block or an empty string is returned.</p>"}}],"comment":" ","src":"can/view/stache/doc/tags/inverse.md","id":276},{"type":"function","name":"can.stache.tags.section","description":"<p>/**</p>","title":"{{#key}}","parent":"can.stache.tags","order":3,"signatures":[{"code":"{{#key}}BLOCK{{/key}}","description":"<p>Render blocks of text one or more times, depending\non the value of the key in the current context.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\n[can.stache.context context]. If the value is a function or [can.compute], the\nfunction's return value is used.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>Depending on the value's type, the following actions happen:</p>\n\n<ul>\n<li><code>Array</code> or [can.List] - the block is rendered for\neach item in the array. The [can.stache.context context] is set to\nthe item within each block rendering.</li>\n<li>A <code>truthy</code> value - the block is rendered with the [can.stache.context context]\nset to the value.</li>\n<li>A <code>falsey</code> value - the block is not rendered.</li>\n</ul>\n\n<p>The rendered result of the blocks, block or an empty string is returned.</p>"}}],"comment":" ","src":"can/view/stache/doc/tags/section.md","id":277},{"type":"function","name":"can.stache.tags.unescaped","description":"<p>Insert the unescaped value of the [can.stache.key key] into the output of the template.</p>","title":"{{{key}}}","parent":"can.stache.tags","order":1,"signatures":[{"code":"{{{key}}}","description":"<p>Behaves just like [can.stache.tags.escaped {{key}}] and [can.stache.helpers.helper {{helper}}] but does not\nescape the result.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's return value is used.</p>"}],"returns":{"types":[{"type":"String"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"*"}],"description":""}}],"src":"can/view/stache/doc/tags/unescaped.md","id":278},{"type":"function","name":"can.stache.tags.unescaped2","description":"<p>Insert the unescaped value of the [can.stache.key key] into the output of the template.</p>","title":"{{&key}}","parent":"can.stache.tags","order":2,"signatures":[{"code":"{{&key}}","description":"<p>The <code>{{&amp;key}}</code> tag is an alias for [can.stache.tags.unescaped {{{key}}}], behaving just\nlike [can.stache.tags.escaped {{key}}] and [can.stache.helpers.helper {{helper}}] but does not\nescape the result.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's return value is used.</p>"}],"returns":{"types":[{"type":"String"},{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]},{"type":"*"}],"description":""}}],"src":"can/view/stache/doc/tags/unescaped_amp.md","id":279}]},{"name":"can.stache.htags","title":"Helper Tags","type":"group","parent":"can.stache","description":"","order":4,"id":271,"children":[{"type":"function","name":"can.stache.helpers.data","description":"","title":"{{data name}}","parent":"can.stache.htags","order":7,"signatures":[{"code":"{{data name}}","description":"<p>Adds the current [can.stache.context context] to the\nelement's [can.data].</p>","params":[{"types":[{"type":"String"}],"name":"name","description":"<p>The name of the data attribute to use for the\ncontext.</p>"}]}],"comment":" ","src":"can/view/stache/doc/helpers/data.md","id":247},{"type":"function","name":"can.stache.helpers.each","description":"","title":"{{#each key}}","parent":"can.stache.htags","order":5,"signatures":[{"code":"{{#each key}}BLOCK{{/each}}","description":"<p>Render the block of text for each item in key's value.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's\nreturn value is used.</p>\n\n<p>If the value of the key is a [can.List], the resulting HTML is updated when the\nlist changes. When a change in the list happens, only the minimum amount of DOM\nelement changes occur.</p>\n\n<p>If the value of the key is a [can.Map], the resulting HTML is updated whenever\nattributes are added or removed. When a change in the map happens, only\nthe minimum amount of DOM element changes occur.</p>"},{"types":[{"type":"can.stache"}],"name":"BLOCK","description":"<p>A template that is rendered for each item in\nthe <code>key</code>'s value. The <code>BLOCK</code> is rendered with the context set to the item being rendered.</p>"}]}],"comment":" ","src":"can/view/stache/doc/helpers/each.md","id":248},{"type":"function","name":"can.stache.helpers.else","description":"","title":"{{else}}","parent":"can.stache.htags","order":3,"signatures":[{"code":"{{#helper}}BLOCK{{else}}INVERSE{{/helper}}","description":"<p>Creates an <code>inverse</code> block for a [can.stache.helper helper function]'s\n[can.stache.helperOptions options argument]'s <code>inverse</code> property.</p>","params":[{"types":[{"type":"can.stache"}],"name":"INVERSE","description":"<p>a stache template coverted to a\nfunction and set as the [can.stache.helper helper function]'s\n[can.stache.helperOptions options argument]'s <code>inverse</code> property.</p>"}]}],"comment":" ","src":"can/view/stache/doc/helpers/else.md","id":249},{"type":"function","name":"can.stache.helpers.helper","description":"<p>Calls a stache helper function and inserts its return value into the rendered template.</p>","title":"{{helper args hashes}}","parent":"can.stache.htags","order":0,"signatures":[{"code":"{{helper [args...] [hashProperty=hashValue...]}}","description":"<p>Calls a stache helper function or a function. For example:</p>\n\n<p>The template:</p>\n\n<pre><code>&lt;p&gt;{{madLib \"Lebron James\" verb 4 foo=\"bar\"}}&lt;/p&gt;\n</code></pre>\n\n<p>Rendered with:</p>\n\n<pre><code>{verb: \"swept\"}\n</code></pre>\n\n<p>Will call a <code>madLib</code> helper with the following arguements:</p>\n\n<pre><code>can.stache.registerHelper('madLib',\n  function(subject, verb, number, options){\n    // subject -&gt; \"Lebron James\"\n    // verb -&gt; \"swept\"\n    // number -&gt; 4\n    // options.hash.foo -&gt; \"bar\"\n});\n</code></pre>","params":[{"types":[{"type":"can.stache.key"}],"name":"helper","description":"<p>A key that finds a [can.stache.helper helper function]\nthat is either [can.stache.registerHelper registered] or found within the\ncurrent or parent [can.stache.context context].</p>"},{"variable":true,"types":[{"type":"can.stache.key"},{"type":"String"},{"type":"Number"}],"optional":true,"name":"args","description":"<p>Space seperated arguments\nthat get passed to the helper function as arguments. If the key's value is a:</p>\n\n<ul>\n<li>[can.Map] - A getter/setter [can.compute] is passed.</li>\n<li>[can.compute] - The can.compute is passed.</li>\n<li><code>function</code> - The function's return value is passed.</li>\n</ul>"},{"types":[{"type":"String"}],"name":"hashProperty","description":"<p>A property name that gets added to a [can.stache.helperOptions helper options]'s\nhash object.</p>"},{"variable":true,"types":[{"type":"can.stache.key"},{"type":"String"},{"type":"Number"}],"name":"hashValue","description":"<p>A value that gets\nset as a property value of the [can.stache.helperOptions helper option argument]'s\nhash object.</p>"}]}],"comment":" ","src":"can/view/stache/doc/helpers/helper.md","id":250},{"type":"function","name":"can.stache.helpers.if","description":"","title":"{{#if key}}","parent":"can.stache.htags","order":2,"signatures":[{"code":"{{#if key}}BLOCK{{/if}}","description":"<p>Renders the <code>BLOCK</code> template within the current template.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's return value is used.</p>"},{"types":[{"type":"can.stache"}],"name":"BLOCK","description":"<p>A stache template.</p>"}],"returns":{"types":[{"type":"String"}],"description":"<p>If the key's value is truthy, the <code>BLOCK</code> is rendered with the\ncurrent context and its value is returned; otherwise, an empty string.</p>"}}],"comment":" ","src":"can/view/stache/doc/helpers/if.md","id":251},{"type":"function","name":"can.stache.helpers.index","description":"","title":"{{@index}}","parent":"can.stache.htags","order":10,"signatures":[{"code":"{{@index [offset]}}","description":"<p>Insert the index of an Array or can.List we are iterating on with <a href=\"can.stache.helpers.each\">#each</a></p>","params":[{"types":[{"type":"Number"}],"name":"offset","description":"<p>The number to optionally offset the index by.</p>"}]}],"comment":" ","src":"can/view/stache/doc/helpers/index.md","id":252},{"type":"function","name":"can.stache.helpers.key","description":"","title":"{{@key}}","parent":"can.stache.htags","order":11,"signatures":[{"code":"{{@key}}","description":"<p>Insert the property name of an Object or attribute name of a can.Map that we iterate over with <a href=\"can.stache.helpers.each\">#each</a></p>","params":[]}],"comment":" ","src":"can/view/stache/doc/helpers/key.md","id":253},{"type":"function","name":"can.stache.helpers.log","description":"","title":"{{log}}","parent":"can.stache.htags","order":9,"signatures":[{"code":"{{#log [message]}}","description":"<p>Logs the context of the current block with an optional message.</p>","params":[{"types":[{"type":"*"}],"name":"message","description":"<p>An optional message to log out in addition to the\ncurrent context.</p>"}]}],"src":"can/view/stache/doc/helpers/log.md","id":254},{"type":"function","name":"can.stache.helpers.sectionHelper","description":"<p>Calls a stache helper function with a block, and optional inverse\nblock.</p>","title":"{{#helper args hashes}}","parent":"can.stache.htags","order":1,"signatures":[{"code":"{{#helper [args...] [hashName=hashValue...]}}BLOCK{{/helper}}","description":"<p>Calls a stache helper function or a function with a block to\nrender.</p>\n\n<p>The template:</p>\n\n<pre><code>&lt;p&gt;{{countTo number}}{{num}}{{/countTo}}&lt;/p&gt;\n</code></pre>\n\n<p>Rendered with:</p>\n\n<pre><code>{number: 5}\n</code></pre>\n\n<p>Will call the <code>countTo</code> helper:</p>\n\n<pre><code>can.stache.registerHelper('madLib',\n  function(number, options){\n    var out = []\n    for(var i =0; i &lt; number; i++){\n      out.push( options.fn({num: i+1}) )\n    }\n    return out.join(\" \")\n});\n</code></pre>\n\n<p>Results in:</p>\n\n<pre><code>&lt;p&gt;1 2 3 4 5&lt;/p&gt;\n</code></pre>","params":[{"types":[{"type":"can.stache.key"}],"name":"helper","description":"<p>A key that finds a [can.stache.helper helper function]\nthat is either [can.stache.registerHelper registered] or found within the\ncurrent or parent [can.stache.context context].</p>"},{"variable":true,"types":[{"type":"can.stache.key"},{"type":"String"},{"type":"Number"}],"optional":true,"name":"args","description":"<p>Space seperated arguments\nthat get passed to the helper function as arguments. If the key's value is a:</p>\n\n<ul>\n<li>[can.Map] - A getter/setter [can.compute] is passed.</li>\n<li>[can.compute] - The can.compute is passed.</li>\n<li><code>function</code> - The function's return value is passed.</li>\n</ul>"},{"types":[{"type":"String"}],"name":"hashProperty","description":"<p>A property name that gets added to a [can.stache.helperOptions helper options]'s\nhash object.</p>"},{"variable":true,"types":[{"type":"can.stache.key"},{"type":"String"},{"type":"Number"}],"name":"hashValue","description":"<p>A value that gets\nset as a property value of the [can.stache.helperOptions helper option argument]'s\nhash object.</p>"},{"types":[{"type":"stache"}],"name":"BLOCK","description":"<p>A stache template that gets compiled and\npassed to the helper function as the [can.stache.helperOptions options argument's] <code>fn</code>\nproperty.</p>"}]},{"code":"{{#helper [args...] [hashName=hashValue...]}}BLOCK{{else}}INVERSE{{/helper}}","description":"<p>Calls a stache helper function or a function with a <code>fn</code> and <code>inverse</code> block to\nrender.</p>\n\n<p>The template:</p>\n\n<pre><code>&lt;p&gt;The bed is\n   {{isJustRight firmness}}\n      pefect!\n   {{else}}\n      uncomfortable.\n   {{/justRight}}&lt;/p&gt;\n</code></pre>\n\n<p>Rendered with:</p>\n\n<pre><code>{firmness: 45}\n</code></pre>\n\n<p>Will call the <code>isJustRight</code> helper:</p>\n\n<pre><code>can.stache.registerHelper('isJustRight',\n  function(number, options){\n    if(number &gt; 50){\n      return options.fn(this)\n    } else {\n      return options.inverse(this)\n    }\n    return out.join(\" \")\n});\n</code></pre>\n\n<p>Results in:</p>\n\n<pre><code>&lt;p&gt;The bed is uncomfortable.&lt;/p&gt;\n</code></pre>","params":[{"types":[{"type":"can.stache.key"}],"name":"helper","description":"<p>A key that finds a [can.stache.helper helper function]\nthat is either [can.stache.registerHelper registered] or found within the\ncurrent or parent [can.stache.context context].</p>"},{"variable":true,"types":[{"type":"can.stache.key"},{"type":"String"},{"type":"Number"}],"optional":true,"name":"args","description":"<p>Space seperated arguments\nthat get passed to the helper function as arguments. If the key's value is a:</p>\n\n<ul>\n<li>[can.Map] - A getter/setter [can.compute] is passed.</li>\n<li>[can.compute] - The can.compute is passed.</li>\n<li><code>function</code> - The function's return value is passed.</li>\n</ul>"},{"types":[{"type":"String"}],"name":"hashProperty","description":"<p>A property name that gets added to a [can.stache.helperOptions helper options]'s\nhash object.</p>"},{"variable":true,"types":[{"type":"can.stache.key"},{"type":"String"},{"type":"Number"}],"name":"hashValue","description":"<p>A value that gets\nset as a property value of the [can.stache.helperOptions helper option argument]'s\nhash object.</p>"},{"types":[{"type":"stache"}],"name":"BLOCK","description":"<p>A stache template that gets compiled and\npassed to the helper function as the [can.stache.helperOptions options argument's] <code>fn</code>\nproperty.</p>"},{"types":[{"type":"stache"}],"name":"INVERSE","description":"<p>A stache template that gets compiled and\npassed to the helper function as the [can.stache.helperOptions options argument's] <code>inverse</code>\nproperty.</p>"}]}],"comment":" ","src":"can/view/stache/doc/helpers/sectionHelper.md","id":256},{"type":"function","name":"can.stache.helpers.unless","description":"","title":"{{#unless key}}","parent":"can.stache.htags","order":4,"signatures":[{"code":"{{#unless key}}BLOCK{{/unless}}","description":"<p>Render the block of text if the key's value is falsey.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's\nreturn value is used.</p>"},{"types":[{"type":"can.stache"}],"name":"BLOCK","description":"<p>A template that is rendered\nif the <code>key</code>'s value is falsey.</p>"}]}],"comment":" ","src":"can/view/stache/doc/helpers/unless.md","id":257},{"type":"function","name":"can.stache.helpers.with","description":"","title":"{{#with key}}","parent":"can.stache.htags","order":6,"signatures":[{"code":"{{#with key}}BLOCK{{/with}}","description":"<p>Changes the context within a block.</p>","params":[{"types":[{"type":"can.stache.key"}],"name":"key","description":"<p>A key that references a value within the current or parent\ncontext. If the value is a function or can.compute, the function's\nreturn value is used.</p>"},{"types":[{"type":"can.stache"}],"name":"BLOCK","description":"<p>A template that is rendered\nwith the context of the <code>key</code>'s value.</p>"}]}],"comment":" ","src":"can/view/stache/doc/helpers/with.md","id":258}]}]}]};

	console.log(docData);
</script>



  <footer>
    <nav class="container">
      <a class="brand javascriptmvc" href="index.html"></a>
      <ul class="nav">
        <li class=""><a href="../../index.html">Home</a></li>
        <li class=""><a href="../guides/index.html">Guides</a></li>
        <li class="active"><a href="../docs/index.html">Api</a></li>
        <li class=""><a href="../../community.html#!forums">Community</a></li>
        <li class=""><a href="../../download.html">Download</a></li>
      </ul>
    </nav>
  </footer>
  <script type="text/javascript">
    window.docConfig = {"debug":false,"enableSearch":true,"parent":"canjs","layout":"shared/_templates/page.mustache","docs":"shared/_templates/docs.mustache","root":"..","out":"2.1/docs","page":"docs","markdown":["can"],"package":{"name":"CanJS","description":"MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy.","version":"2.1.1","author":{"name":"Bitovi","email":"contact@bitovi.com","web":"http://bitovi.com/"},"homepage":"http://canjs.us/","repository":{"type":"git","url":"git@github.com:bitovi/canjs.git","github":"https://github.com/bitovi/canjs"},"devDependencies":{"grunt":"~0.4.0","grunt-string-replace":"~0.2.2","grunt-contrib-qunit":"~0.2.1","grunt-contrib-connect":"~0.3.0","bitovi-tools":"https://github.com/bitovi/bitovi-tools/tarball/master","steal":"https://github.com/bitovi/steal-build/tarball/master","grunt-contrib-uglify":"~0.2.1","grunt-contrib-clean":"~0.5.0","grunt-shell":"~0.5.0","grunt-release-steps":"~0.3.7","bower":"~1.2.7","grunt-contrib-jshint":"~0.8.0","grunt-jsbeautifier":"~0.2.6","grunt-docco2":"git://github.com/shcarrico/grunt-docco.git#e4de54886ed5c421b2e26e7a2aeba1f73e889733","grunt-plato":"~0.2.1"},"scripts":{"test":"grunt test","install":"node node_modules/bower/bin/bower install"},"demos":["http://canjs.us/#examples","http://canjs.us/recipes"],"licenses":[{"type":"MIT","url":"http://opensource.org/licenses/mit-license.php"}],"dependencies":{"grunt-cli":"~0.1.7"}},"self":{"name":"canjs.com","description":"We can do JS better.","version":"0.2.0","homepage":"http://canjs.com","author":{"name":"Bitovi","url":"http://bitovi.com/"},"repository":{"type":"git","url":"git://github.com/bitovi/canjs.com.git","github":"https://github.com/bitovi/canjs.com"},"bugs":{"url":"https://github.com/bitovi/canjs.com/issues"},"licenses":[{"type":"MIT","url":"https://github.com/bitovi/canjs.com/blob/master/LICENSE-MIT"}],"engines":{"node":">= 0.10.0"},"devDependencies":{"grunt":"~0.4.1","grunt-contrib-watch":"~0.3.1","grunt-contrib-less":"~0.5.0","documentjs":"https://github.com/bitovi/documentjs/tarball/node-generator","grunt-contrib-clean":"~0.4.1","grunt-docco2":"git://github.com/shcarrico/grunt-docco.git#options-passing","grunt-plato":"~0.2.1","grunt-jsbeautifier":"~0.2.6"}},"builder":{"filename":"can.custom.js","banner":"/*!\n * <%= pkg.title || pkg.name %> - <%= pkg.version %>\n * <%= pkg.homepage %>\n * Copyright (c) <%= new Date().getFullYear() %> <%= pkg.author.name %>\n * <%= new Date().toUTCString() %>\n * Licensed <%= pkg.licenses[0].type %><% if(typeof url !== \"undefined\") { %>\n * Includes: <%= ids %>\n * Download from: <%= url %>\n<% } %> */\n","modules":{"can/component":{"name":"can.Component","description":"Custom elements and widgets","type":"core","isDefault":true},"can/construct":{"name":"can.Construct","description":"Inheritable constructor functions","type":"core","isDefault":true},"can/map":{"name":"can.Map","description":"Observables and key-value bindings","type":"core","isDefault":true},"can/list":{"name":"can.List","description":"Observables lists","type":"core","isDefault":true},"can/list/promise":{"name":"can.List.promise","description":"Promises on lists","type":"plugin"},"can/observe":{"name":"can.Observe","description":"Observables and key-value bindings","type":"core","isDefault":true,"hidden":true},"can/compute":{"name":"can.compute","description":"can.compute lets you make observable values","type":"core","isDefault":true},"can/model":{"name":"can.Model","description":"Observes connected to a RESTful JSON interface","type":"core","isDefault":true},"can/view":{"name":"can.view","description":"Template loading, caching, rendering","type":"core","isDefault":true},"can/view/ejs":{"name":"can.ejs","description":"Live-binding Embedded JavaScript","type":"plugin"},"can/view/stache":{"name":"can.stache","description":"High performance Mustache templates","type":"plugin"},"can/control":{"name":"can.Control","description":"Declarative event bindings","type":"core","isDefault":true},"can/route":{"name":"can.route","description":"Back button and bookmarking support","type":"core","isDefault":true},"can/control/route":{"name":"can.Control.route","description":"Declare routes in your Control","type":"core","isDefault":true},"can/view/mustache":{"name":"can.mustache","description":"Live-binding Handlebars and Mustache views","type":"core","isDefault":true},"can/route/pushstate":{"name":"can.route.pushstate","description":"can.route with pushstate","type":"plugin"},"can/model/queue":{"name":"can.Model.Queue","type":"plugin","description":"Queued requests to the server."},"can/construct/super":{"name":"can.Construct.super","type":"plugin","description":"Call super methods"},"can/construct/proxy":{"name":"can.Construct.proxy","type":"plugin","description":"Proxy construct methods"},"can/map/lazy":{"name":"can.Map.Lazy","type":"plugin","description":"Lazy initializing maps and lists"},"can/map/delegate":{"name":"can.Map.delegate","type":"plugin","description":"Listen to Observe attributes"},"can/map/setter":{"name":"can.Map.setter","type":"plugin","description":"Use setter methods on can.Map"},"can/map/attributes":{"name":"can.Map.attributes","type":"plugin","deprecated":true,"description":"Define Observe attributes"},"can/map/validations":{"name":"can.Map.validations","type":"plugin","description":"Validate Observe attributes"},"can/map/backup":{"name":"can.Map.backup","type":"plugin","description":"Backup and restore an Observes state"},"can/map/list":{"name":"can.Map.List","type":"plugin","description":"Live-updating mapped and filtered observe lists"},"can/map/define":{"name":"can.Map.define","type":"plugin","description":"Define rich attribute behavior"},"can/map/sort":{"name":"can.List.Sort","type":"plugin","description":"Sort observable lists"},"can/control/plugin":{"name":"can.Control.plugin","type":"plugin","description":"Registers a jQuery plugin function for Controls","configurations":["jquery","jquery-2"]},"can/view/modifiers":{"name":"can.view.modifiers","type":"plugin","description":"Use jQuery modifiers to render views","configurations":["jquery","jquery-2"]},"can/util/object":{"name":"can.Object","type":"plugin","description":"Helper methods for object comparison"},"can/util/fixture":{"name":"can.fixture","type":"plugin","description":"Intercepts an AJAX request and simulates the response with a file or function"},"can/view/bindings":{"name":"can.view.bindings","type":"core","isDefault":true,"hidden":true},"can/view/live":{"name":"can.view.live","type":"core","isDefault":true,"hidden":true},"can/view/scope":{"name":"can.view.Scope","type":"core","isDefault":true,"hidden":true},"can/util/string":{"name":"can.util.string","type":"core","isDefault":true,"hidden":true},"can/util/attr":{"name":"can.util.attr","type":"core","isDefault":true,"hidden":true}},"types":{"core":"CanJS core","plugin":"Plugins"},"pluginify":{"shim":{"can/lib/jquery.2.0.3.js":"jQuery","can/lib/jquery.1.10.2.js":"jQuery","can/bower_components/zepto/zepto.js":"Zepto","can/lib/mootools-core-1.4.5.js":"{}","can/util/dojo/dojo-1.8.1.js":"{}","can/lib/yui-3.7.3.js":"YUI"},"exports":{"can/util/can.js":"can"}},"configurations":{"jquery":{"description":"jQuery","isDefault":true,"library":"lib/jquery.1.10.2.js","steal":{"map":{"*":{"can/util/util.js":"can/util/jquery/jquery.js","jquery/jquery.js":"can/lib/jquery.1.10.2.js"}}}},"jquery-2":{"description":"jQuery (2.x)","hidden":true,"library":"lib/jquery.2.0.3.js","steal":{"map":{"*":{"can/util/util.js":"can/util/jquery/jquery.js","jquery/jquery.js":"can/lib/jquery.2.0.3.js"}}}},"zepto":{"description":"Zepto","library":"bower_components/zepto/zepto.js","steal":{"map":{"*":{"can/util/util.js":"can/util/zepto/zepto.js","zepto/zepto.js":"can/bower_components/zepto/zepto.js"}}}},"mootools":{"description":"Mootools","library":"lib/mootools-core-1.4.5.js","steal":{"map":{"*":{"can/util/util.js":"can/util/mootools/mootools.js","mootools/mootools.js":"can/lib/mootools-core-1.4.5.js"}}}},"yui":{"description":"YUI","library":"lib/yui-3.7.3.js","steal":{"map":{"*":{"can/util/util.js":"can/util/yui/yui.js","yui/yui.js":"can/lib/yui-3.7.3.js"}}}},"dojo":{"description":"Dojo","library":"util/dojo/dojo-1.8.1.js","steal":{"map":{"*":{"can/util/util.js":"can/util/dojo/dojo.js","dojo/dojo.js":"can/util/dojo/dojo-1.8.1.js"}}}}}},"url":{"builderData":"http://bitbuilder.herokuapp.com/canjs","builder":"http://bitbuilder.herokuapp.com/can.custom.js","bithub":"http://api.bithub.com/api/v1/events/","cdn":"//canjs.com/release/"},"static":"scripts/static","templates":"scripts/templates","forceBuild":true,"minifyBuild":true,"versionsSrc":"../../versions.json","version":"2.1","isVersioned":true,"versions":[{"number":"2.1","branch":"master"},{"number":"2.0"},{"number":"1.1"}]};
    window.Bitovi = {
      URL: {
        BUILDER: 'http://bitbuilder.herokuapp.com/can.custom.js',
        BUILDER_DATA: 'http://bitbuilder.herokuapp.com/canjs',
        BITHUB: 'http://api.bithub.com/api/v1/events/',
        CDN: '//canjs.com/release/'
      }
    }
    steal = {
      productionId: "production.js",
      executed: ["documentjs/site/static/build/production.css"]
    }
  </script>
  <script 
  
    src="./static/steal.production.js"
  
    ></script>
  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2302003-11']);
  _gaq.push(['_setDomainName', 'canjs.com']);
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);

  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  </script>
</body>

</html>
