<!DOCTYPE html>

<html>
<head>
  <title>live.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>live.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>steal(<span class="hljs-string">'can/util'</span>,
	<span class="hljs-string">'can/view/elements.js'</span>,
	<span class="hljs-string">'can/view'</span>,
	<span class="hljs-string">'can/view/node_lists'</span>,
	<span class="hljs-string">'can/view/parser'</span>,
	<span class="hljs-string">'can/util/array/diff.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">can, elements, view, nodeLists, parser, diff</span>) </span>{

	elements = elements || can.view.elements;
	nodeLists = nodeLists || can.view.NodeLists;
	parser = parser || can.view.parser;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="live-js">live.js</h2>
<p>The live module provides live binding for computes
and can.List.</p>
<p>Currently, it’s API is designed for <code>can/view/render</code>, but
it could easily be used for other purposes.</p>
<h3 id="helper-methods">Helper methods</h3>
<h4 id="setup">setup</h4>
<p><code>setup(HTMLElement, bind(data), unbind(data)) -&gt; data</code></p>
<p>Calls bind right away, but will call unbind
if the element is “destroyed” (removed from the DOM).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, bind, unbind</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Removing an element can call teardown which
unregister the nodeList which calls teardown</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> tornDown = <span class="hljs-literal">false</span>,
			teardown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">if</span> (!tornDown) {
					tornDown = <span class="hljs-literal">true</span>;
					unbind(data);
					can.unbind.call(el, <span class="hljs-string">'removed'</span>, teardown);
				}
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
			}, data = {
				<span class="hljs-attr">teardownCheck</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent</span>) </span>{
					<span class="hljs-keyword">return</span> parent ? <span class="hljs-literal">false</span> : teardown();
				}
			};
		can.bind.call(el, <span class="hljs-string">'removed'</span>, teardown);
		bind(data);
		<span class="hljs-keyword">return</span> data;
	},
		getChildNodes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>)</span>{
			<span class="hljs-keyword">var</span> childNodes = node.childNodes;
			<span class="hljs-keyword">if</span>(<span class="hljs-string">"length"</span> <span class="hljs-keyword">in</span> childNodes) {
				<span class="hljs-keyword">return</span> childNodes;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">var</span> cur = node.firstChild;
				<span class="hljs-keyword">var</span> nodes = [];
				<span class="hljs-keyword">while</span>(cur) {
					nodes.push(cur);
					cur = cur.nextSibling;
				}
				<span class="hljs-keyword">return</span> nodes;
			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h4 id="listen">listen</h4>
<p>Calls setup, but presets bind and unbind to
operate on a compute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		listen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, compute, change</span>) </span>{
			<span class="hljs-keyword">return</span> setup(el, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
				compute.computeInstance.bind(<span class="hljs-string">'change'</span>, change);
			}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
				compute.computeInstance.unbind(<span class="hljs-string">'change'</span>, change);
				<span class="hljs-keyword">if</span> (data.nodeList) {
					nodeLists.unregister(data.nodeList);
				}
			});
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h4 id="getattributeparts">getAttributeParts</h4>
<p>Breaks up a string like foo=’bar’ into [“foo”,”‘bar’””]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		getAttributeParts = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newVal</span>) </span>{
			<span class="hljs-keyword">var</span> attrs = {},
				attr;
			parser.parseAttrs(newVal,{
				<span class="hljs-attr">attrStart</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{
					attrs[name] = <span class="hljs-string">""</span>;
					attr = name;
				},
				<span class="hljs-attr">attrValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>{
					attrs[attr] += value;
				},
				<span class="hljs-attr">attrEnd</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}
			});
			<span class="hljs-keyword">return</span> attrs;
		},
		splice = [].splice,
		isNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>)</span>{
			<span class="hljs-keyword">return</span> obj &amp;&amp; obj.nodeType;
		},
		addTextNodeIfNoChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">frag</span>)</span>{
			<span class="hljs-keyword">if</span>(!frag.firstChild) {
				frag.appendChild(frag.ownerDocument.createTextNode(<span class="hljs-string">""</span>));
			}
		},
		getLiveFragment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">itemHTML</span>)</span>{
			<span class="hljs-keyword">var</span> gotText = <span class="hljs-keyword">typeof</span> itemHTML === <span class="hljs-string">"string"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>and convert it into elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				itemFrag = can.frag(itemHTML);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Add those elements to the mappings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> gotText ? can.view.hookup(itemFrag) : itemFrag;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>a helper function that renders something and adds its nodeLists to newNodeLists
in the right way for both stache and mustache.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		renderAndAddToNodeLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newNodeLists, parentNodeList, render, context, args</span>)</span>{
			<span class="hljs-keyword">var</span> itemNodeList = [];

			<span class="hljs-keyword">if</span>(parentNodeList) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Pass in true so itemNodeList doesn’t get added to the
parentNodeList’s replacements array. #2332.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				nodeLists.register(itemNodeList,<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
				itemNodeList.parentList = parentNodeList;
				itemNodeList.expression = <span class="hljs-string">"#each SUBEXPRESSION"</span>;
			}

			<span class="hljs-keyword">var</span> itemHTML = render.apply(context, args.concat([itemNodeList])),
				itemFrag = getLiveFragment(itemHTML);

			<span class="hljs-keyword">var</span> childNodes = can.makeArray(getChildNodes(itemFrag));
			<span class="hljs-keyword">if</span>(parentNodeList) {
				nodeLists.update(itemNodeList, childNodes);
				newNodeLists.push(itemNodeList);
			} <span class="hljs-keyword">else</span> {
				newNodeLists.push(nodeLists.register(childNodes));
			}
			<span class="hljs-keyword">return</span> itemFrag;
		},
		removeFromNodeList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">masterNodeList, index, length</span>)</span>{
			<span class="hljs-keyword">var</span> removedMappings = masterNodeList.splice(index + <span class="hljs-number">1</span>, length),
				itemsToRemove = [];
			can.each(removedMappings, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodeList</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Unregister to free up event bindings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> nodesToRemove = nodeLists.unregister(nodeList);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>add items that we will remove all at once</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				[].push.apply(itemsToRemove, nodesToRemove);
			});
			<span class="hljs-keyword">return</span> itemsToRemove;
		},
		addFalseyIfEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list, falseyRender, masterNodeList, nodeList</span>)</span>{
			<span class="hljs-keyword">if</span>(falseyRender &amp;&amp; list.length === <span class="hljs-number">0</span>){</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>there are no items … we should render the falsey template</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> falseyNodeLists = [];
				<span class="hljs-keyword">var</span> falseyFrag = renderAndAddToNodeLists(falseyNodeLists, nodeList, falseyRender, list, [list]);

				elements.after([masterNodeList[<span class="hljs-number">0</span>]], falseyFrag);
				masterNodeList.push(falseyNodeLists[<span class="hljs-number">0</span>]);
			}
		},
		childMutationCallbacks = {};
	<span class="hljs-comment">/**
	 * @property {Object} can.view.live
	 * @parent can.view.static
	 * @release 2.0.4
	 *
	 * Setup live-binding between the DOM and a compute manually.
	 *
	 * @option {Object} An object with the live-binding methods:
	 * [can.view.live.html], [can.view.live.list], [can.view.live.text],
	 * [can.view.live.attr] and [can.view.live.attrs].
	 *
	 * @body
	 *
	 * ## Use
	 *
	 * `can.view.live` is an object with utlitiy methods for setting up
	 * live-binding in relation to different parts of the DOM and DOM elements.  For
	 * example, to make an `&lt;h2&gt;`'s text stay live with
	 * a compute:
	 *
	 *     var text = can.compute("Hello World");
	 *     var textNode = $("h2").text(" ")[0].childNodes[0];
	 *     can.view.live.text(textNode, text);
	 *
	 *
	 */</span>
	<span class="hljs-keyword">var</span> live = {
		<span class="hljs-attr">registerChildMutationCallback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tag, callback</span>)</span>{
			<span class="hljs-keyword">if</span>(callback) {
				childMutationCallbacks[tag] = callback;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> childMutationCallbacks[tag];
			}
		},
		<span class="hljs-attr">callChildMutationCallback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>) </span>{
			<span class="hljs-keyword">var</span> callback = el &amp;&amp; childMutationCallbacks[el.nodeName.toLowerCase()];
			<span class="hljs-keyword">if</span>(callback) {
				callback(el);
			}
		},
		<span class="hljs-comment">/**
		 * @function can.view.live.list
		 * @parent can.view.live
		 * @release 2.0.4
		 *
		 * Live binds a compute's [can.List] incrementally.
		 *
		 *
		 * @param {HTMLElement} el An html element to replace with the live-section.
		 *
		 * @param {can.compute|can.List} list A [can.List] or [can.compute] whose value is a [can.List].
		 *
		 * @param {function(this:*,*,index):String} render(index, index) A function that when called with
		 * the incremental item to render and the index of the item in the list.
		 *
		 * @param {Object} context The `this` the `render` function will be called with.
		 *
		 * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is
		 * a documentFragment.
		 *
		 * ## Use
		 *
		 * `can.view.live.list` is used to setup incremental live-binding.
		 *
		 *     // a compute that change's it's list
		 *     var todos = can.compute(function(){
		 *       return new Todo.List({page: can.route.attr("page")})
		 *     })
		 *
		 *     var placeholder = document.createTextNode(" ")
		 *     $("ul#todos").append(placeholder)
		 *
		 *
		 *
		 *     can.view.live.list(
		 *       placeholder,
		 *       todos,
		 *       function(todo, index){
		 *         return "&lt;li&gt;"+todo.attr("name")+"&lt;/li&gt;"
		 *       })
		 *
		 */</span>
		list: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, compute, render, context, parentNode, nodeList, falseyRender</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>A nodeList of all elements this live-list manages.
This is here so that if this live list is within another section
that section is able to remove the items in this list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> masterNodeList = nodeList || [el],</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>A mapping of items to their indicies’</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				indexMap = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>True once all previous events have been fired</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				afterPreviousEvents = <span class="hljs-literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Indicates that we should not be responding to changes in the list.
It’s possible that the compute change causes this list behavior to be torn down.
However that same “change” dispatch will eventually fire the updateList handler because
the list of “change” handlers is copied when dispatching starts.
A ‘perfect’ fix would be to use linked lists for event handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				isTornDown = <span class="hljs-literal">false</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Called when items are added to the list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, items, index</span>) </span>{

					<span class="hljs-keyword">if</span> (!afterPreviousEvents) {
						<span class="hljs-keyword">return</span>;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Collect new html and mappings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> frag = text.ownerDocument.createDocumentFragment(),
						newNodeLists = [],
						newIndicies = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>For each new item,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					can.each(items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, key</span>) </span>{
						<span class="hljs-keyword">var</span> itemIndex = can.compute(key + index),
							itemFrag = renderAndAddToNodeLists(newNodeLists, nodeList, render, context, [item, itemIndex]);</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Hookup the fragment (which sets up child live-bindings) and
add it to the collection of all added elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						frag.appendChild(itemFrag);</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>track indicies;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						newIndicies.push(itemIndex);
					});</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>The position of elements is always after the initial text placeholder node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> masterListIndex = index+<span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>remove falsey if there’s something there</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span>(!indexMap.length) {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>remove all leftover things</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> falseyItemsToRemove = removeFromNodeList(masterNodeList, <span class="hljs-number">0</span>, masterNodeList.length - <span class="hljs-number">1</span>);
						can.remove(can.$(falseyItemsToRemove));
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Check if we are adding items at the end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!masterNodeList[masterListIndex]) {
						elements.after(masterListIndex === <span class="hljs-number">1</span> ? [text] : [nodeLists.last(masterNodeList[masterListIndex - <span class="hljs-number">1</span>])], frag);
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Add elements before the next index’s first element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> el = nodeLists.first(masterNodeList[masterListIndex]);
						can.insertBefore(el.parentNode, frag, el);
					}
					splice.apply(masterNodeList, [
						masterListIndex,
						<span class="hljs-number">0</span>
					].concat(newNodeLists));</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>update indices after insert point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					splice.apply(indexMap, [
						index,
						<span class="hljs-number">0</span>
					].concat(newIndicies));

					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = index + newIndicies.length, len = indexMap.length; i &lt; len; i++) {
						indexMap[i](i);
					}
					<span class="hljs-keyword">if</span>(ev.callChildMutationCallback !== <span class="hljs-literal">false</span>) {
						live.callChildMutationCallback(text.parentNode);
					}

				},</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Called when an item is set with .attr</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				set = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev, newVal, index</span>) </span>{
					remove({}, { <span class="hljs-attr">length</span>: <span class="hljs-number">1</span> }, index, <span class="hljs-literal">true</span>);
					add({}, [newVal], index);
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Called when items are removed or when the bindings are torn down.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, items, index, duringTeardown, fullTeardown</span>) </span>{

					<span class="hljs-keyword">if</span> (!afterPreviousEvents) {
						<span class="hljs-keyword">return</span>;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>If this is because an element was removed, we should
check to make sure the live elements are still in the page.
If we did this during a teardown, it would cause an infinite loop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!duringTeardown &amp;&amp; data.teardownCheck(text.parentNode)) {
						<span class="hljs-keyword">return</span>;
					}
					<span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>) {
						index = indexMap.length + index;
					}
					<span class="hljs-keyword">var</span> itemsToRemove = removeFromNodeList(masterNodeList, index, items.length);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>update indices after remove point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					indexMap.splice(index, items.length);
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = index, len = indexMap.length; i &lt; len; i++) {
						indexMap[i](i);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>don’t remove elements during teardown.  Something else will probably be doing that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span>(!fullTeardown) {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>adds the falsey section if the list is empty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
						can.remove(can.$(itemsToRemove));
						<span class="hljs-keyword">if</span>(ev.callChildMutationCallback !== <span class="hljs-literal">false</span>) {
							live.callChildMutationCallback(text.parentNode);
						}
					} <span class="hljs-keyword">else</span> {
						nodeLists.unregister(masterNodeList);
					}
				},
				move = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, item, newIndex, currentIndex</span>) </span>{
					<span class="hljs-keyword">if</span> (!afterPreviousEvents) {
						<span class="hljs-keyword">return</span>;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>The position of elements is always after the initial text
placeholder node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					newIndex = newIndex + <span class="hljs-number">1</span>;
					currentIndex = currentIndex + <span class="hljs-number">1</span>;

					<span class="hljs-keyword">var</span> referenceNodeList = masterNodeList[newIndex];
					<span class="hljs-keyword">var</span> movedElements = can.frag( nodeLists.flatten(masterNodeList[currentIndex]) );
					<span class="hljs-keyword">var</span> referenceElement;</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>If we’re moving forward in the list, we want to be placed before
the item AFTER the target index since removing the item from
the currentIndex drops the referenceItem’s index. If there is no
nextSibling, insertBefore acts like appendChild.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (currentIndex &lt; newIndex) {
						referenceElement = nodeLists.last(referenceNodeList).nextSibling;
					} <span class="hljs-keyword">else</span> {
						referenceElement = nodeLists.first(referenceNodeList);
					}

					<span class="hljs-keyword">var</span> parentNode = masterNodeList[<span class="hljs-number">0</span>].parentNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Move the DOM nodes into the proper location</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					parentNode.insertBefore(movedElements, referenceElement);</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Now, do the same for the masterNodeList. We need to keep it
in sync with the DOM.</p>

            </div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Save a reference to the “node” that we’re manually moving</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> temp = masterNodeList[currentIndex];</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Remove the movedItem from the masterNodeList</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[].splice.apply(masterNodeList, [currentIndex, <span class="hljs-number">1</span>]);</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Move the movedItem to the correct index in the masterNodeList</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[].splice.apply(masterNodeList, [newIndex, <span class="hljs-number">0</span>, temp]);</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Convert back to a zero-based array index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					newIndex = newIndex - <span class="hljs-number">1</span>;
					currentIndex = currentIndex - <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Grab the index compute from the <code>indexMap</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> indexCompute = indexMap[currentIndex];</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Remove the index compute from the <code>indexMap</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[].splice.apply(indexMap, [currentIndex, <span class="hljs-number">1</span>]);</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Move the index compute to the correct index in the <code>indexMap</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[].splice.apply(indexMap, [newIndex, <span class="hljs-number">0</span>, indexCompute]);

					<span class="hljs-keyword">var</span> i = <span class="hljs-built_in">Math</span>.min(currentIndex, newIndex);
					<span class="hljs-keyword">var</span> len = indexMap.length;

					<span class="hljs-keyword">for</span> (i, len; i &lt; len; i++) {
						indexMap[i](i);
					}
					<span class="hljs-keyword">if</span>(ev.callChildMutationCallback !== <span class="hljs-literal">false</span>) {
						live.callChildMutationCallback(text.parentNode);
					}
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>A text node placeholder</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				text = el.ownerDocument.createTextNode(<span class="hljs-string">''</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>The current list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				list,</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Called when the list is replaced with a new list or the binding is torn-down.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				teardownList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fullTeardown</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>there might be no list right away, and the list might be a plain
array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (list &amp;&amp; list.unbind) {
						list.unbind(<span class="hljs-string">'add'</span>, add)
							.unbind(<span class="hljs-string">'set'</span>, set)
							.unbind(<span class="hljs-string">'remove'</span>, remove)
							.unbind(<span class="hljs-string">'move'</span>, move);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>use remove to clean stuff up for us</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					remove({<span class="hljs-attr">callChildMutationCallback</span>: !!fullTeardown}, {
						<span class="hljs-attr">length</span>: masterNodeList.length - <span class="hljs-number">1</span>
					}, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, fullTeardown);
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Called when the list is replaced or setup.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				updateList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, newList, oldList</span>) </span>{

					<span class="hljs-keyword">if</span>(isTornDown) {
						<span class="hljs-keyword">return</span>;
					}

					afterPreviousEvents = <span class="hljs-literal">true</span>;
					<span class="hljs-keyword">if</span>(newList &amp;&amp; oldList) {
						list = newList || [];
						<span class="hljs-keyword">var</span> patches = diff(oldList, newList);

						<span class="hljs-keyword">if</span> ( oldList.unbind ) {
							oldList.unbind(<span class="hljs-string">'add'</span>, add)
								.unbind(<span class="hljs-string">'set'</span>, set)
								.unbind(<span class="hljs-string">'remove'</span>, remove)
								.unbind(<span class="hljs-string">'move'</span>, move);
						}
						<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, patchLen = patches.length; i &lt; patchLen; i++) {
							<span class="hljs-keyword">var</span> patch = patches[i];
							<span class="hljs-keyword">if</span>(patch.deleteCount) {
								remove({<span class="hljs-attr">callChildMutationCallback</span>: <span class="hljs-literal">false</span>}, {
									<span class="hljs-attr">length</span>: patch.deleteCount
								}, patch.index, <span class="hljs-literal">true</span>);
							}
							<span class="hljs-keyword">if</span>(patch.insert.length) {
								add({<span class="hljs-attr">callChildMutationCallback</span>: <span class="hljs-literal">false</span>}, patch.insert, patch.index);
							}
						}
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">if</span>(oldList) {
							teardownList();
						}
						list = newList || [];
						add({<span class="hljs-attr">callChildMutationCallback</span>: <span class="hljs-literal">false</span>}, list, <span class="hljs-number">0</span>);
						addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
					}
					live.callChildMutationCallback(text.parentNode);

					afterPreviousEvents = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>list might be a plain array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (list.bind) {
						list.bind(<span class="hljs-string">'add'</span>, add)
							.bind(<span class="hljs-string">'set'</span>, set)
							.bind(<span class="hljs-string">'remove'</span>, remove)
							.bind(<span class="hljs-string">'move'</span>, move);
					}

					can.batch.afterPreviousEvents(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
						afterPreviousEvents = <span class="hljs-literal">true</span>;
					});
				};

			parentNode = elements.getParentNode(el, parentNode);</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Setup binding and teardown to add and remove events</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> data = setup(parentNode, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>TODO: for stache, binding on the compute is not necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (can.isFunction(compute)) {
					compute.bind(<span class="hljs-string">'change'</span>, updateList);
				}
			}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">if</span> (can.isFunction(compute)) {
					compute.unbind(<span class="hljs-string">'change'</span>, updateList);
				}
				teardownList(<span class="hljs-literal">true</span>);
			});

			<span class="hljs-keyword">if</span>(!nodeList) {
				live.replace(masterNodeList, text, data.teardownCheck);
			} <span class="hljs-keyword">else</span> {
				elements.replace(masterNodeList, text);
				nodeLists.update(masterNodeList, [text]);
				nodeList.unregistered = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
					data.teardownCheck();
					isTornDown = <span class="hljs-literal">true</span>;
				};
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>run the list setup</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			updateList({}, can.isFunction(compute) ? compute() : compute);
		},
		<span class="hljs-comment">/**
		 * @function can.view.live.html
		 * @parent can.view.live
		 * @release 2.0.4
		 *
		 * Live binds a compute's value to a collection of elements.
		 *
		 *
		 * @param {HTMLElement} el An html element to replace with the live-section.
		 *
		 * @param {can.compute} compute A [can.compute] whose value is HTML.
		 *
		 * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is
		 * a documentFragment.
		 *
		 * ## Use
		 *
		 * `can.view.live.html` is used to setup incremental live-binding.
		 *
		 *     // a compute that change's it's list
		 *     var greeting = can.compute(function(){
		 *       return "Welcome &lt;i&gt;"+me.attr("name")+"&lt;/i&gt;"
		 *     });
		 *
		 *     var placeholder = document.createTextNode(" ");
		 *     $("#greeting").append(placeholder);
		 *
		 *     can.view.live.html( placeholder,  greeting );
		 *
		 */</span>
		html: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, compute, parentNode, nodeList</span>) </span>{
			<span class="hljs-keyword">var</span> data;
			parentNode = elements.getParentNode(el, parentNode);
			data = listen(parentNode, compute, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, newVal, oldVal</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>TODO: remove teardownCheck in 2.1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> attached = nodeLists.first(nodes).parentNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>update the nodes in the DOM with the new rendered value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (attached) {
					makeAndPut(newVal);
				}
				<span class="hljs-keyword">var</span> pn = nodeLists.first(nodes).parentNode;
				data.teardownCheck(pn);
				live.callChildMutationCallback(pn);
			});

			<span class="hljs-keyword">var</span> nodes = nodeList || [el],
				makeAndPut = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{
					<span class="hljs-keyword">var</span> isFunction = <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">"function"</span>,
						aNode = isNode(val),
						frag = can.frag(isFunction ? <span class="hljs-string">""</span> : val),
						oldNodes = can.makeArray(nodes);</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Add a placeholder textNode if necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					addTextNodeIfNoChildren(frag);

					<span class="hljs-keyword">if</span>(!aNode &amp;&amp; !isFunction){
						frag = can.view.hookup(frag, parentNode);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>We need to mark each node as belonging to the node list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					oldNodes = nodeLists.update(nodes, getChildNodes(frag));
					<span class="hljs-keyword">if</span>(isFunction) {
						val(frag.firstChild);
					}
					elements.replace(oldNodes, frag);
				};

			data.nodeList = nodes;</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>register the span so nodeLists knows the parentNodeList</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(!nodeList) {
				nodeLists.register(nodes, data.teardownCheck);
			} <span class="hljs-keyword">else</span> {
				nodeList.unregistered = data.teardownCheck;
			}
			makeAndPut(compute());
		},
		<span class="hljs-comment">/**
		 * @function can.view.live.replace
		 * @parent can.view.live
		 * @release 2.0.4
		 *
		 * Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data
		 * correct.
		 *
		 * @param {Array.&lt;HTMLElement&gt;} nodes An array of elements.  There should typically be one element.
		 * @param {String|HTMLElement|DocumentFragment} val The content that should replace
		 * `nodes`.  If a string is passed, it will be [can.view.hookup hookedup].
		 *
		 * @param {function} [teardown] A callback if these elements are torn down.
		 */</span>
		replace: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes, val, teardown</span>) </span>{
			<span class="hljs-keyword">var</span> oldNodes = nodes.slice(<span class="hljs-number">0</span>),
				frag = can.frag(val);
			nodeLists.register(nodes, teardown);


			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>if it was a string, check for hookups</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				frag = can.view.hookup(frag, nodes[<span class="hljs-number">0</span>].parentNode);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>We need to mark each node as belonging to the node list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			nodeLists.update(nodes, getChildNodes(frag));
			elements.replace(oldNodes, frag);
			<span class="hljs-keyword">return</span> nodes;
		},
		<span class="hljs-comment">/**
		 * @function can.view.live.text
		 * @parent can.view.live
		 * @release 2.0.4
		 *
		 * Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data
		 * correct.
		 */</span>
		text: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, compute, parentNode, nodeList</span>) </span>{
			<span class="hljs-keyword">var</span> parent = elements.getParentNode(el, parentNode);</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>setup listening right away so we don’t have to re-calculate value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> data = listen(parent, compute, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, newVal, oldVal</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Sometimes this is ‘unknown’ in IE and will throw an exception if it is</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/* jshint ignore:start */</span>
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node.nodeValue !== <span class="hljs-string">'unknown'</span>) {
					node.nodeValue = can.view.toStr(newVal);
				}
				<span class="hljs-comment">/* jshint ignore:end */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>TODO: remove in 2.1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				data.teardownCheck(node.parentNode);
			});</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>The text node that will be updated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
			<span class="hljs-keyword">var</span> node = el.ownerDocument.createTextNode(can.view.toStr(compute()));
			<span class="hljs-keyword">if</span>(nodeList) {
				nodeList.unregistered = data.teardownCheck;
				data.nodeList = nodeList;

				nodeLists.update(nodeList, [node]);
				elements.replace([el], node);
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Replace the placeholder with the live node and do the nodeLists thing.
Add that node to nodeList so we can remove it when the parent element is removed from the page</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				data.nodeList = live.replace([el], node, data.teardownCheck);
			}

		},
		<span class="hljs-attr">setAttributes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, newVal</span>) </span>{
			<span class="hljs-keyword">var</span> attrs = getAttributeParts(newVal);
			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> attrs) {
				can.attr.set(el, name, attrs[name]);
			}
		},
		<span class="hljs-comment">/**
		 * @function can.view.live.attrs
		 * @parent can.view.live
		 *
		 * Keep attributes live to a [can.compute].
		 *
		 * @param {HTMLElement} el The element whos attributes will be kept live.
		 * @param {can.compute} compute The compute.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 *     var div = document.createElement('div');
		 *     var compute = can.compute("foo='bar' zed='ted'");
		 *     can.view.live.attr(div,compute);
		 *
		 */</span>
		attributes: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, compute, currentValue</span>) </span>{
			<span class="hljs-keyword">var</span> oldAttrs = {};

			<span class="hljs-keyword">var</span> setAttrs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newVal</span>) </span>{
				<span class="hljs-keyword">var</span> newAttrs = getAttributeParts(newVal),
					name;
				<span class="hljs-keyword">for</span>( name <span class="hljs-keyword">in</span> newAttrs ) {
					<span class="hljs-keyword">var</span> newValue = newAttrs[name],
						oldValue = oldAttrs[name];
					<span class="hljs-keyword">if</span>(newValue !== oldValue) {
						can.attr.set(el, name, newValue);
					}
					<span class="hljs-keyword">delete</span> oldAttrs[name];
				}
				<span class="hljs-keyword">for</span>( name <span class="hljs-keyword">in</span> oldAttrs ) {
					elements.removeAttr(el, name);
				}
				oldAttrs = newAttrs;
			};
			listen(el, compute, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, newVal</span>) </span>{
				setAttrs(newVal);
			});</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>current value has been set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt;= <span class="hljs-number">3</span>) {
				oldAttrs = getAttributeParts(currentValue);
			} <span class="hljs-keyword">else</span> {
				setAttrs(compute());
			}
		},
		<span class="hljs-attr">attributePlaceholder</span>: <span class="hljs-string">'__!!__'</span>,
		<span class="hljs-attr">attributeReplace</span>: <span class="hljs-regexp">/__!!__/g</span>,
		<span class="hljs-attr">attribute</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, attributeName, compute</span>) </span>{
			listen(el, compute, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, newVal</span>) </span>{
				elements.setAttr(el, attributeName, hook.render());
			});
			<span class="hljs-keyword">var</span> wrapped = can.$(el),
				hooks;</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Get the list of hookups or create one for this element.
Hooks is a map of attribute names to hookup <code>data</code>s.
Each hookup data has:
<code>render</code> - A <code>function</code> to render the value of the attribute.
<code>funcs</code> - A list of hookup <code>function</code>s on that attribute.
<code>batchNum</code> - The last event <code>batchNum</code>, used for performance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			hooks = can.data(wrapped, <span class="hljs-string">'hooks'</span>);
			<span class="hljs-keyword">if</span> (!hooks) {
				can.data(wrapped, <span class="hljs-string">'hooks'</span>, hooks = {});
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Get the attribute value.
Cast to String. String expected for rendering. Attr may return other types for some attributes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> attr = <span class="hljs-built_in">String</span>(elements.getAttr(el, attributeName)),</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Split the attribute value by the template.
Only split out the first <strong>!!</strong> so if we have multiple hookups in the same attribute,
they will be put in the right spot on first render</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				parts = attr.split(live.attributePlaceholder),
				goodParts = [],
				hook;
			goodParts.push(parts.shift(), parts.join(live.attributePlaceholder));</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>If we already had a hookup for this attribute…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (hooks[attributeName]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Just add to that attribute’s list of <code>function</code>s.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				hooks[attributeName].computes.push(compute);
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>Create the hookup data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				hooks[attributeName] = {
					<span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
						<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>attr doesn’t have a value in IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							newAttr = attr ? attr.replace(live.attributeReplace, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
								<span class="hljs-keyword">return</span> elements.contentText(hook.computes[i++]());
							}) : elements.contentText(hook.computes[i++]());
						<span class="hljs-keyword">return</span> newAttr;
					},
					<span class="hljs-attr">computes</span>: [compute],
					<span class="hljs-attr">batchNum</span>: <span class="hljs-literal">undefined</span>
				};
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Save the hook for slightly faster performance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			hook = hooks[attributeName];</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Insert the value in parts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			goodParts.splice(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, compute());</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Set the attribute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			elements.setAttr(el, attributeName, goodParts.join(<span class="hljs-string">''</span>));
		},
		<span class="hljs-attr">specialAttribute</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, attributeName, compute</span>) </span>{
			listen(el, compute, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, newVal</span>) </span>{
				elements.setAttr(el, attributeName, getValue(newVal));
			});
			elements.setAttr(el, attributeName, getValue(compute()));
		},
		<span class="hljs-comment">/**
		 * @function can.view.live.attr
		 * @parent can.view.live
		 *
		 * Keep an attribute live to a [can.compute].
		 *
		 * @param {HTMLElement} el The element whos attribute will be kept live.
		 * @param {String} attributeName The attribute name.
		 * @param {can.compute} compute The compute.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 *     var div = document.createElement('div');
		 *     var compute = can.compute("foo bar");
		 *     can.view.live.attr(div,"class", compute);
		 */</span>
		simpleAttribute: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, attributeName, compute</span>)</span>{
			listen(el, compute, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev, newVal</span>) </span>{
				elements.setAttr(el, attributeName, newVal);
			});
			elements.setAttr(el, attributeName, compute());
		}
	};
	live.attr = live.simpleAttribute;
	live.attrs = live.attributes;
	live.getAttributeParts = getAttributeParts;
	<span class="hljs-keyword">var</span> newLine = <span class="hljs-regexp">/(\r|\n)+/g</span>;
	<span class="hljs-keyword">var</span> getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{
		<span class="hljs-keyword">var</span> regexp = <span class="hljs-regexp">/^["'].*["']$/</span>;
		val = val.replace(elements.attrReg, <span class="hljs-string">''</span>)
			.replace(newLine, <span class="hljs-string">''</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>check if starts and ends with “ or ‘</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span> regexp.test(val) ? val.substr(<span class="hljs-number">1</span>, val.length - <span class="hljs-number">2</span>) : val;
	};
	can.view.live = live;

	<span class="hljs-keyword">return</span> live;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
