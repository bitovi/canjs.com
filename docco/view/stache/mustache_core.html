<!DOCTYPE html>

<html>
<head>
  <title>can/view/stache/mustache_core.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="add_bundles.html">
                add_bundles.js
              </a>
            
              
              <a class="source" href="expression.html">
                expression.js
              </a>
            
              
              <a class="source" href="html_section.html">
                html_section.js
              </a>
            
              
              <a class="source" href="intermediate_and_imports.html">
                intermediate_and_imports.js
              </a>
            
              
              <a class="source" href="live_attr.html">
                live_attr.js
              </a>
            
              
              <a class="source" href="mustache_core.html">
                mustache_core.js
              </a>
            
              
              <a class="source" href="mustache_helpers.html">
                mustache_helpers.js
              </a>
            
              
              <a class="source" href="stache.html">
                stache.js
              </a>
            
              
              <a class="source" href="system.html">
                system.js
              </a>
            
              
              <a class="source" href="text_section.html">
                text_section.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="can-view-stache-mustache_core-js">can/view/stache/mustache_core.js</h1>
<p>This provides helper utilities for Mustache processing. Currently,
only stache uses these helpers.  Ideally, these utilities could be used
in other libraries implementing Mustache-like features.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
steal(<span class="hljs-string">"can/util"</span>,
	<span class="hljs-string">"./utils"</span>,
	<span class="hljs-string">"./mustache_helpers"</span>,
	<span class="hljs-string">"./expression.js"</span>,
	<span class="hljs-string">"can/view/live"</span>,
	<span class="hljs-string">"can/view/elements.js"</span>,
	<span class="hljs-string">"can/view/scope"</span>,
	<span class="hljs-string">"can/view/node_lists"</span>,
	<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">can, utils, mustacheHelpers, expression, live, elements, Scope, nodeLists </span>)</span>{

	live = live || can.view.live;
	elements = elements || can.view.elements;
	Scope = Scope || can.view.Scope;
	nodeLists = nodeLists || can.view.nodeLists;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="types">Types</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A lookup is an object that is used to identify a lookup in the scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @hide
	 * @typedef {{get: String}} can.mustache.Lookup
	 * @option {String} get A value in the scope to look up.
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="helpers">Helpers</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">var</span> mustacheLineBreakRegExp = <span class="hljs-regexp">/(?:(?:^|(\r?)\n)(\s*)(\{\{([^\}]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([^\}]*)\}\}\}?)/g</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>A helper for calling the truthy subsection for each item in a list and returning them in a string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		getItemsStringContent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">items, isObserveList, helperOptions, options</span>)</span>{
			<span class="hljs-keyword">var</span> txt = <span class="hljs-string">""</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = items.length; i &lt; len; i++) {
				txt += helperOptions.fn( isObserveList ? items.attr(<span class="hljs-string">''</span> + i) : items[i], options);
			}
			<span class="hljs-keyword">return</span> txt;
		},
		k = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};


	<span class="hljs-keyword">var</span> core = {
		<span class="hljs-attr">expression</span>: expression,</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2 id="mustachecore-makeevaluator">mustacheCore.makeEvaluator</h2>
<p>Given a scope and expression, returns a function that evaluates that expression in the scope.</p>
<p>This function first reads lookup values in the args and hash.  Then it tries to figure out
if a helper is being called or a value is being read.  Finally, depending on
if it’s a helper, or not, and which mode the expression is in, it returns
a function that can quickly evaluate the expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Given a mode and expresion data, returns a function that evaluates that expression.
		 * @param {can.view.Scope} The scope in which the expression is evaluated.
		 * @param {can.view.Options} The option helpers in which the expression is evaluated.
		 * @param {String} mode Either null, #, ^. &gt; is handled elsewhere
		 * @param {Object} exprData Data about what was in the mustache expression
		 * @param {renderer} [truthyRenderer] Used to render a subsection
		 * @param {renderer} [falseyRenderer] Used to render the inverse subsection
		 * @param {String} [stringOnly] A flag to indicate that only strings will be returned by subsections.
		 * @return {Function} An 'evaluator' function that evaluates the expression.
		 */</span>
		makeEvaluator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope, helperOptions, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly</span>) </span>{

			<span class="hljs-keyword">if</span>(mode === <span class="hljs-string">"^"</span>) {
				<span class="hljs-keyword">var</span> temp = truthyRenderer;
				truthyRenderer = falseyRenderer;
				falseyRenderer = temp;
			}

			<span class="hljs-keyword">var</span> value,
				helperOptionArg;

			<span class="hljs-keyword">if</span>(exprData <span class="hljs-keyword">instanceof</span> expression.Call) {
				helperOptionArg =  {
					<span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
					<span class="hljs-attr">inverse</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
					<span class="hljs-attr">context</span>: scope.attr(<span class="hljs-string">"."</span>),
					<span class="hljs-attr">scope</span>: scope,
					<span class="hljs-attr">nodeList</span>: nodeList,
					<span class="hljs-attr">exprData</span>: exprData,
					<span class="hljs-attr">helpersScope</span>: helperOptions
				};
				utils.convertToScopes(helperOptionArg, scope,helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);

				value = exprData.value(scope, helperOptions, helperOptionArg);
				<span class="hljs-keyword">if</span>(exprData.isHelper) {
					<span class="hljs-keyword">return</span> value;
				}
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">var</span> readOptions = {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>will return a function instead of calling it.
allowing it to be turned into a compute if necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					isArgument: <span class="hljs-literal">true</span>,
					<span class="hljs-attr">args</span>: [scope.attr(<span class="hljs-string">'.'</span>), scope],
					<span class="hljs-attr">asCompute</span>: <span class="hljs-literal">true</span>
				};
				<span class="hljs-keyword">var</span> helperAndValue = exprData.helperAndValue(scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
				<span class="hljs-keyword">var</span> helper = helperAndValue.helper;
				value = helperAndValue.value;

				<span class="hljs-keyword">if</span>(helper) {
					<span class="hljs-keyword">return</span> exprData.evaluator(helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Return evaluators for no mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(!mode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>If it’s computed, return a function that just reads the compute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span>(value &amp;&amp; value.isComputed) {
					<span class="hljs-keyword">return</span> value;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Just return value as the value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">else</span> {

					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
						<span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + (value != <span class="hljs-literal">null</span> ? value : <span class="hljs-string">''</span>);
					};
				}
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( mode === <span class="hljs-string">"#"</span> || mode === <span class="hljs-string">"^"</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Setup renderers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				helperOptionArg = {
					<span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
					<span class="hljs-attr">inverse</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
				};
				utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Get the value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> finalValue;
					<span class="hljs-keyword">if</span> (can.isFunction(value) &amp;&amp; value.isComputed) {
						finalValue = value();
					} <span class="hljs-keyword">else</span> {
						finalValue = value;
					}
					<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> finalValue === <span class="hljs-string">"function"</span>) {
						<span class="hljs-keyword">return</span> finalValue;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>If it’s an array, render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (utils.isArrayLike(finalValue) ) {
						<span class="hljs-keyword">var</span> isObserveList = utils.isObserveLike(finalValue);

						<span class="hljs-keyword">if</span>(isObserveList ? finalValue.attr(<span class="hljs-string">"length"</span>) : finalValue.length) {
							<span class="hljs-keyword">if</span> (stringOnly) {
								<span class="hljs-keyword">return</span> getItemsStringContent(finalValue, isObserveList, helperOptionArg, helperOptions);
							} <span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">return</span> can.frag(utils.getItemsFragContent(finalValue, helperOptionArg, scope));
							}
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> helperOptionArg.inverse(scope, helperOptions);
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>If truthy, render fn, otherwise, inverse.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> finalValue ? helperOptionArg.fn(finalValue || scope, helperOptions) : helperOptionArg.inverse(scope, helperOptions);
					}
				};
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>not supported!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h2 id="mustachecore-makelivebindingpartialrenderer">mustacheCore.makeLiveBindingPartialRenderer</h2>
<p>Returns a renderer function that live binds a partial.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Returns a renderer function that live binds a partial.
		 * @param {String} partialName the name of the partial.
		 * @return {function(this:HTMLElement,can.view.Scope,can.view.Options)} A renderer function
		 * live binds a partial.
		 */</span>
		makeLiveBindingPartialRenderer: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">partialName, state</span>)</span>{
			partialName = can.trim(partialName);

			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scope, options, parentSectionNodeList</span>)</span>{
				<span class="hljs-keyword">var</span> nodeList = [<span class="hljs-keyword">this</span>];
				nodeList.expression = <span class="hljs-string">"&gt;"</span> + partialName;
				nodeLists.register(nodeList, <span class="hljs-literal">null</span>, parentSectionNodeList || <span class="hljs-literal">true</span>, state.directlyNested);

				<span class="hljs-keyword">var</span> partialFrag = can.compute(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
					<span class="hljs-keyword">var</span> localPartialName = partialName;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Look up partials in options first.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> partial = options.attr(<span class="hljs-string">"partials."</span> + localPartialName), renderer;
					<span class="hljs-keyword">if</span> (partial) {
						renderer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
							<span class="hljs-keyword">return</span> partial.render ? partial.render(scope, options, nodeList)
								: partial(scope, options);
						};
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Use can.view to get and render the partial.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">var</span> scopePartialName = scope.read(localPartialName, {
							<span class="hljs-attr">isArgument</span>: <span class="hljs-literal">true</span>
						}).value;

						<span class="hljs-keyword">if</span> (scopePartialName === <span class="hljs-literal">null</span> || !scopePartialName &amp;&amp; localPartialName[<span class="hljs-number">0</span>] === <span class="hljs-string">'*'</span>) {
							<span class="hljs-keyword">return</span> can.frag(<span class="hljs-string">""</span>);
						}
						<span class="hljs-keyword">if</span> (scopePartialName) {
							localPartialName = scopePartialName;
						}

						renderer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
							<span class="hljs-keyword">return</span> can.isFunction(localPartialName) ? localPartialName(scope, options, nodeList)
								: can.view.render(localPartialName, scope, options, nodeList);
						};
					}
					<span class="hljs-keyword">var</span> res = can.__notObserve(renderer)();
					<span class="hljs-keyword">return</span> can.frag(res);
				});

				partialFrag.computeInstance.setPrimaryDepth(nodeList.nesting);

				live.html(<span class="hljs-keyword">this</span>, partialFrag, <span class="hljs-keyword">this</span>.parentNode, nodeList);
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h2 id="mustachecore-makestringbranchrenderer">mustacheCore.makeStringBranchRenderer</h2>
<p>Return a renderer function that evalutes to a string and caches
the evaluator on the scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Return a renderer function that evaluates to a string.
		 * @param {String} mode
		 * @param {can.mustache.Expression} expression
		 * @return {function(can.view.Scope,can.view.Options, can.view.renderer, can.view.renderer)}
		 */</span>
		makeStringBranchRenderer: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mode, expressionString</span>)</span>{
			<span class="hljs-keyword">var</span> exprData = core.expression.parse(expressionString),</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Use the full mustache expression as the cache key.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				fullExpression = mode+expressionString;</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>convert a lookup like <code>{{value}}</code> to still be called as a helper if necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(!(exprData <span class="hljs-keyword">instanceof</span> expression.Helper) &amp;&amp; !(exprData <span class="hljs-keyword">instanceof</span> expression.Call)) {
				exprData = <span class="hljs-keyword">new</span> expression.Helper(exprData,[],{});
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>A branching renderer takes truthy and falsey renderer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">branchRenderer</span>(<span class="hljs-params">scope, options, truthyRenderer, falseyRenderer</span>)</span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Check the scope’s cache if the evaluator already exists for performance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> evaluator = scope.__cache[fullExpression];
				<span class="hljs-keyword">if</span>(mode || !evaluator) {
					evaluator = makeEvaluator( scope, options, <span class="hljs-literal">null</span>, mode, exprData, truthyRenderer, falseyRenderer, <span class="hljs-literal">true</span>);
					<span class="hljs-keyword">if</span>(!mode) {
						scope.__cache[fullExpression] = evaluator;
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Run the evaluator and return the result.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> res = evaluator();
				<span class="hljs-keyword">return</span> res == <span class="hljs-literal">null</span> ? <span class="hljs-string">""</span> : <span class="hljs-string">""</span>+res;
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h2 id="mustachecore-makelivebindingbranchrenderer">mustacheCore.makeLiveBindingBranchRenderer</h2>
<p>Return a renderer function that evaluates the mustache expression and
sets up live binding if a compute with dependencies is found. Otherwise,
the element’s value is set.</p>
<p>This function works by creating a <code>can.compute</code> from the mustache expression.
If the compute has dependent observables, it passes the compute to <code>can.view.live</code>; otherwise,
it updates the element’s property based on the compute’s value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Returns a renderer function that evaluates the mustache expression.
		 * @param {String} mode
		 * @param {can.mustache.Expression} expression
		 * @param {Object} state The html state of where the expression was found.
		 */</span>
		makeLiveBindingBranchRenderer: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mode, expressionString, state</span>)</span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Pre-process the expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> exprData = core.expression.parse(expressionString);
			<span class="hljs-keyword">if</span>(!(exprData <span class="hljs-keyword">instanceof</span> expression.Helper) &amp;&amp; !(exprData <span class="hljs-keyword">instanceof</span> expression.Call)) {
				exprData = <span class="hljs-keyword">new</span> expression.Helper(exprData,[],{});
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>A branching renderer takes truthy and falsey renderer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">branchRenderer</span>(<span class="hljs-params">scope, options, parentSectionNodeList, truthyRenderer, falseyRenderer</span>)</span>{

				<span class="hljs-keyword">var</span> nodeList = [<span class="hljs-keyword">this</span>];
				nodeList.expression = expressionString;</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>register this nodeList.
Regsiter it with its parent ONLY if this is directly nested.  Otherwise, it’s unencessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				nodeLists.register(nodeList, <span class="hljs-literal">null</span>, parentSectionNodeList || <span class="hljs-literal">true</span>, state.directlyNested);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Get the evaluator. This does not need to be cached (probably) because if there
an observable value, it will be handled by <code>can.view.live</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> evaluator = makeEvaluator( scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer,</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>If this is within a tag, make sure we only get string values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					state.tag );</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Create a compute that can not be observed by other
comptues. This is important because this renderer is likely called by
parent expresions.  If this value changes, the parent expressions should
not re-evaluate. We prevent that by making sure this compute is ignored by
everyone else.
var compute = can.compute(evaluator, null, false);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> gotCompute = evaluator.isComputed,
					compute;
				<span class="hljs-keyword">if</span>(gotCompute) {
					compute = evaluator;
				} <span class="hljs-keyword">else</span> {
					compute = can.compute(evaluator, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);
				}

				compute.computeInstance.setPrimaryDepth(nodeList.nesting);</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Bind on the compute to set the cached value. This helps performance
so live binding can read a cached value instead of re-calculating.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				compute.computeInstance.bind(<span class="hljs-string">"change"</span>, k);

				<span class="hljs-keyword">var</span> value = compute();</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>If value is a function, it’s a helper that returned a function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"function"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>A helper function should do it’s own binding.  Similar to how
we prevented this function’s compute from being noticed by parent expressions,
we hide any observables read in the function by saving any observables that
have been read and then setting them back which overwrites any <code>can.__observe</code> calls
performed in value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					can.__notObserve(value)(<span class="hljs-keyword">this</span>);

				}</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>If the compute has observable dependencies, setup live binding.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(gotCompute || compute.computeInstance.hasDependencies ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Depending on where the template is, setup live-binding differently.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span>(state.attr) {
						live.simpleAttribute(<span class="hljs-keyword">this</span>, state.attr, compute);
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( state.tag )  {
						live.attributes( <span class="hljs-keyword">this</span>, compute );
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state.text &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">"object"</span>){
						live.text(<span class="hljs-keyword">this</span>, compute, <span class="hljs-keyword">this</span>.parentNode, nodeList);
					}
					<span class="hljs-keyword">else</span> {
						live.html(<span class="hljs-keyword">this</span>, compute, <span class="hljs-keyword">this</span>.parentNode, nodeList);
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>If the compute has no observable dependencies, just set the value on the element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">else</span> {

					<span class="hljs-keyword">if</span>(state.attr) {
						can.attr.set(<span class="hljs-keyword">this</span>, state.attr, value);
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state.tag) {
						live.setAttributes(<span class="hljs-keyword">this</span>, value);
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state.text &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"string"</span>) {
						<span class="hljs-keyword">this</span>.nodeValue = value;
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( value != <span class="hljs-literal">null</span> ){
						elements.replace([<span class="hljs-keyword">this</span>], can.frag(value, <span class="hljs-keyword">this</span>.ownerDocument));
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Unbind the compute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				compute.computeInstance.unbind(<span class="hljs-string">"change"</span>, k);
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h2 id="mustachecore-splitmodefromexpression">mustacheCore.splitModeFromExpression</h2>
<p>Returns the mustache mode split from the rest of the expression.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Returns the mustache mode split from the rest of the expression.
		 * @param {can.mustache.Expression} expression
		 * @param {Object} state The state of HTML where the expression was found.
		 */</span>
		splitModeFromExpression: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">expression, state</span>)</span>{
			expression = can.trim(expression);
			<span class="hljs-keyword">var</span> mode = expression.charAt(<span class="hljs-number">0</span>);

			<span class="hljs-keyword">if</span>( <span class="hljs-string">"#/{&amp;^&gt;!"</span>.indexOf(mode) &gt;= <span class="hljs-number">0</span> ) {
				expression = can.trim( expression.substr(<span class="hljs-number">1</span>) );
			} <span class="hljs-keyword">else</span> {
				mode = <span class="hljs-literal">null</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Triple braces do nothing within a tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(mode === <span class="hljs-string">"{"</span> &amp;&amp; state.node) {
				mode = <span class="hljs-literal">null</span>;
			}
			<span class="hljs-keyword">return</span> {
				<span class="hljs-attr">mode</span>: mode,
				<span class="hljs-attr">expression</span>: expression
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h2 id="mustachecore-cleanlineendings">mustacheCore.cleanLineEndings</h2>
<p>Removes line breaks accoding to the mustache specification.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * Prunes line breaks accoding to the mustache specification.
		 * @param {String} template
		 * @return {String}
		 */</span>
		cleanLineEndings: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">template</span>)</span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Finds mustache tags with space around them or no space around them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> template.replace( mustacheLineBreakRegExp,
				<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">whole,
					returnBefore,
					spaceBefore,
					special,
					expression,
					spaceAfter,
					returnAfter,
</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>A mustache magic tag that has no space around it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					spaceLessSpecial,
					spaceLessExpression,
					matchIndex){</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>IE 8 will provide undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				spaceAfter = (spaceAfter || <span class="hljs-string">""</span>);
				returnBefore = (returnBefore || <span class="hljs-string">""</span>);
				spaceBefore = (spaceBefore || <span class="hljs-string">""</span>);

				<span class="hljs-keyword">var</span> modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>If it’s a partial or tripple stache, leave in place.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span>(spaceLessSpecial || <span class="hljs-string">"&gt;{"</span>.indexOf( modeAndExpression.mode) &gt;= <span class="hljs-number">0</span>) {
					<span class="hljs-keyword">return</span> whole;
				}  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-string">"^#!/"</span>.indexOf(  modeAndExpression.mode ) &gt;= <span class="hljs-number">0</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Return the magic tag and a trailing linebreak if this did not
start a new line and there was an end line.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> special+( matchIndex !== <span class="hljs-number">0</span> &amp;&amp; returnAfter.length ? returnBefore+<span class="hljs-string">"\n"</span> :<span class="hljs-string">""</span>);


				} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>There is no mode, return special with spaces around it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== <span class="hljs-number">0</span> ? returnBefore+<span class="hljs-string">"\n"</span> : <span class="hljs-string">""</span>);
				}

			});
		},
		<span class="hljs-attr">Options</span>: utils.Options
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h2 id="local-variable-cache">Local Variable Cache</h2>
<p>The following creates slightly more quickly accessible references of the following
core functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> makeEvaluator = core.makeEvaluator,
		splitModeFromExpression = core.splitModeFromExpression;

	can.view.mustacheCore = core;
	<span class="hljs-keyword">return</span> core;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
