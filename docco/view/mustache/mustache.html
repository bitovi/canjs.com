<!DOCTYPE html>

<html>
<head>
  <title>mustache.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="mustache.html">
                mustache.js
              </a>
            
              
              <a class="source" href="mustache_benchmark.html">
                mustache_benchmark.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>mustache.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>steal(<span class="hljs-string">'can/util'</span>,
	<span class="hljs-string">'can/view/scope'</span>,
	<span class="hljs-string">'can/view'</span>,
	<span class="hljs-string">'can/view/scanner.js'</span>,
	<span class="hljs-string">'can/compute'</span>,
	<span class="hljs-string">'can/view/render.js'</span>,
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(can)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1 id="mustache-js">mustache.js</h1>
<p><code>can.Mustache</code>: The Mustache templating engine.</p>
<p>See the <a href="#section-29">Transformation</a> section within <em>Scanning Helpers</em> for a detailed explanation 
of the runtime render code design. The majority of the Mustache engine implementation 
occurs within the <em>Transformation</em> scanning helper.</p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2 id="initialization">Initialization</h2>
<p>Define the view extension.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		can.view.ext = <span class="hljs-string">".mustache"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h3 id="setup-internal-helper-variables-and-functions-">Setup internal helper variables and functions.</h3>
<p>An alias for the context variable used for tracking a stack of contexts.
This is also used for passing to helper functions to maintain proper context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> SCOPE = <span class="hljs-string">'scope'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>An alias for the variable used for the hash object that can be passed
to helpers via <code>options.hash</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			HASH = <span class="hljs-string">'___h4sh'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>An alias for the most used context stacking call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			CONTEXT_OBJ = <span class="hljs-string">'{scope:'</span> + SCOPE + <span class="hljs-string">',options:options}'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>a context object used to incidate being special</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			SPECIAL_CONTEXT_OBJ = <span class="hljs-string">'{scope:'</span> + SCOPE + <span class="hljs-string">',options:options, special: true}'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>argument names used to start the function (used by scanner and steal)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			ARG_NAMES = SCOPE + <span class="hljs-string">",options"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>matches arguments inside a {{ }}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			argumentsRegExp = <span class="hljs-regexp">/((([^'"\s]+?=)?('.*?'|".*?"))|.*?)\s/g</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>matches a literal number, string, null or regexp</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			literalNumberStringBooleanRegExp = <span class="hljs-regexp">/^(('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)|((.+?)=(('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false)|(.+))))$/</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>returns an object literal that we can use to look up a value in the current scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			makeLookupLiteral = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type)</span> </span>{
				<span class="hljs-keyword">return</span> <span class="hljs-string">'{get:"'</span> + type.replace(<span class="hljs-regexp">/"/g</span>, <span class="hljs-string">'\\"'</span>) + <span class="hljs-string">'"}'</span>;
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>returns if the object is a lookup</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			isLookup = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> </span>{
				<span class="hljs-keyword">return</span> obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj.get === <span class="hljs-string">"string"</span>;
			},

			<span class="hljs-comment">/*
			 * Checks whether an object is like a can.Map. This takes into
			 * fact that can.route is can.Map like.
			 * @param  {[can.Map]}  observable
			 * @return {Boolean} returns if the object is observable like.
			 */</span>
			isObserveLike = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> </span>{
				<span class="hljs-keyword">return</span> obj <span class="hljs-keyword">instanceof</span> can.Map || (obj &amp;&amp; !! obj._get);
			},

			<span class="hljs-comment">/*
			 * Tries to determine if the object passed is an array.
			 * @param  {Array}  obj The object to check.
			 * @return {Boolean} returns if the object is an array.
			 */</span>
			isArrayLike = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> </span>{
				<span class="hljs-keyword">return</span> obj &amp;&amp; obj.splice &amp;&amp; <span class="hljs-keyword">typeof</span> obj.length === <span class="hljs-string">'number'</span>;
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>used to make sure .fn and .inverse are always called with a Scope like object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			makeConvertToScopes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(original, scope, options)</span> </span>{
				<span class="hljs-keyword">var</span> originalWithScope = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx, opts)</span></span>{
					<span class="hljs-keyword">return</span> original(ctx || scope, opts);
				};
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(updatedScope, updatedOptions)</span> </span>{
					<span class="hljs-keyword">if</span> (updatedScope !== <span class="hljs-literal">undefined</span> &amp;&amp; !(updatedScope <span class="hljs-keyword">instanceof</span> can.view.Scope)) {
						updatedScope = scope.add(updatedScope);
					}
					<span class="hljs-keyword">if</span> (updatedOptions !== <span class="hljs-literal">undefined</span> &amp;&amp; !(updatedOptions <span class="hljs-keyword">instanceof</span> can.view.Options)) {
						updatedOptions = options.add(updatedOptions);
					}
					<span class="hljs-keyword">return</span> originalWithScope(updatedScope, updatedOptions || options);
				};
			};</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h2 id="mustache">Mustache</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @hide
		 * The Mustache templating engine.
		 * @param {Object} options	Configuration options
		 */</span>
		<span class="hljs-keyword">var</span> Mustache = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options, helpers)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Support calling Mustache without the constructor.
This returns a function that renders the template.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.constructor !== Mustache) {
				<span class="hljs-keyword">var</span> mustache = <span class="hljs-keyword">new</span> Mustache(options);
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, options)</span> </span>{
					<span class="hljs-keyword">return</span> mustache.render(data, options);
				};
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>If we get a <code>function</code> directly, it probably is coming from
a <code>steal</code>-packaged view.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"function"</span>) {
				<span class="hljs-keyword">this</span>.template = {
					fn: options
				};
				<span class="hljs-keyword">return</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Set options on self.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			can.extend(<span class="hljs-keyword">this</span>, options);
			<span class="hljs-keyword">this</span>.template = <span class="hljs-keyword">this</span>.scanner.scan(<span class="hljs-keyword">this</span>.text, <span class="hljs-keyword">this</span>.name);
		};

		<span class="hljs-comment">/**
		 * @add can.MustacheConstructor
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Put Mustache on the <code>can</code> object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		can.Mustache = <span class="hljs-built_in">window</span>.Mustache = Mustache;

		<span class="hljs-comment">/** 
		 * @prototype
		 */</span>
		Mustache.prototype.
		<span class="hljs-comment">/**
		 * @function can.MustacheConstructor.prototype.render render
		 * @parent can.MustacheConstructor.prototype
		 * @signature `mustache.render( data [, helpers] )`
		 * @param {Object} data Data to interpolate into the template.
		 * @return {String} The template with interpolated data, in string form.
		 * @hide
		 *
		 * @body
		 * Renders an object with view helpers attached to the view.
		 *
		 *		 new Mustache({text: "&lt;%= message %&gt;"}).render({
		 *			 message: "foo"
		 *		 })
		 */</span>
		render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, options)</span> </span>{
			<span class="hljs-keyword">if</span> (!(data <span class="hljs-keyword">instanceof</span> can.view.Scope)) {
				data = <span class="hljs-keyword">new</span> can.view.Scope(data || {});
			}
			<span class="hljs-keyword">if</span> (!(options <span class="hljs-keyword">instanceof</span> can.view.Options)) {
				options = <span class="hljs-keyword">new</span> can.view.Options(options || {});
			}
			options = options || {};

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.template.fn.call(data, data, options);
		};

		can.extend(Mustache.prototype, {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Share a singleton scanner for parsing templates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			scanner: <span class="hljs-keyword">new</span> can.view.Scanner({</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>A hash of strings for the scanner to inject at certain points.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				text: {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>This is the logic to inject at the beginning of a rendered template. 
This includes initializing the <code>context</code> stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					start: <span class="hljs-string">""</span>, <span class="hljs-comment">//"var "+SCOPE+"= this instanceof can.view.Scope? this : new can.view.Scope(this);\n",</span>
					scope: SCOPE,
					options: <span class="hljs-string">",options: options"</span>,
					argNames: ARG_NAMES
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>An ordered token registry for the scanner.
This needs to be ordered by priority to prevent token parsing errors.
Each token follows the following structure:</p>
<pre><code>[
    <span class="hljs-comment">// Which key in the token map to match.</span>
    <span class="hljs-string">"tokenMapName"</span>,

    <span class="hljs-comment">// A simple token to match, like "{{".</span>
    <span class="hljs-string">"token"</span>,

    <span class="hljs-comment">// Optional. A complex (regexp) token to match that </span>
    <span class="hljs-comment">// overrides the simple token.</span>
    <span class="hljs-string">"[\\s\\t]*{{"</span>,

    <span class="hljs-comment">// Optional. A function that executes advanced </span>
    <span class="hljs-comment">// manipulation of the matched content. This is </span>
    <span class="hljs-comment">// rarely used.</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(content)</span></span>{   
        <span class="hljs-keyword">return</span> content;
    }
]
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>				tokens: [
					<span class="hljs-comment">/**
					 * @function can.mustache.tags.escaped {{key}}
					 *
					 * @description Insert the value of the [can.mustache.key key] into the
					 * output of the template.
					 *
					 * @parent can.mustache.tags 0
					 *
					 * @signature `{{key}}`
					 *
					 * @param {can.mustache.key} key A key that references one of the following:
					 *
					 *  - A [can.mustache.registerHelper registered helper].
					 *  - A value within the current or parent
					 *    [can.mustache.context context]. If the value is a function or [can.compute], the
					 *    function's return value is used.
					 *
					 * @return {String|Function|*}
					 *
					 * After the key's value is found (and set to any function's return value),
					 * it is passed to [can.view.txt] as the result of a call to its `func`
					 * argument. There, if the value is a:
					 *
					 *  - `null` or `undefined` - an empty string is inserted into the rendered template result.
					 *  - `String` or `Number` - the value is inserted into the rendered template result.
					 *  - `Function` - A [can.view.hook hookup] attribute or element is inserted so this function
					 *    will be called back with the DOM element after it is created.
					 *
					 * @body
					 *
					 * ## Use
					 *
					 * `{{key}}` insert data into the template. It most commonly references
					 * values within the current [can.mustache.context context]. For example:
					 *
					 * Rendering:
					 *
					 *     &lt;h1&gt;{{name}}&lt;/h1&gt;
					 *
					 * With:
					 *
					 *     {name: "Austin"}
					 *
					 * Results in:
					 *
					 *     &lt;h1&gt;Austin&lt;/h1&gt;
					 *
					 * If the key value is a String or Number, it is inserted into the template.
					 * If it is `null` or `undefined`, nothing is added to the template.
					 *
					 *
					 * ## Nested Properties
					 *
					 * Mustache supports nested paths, making it possible to
					 * look up properties nested deep inside the current context. For example:
					 *
					 * Rendering:
					 *
					 *     &lt;h1&gt;{{book.author}}&lt;/h1&gt;
					 *
					 * With:
					 *
					 *     {
					 *       book: {
					 *         author: "Ernest Hemingway"
					 *       }
					 *     }
					 *
					 * Results in:
					 *
					 *     &lt;h1&gt;Ernest Hemingway&lt;/h1&gt;
					 *
					 * ## Looking up values in parent contexts
					 *
					 * Sections and block helpers can create their own contexts. If a key's value
					 * is not found in the current context, it will look up the key's value
					 * in parent contexts. For example:
					 *
					 * Rendering:
					 *
					 *     {{#chapters}}
					 *        &lt;li&gt;{{title}} - {{name}}&lt;/li&gt;
					 *     {{chapters}}
					 *
					 * With:
					 *
					 *     {
					 *       title: "The Book of Bitovi"
					 *       chapters: [{name: "Breakdown"}]
					 *     }
					 *
					 * Results in:
					 *
					 *     &lt;li&gt;The Book of Bitovi - Breakdown&lt;/li&gt;
					 *
					 *
					 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Return unescaped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[<span class="hljs-string">"returnLeft"</span>, <span class="hljs-string">"{{{"</span>, <span class="hljs-string">"{{[{&amp;]"</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Full line comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[<span class="hljs-string">"commentFull"</span>, <span class="hljs-string">"{{!}}"</span>, <span class="hljs-string">"^[\\s\\t]*{{!.+?}}\\n"</span>],
					<span class="hljs-comment">/**
					 * @function can.mustache.tags.comment {{!key}}
					 *
					 * @parent can.mustache.tags 7
					 *
					 * @description A comment that doesn't get inserted into the rendered result.
					 *
					 * @signature `{{!key}}`
					 *
					 * The comment tag operates similarly to a `&lt;!-- --&gt;` tag in HTML. It exists in your template but never shows up.
					 *
					 * @param {can.mustache.key} key Everything within this tag is completely ignored.
					 * @return {String}
					 *
					 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Inline comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[<span class="hljs-string">"commentLeft"</span>, <span class="hljs-string">"{{!"</span>, <span class="hljs-string">"(\\n[\\s\\t]*{{!|{{!)"</span>],
					<span class="hljs-comment">/**
					 * @function can.mustache.tags.unescaped {{{key}}}
					 *
					 * @parent can.mustache.tags 1
					 *
					 * @description Insert the unescaped value of the [can.mustache.key key] into the
					 * output of the template.
					 *
					 * @signature `{{{key}}}`
					 *
					 * Behaves just like [can.mustache.tags.escaped {{key}}] and [can.mustache.helpers.helper {{helper}}] but does not
					 * escape the result.
					 *
					 * @param {can.mustache.key} key A key that references a value within the current or parent
					 * context. If the value is a function or can.compute, the function's return value is used.
					 * @return {String|Function|*}
					 *
					 *
					 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-comment">/**
					 * @function can.mustache.tags.unescaped2 {{&amp;key}}
					 *
					 * @parent can.mustache.tags 2
					 *
					 * @description Insert the unescaped value of the [can.mustache.key key] into the
					 * output of the template.
					 *
					 * @signature `{{&amp;key}}`
					 *
					 * The `{{&amp;key}}` tag is an alias for [can.mustache.tags.unescaped {{{key}}}], behaving just
					 * like [can.mustache.tags.escaped {{key}}] and [can.mustache.helpers.helper {{helper}}] but does not
					 * escape the result.
					 *
					 * @param {can.mustache.key} key A key that references a value within the current or parent
					 * context. If the value is a function or can.compute, the function's return value is used.
					 * @return {String|Function|*}
					 *
					 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Full line escapes
This is used for detecting lines with only whitespace and an escaped tag</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[<span class="hljs-string">"escapeFull"</span>, <span class="hljs-string">"{{}}"</span>, <span class="hljs-string">"(^[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}$)"</span>,
						<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(content)</span> </span>{
							<span class="hljs-keyword">return</span> {
								before: <span class="hljs-regexp">/^\n.+?\n$/</span>.test(content) ? <span class="hljs-string">'\n'</span> : <span class="hljs-string">''</span>,
								content: content.match(<span class="hljs-regexp">/\{\{(.+?)\}\}/</span>)[<span class="hljs-number">1</span>] || <span class="hljs-string">''</span>
							};
						}
					],</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Return escaped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[<span class="hljs-string">"escapeLeft"</span>, <span class="hljs-string">"{{"</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Close return unescaped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[<span class="hljs-string">"returnRight"</span>, <span class="hljs-string">"}}}"</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Close tag</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					[<span class="hljs-string">"right"</span>, <span class="hljs-string">"}}"</span>]
				],</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h2 id="scanning-helpers">Scanning Helpers</h2>
<p>This is an array of helpers that transform content that is within escaped tags like <code>{{token}}</code>. These helpers are solely for the scanning phase; they are unrelated to Mustache/Handlebars helpers which execute at render time. Each helper has a definition like the following:</p>
<pre><code>{
    <span class="hljs-comment">// The content pattern to match in order to execute.</span>
    <span class="hljs-comment">// Only the first matching helper is executed.</span>
    name: <span class="hljs-regexp">/pattern to match/</span>,

    <span class="hljs-comment">// The function to transform the content with.</span>
    <span class="hljs-comment">// @param {String} content   The content to transform.</span>
    <span class="hljs-comment">// @param {Object} cmd       Scanner helper data.</span>
    <span class="hljs-comment">//                           {</span>
    <span class="hljs-comment">//                             insert: "insert command",</span>
    <span class="hljs-comment">//                             tagName: "div",</span>
    <span class="hljs-comment">//                             status: 0</span>
    <span class="hljs-comment">//                           }</span>
    fn: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(content, cmd)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'for text injection'</span> || 
            { raw: <span class="hljs-string">'to bypass text injection'</span> };
    }
}
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>				helpers: [</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h3 id="partials">Partials</h3>
<p>Partials begin with a greater than sign, like {{&gt; box}}.</p>
<p>Partials are rendered at runtime (as opposed to compile time), 
so recursive partials are possible. Just avoid infinite loops.</p>
<p>For example, this template and partial:</p>
<pre><code>    base.mustache:
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">h2</span>&gt;</span>Names<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>
        {{#names}}
            {{&gt; user}}
        {{/names}}

    user.mustache:
        <span class="hljs-tag">&lt;<span class="hljs-title">strong</span>&gt;</span>{{name}}<span class="hljs-tag">&lt;/<span class="hljs-title">strong</span>&gt;</span></span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>					{
						name: <span class="hljs-regexp">/^&gt;[\s]*\w*/</span>,
						fn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(content, cmd)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Get the template name and call back into the render method,
passing the name and the current context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">var</span> templateName = can.trim(content.replace(<span class="hljs-regexp">/^&gt;\s?/</span>, <span class="hljs-string">''</span>))
								.replace(<span class="hljs-regexp">/["|']/g</span>, <span class="hljs-string">""</span>);
							<span class="hljs-keyword">return</span> <span class="hljs-string">"can.Mustache.renderPartial('"</span> + templateName + <span class="hljs-string">"',"</span> + ARG_NAMES + <span class="hljs-string">")"</span>;
						}
					},</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <h3 id="data-hookup">Data Hookup</h3>
<p>This will attach the data property of <code>this</code> to the element
its found on using the first argument as the data attribute
key.</p>
<p>For example:</p>
<pre><code>&lt;li id=<span class="hljs-string">"nameli"</span> {{ data <span class="hljs-string">'name'</span> }}&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span></span>
</code></pre><p>then later you can access it like:</p>
<pre><code>can.$(<span class="hljs-string">'#nameli'</span>).data(<span class="hljs-string">'name'</span>);
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-comment">/**
					 * @function can.mustache.helpers.data {{data name}}
					 * @parent can.mustache.htags 7
					 * @signature `{{data name}}`
					 *
					 * Adds the current [can.mustache.context context] to the
					 * element's [can.data].
					 *
					 * @param {String} name The name of the data attribute to use for the
					 * context.
					 *
					 * @body
					 *
					 * ## Use
					 *
					 * It is common for you to want some data in the template to be available
					 * on an element.  `{{data name}}` allows you to save the
					 * context so it can later be retrieved by [can.data] or
					 * `$.fn.data`. For example,
					 *
					 * The template:
					 *
					 *     &lt;ul&gt;
					 *       &lt;li id="person" {{data 'person'}}&gt;{{name}}&lt;/li&gt;
					 *     &lt;/ul&gt;
					 *
					 * Rendered with:
					 *
					 *     document.body.appendChild(
					 *       can.view.mustache(template,{ person: { name: 'Austin' } });
					 *
					 * Retrieve the person data back with:
					 *
					 *     $("#person").data("person")
					 *
					 */</span>
					{
						name: <span class="hljs-regexp">/^\s*data\s/</span>,
						fn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(content, cmd)</span> </span>{
							<span class="hljs-keyword">var</span> attr = content.match(<span class="hljs-regexp">/["|'](.*)["|']/</span>)[<span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>return a function which calls <code>can.data</code> on the element
with the attribute name with the current context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> <span class="hljs-string">"can.proxy(function(__){"</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>“var context = this[this.length-1];” +
“context = context.” + STACKED + “ ? context[context.length-2] : context; console.warn(this, context);” +</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-string">"can.data(can.$(__),'"</span> + attr + <span class="hljs-string">"', this.attr('.')); }, "</span> + SCOPE + <span class="hljs-string">")"</span>;
						}
					}, {
						name: <span class="hljs-regexp">/\s*\(([\$\w]+)\)\s*-&gt;([^\n]*)/</span>,
						fn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(content)</span> </span>{
							<span class="hljs-keyword">var</span> quickFunc = <span class="hljs-regexp">/\s*\(([\$\w]+)\)\s*-&gt;([^\n]*)/</span>,
								parts = content.match(quickFunc);</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>find </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> <span class="hljs-string">"can.proxy(function(__){var "</span> + parts[<span class="hljs-number">1</span>] + <span class="hljs-string">"=can.$(__);with("</span> + SCOPE + <span class="hljs-string">".attr('.')){"</span> + parts[<span class="hljs-number">2</span>] + <span class="hljs-string">"}}, this);"</span>;
						}
					},</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h3 id="transformation-default-">Transformation (default)</h3>
<p>This transforms all content to its interpolated equivalent,
including calls to the corresponding helpers as applicable. 
This outputs the render code for almost all cases.</p>
<h4 id="definitions">Definitions</h4>
<ul>
<li><code>context</code> - This is the object that the current rendering context operates within. 
  Each nested template adds a new <code>context</code> to the context stack.</li>
<li><code>stack</code> - Mustache supports nested sections, 
  each of which add their own context to a stack of contexts.
  Whenever a token gets interpolated, it will check for a match against the 
  last context in the stack, then iterate through the rest of the stack checking for matches.
  The first match is the one that gets returned.</li>
<li><code>Mustache.txt</code> - This serializes a collection of logic, optionally contained within a section.
  If this is a simple interpolation, only the interpolation lookup will be passed.
  If this is a section, then an <code>options</code> object populated by the truthy (<code>options.fn</code>) and 
  falsey (<code>options.inverse</code>) encapsulated functions will also be passed. This section handling 
  exists to support the runtime context nesting that Mustache supports.</li>
<li><code>Mustache.get</code> - This resolves an interpolation reference given a stack of contexts.</li>
<li><code>options</code> - An object containing methods for executing the inner contents of sections or helpers.<br>  <code>options.fn</code> - Contains the inner template logic for a truthy section.<br>  <code>options.inverse</code> - Contains the inner template logic for a falsey section.<br>  <code>options.hash</code> - Contains the merged hash object argument for custom helpers.</li>
</ul>
<h4 id="design">Design</h4>
<p>This covers the design of the render code that the transformation helper generates.</p>
<h5 id="pseudocode">Pseudocode</h5>
<p>A detailed explanation is provided in the following sections, but here is some brief pseudocode
that gives a high level overview of what the generated render code does (with a template similar to<br><code>&quot;{{#a}}{{b.c.d.e.name}}{{/a}}&quot; == &quot;Phil&quot;</code>).</p>
<p><em>Initialize the render code.</em></p>
<pre><code>    view = []
    context = []
    stack = fn { context.concat([<span class="hljs-keyword">this</span>]) }
</code></pre><p><em>Render the root section.</em></p>
<pre><code>    view.push( <span class="hljs-string">"string"</span> )
    view.push( can.view.txt(
</code></pre><p><em>Render the nested section with <code>can.Mustache.txt</code>.</em></p>
<pre><code>        txt( 
</code></pre><p><em>Add the current context to the stack.</em></p>
<pre><code>            stack(), 
</code></pre><p><em>Flag this for truthy section mode.</em></p>
<pre><code>            <span class="hljs-string">"#"</span>,
</code></pre><p><em>Interpolate and check the <code>a</code> variable for truthyness using the stack with <code>can.Mustache.get</code>.</em></p>
<pre><code>            get( <span class="hljs-string">"a"</span>, stack() ),
</code></pre><p><em>Include the nested section’s inner logic.
The stack argument is usually the parent section’s copy of the stack, 
but it can be an override context that was passed by a custom helper.
Sections can nest <code>0..n</code> times — <strong>NESTCEPTION</strong>.</em></p>
<pre><code>            { fn: fn(stack) {
</code></pre><p><em>Render the nested section (everything between the <code>{{#a}}</code> and <code>{{/a}}</code> tokens).</em></p>
<pre><code>                view = []
                view.push( <span class="hljs-string">"string"</span> )
                view.push(
</code></pre><p><em>Add the current context to the stack.</em></p>
<pre><code>                    stack(),
</code></pre><p><em>Flag this as interpolation-only mode.</em></p>
<pre><code>                    <span class="hljs-literal">null</span>,
</code></pre><p><em>Interpolate the <code>b.c.d.e.name</code> variable using the stack.</em></p>
<pre><code>                    get( <span class="hljs-string">"b.c.d.e.name"</span>, stack() ),
                )
                view.push( <span class="hljs-string">"string"</span> )
</code></pre><p><em>Return the result for the nested section.</em></p>
<pre><code>                <span class="hljs-keyword">return</span> view.join()
            }}
        )
    ))
    view.push( <span class="hljs-string">"string"</span> )
</code></pre><p><em>Return the result for the root section, which includes all nested sections.</em></p>
<pre><code>    <span class="hljs-keyword">return</span> view.join()
</code></pre><h5 id="initialization">Initialization</h5>
<p>Each rendered template is started with the following initialization code:</p>
<pre><code>    <span class="hljs-keyword">var</span> ___v1ew = [];
    <span class="hljs-keyword">var</span> ___c0nt3xt = [];
    ___c0nt3xt.__sc0pe = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> __sc0pe = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(context, self)</span> </span>{
        <span class="hljs-keyword">var</span> s;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">1</span> &amp;&amp; context) {
            s = !context.__sc0pe ? [context] : context;
        } <span class="hljs-keyword">else</span> {
            s = context &amp;&amp; context.__sc0pe 
            ? context.concat([self]) 
            : __sc0pe(context).concat([self]);
        }
        <span class="hljs-keyword">return</span> (s.__sc0pe = <span class="hljs-literal">true</span>) &amp;&amp; s;
    };
</code></pre><p>The <code>___v1ew</code> is the the array used to serialize the view.
The <code>___c0nt3xt</code> is a stacking array of contexts that slices and expands with each nested section.
The <code>__sc0pe</code> function is used to more easily update the context stack in certain situations.
Usually, the stack function simply adds a new context (<code>self</code>/<code>this</code>) to a context stack. 
However, custom helpers will occasionally pass override contexts that need their own context stack.</p>
<h5 id="sections">Sections</h5>
<p>Each section, <code>{{#section}} content {{/section}}</code>, within a Mustache template generates a section 
context in the resulting render code. The template itself is treated like a root section, with the 
same execution logic as any others. Each section can have <code>0..n</code> nested sections within it.</p>
<p>Here’s an example of a template without any descendent sections.<br>Given the template: <code>&quot;{{a.b.c.d.e.name}}&quot; == &quot;Phil&quot;</code><br>Would output the following render code:</p>
<pre><code>___v1ew.push(<span class="hljs-string">"\""</span>);
___v1ew.push(can.view.txt(<span class="hljs-number">1</span>, <span class="hljs-string">''</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> can.Mustache.txt(__sc0pe(___c0nt3xt, <span class="hljs-keyword">this</span>), <span class="hljs-literal">null</span>, 
        can.Mustache.get(<span class="hljs-string">"a.b.c.d.e.name"</span>, 
            __sc0pe(___c0nt3xt, <span class="hljs-keyword">this</span>))
    );
}));
___v1ew.push(<span class="hljs-string">"\" == \"Phil\""</span>);
</code></pre><p>The simple strings will get appended to the view. Any interpolated references (like <code>{{a.b.c.d.e.name}}</code>) 
will be pushed onto the view via <code>can.view.txt</code> in order to support live binding.
The function passed to <code>can.view.txt</code> will call <code>can.Mustache.txt</code>, which serializes the object data by doing 
a context lookup with <code>can.Mustache.get</code>.</p>
<p><code>can.Mustache.txt</code>‘s first argument is a copy of the context stack with the local context <code>this</code> added to it.
This stack will grow larger as sections nest.</p>
<p>The second argument is for the section type. This will be <code>&quot;#&quot;</code> for truthy sections, <code>&quot;^&quot;</code> for falsey, 
or <code>null</code> if it is an interpolation instead of a section.</p>
<p>The third argument is the interpolated value retrieved with <code>can.Mustache.get</code>, which will perform the 
context lookup and return the approriate string or object.</p>
<p>Any additional arguments, if they exist, are used for passing arguments to custom helpers.</p>
<p>For nested sections, the last argument is an <code>options</code> object that contains the nested section’s logic.</p>
<p>Here’s an example of a template with a single nested section.<br>Given the template: <code>&quot;{{#a}}{{b.c.d.e.name}}{{/a}}&quot; == &quot;Phil&quot;</code><br>Would output the following render code:</p>
<pre><code>___v1ew.push(<span class="hljs-string">"\""</span>);
    ___v1ew.push(can.view.txt(<span class="hljs-number">0</span>, <span class="hljs-string">''</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> can.Mustache.txt(__sc0pe(___c0nt3xt, <span class="hljs-keyword">this</span>), <span class="hljs-string">"#"</span>, 
        can.Mustache.get(<span class="hljs-string">"a"</span>, __sc0pe(___c0nt3xt, <span class="hljs-keyword">this</span>)), 
            [{
                _: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">return</span> ___v1ew.join(<span class="hljs-string">""</span>);
                }
            }, {
                fn: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(___c0nt3xt)</span> </span>{
                    <span class="hljs-keyword">var</span> ___v1ew = [];
                    ___v1ew.push(can.view.txt(<span class="hljs-number">1</span>, <span class="hljs-string">''</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>, 
                        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                             <span class="hljs-keyword">return</span> can.Mustache.txt(
                                __sc0pe(___c0nt3xt, <span class="hljs-keyword">this</span>), 
                                <span class="hljs-literal">null</span>, 
                                can.Mustache.get(<span class="hljs-string">"b.c.d.e.name"</span>, 
                                    __sc0pe(___c0nt3xt, <span class="hljs-keyword">this</span>))
                            );
                        }
                    ));
                    <span class="hljs-keyword">return</span> ___v1ew.join(<span class="hljs-string">""</span>);
                }
            }]
    )
    }));
___v1ew.push(<span class="hljs-string">"\" == \"Phil\""</span>);
</code></pre><p>This is specified as a truthy section via the <code>&quot;#&quot;</code> argument. The last argument includes an array of helper methods used with <code>options</code>.
These act similarly to custom helpers: <code>options.fn</code> will be called for truthy sections, <code>options.inverse</code> will be called for falsey sections.
The <code>options._</code> function only exists as a dummy function to make generating the section nesting easier (a section may have a <code>fn</code>, <code>inverse</code>,
or both, but there isn’t any way to determine that at compilation time).</p>
<p>Within the <code>fn</code> function is the section’s render context, which in this case will render anything between the <code>{{#a}}</code> and <code>{{/a}}</code> tokens.
This function has <code>___c0nt3xt</code> as an argument because custom helpers can pass their own override contexts. For any case where custom helpers
aren’t used, <code>___c0nt3xt</code> will be equivalent to the <code>__sc0pe(___c0nt3xt, this)</code> stack created by its parent section. The <code>inverse</code> function
works similarly, except that it is added when <code>{{^a}}</code> and <code>{{else}}</code> are used. <code>var ___v1ew = []</code> is specified in <code>fn</code> and <code>inverse</code> to 
ensure that live binding in nested sections works properly.</p>
<p>All of these nested sections will combine to return a compiled string that functions similar to EJS in its uses of <code>can.view.txt</code>.</p>
<h4 id="implementation">Implementation</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>					{
						name: <span class="hljs-regexp">/^.*$/</span>,
						fn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(content, cmd)</span> </span>{
							<span class="hljs-keyword">var</span> mode = <span class="hljs-literal">false</span>,
								result = {
									content: <span class="hljs-string">""</span>,
									startTxt: <span class="hljs-literal">false</span>,
									startOnlyTxt: <span class="hljs-literal">false</span>,
									end: <span class="hljs-literal">false</span>
								};</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Trim the content so we don’t have any trailing whitespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							content = can.trim(content);</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Determine what the active mode is.</p>
<ul>
<li><code>#</code> - Truthy section</li>
<li><code>^</code> - Falsey section</li>
<li><code>/</code> - Close the prior section</li>
<li><code>else</code> - Inverted section (only exists within a truthy/falsey section)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (content.length &amp;&amp; (mode = content.match(<span class="hljs-regexp">/^([#^/]|else$)/</span>))) {
								mode = mode[<span class="hljs-number">0</span>];
								<span class="hljs-keyword">switch</span> (mode) {
									<span class="hljs-comment">/**
									 * @function can.mustache.helpers.section {{#key}}
									 * @parent can.mustache.tags 3
									 *
									 * @signature `{{#key}}BLOCK{{/key}}`
									 *
									 * Render blocks of text one or more times, depending
									 * on the value of the key in the current context.
									 *
									 * @param {can.mustache.key} key A key that references a value within the current or parent
									 * [can.mustache.context context]. If the value is a function or [can.compute], the
									 * function's return value is used.
									 *
									 *
									 * @return {String}
									 *
									 * Depending on the value's type, the following actions happen:
									 *
									 * - `Array` or [can.List] - the block is rendered for
									 *   each item in the array. The [can.mustache.context context] is set to
									 *   the item within each block rendering.
									 * - A `truthy` value - the block is rendered with the [can.mustache.context context]
									 *   set to the value.
									 * - A `falsey` value - the block is not rendered.
									 *
									 * The rendered result of the blocks, block or an empty string is returned.
									 *
									 * @body
									 *
									 * Sections contain text blocks and evaluate whether to render it or not.  If
									 * the object evaluates to an array it will iterate over it and render the block
									 * for each item in the array.  There are four different types of sections.
									 *
									 * ## Falseys or Empty Arrays
									 *
									 * If the value returns a `false`, `undefined`, `null`, `""` or `[]` we consider
									 * that a *falsey* value.
									 *
									 * If the value is falsey, the section will **NOT** render the block.
									 *
									 *     {
									 *       friends: false
									 *     }
									 *
									 *     {{#friends}}
									 *       Never shown!
									 *     {{/friends}}
									 *
									 *
									 * ## Arrays
									 *
									 * If the value is a non-empty array, sections will iterate over the
									 * array of items, rendering the items in the block.
									 *
									 * For example, a list of friends will iterate
									 * over each of those items within a section.
									 *
									 *     {
									 *         friends: [
									 *             { name: "Austin" },
									 *             { name: "Justin" }
									 *         ]
									 *     }
									 *
									 *     &lt;ul&gt;
									 *         {{#friends}}
									 *             &lt;li&gt;{{name}}&lt;/li&gt;
									 *         {{/friends}}
									 *     &lt;/ul&gt;
									 *
									 * would render:
									 *
									 *     &lt;ul&gt;
									 *         &lt;li&gt;Austin&lt;/li&gt;
									 *         &lt;li&gt;Justin&lt;/li&gt;
									 *     &lt;/ul&gt;
									 *
									 * Reminder: Sections will reset the current context to the value for which it is iterating.
									 * See the [basics of contexts](#Basics) for more information.
									 *
									 * ## Truthys
									 *
									 * When the value is a non-falsey object but not a list, it is considered truthy and will be used
									 * as the context for a single rendering of the block.
									 *
									 *     {
									 *         friends: { name: "Jon" }
									 *     }
									 *
									 *     {{#friends}}
									 *         Hi {{name}}
									 *     {{/friends}}
									 *
									 * would render:
									 *
									 *     Hi Jon!
									 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-comment">/**
									 * @function can.mustache.helpers.helper {{helper args hashes}}
									 * @parent can.mustache.htags 0
									 *
									 * @description Calls a mustache helper function and inserts its return value into
									 * the rendered template.
									 *
									 * @signature `{{helper [args...] [hashProperty=hashValue...]}}`
									 *
									 * Calls a mustache helper function or a function. For example:
									 *
									 * The template:
									 *
									 *     &lt;p&gt;{{madLib "Lebron James" verb 4 foo="bar"}}&lt;/p&gt;
									 *
									 * Rendered with:
									 *
									 *     {verb: "swept"}
									 *
									 * Will call a `madLib` helper with the following arguements:
									 *
									 *     can.mustache.registerHelper('madLib',
									 *       function(subject, verb, number, options){
									 *         // subject -&gt; "Lebron James"
									 *         // verb -&gt; "swept"
									 *         // number -&gt; 4
									 *         // options.hash.foo -&gt; "bar"
									 *     });
									 *
									 * @param {can.mustache.key} helper A key that finds a [can.mustache.helper helper function]
									 * that is either [can.mustache.registerHelper registered] or found within the
									 * current or parent [can.mustache.context context].
									 *
									 * @param {...can.mustache.key|String|Number} [args] Space seperated arguments
									 * that get passed to the helper function as arguments. If the key's value is a:
									 *
									 *  - [can.Map] - A getter/setter [can.compute] is passed.
									 *  - [can.compute] - The can.compute is passed.
									 *  - `function` - The function's return value is passed.
									 *
									 * @param {String} hashProperty
									 *
									 * A property name that gets added to a [can.mustache.helperOptions helper options]'s
									 * hash object.
									 *
									 * @param {...can.mustache.key|String|Number} hashValue A value that gets
									 * set as a property value of the [can.mustache.helperOptions helper option argument]'s
									 * hash object.
									 *
									 * @body
									 *
									 * ## Use
									 *
									 * The `{{helper}}` syntax is used to call out to Mustache [can.mustache.helper helper functions] functions
									 * that may contain more complex functionality. `helper` is a [can.mustache.key key] that must match either:
									 *
									 *  - a [can.mustache.registerHelper registered helper function], or
									 *  - a function in the current or parent [can.mustache.context contexts]
									 *
									 * The following example shows both cases.
									 *
									 * The Template:
									 *
									 *     &lt;p&gt;{{greeting}} {{user}}&lt;/p&gt;
									 *
									 * Rendered with data:
									 *
									 *     {
									 *       user: function(){ return "Justin" }
									 *     }
									 *
									 * And a with a registered helper like:
									 *
									 *     can.mustache.registerHelper('greeting', function(){
									 *       return "Hello"
									 *     });
									 *
									 * Results in:
									 *
									 *     &lt;p&gt;Hello Justin&lt;/p&gt;
									 *
									 * ## Arguments
									 *
									 * Arguments can be passed from the template to helper function by
									 * listing space seperated strings, numbers or other [can.mustache.key keys] after the
									 * `helper` name.  For example:
									 *
									 * The template:
									 *
									 *     &lt;p&gt;{{madLib "Lebron James" verb 4}}&lt;/p&gt;
									 *
									 * Rendered with:
									 *
									 *     {verb: "swept"}
									 *
									 * Will call a `madLib` helper with the following arguements:
									 *
									 *     can.mustache.registerHelper('madLib',
									 *       function(subject, verb, number, options){
									 *         // subject -&gt; "Lebron James"
									 *         // verb -&gt; "swept"
									 *         // number -&gt; 4
									 *     });
									 *
									 * If an argument `key` value is a [can.Map] property, the Observe's
									 * property is converted to a getter/setter [can.compute]. For example:
									 *
									 * The template:
									 *
									 *     &lt;p&gt;What! My name is: {{mr user.name}}&lt;/p&gt;
									 *
									 * Rendered with:
									 *
									 *     {user: new can.Map({name: "Slim Shady"})}
									 *
									 * Needs the helper to check if name is a function or not:
									 *
									 *     can.mustache.registerHelper('mr',function(name){
									 *       return "Mr. "+ (typeof name === "function" ?
									 *                       name():
									 *                       name)
									 *     })
									 *
									 * This behavior enables two way binding helpers and is explained in more detail
									 * on the [can.mustache.helper helper functions] docs.
									 *
									 * ## Hash
									 *
									 * If enumerated arguments isn't an appropriate way to configure the behavior
									 * of a helper, it's possible to pass a hash of key-value pairs to the
									 * [can.mustache.helperOptions helper option argument]'s
									 * hash object.  Properties and values are specified
									 * as `hashProperty=hashValue`.  For example:
									 *
									 * The template:
									 *
									 *     &lt;p&gt;My {{excuse who=pet how="shreded"}}&lt;/p&gt;
									 * `
									 * And the helper:
									 *
									 *     can.mustache.registerHelper("excuse",function(options){
									 *       return ["My",
									 *         options.hash.who || "dog".
									 *         options.hash.how || "ate",
									 *         "my",
									 *         options.hash.what || "homework"].join(" ")
									 *     })
									 *
									 * Render with:
									 *
									 *     {pet: "cat"}
									 *
									 * Results in:
									 *
									 *     &lt;p&gt;My cat shareded my homework&lt;/p&gt;
									 *
									 * ## Returning an element callback function
									 *
									 * If a helper returns a function, that function is called back after
									 * the template has been rendered into DOM elements. This can
									 * be used to create mustache tags that have rich behavior. Read about it
									 * on the [can.mustache.helper helper function] page.
									 *
									 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-comment">/**
									 * @function can.mustache.helpers.sectionHelper {{#helper args hashes}}
									 * @parent can.mustache.htags 1
									 *
									 * Calls a mustache helper function with a block, and optional inverse
									 * block.
									 *
									 * @signature `{{#helper [args...] [hashName=hashValue...]}}BLOCK{{/helper}}`
									 *
									 * Calls a mustache helper function or a function with a block to
									 * render.
									 *
									 * The template:
									 *
									 *     &lt;p&gt;{{countTo number}}{{num}}{{/countTo}}&lt;/p&gt;
									 *
									 * Rendered with:
									 *
									 *     {number: 5}
									 *
									 * Will call the `countTo` helper:
									 *
									 *     can.mustache.registerHelper('madLib',
									 *       function(number, options){
									 *         var out = []
									 *         for(var i =0; i &lt; number; i++){
									 *           out.push( options.fn({num: i+1}) )
									 *         }
									 *         return out.join(" ")
									 *     });
									 *
									 * Results in:
									 *
									 *     &lt;p&gt;1 2 3 4 5&lt;/p&gt;
									 *
									 * @param {can.mustache.key} helper A key that finds a [can.mustache.helper helper function]
									 * that is either [can.mustache.registerHelper registered] or found within the
									 * current or parent [can.mustache.context context].
									 *
									 * @param {...can.mustache.key|String|Number} [args] Space seperated arguments
									 * that get passed to the helper function as arguments. If the key's value is a:
									 *
									 *  - [can.Map] - A getter/setter [can.compute] is passed.
									 *  - [can.compute] - The can.compute is passed.
									 *  - `function` - The function's return value is passed.
									 *
									 * @param {String} hashProperty
									 *
									 * A property name that gets added to a [can.mustache.helperOptions helper options]'s
									 * hash object.
									 *
									 * @param {...can.mustache.key|String|Number} hashValue A value that gets
									 * set as a property value of the [can.mustache.helperOptions helper option argument]'s
									 * hash object.
									 *
									 * @param {mustache} BLOCK A mustache template that gets compiled and
									 * passed to the helper function as the [can.mustache.helperOptions options argument's] `fn`
									 * property.
									 *
									 *
									 * @signature `{{#helper [args...] [hashName=hashValue...]}}BLOCK{{else}}INVERSE{{/helper}}`
									 *
									 * Calls a mustache helper function or a function with a `fn` and `inverse` block to
									 * render.
									 *
									 * The template:
									 *
									 *     &lt;p&gt;The bed is
									 *        {{isJustRight firmness}}
									 *           pefect!
									 *        {{else}}
									 *           uncomfortable.
									 *        {{/justRight}}&lt;/p&gt;
									 *
									 * Rendered with:
									 *
									 *     {firmness: 45}
									 *
									 * Will call the `isJustRight` helper:
									 *
									 *     can.mustache.registerHelper('isJustRight',
									 *       function(number, options){
									 *         if(number &gt; 50){
									 *           return options.fn(this)
									 *         } else {
									 *           return options.inverse(this)
									 *         }
									 *         return out.join(" ")
									 *     });
									 *
									 * Results in:
									 *
									 *     &lt;p&gt;The bed is uncomfortable.&lt;/p&gt;
									 *
									 * @param {can.mustache.key} helper A key that finds a [can.mustache.helper helper function]
									 * that is either [can.mustache.registerHelper registered] or found within the
									 * current or parent [can.mustache.context context].
									 *
									 * @param {...can.mustache.key|String|Number} [args] Space seperated arguments
									 * that get passed to the helper function as arguments. If the key's value is a:
									 *
									 *  - [can.Map] - A getter/setter [can.compute] is passed.
									 *  - [can.compute] - The can.compute is passed.
									 *  - `function` - The function's return value is passed.
									 *
									 * @param {String} hashProperty
									 *
									 * A property name that gets added to a [can.mustache.helperOptions helper options]'s
									 * hash object.
									 *
									 * @param {...can.mustache.key|String|Number} hashValue A value that gets
									 * set as a property value of the [can.mustache.helperOptions helper option argument]'s
									 * hash object.
									 *
									 * @param {mustache} BLOCK A mustache template that gets compiled and
									 * passed to the helper function as the [can.mustache.helperOptions options argument's] `fn`
									 * property.
									 *
									 * @param {mustache} INVERSE A mustache template that gets compiled and
									 * passed to the helper function as the [can.mustache.helperOptions options argument's] `inverse`
									 * property.
									 *
									 *
									 * @body
									 *
									 * ## Use
									 *
									 * Read the [use section of {{helper}}](can.mustache.helpers.helper.html#section_Use) to better understand how:
									 *
									 *  - [Helper functions are found](can.mustache.helpers.helper.html#section_Arguments)
									 *  - [Arguments are passed to the helper](can.mustache.helpers.helper.html#section_Arguments)
									 *  - [Hash values are passed to the helper](can.mustache.helpers.helper.html#section_Hash)
									 *
									 * Read how [helpers that return functions](can.mustache.helper.html#section_Returninganelementcallbackfunction) can
									 * be used for rich behavior like 2-way binding.
									 *
									 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Open a new section.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">case</span> <span class="hljs-string">'#'</span>:
									<span class="hljs-comment">/**
									 * @function can.mustache.helpers.inverse {{^key}}
									 * @parent can.mustache.tags 5
									 *
									 * @signature `{{^key}}BLOCK{{/key}}`
									 *
									 * Render blocks of text if the value of the key
									 * is falsey.  An inverted section syntax is similar to regular
									 * sections except it begins with a caret rather than a
									 * pound. If the value referenced is falsey, the section will render.
									 *
									 * @param {can.mustache.key} key A key that references a value within the current or parent
									 * [can.mustache.context context]. If the value is a function or [can.compute], the
									 * function's return value is used.
									 *
									 * @return {String}
									 *
									 * Depending on the value's type, the following actions happen:
									 *
									 * - A `truthy` value - the block is not rendered.
									 * - A `falsey` value - the block is rendered.
									 *
									 * The rendered result of the block or an empty string is returned.
									 *
									 * @body
									 *
									 * ## Use
									 *
									 * Inverted sections match falsey values. An inverted section
									 * syntax is similar to regular sections except it begins with a caret
									 * rather than a pound. If the value referenced is falsey, the section
									 * will render. For example:
									 *
									 *
									 * The template:
									 *
									 *     &lt;ul&gt;
									 *         {{#friends}}
									 *             &lt;/li&gt;{{name}}&lt;/li&gt;
									 *         {{/friends}}
									 *         {{^friends}}
									 *             &lt;li&gt;No friends.&lt;/li&gt;
									 *         {{/friends}}
									 *     &lt;/ul&gt;
									 *
									 * And data:
									 *
									 *     {
									 *         friends: []
									 *     }
									 *
									 * Results in:
									 *
									 *
									 *     &lt;ul&gt;
									 *         &lt;li&gt;No friends.&lt;/li&gt;
									 *     &lt;/ul&gt;
									 */</span>
								<span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
									<span class="hljs-keyword">if</span> (cmd.specialAttribute) {
										result.startOnlyTxt = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>result.push(cmd.insert + ‘can.view.onlytxt(this,function(){ return ‘);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									} <span class="hljs-keyword">else</span> {
										result.startTxt = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>sections should never be escaped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										result.escaped = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>result.push(cmd.insert + ‘can.view.txt(0,\’’ + cmd.tagName + ‘\’,’ + cmd.status + ‘,this,function(){ return ‘);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									}
									<span class="hljs-keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Close the prior section.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-comment">/**
									 * @function can.mustache.helpers.close {{/key}}
									 * @parent can.mustache.tags 4
									 *
									 * @signature `{{/key}}`
									 *
									 * Ends a [can.mustache.helpers.section {{#key}}] or [can.mustache.helpers.sectionHelper {{#helper}}]
									 * block.
									 *
									 * @param {can.mustache.key} [key] A key that matches the opening key or helper name. It's also
									 * possible to simply write `{{/}}` to end a block.
									 */</span>
								<span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
									result.end = <span class="hljs-literal">true</span>;
									result.content += <span class="hljs-string">'return ___v1ew.join("");}}])'</span>;
									<span class="hljs-keyword">return</span> result;
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Trim the mode off of the content.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								content = content.substring(<span class="hljs-number">1</span>);
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p><code>else</code> helpers are special and should be skipped since they don’t 
have any logic aside from kicking off an <code>inverse</code> function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (mode !== <span class="hljs-string">'else'</span>) {
								<span class="hljs-keyword">var</span> args = [],
									hashes = [],
									i = <span class="hljs-number">0</span>,
									m;</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Start the content render block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								result.content += <span class="hljs-string">'can.Mustache.txt(\n'</span> +
									(cmd.specialAttribute ? SPECIAL_CONTEXT_OBJ : CONTEXT_OBJ ) +
									<span class="hljs-string">',\n'</span> + (mode ? <span class="hljs-string">'"'</span> + mode + <span class="hljs-string">'"'</span> : <span class="hljs-string">'null'</span>) + <span class="hljs-string">','</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Parse the helper arguments.
This needs uses this method instead of a split(/\s/) so that 
strings with spaces can be correctly parsed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								(can.trim(content) + <span class="hljs-string">' '</span>)
									.replace(argumentsRegExp, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(whole, arg)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Check for special helper arguments (string/number/boolean/hashes).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										<span class="hljs-keyword">if</span> (i &amp;&amp; (m = arg.match(literalNumberStringBooleanRegExp))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Found a native type like string/number/boolean.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>											<span class="hljs-keyword">if</span> (m[<span class="hljs-number">2</span>]) {
												args.push(m[<span class="hljs-number">0</span>]);
											}</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Found a hash object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>											<span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Addd to the hash object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
												hashes.push(m[<span class="hljs-number">4</span>] + <span class="hljs-string">":"</span> + (m[<span class="hljs-number">6</span>] ? m[<span class="hljs-number">6</span>] : makeLookupLiteral(m[<span class="hljs-number">5</span>])));
											}
										}</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Otherwise output a normal interpolation reference.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										<span class="hljs-keyword">else</span> {
											args.push(makeLookupLiteral(arg));
										}
										i++;
									});

								result.content += args.join(<span class="hljs-string">","</span>);
								<span class="hljs-keyword">if</span> (hashes.length) {
									result.content += <span class="hljs-string">",{"</span> + HASH + <span class="hljs-string">":{"</span> + hashes.join(<span class="hljs-string">","</span>) + <span class="hljs-string">"}}"</span>;
								}

							}</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Create an option object for sections of code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (mode &amp;&amp; mode !== <span class="hljs-string">'else'</span>) {
								result.content += <span class="hljs-string">',[\n\n'</span>;
							}
							<span class="hljs-keyword">switch</span> (mode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Truthy section</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
							<span class="hljs-keyword">case</span> <span class="hljs-string">'#'</span>:
								result.content += (<span class="hljs-string">'{fn:function('</span> + ARG_NAMES + <span class="hljs-string">'){var ___v1ew = [];'</span>);
								<span class="hljs-keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>If/else section
Falsey section</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-comment">/**
								 * @function can.mustache.helpers.else {{else}}
								 * @parent can.mustache.htags 3
								 *
								 * @signature `{{#helper}}BLOCK{{else}}INVERSE{{/helper}}`
								 *
								 * Creates an `inverse` block for a [can.mustache.helper helper function]'s
								 * [can.mustache.helperOptions options argument]'s `inverse` property.
								 *
								 * @param {can.mustache} INVERSE a mustache template coverted to a
								 * function and set as the [can.mustache.helper helper function]'s
								 * [can.mustache.helperOptions options argument]'s `inverse` property.
								 *
								 * @body
								 *
								 * ## Use
								 *
								 * For more information on how `{{else}}` is used checkout:
								 *
								 *  - [can.mustache.helpers.if {{if key}}]
								 *  - [can.mustache.helpers.sectionHelper {{#helper}}]
								 *
								 */</span>
							<span class="hljs-keyword">case</span> <span class="hljs-string">'else'</span>:
								result.content += <span class="hljs-string">'return ___v1ew.join("");}},\n{inverse:function('</span> + ARG_NAMES + <span class="hljs-string">'){\nvar ___v1ew = [];'</span>;
								<span class="hljs-keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Not a section, no mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">default</span>:
								result.content += (<span class="hljs-string">')'</span>);
								<span class="hljs-keyword">break</span>;
							}

							<span class="hljs-keyword">if</span> (!mode) {
								result.startTxt = <span class="hljs-literal">true</span>;
								result.end = <span class="hljs-literal">true</span>;
							}

							<span class="hljs-keyword">return</span> result;
						}
					}
				]
			})
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>Add in default scanner helpers first.
We could probably do this differently if we didn’t ‘break’ on every match.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> helpers = can.view.Scanner.prototype.helpers;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; helpers.length; i++) {
			Mustache.prototype.scanner.helpers.unshift(helpers[i]);
		}

		<span class="hljs-comment">/**
		 * @function can.MustacheConstructor.txt
		 * @hide
		 *
		 * Evaluates the resulting string based on the context/name.
		 *
		 * @param {Object|Array} context	The context stack to be used with evaluation.
		 * @param {String} mode		The mode to evaluate the section with: # for truthy, ^ for falsey
		 * @param {String|Object} name	The string (or sometimes object) to pass to the given helper method.
		 */</span>
		Mustache.txt = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(scopeAndOptions, mode, name)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>here we are going to cache the lookup values so future calls are much faster</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> scope = scopeAndOptions.scope,
				options = scopeAndOptions.options,
				args = [],
				helperOptions = {
					fn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{},
					inverse: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{}
				},
				hash,
				context = scope.attr(<span class="hljs-string">"."</span>),
				getHelper = <span class="hljs-literal">true</span>,
				helper;</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>convert lookup values to actual values in name, arguments, and hash</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">3</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
				<span class="hljs-keyword">var</span> arg = <span class="hljs-built_in">arguments</span>[i];
				<span class="hljs-keyword">if</span> (mode &amp;&amp; can.isArray(arg)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>merge into options</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					helperOptions = can.extend.apply(can, [helperOptions].concat(arg));
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg &amp;&amp; arg[HASH]) {
					hash = arg[HASH];</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>get values on hash</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> hash) {
						<span class="hljs-keyword">if</span> (isLookup(hash[prop])) {
							hash[prop] = Mustache.get(hash[prop].get, scopeAndOptions, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
						}
					}
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg &amp;&amp; isLookup(arg)) {
					args.push(Mustache.get(arg.get, scopeAndOptions, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>));
				} <span class="hljs-keyword">else</span> {
					args.push(arg);
				}
			}

			<span class="hljs-keyword">if</span> (isLookup(name)) {
				<span class="hljs-keyword">var</span> get = name.get;
				name = Mustache.get(name.get, scopeAndOptions, args.length, <span class="hljs-literal">false</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Base whether or not we will get a helper on whether or not the original
name.get and Mustache.get resolve to the same thing. Saves us from running
into issues like {{text}} / {text: ‘with’}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				getHelper = (get === name);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>overwrite fn and inverse to always convert to scopes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			helperOptions.fn = makeConvertToScopes(helperOptions.fn, scope, options);
			helperOptions.inverse = makeConvertToScopes(helperOptions.inverse, scope, options);</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>if mode is ^, swap fn and inverse</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span>(mode === <span class="hljs-string">'^'</span>) {
				<span class="hljs-keyword">var</span> tmp = helperOptions.fn;
				helperOptions.fn = helperOptions.inverse;
				helperOptions.inverse = tmp;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Check for a registered helper or a helper-like function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (helper = (getHelper &amp;&amp; (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">"string"</span> &amp;&amp; Mustache.getHelper(name, options)) || (can.isFunction(name) &amp;&amp; !name.isComputed &amp;&amp; {
				fn: name
			}))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Add additional data to be used by helper functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
				can.extend(helperOptions, {
					context: context,
					scope: scope,
					contexts: scope,
					hash: hash
				});

				args.push(helperOptions);</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Call the helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
					<span class="hljs-keyword">return</span> helper.fn.apply(context, args) || <span class="hljs-string">''</span>;
				};

			}
			<span class="hljs-comment">/*if( !mode &amp;&amp; !args.length &amp;&amp; can.isFunction(name) &amp;&amp; name.isComputed ) {
				if(!scopeAndOptions.special) {
					name.canReadForChangeEvent = false;
				}
				return name;
			}*/</span>
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>{{#foo.bar zed ted}}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> value;
				<span class="hljs-keyword">if</span> (can.isFunction(name) &amp;&amp; name.isComputed) {
					value = name();
				} <span class="hljs-keyword">else</span> {
					value = name;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>An array of arguments to check for truthyness when evaluating sections.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> validArgs = args.length ? args : [value],</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Whether the arguments meet the condition of the section.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					valid = <span class="hljs-literal">true</span>,
					result = [],
					i, argIsObserve, arg;</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Validate the arguments based on the section mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (mode) {
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; validArgs.length; i++) {
						arg = validArgs[i];
						argIsObserve = <span class="hljs-keyword">typeof</span> arg !== <span class="hljs-string">'undefined'</span> &amp;&amp; isObserveLike(arg);</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Array-like objects are falsey if their length = 0.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (isArrayLike(arg)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Use .attr to trigger binding on empty lists returned from function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (mode === <span class="hljs-string">'#'</span>) {
								valid = valid &amp;&amp; !! (argIsObserve ? arg.attr(<span class="hljs-string">'length'</span>) : arg.length);
							} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode === <span class="hljs-string">'^'</span>) {
								valid = valid &amp;&amp; !(argIsObserve ? arg.attr(<span class="hljs-string">'length'</span>) : arg.length);
							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Otherwise just check if it is truthy or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">else</span> {
							valid = mode === <span class="hljs-string">'#'</span> ? valid &amp;&amp; !! arg : mode === <span class="hljs-string">'^'</span> ? valid &amp;&amp; !arg : valid;
						}
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Otherwise interpolate like normal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (valid) {

					<span class="hljs-keyword">if</span> (mode === <span class="hljs-string">"#"</span>) {
						<span class="hljs-keyword">if</span> (isArrayLike(value)) {
							<span class="hljs-keyword">var</span> isObserveList = isObserveLike(value);</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Add the reference to the list in the contexts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; value.length; i++) {
								result.push(helperOptions.fn(
									isObserveList ? value.attr(<span class="hljs-string">''</span> + i) : value[i]));
							}
							<span class="hljs-keyword">return</span> result.join(<span class="hljs-string">''</span>);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Normal case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> helperOptions.fn(value || {}) || <span class="hljs-string">''</span>;
						}
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode === <span class="hljs-string">"^"</span>) {
						<span class="hljs-keyword">return</span> helperOptions.inverse(value || {}) || <span class="hljs-string">''</span>;
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + (value != <span class="hljs-literal">null</span> ? value : <span class="hljs-string">''</span>);
					}
				}

				<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
			};
		};

		<span class="hljs-comment">/**
		 * @function can.MustacheConstructor.get
		 * @hide
		 *
		 * Resolves a key for a given object (and then a context if that fails).
		 *
		 *     obj = this
		 *     context = { a: true }
		 *     ref = 'a.b.c'
		 *          =&gt; obj.a.b.c || context.a.b.c || ''
		 *
		 * This implements the following Mustache specs:
		 * Deeply Nested Contexts
		 * All elements on the context stack should be accessible.
		 *
		 *     {{#bool}}B {{#bool}}C{{/bool}} D{{/bool}}
		 *     { bool: true }
		 *     =&gt; "B C D"
		 *
		 * Basic Context Miss Interpolation
		 * Failed context lookups should default to empty strings.
		 *
		 *     {{cannot}}
		 *     =&gt; ""
		 *
		 * Dotted Names - Broken Chains
		 * Any falsey value prior to the last part of the name should yield ''.
		 *		{{a.b.c}}
		 *		{ a: { d: 1 } }
		 *		=&gt; ""
		 *
		 * @param {can.mustache.key} key The reference to check for on the obj/context.
		 * @param {Object} obj The object to use for checking for a reference.
		 * @param {Object} context The context to use for checking for a reference if it doesn't exist in the object.
		 * @param {Boolean} [isHelper] Whether the reference is seen as a helper.
		 */</span>
		Mustache.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, scopeAndOptions, isHelper, isArgument, isLookup)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Cache a reference to the current context and options, we will use them a bunch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> context = scopeAndOptions.scope.attr(<span class="hljs-string">'.'</span>),
				options = scopeAndOptions.options || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>If key is called as a helper,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (isHelper) {</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>try to find a registered helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (Mustache.getHelper(key, options)) {
					<span class="hljs-keyword">return</span> key;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Support helper-like functions as anonymous helpers.
Check if there is a method directly in the “top” context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (scopeAndOptions.scope &amp;&amp; can.isFunction(context[key])) {
					<span class="hljs-keyword">return</span> context[key];
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>!steal-remove-start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				can.dev.warn(<span class="hljs-string">'can/view/mustache/mustache.js: Unable to find helper "'</span> + key + <span class="hljs-string">'".'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>!steal-remove-end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			}</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Get a compute (and some helper data) that represents key’s value in the current scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> computeData = scopeAndOptions.scope.computeData(key, {
				isArgument: isArgument,
				args: [context, scopeAndOptions.scope]
			}),
				compute = computeData.compute;</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Bind on the compute to cache its value. We will unbind in a timeout later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			can.compute.temporarilyBind(compute);</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>computeData gives us an initial value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> initialValue = computeData.initialValue;</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>!steal-remove-start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (initialValue === <span class="hljs-literal">undefined</span> &amp;&amp; !isHelper) {
				can.dev.warn(<span class="hljs-string">'can/view/mustache/mustache.js: Unable to find key "'</span> + key + <span class="hljs-string">'".'</span>);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>!steal-remove-end</p>

            </div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Use helper over the found value if the found value isn’t in the current context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!isLookup &amp;&amp; (initialValue === <span class="hljs-literal">undefined</span> || computeData.scope !== scopeAndOptions.scope) &amp;&amp; Mustache.getHelper(key, options)) {
				<span class="hljs-keyword">return</span> key;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>If there are no dependencies, just return the value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!compute.hasDependencies) {
				<span class="hljs-keyword">return</span> initialValue;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> compute;
			}
		};

		<span class="hljs-comment">/**
		 * @hide
		 *
		 * Resolves an object to its truthy equivalent.
		 *
		 * @param {Object} value    The object to resolve.
		 * @return {Object} The resolved object.
		 */</span>
		Mustache.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{
			<span class="hljs-keyword">if</span> (isObserveLike(value) &amp;&amp; isArrayLike(value) &amp;&amp; value.attr(<span class="hljs-string">'length'</span>)) {
				<span class="hljs-keyword">return</span> value;
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (can.isFunction(value)) {
				<span class="hljs-keyword">return</span> value();
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> value;
			}
		};

		<span class="hljs-comment">/**
		 * @static
		 */</span>

		can.view.Options = can.view.Scope.extend({
			init: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, parent)</span> </span>{
				<span class="hljs-keyword">if</span> (!data.helpers &amp;&amp; !data.partials &amp;&amp; !data.tags) {
					data = {
						helpers: data
					};
				}
				can.view.Scope.prototype.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			}
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <h2 id="helpers">Helpers</h2>
<p>Helpers are functions that can be called from within a template.
These helpers differ from the scanner helpers in that they execute
at runtime instead of during compilation.</p>
<p>Custom helpers can be added via <code>can.Mustache.registerHelper</code>,
but there are also some built-in helpers included by default.
Most of the built-in helpers are little more than aliases to actions 
that the base version of Mustache simply implies based on the 
passed in object.</p>
<p>Built-in helpers:</p>
<ul>
<li><code>data</code> - <code>data</code> is a special helper that is implemented via scanning helpers. 
  It hooks up the active element to the active data object: <code>&lt;div {{data &quot;key&quot;}} /&gt;</code></li>
<li><code>if</code> - Renders a truthy section: <code>{{#if var}} render {{/if}}</code></li>
<li><code>unless</code> - Renders a falsey section: <code>{{#unless var}} render {{/unless}}</code></li>
<li><code>each</code> - Renders an array: <code>{{#each array}} render {{this}} {{/each}}</code></li>
<li><code>with</code> - Opens a context section: <code>{{#with var}} render {{/with}}</code></li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>		Mustache._helpers = {};
		<span class="hljs-comment">/**
		 * @function can.mustache.registerHelper
		 * @parent can.mustache.methods
		 * @description Register a helper.
		 * @function can.mustache.registerHelper registerHelper
		 * @signature `Mustache.registerHelper(name, helper)`
		 * @param {String} name The name of the helper.
		 * @param {can.mustache.helper} helper The helper function.
		 *
		 * @body
		 * Registers a helper with the Mustache system.
		 * Pass the name of the helper followed by the
		 * function to which Mustache should invoke.
		 * These are run at runtime.
		 */</span>
		Mustache.registerHelper = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, fn)</span> </span>{
			<span class="hljs-keyword">this</span>._helpers[name] = {
				name: name,
				fn: fn
			};
		};

		<span class="hljs-comment">/**
		 * @hide
		 * @function can.MustacheConstructor.getHelper getHelper
		 * @description Retrieve a helper.
		 * @signature `Mustache.getHelper(name)`
		 * @param {String} name The name of the helper.
		 * @return {Function|null} The helper, or `null` if
		 * no helper by that name is found.
		 *
		 * @body
		 * Returns a helper given the name.
		 */</span>
		Mustache.getHelper = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, options)</span> </span>{
			<span class="hljs-keyword">var</span> helper = options.attr(<span class="hljs-string">"helpers."</span> + name);
			<span class="hljs-keyword">return</span> helper ? {
				fn: helper
			} : <span class="hljs-keyword">this</span>._helpers[name];
		};

		<span class="hljs-comment">/**
		 * @function can.MustacheConstructor.static.render render
		 * @hide
		 * @parent can.Mustache.static
		 * @signature `Mustache.render(partial, context)`
		 * @param {Object} partial
		 * @param {can.view.Scope} scope
		 *
		 * @body
		 * `Mustache.render` is a helper method that calls
		 * into `can.view.render` passing the partial
		 * and the context object.
		 *
		 * Its purpose is to determine if the partial object
		 * being passed represents a template like:
		 *
		 *     partial === "movember.mustache"
		 *
		 * or if the partial is a variable name that represents
		 * a partial on the context object such as:
		 *
		 *     context[partial] === "movember.mustache"
		 */</span>
		Mustache.render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(partial, scope, options)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>TOOD: clean up the following
If there is a “partial” property and there is not
an already-cached partial, we use the value of the 
property to look up the partial</p>

            </div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>if this partial is not cached …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!can.view.cached[partial]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>we don’t want to bind to changes so clear and restore reading</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> reads = can.__clearReading();
				<span class="hljs-keyword">if</span> (scope.attr(<span class="hljs-string">'partial'</span>)) {
					partial = scope.attr(<span class="hljs-string">'partial'</span>);
				}
				can.__setReading(reads);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Call into <code>can.view.render</code> passing the
partial and scope.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> can.view.render(partial, scope, options);
		};

		<span class="hljs-comment">/**
		 * @function can.mustache.safeString
		 * @parent can.mustache.methods
		 * 
		 * @signature `can.mustache.safeString(str)`
		 *
		 * @param {String} str A string you don't want to become escaped.
		 * @return {String} A string flagged by `can.mustache` as safe, which will
		 * not become escaped, even if you use [can.mustache.tags.unescaped](triple slash).
		 *
		 * @body
		 * If you write a helper that generates its own HTML, you will
		 * usually want to return a `can.mustache.safeString.` In this case,
		 * you will want to manually escape parameters with `[can.esc].`
		 *
		 * @codestart
		 * can.mustache.registerHelper('link', function(text, url) {
		 *   text = can.esc(text);
		 *   url  = can.esc(url);
		 *
		 *   var result = '&amp;lt;a href="' + url + '"&amp;gt;' + text + '&amp;lt;/a&amp;gt;';
		 *   return can.mustache.safeString(result);
		 * });
		 * @codeend
		 *
		 * Rendering:
		 * @codestart
		 * &amp;lt;div&amp;gt;{{link "Google", "http://google.com"}}&amp;lt;/div&amp;gt;
		 * @codeend
		 *
		 * Results in:
		 *
		 * @codestart
		 * &amp;lt;div&amp;gt;&amp;lt;a href="http://google.com"&amp;gt;Google&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
		 * @codeend
		 *
		 * As an anchor tag whereas if we would have just returned the result rather than a
		 * `can.mustache.safeString` our template would have rendered a div with the escaped anchor tag.
		 *
		 */</span>
		Mustache.safeString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(str)</span> </span>{
			<span class="hljs-keyword">return</span> {
				toString: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
					<span class="hljs-keyword">return</span> str;
				}
			};
		};

		Mustache.renderPartial = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(partialName, scope, options)</span> </span>{
			<span class="hljs-keyword">var</span> partial = options.attr(<span class="hljs-string">"partials."</span> + partialName);
			<span class="hljs-keyword">if</span> (partial) {
				<span class="hljs-keyword">return</span> partial.render ? partial.render(scope, options) :
					partial(scope, options);
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> can.Mustache.render(partialName, scope, options);
			}
		};</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>The built-in Mustache helpers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		can.each({</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>Implements the <code>if</code> built-in helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @function can.mustache.helpers.if {{#if key}}
			 * @parent can.mustache.htags 2
			 * @signature `{{#if key}}BLOCK{{/if}}`
			 *
			 * Renders the `BLOCK` template within the current template.
			 *
			 * @param {can.mustache.key} key A key that references a value within the current or parent
			 * context. If the value is a function or can.compute, the function's return value is used.
			 *
			 * @param {can.mustache} BLOCK A mustache template.
			 *
			 * @return {String} If the key's value is truthy, the `BLOCK` is rendered with the
			 * current context and its value is returned; otherwise, an empty string.
			 *
			 * @body
			 *
			 * ## Use
			 *
			 * `{{#if key}}` provides explicit conditional truthy tests. For example,
			 *
			 * The template:
			 *
			 *     {{#if user.isFemale}}
			 *       {{#if user.isMarried}}
			 *         Mrs
			 *       {{/if}}
			 *       {{#if user.isSingle}}
			 *         Miss
			 *       {{/if}}
			 *     {{/if}}
			 *
			 * Rendered with:
			 *
			 *     {user: {isFemale: true, isMarried: true}}
			 *
			 * Results in:
			 *
			 *     Mrs
			 *
			 * If can be used with [can.mustache.helpers.else {{else}}] too. For example,
			 *
			 *     {{#if user.isFemale}}
			 *       {{#if user.isMarried}}
			 *         Mrs
			 *       {{else}}
			 *         Miss
			 *       {{/if}}
			 *     {{/if}}
			 *
			 * Rendered with:
			 *
			 *     {user: {isFemale: true, isMarried: false}}
			 *
			 * Results in:
			 *
			 *     Miss
			 */</span>
			<span class="hljs-string">'if'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(expr, options)</span> </span>{
				<span class="hljs-keyword">var</span> value;</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>if it’s a function, wrap its value in a compute
that will only change values from true to false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (can.isFunction(expr)) {
					value = can.compute.truthy(expr)();
				} <span class="hljs-keyword">else</span> {
					value = !! Mustache.resolve(expr);
				}

				<span class="hljs-keyword">if</span> (value) {
					<span class="hljs-keyword">return</span> options.fn(options.contexts || <span class="hljs-keyword">this</span>);
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> options.inverse(options.contexts || <span class="hljs-keyword">this</span>);
				}
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Implements the <code>unless</code> built-in helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @function can.mustache.helpers.unless {{#unless key}}
			 * @parent can.mustache.htags 4
			 *
			 * @signature `{{#unless key}}BLOCK{{/unless}}`
			 *
			 * Render the block of text if the key's value is falsey.
			 *
			 * @param {can.mustache.key} key A key that references a value within the current or parent
			 * context. If the value is a function or can.compute, the function's
			 * return value is used.
			 *
			 * @param {can.mustache} BLOCK A template that is rendered
			 * if the `key`'s value is falsey.
			 *
			 * @body
			 *
			 * The `unless` helper evaluates the inverse of the value
			 * of the key and renders the block between the helper and the slash.
			 *
			 *     {{#unless expr}}
			 *       // unless
			 *     {{/unless}}
			 */</span>
			<span class="hljs-string">'unless'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(expr, options)</span> </span>{
				<span class="hljs-keyword">return</span> Mustache._helpers[<span class="hljs-string">'if'</span>].fn.apply(<span class="hljs-keyword">this</span>, [can.isFunction(expr) ? can.compute(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> !expr(); }) : !expr, options]);
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Implements the <code>each</code> built-in helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @function can.mustache.helpers.each {{#each key}}
			 * @parent can.mustache.htags 5
			 *
			 * @signature `{{#each key}}BLOCK{{/each}}`
			 *
			 * Render the block of text for each item in key's value.
			 *
			 * @param {can.mustache.key} key A key that references a value within the current or parent
			 * context. If the value is a function or can.compute, the function's
			 * return value is used.
			 *
			 * If the value of the key is a [can.List], the resulting HTML is updated when the
			 * list changes. When a change in the list happens, only the minimum amount of DOM
			 * element changes occur.
			 *
			 * If the value of the key is a [can.Map], the resulting HTML is updated whenever
			 * attributes are added or removed. When a change in the map happens, only
			 * the minimum amount of DOM element changes occur.
			 *
			 * @param {can.mustache} BLOCK A template that is rendered for each item in
			 * the `key`'s value. The `BLOCK` is rendered with the context set to the item being rendered.
			 *
			 * @body
			 *
			 * ## Use
			 *
			 * Use the `each` helper to iterate over a array
			 * of items and render the block between the helper and the slash. For example,
			 *
			 * The template:
			 *
			 *     &lt;ul&gt;
			 *       {{#each friends}}
			 *         &lt;li&gt;{{name}}&lt;/li&gt;
			 *       {{/each}}
			 *     &lt;/ul&gt;
			 *
			 * Rendered with:
			 *
			 *     {friends: [{name: "Austin"},{name: "Justin"}]}
			 *
			 * Renders:
			 *
			 *     &lt;ul&gt;
			 *       &lt;li&gt;Austin&lt;/li&gt;
			 *       &lt;li&gt;Justin&lt;/li&gt;
			 *     &lt;/ul&gt;
			 *
			 * ## Object iteration
			 *
			 * As of 2.1, you can now iterate over properties of objects and attributes with
			 * the `each` helper. When iterating over [can.Map] it will only iterate over the
			 * map's [keys](can.Map.keys.html) and none of the hidden properties of a can.Map. For example,
			 *
			 * The template:
			 *
			 *     &lt;ul&gt;
			 *       {{#each person}}
			 *         &lt;li&gt;{{.}}&lt;/li&gt;
			 *       {{/each}}
			 *     &lt;/ul&gt;
			 *
			 * Rendered with:
			 *
			 *     {person: {name: 'Josh', age: 27}}
			 *
			 * Renders:
			 *
			 *     &lt;ul&gt;
			 *       &lt;li&gt;Josh&lt;/li&gt;
			 *       &lt;li&gt;27&lt;/li&gt;
			 *     &lt;/ul&gt;
			 */</span>
			<span class="hljs-string">'each'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(expr, options)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>Check if this is a list or a compute that resolves to a list, and setup
the incremental live-binding </p>

            </div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>First, see what we are dealing with.  It’s ok to read the compute
because can.view.text is only temporarily binding to what is going on here.
Calling can.view.lists prevents anything from listening on that compute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> resolved = Mustache.resolve(expr),
					result = [],
					keys,
					key,
					i;</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>When resolved === undefined, the property hasn’t been defined yet
Assume it is intended to be a list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (can.view.lists &amp;&amp; (resolved <span class="hljs-keyword">instanceof</span> can.List || (expr &amp;&amp; expr.isComputed &amp;&amp; resolved === <span class="hljs-literal">undefined</span>))) {
					<span class="hljs-keyword">return</span> can.view.lists(expr, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(item, index)</span> </span>{
						<span class="hljs-keyword">return</span> options.fn(options.scope.add({
								<span class="hljs-string">"@index"</span>: index
							})
							.add(item));
					});
				}
				expr = resolved;

				<span class="hljs-keyword">if</span> ( !! expr &amp;&amp; isArrayLike(expr)) {
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; expr.length; i++) {
						result.push(options.fn(options.scope.add({
								<span class="hljs-string">"@index"</span>: i
							})
							.add(expr[i])));
					}
					<span class="hljs-keyword">return</span> result.join(<span class="hljs-string">''</span>);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObserveLike(expr)) {
					keys = can.Map.keys(expr);</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>listen to keys changing so we can livebind lists of attributes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
						key = keys[i];
						result.push(options.fn(options.scope.add({
								<span class="hljs-string">"@key"</span>: key
							})
							.add(expr[key])));
					}
					<span class="hljs-keyword">return</span> result.join(<span class="hljs-string">''</span>);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) {
					<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> expr) {
						result.push(options.fn(options.scope.add({
								<span class="hljs-string">"@key"</span>: key
							})
							.add(expr[key])));
					}
					<span class="hljs-keyword">return</span> result.join(<span class="hljs-string">''</span>);

				}
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>Implements the <code>with</code> built-in helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @function can.mustache.helpers.with {{#with key}}
			 * @parent can.mustache.htags 6
			 *
			 * @signature `{{#with key}}BLOCK{{/with}}`
			 *
			 * Changes the context within a block.
			 *
			 * @param {can.mustache.key} key A key that references a value within the current or parent
			 * context. If the value is a function or can.compute, the function's
			 * return value is used.
			 *
			 * @param {can.mustache} BLOCK A template that is rendered
			 * with the context of the `key`'s value.
			 *
			 * @body
			 *
			 * Mustache typically applies the context passed in the section
			 * at compiled time.  However, if you want to override this
			 * context you can use the `with` helper.
			 *
			 *     {{#with arr}}
			 *       // with
			 *     {{/with}}
			 */</span>
			<span class="hljs-string">'with'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(expr, options)</span> </span>{
				<span class="hljs-keyword">var</span> ctx = expr;
				expr = Mustache.resolve(expr);
				<span class="hljs-keyword">if</span> ( !! expr) {
					<span class="hljs-keyword">return</span> options.fn(ctx);
				}
			},
			<span class="hljs-comment">/**
			 * @function can.mustache.helpers.log {{log}}
			 * @parent can.mustache.htags 9
			 *
			 * @signature `{{#log [message]}}`
			 *
			 * Logs the context of the current block with an optional message.
			 *
			 * @param {*} message An optional message to log out in addition to the
			 * current context.
			 *
			 */</span>
			<span class="hljs-string">'log'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(expr, options)</span> </span>{
				<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-built_in">console</span>.log) {
					<span class="hljs-keyword">if</span> (!options) {
						<span class="hljs-built_in">console</span>.log(expr.context);
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-built_in">console</span>.log(expr, options.context);
					}
				}
			},
			<span class="hljs-comment">/**
			 * @function can.mustache.helpers.elementCallback {{(el)-&gt;CODE}}
			 *
			 * @parent can.mustache.htags 8
			 *
			 * @signature `{{(el) -&gt; CODE}}`
			 *
			 * Executes an element callback with the inline code on the element.
			 *
			 * @param {String} code The inline code to execute on the element.
			 *
			 * @body
			 *
			 * ## Use
			 *
			 * It is common for you to want to execute some code on a given
			 * DOM element. An example would be for initializing a jQuery plugin
			 * on the new HTML.
			 *
			 *     &lt;div class="tabs" {{(el) -&gt; el.jquery_tabs()}}&gt;&lt;/div&gt;
			 *
			 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @function can.mustache.helpers.index {{@index}}
			 *
			 * @parent can.mustache.htags 10
			 *
			 * @signature `{{@index [offset]}}`
			 *
			 * Insert the index of an Array or can.List we are iterating on with [#each](can.mustache.helpers.each)
			 *
			 * @param {Number} offset The number to optionally offset the index by.
			 *
			 * @body
			 *
			 * ## Use
			 *
			 * When iterating over and array or list of items, you might need to render the index
			 * of the item. Use the `@index` directive to do so. For example,
			 *
			 * The template:
			 *
			 *     &lt;ul&gt;
			 *       {{#each items}}
			 *         &lt;li&gt; {{@index}} - {{.}} &lt;/li&gt;
			 *       {{/each}}
			 *     &lt;/ul&gt;
			 *
			 * Rendered with:
			 *
			 *     { items: ['Josh', 'Eli', 'David'] }
			 *
			 * Renders:
			 *
			 *     &lt;ul&gt;
			 *       &lt;li&gt; 0 - Josh &lt;/li&gt;
			 *       &lt;li&gt; 1 - Eli &lt;/li&gt;
			 *       &lt;li&gt; 2 - David &lt;/li&gt;
			 *     &lt;/ul&gt;
			 *
			 */</span>
			<span class="hljs-string">"@index"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(offset, options)</span> </span>{
				<span class="hljs-keyword">if</span> (!options) {
					options = offset;
					offset = <span class="hljs-number">0</span>;
				}
				<span class="hljs-keyword">var</span> index = options.scope.attr(<span class="hljs-string">"@index"</span>);
				<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>+((can.isFunction(index) ? index() : index) + offset);
			}
			<span class="hljs-comment">/**
			 * @function can.mustache.helpers.key {{@key}}
			 *
			 * @parent can.mustache.htags 11
			 *
			 * @signature `{{@key}}`
			 *
			 * Insert the property name of an Object or attribute name of a can.Map that we iterate over with [#each](can.mustache.helpers.each)
			 *
			 * @body
			 *
			 * ## Use
			 *
			 * Use `{{@key}}` to render the property or attribute name of an Object or can.Map, when iterating over it with [#each](can.mustache.helpers.each). For example,
			 *
			 * The template:
			 *
			 *     &lt;ul&gt;
			 *       {{#each person}}
			 *         &lt;li&gt; {{@key}}: {{.}} &lt;/li&gt;
			 *       {{/each}}
			 *     &lt;/ul&gt;
			 *
			 * Rendered with:
			 *
			 *     { person: {name: 'Josh', age: 27, likes: 'Mustache, JavaScript, High Fives'} }
			 *
			 * Renders:
			 *
			 *     &lt;ul&gt;
			 *       &lt;li&gt; name: Josh &lt;/li&gt;
			 *       &lt;li&gt; age: 27 &lt;/li&gt;
			 *       &lt;li&gt; likes: Mustache, JavaScript, High Fives &lt;/li&gt;
			 *     &lt;/ul&gt;
			 *
			 */</span>
		}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, name)</span> </span>{
			Mustache.registerHelper(name, fn);
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <h2 id="registration">Registration</h2>
<p>Registers Mustache with can.view.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		can.view.register({
			suffix: <span class="hljs-string">"mustache"</span>,

			contentType: <span class="hljs-string">"x-mustache-template"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Returns a <code>function</code> that renders the view.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			script: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, src)</span> </span>{
				<span class="hljs-keyword">return</span> <span class="hljs-string">"can.Mustache(function("</span> + ARG_NAMES + <span class="hljs-string">") { "</span> + <span class="hljs-keyword">new</span> Mustache({
					text: src,
					name: id
				})
					.template.out + <span class="hljs-string">" })"</span>;
			},

			renderer: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, text)</span> </span>{
				<span class="hljs-keyword">return</span> Mustache({
					text: text,
					name: id
				});
			}
		});
		
		can.mustache.registerHelper = can.proxy(can.Mustache.registerHelper, can.Mustache);
		can.mustache.safeString = can.Mustache.safeString;
		<span class="hljs-keyword">return</span> can;
	});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
