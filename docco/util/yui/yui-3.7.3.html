<!DOCTYPE html>

<html>
<head>
  <title>yui-3.7.3.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="yui-3.7.3.html">
                yui-3.7.3.js
              </a>
            
              
              <a class="source" href="yui.html">
                yui.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>yui-3.7.3.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @documentjs-ignore
 */</span>
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
<span class="hljs-comment">/**
 * The YUI module contains the components required for building the YUI seed
 * file.  This includes the script loading mechanism, a simple queue, and
 * the core utilities for the library.
 * @module yui
 * @main yui
 * @submodule yui-base
 */</span>

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> YUI != <span class="hljs-string">'undefined'</span>) {
	YUI._YUI = YUI;
}

<span class="hljs-comment">/**
 The YUI global namespace object.  If YUI is already defined, the
 existing YUI object will not be overwritten so that defined
 namespaces are preserved.  It is the constructor for the object
 the end user interacts with.  As indicated below, each instance
 has full custom event support, but only if the event system
 is available.  This is a self-instantiable factory function.  You
 can invoke it directly like this:

 YUI().use('*', function(Y) {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>ready</p>

            </div>
            
            <div class="content"><div class='highlight'><pre> });

 But it also works like <span class="hljs-keyword">this</span>:

 <span class="hljs-keyword">var</span> Y = YUI();

 Configuring the YUI object:

 YUI({
 <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,
 <span class="hljs-attr">combine</span>: <span class="hljs-literal">false</span>
 }).use(<span class="hljs-string">'node'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Node is ready to use</p>

            </div>
            
            <div class="content"><div class='highlight'><pre> });

 See the API docs for the &lt;a href="config.html"&gt;Config&lt;/a&gt; class
 for the complete list of supported configuration properties accepted
 by the YUI constuctor.

 @class YUI
 @constructor
 @global
 @uses EventTarget
 @param [o]* {Object} 0..n optional configuration objects.  these values
 are store in Y.config.  See &lt;a href="config.html"&gt;Config&lt;/a&gt; for the list of supported
 properties.
 */
/*global YUI*/
/*global YUI_config*/
var YUI = function() {
	var i = 0,
		Y = this,
		args = arguments,
		l = args.length,
		instanceOf = function(o, type) {
			return (o &amp;&amp; o.hasOwnProperty &amp;&amp; (o instanceof type));
		},
		gconf = (typeof YUI_config !== 'undefined') &amp;&amp; YUI_config;

	if (!(instanceOf(Y, YUI))) {
		Y = new YUI();
	} else {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>set up the core environment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		Y._init();

		<span class="hljs-comment">/**
		 YUI.GlobalConfig is a master configuration that might span
		 multiple contexts in a non-browser environment.  It is applied
		 first to all instances in all contexts.
		 @property GlobalConfig
		 @type {Object}
		 @global
		 @static
		 @example


		 YUI.GlobalConfig = {
		 filter: 'debug'
		 };

		 YUI().use('node', function(Y) {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>debug files used here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 });

		 YUI({
		 <span class="hljs-attr">filter</span>: <span class="hljs-string">'min'</span>
		 }).use(<span class="hljs-string">'node'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>min files used here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 });

		 */
		if (YUI.GlobalConfig) {
			Y.applyConfig(YUI.GlobalConfig);
		}

		/**
		 YUI_config is a page-level config.  It is applied to all
		 instances created on the page.  This is applied after
		 YUI.GlobalConfig, and before the instance level configuration
		 objects.
		 @global
		 @property YUI_config
		 @type {Object}
		 @example</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Single global var to include before YUI seed file</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 YUI_config = {
		 <span class="hljs-attr">filter</span>: <span class="hljs-string">'debug'</span>
		 };

		 YUI().use(<span class="hljs-string">'node'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>debug files used here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 });

		 YUI({
		 <span class="hljs-attr">filter</span>: <span class="hljs-string">'min'</span>
		 }).use(<span class="hljs-string">'node'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>min files used here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 });
		 */
		if (gconf) {
			Y.applyConfig(gconf);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>bind the specified additional modules for this instance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!l) {
			Y._setup();
		}
	}

	<span class="hljs-keyword">if</span> (l) {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Each instance can accept one or more configuration objects.
These are applied after YUI.GlobalConfig and YUI_Config,
overriding values set in those config files if there is a ‘
matching property.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (; i &lt; l; i++) {
			Y.applyConfig(args[i]);
		}

		Y._setup();
	}

	Y.instanceOf = instanceOf;

	<span class="hljs-keyword">return</span> Y;
};

(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

	<span class="hljs-keyword">var</span> proto, prop,
		VERSION = <span class="hljs-string">'3.7.3'</span>,
		PERIOD = <span class="hljs-string">'.'</span>,
		BASE = <span class="hljs-string">'http://yui.yahooapis.com/'</span>,
	<span class="hljs-comment">/*
	 These CSS class names can't be generated by
	 getClassName since it is not available at the
	 time they are being used.
	 */</span>
		DOC_LABEL = <span class="hljs-string">'yui3-js-enabled'</span>,
		CSS_STAMP_EL = <span class="hljs-string">'yui3-css-stamp'</span>,
		NOOP = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{},
		SLICE = <span class="hljs-built_in">Array</span>.prototype.slice,
		APPLY_TO_AUTH = { <span class="hljs-string">'io.xdrReady'</span>: <span class="hljs-number">1</span>,   <span class="hljs-comment">// the functions applyTo</span>
			<span class="hljs-string">'io.xdrResponse'</span>: <span class="hljs-number">1</span>,   <span class="hljs-comment">// can call. this should</span>
			<span class="hljs-string">'SWF.eventHandler'</span>: <span class="hljs-number">1</span> }, <span class="hljs-comment">// be done at build time</span>
		hasWin = (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> != <span class="hljs-string">'undefined'</span>),
		win = (hasWin) ? <span class="hljs-built_in">window</span> : <span class="hljs-literal">null</span>,
		doc = (hasWin) ? win.document : <span class="hljs-literal">null</span>,
		docEl = doc &amp;&amp; doc.documentElement,
		docClass = docEl &amp;&amp; docEl.className,
		instances = {},
		time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime(),
		add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, type, fn, capture</span>) </span>{
			<span class="hljs-keyword">if</span> (el &amp;&amp; el.addEventListener) {
				el.addEventListener(type, fn, capture);
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el &amp;&amp; el.attachEvent) {
				el.attachEvent(<span class="hljs-string">'on'</span> + type, fn);
			}
		},
		remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, type, fn, capture</span>) </span>{
			<span class="hljs-keyword">if</span> (el &amp;&amp; el.removeEventListener) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>this can throw an uncaught exception in FF</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">try</span> {
					el.removeEventListener(type, fn, capture);
				} <span class="hljs-keyword">catch</span> (ex) {}
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el &amp;&amp; el.detachEvent) {
				el.detachEvent(<span class="hljs-string">'on'</span> + type, fn);
			}
		},
		handleLoad = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			YUI.Env.windowLoaded = <span class="hljs-literal">true</span>;
			YUI.Env.DOMReady = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">if</span> (hasWin) {
				remove(<span class="hljs-built_in">window</span>, <span class="hljs-string">'load'</span>, handleLoad);
			}
		},
		getLoader = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y, o</span>) </span>{
			<span class="hljs-keyword">var</span> loader = Y.Env._loader,
				lCore = [ <span class="hljs-string">'loader-base'</span> ],
				G_ENV = YUI.Env,
				mods = G_ENV.mods;

			<span class="hljs-keyword">if</span> (loader) {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>loader._config(Y.config);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				loader.ignoreRegistered = <span class="hljs-literal">false</span>;
				loader.onEnd = <span class="hljs-literal">null</span>;
				loader.data = <span class="hljs-literal">null</span>;
				loader.required = [];
				loader.loadType = <span class="hljs-literal">null</span>;
			} <span class="hljs-keyword">else</span> {
				loader = <span class="hljs-keyword">new</span> Y.Loader(Y.config);
				Y.Env._loader = loader;
			}
			<span class="hljs-keyword">if</span> (mods &amp;&amp; mods.loader) {
				lCore = [].concat(lCore, YUI.Env.loaderExtras);
			}
			YUI.Env.core = Y.Array.dedupe([].concat(YUI.Env.core, lCore));

			<span class="hljs-keyword">return</span> loader;
		},

		clobber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r, s</span>) </span>{
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> s) {
				<span class="hljs-keyword">if</span> (s.hasOwnProperty(i)) {
					r[i] = s[i];
				}
			}
		},

		ALREADY_DONE = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p> Stamp the documentElement (HTML) with a class of “yui-loaded” to
 enable styles that need to key off of JS being enabled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (docEl &amp;&amp; docClass.indexOf(DOC_LABEL) == <span class="hljs-number">-1</span>) {
		<span class="hljs-keyword">if</span> (docClass) {
			docClass += <span class="hljs-string">' '</span>;
		}
		docClass += DOC_LABEL;
		docEl.className = docClass;
	}

	<span class="hljs-keyword">if</span> (VERSION.indexOf(<span class="hljs-string">'@'</span>) &gt; <span class="hljs-number">-1</span>) {
		VERSION = <span class="hljs-string">'3.5.0'</span>; <span class="hljs-comment">// dev time hack for cdn test</span>
	}

	proto = {
		<span class="hljs-comment">/**
		 * Applies a new configuration object to the YUI instance config.
		 * This will merge new group/module definitions, and will also
		 * update the loader cache if necessary.  Updating Y.config directly
		 * will not update the cache.
		 * @method applyConfig
		 * @param {Object} o the configuration object.
		 * @since 3.2.0
		 */</span>
		applyConfig: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{

			o = o || NOOP;

			<span class="hljs-keyword">var</span> attr,
				name,</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>detail,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				config = <span class="hljs-keyword">this</span>.config,
				mods = config.modules,
				groups = config.groups,
				aliases = config.aliases,
				loader = <span class="hljs-keyword">this</span>.Env._loader;

			<span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> o) {
				<span class="hljs-keyword">if</span> (o.hasOwnProperty(name)) {
					attr = o[name];
					<span class="hljs-keyword">if</span> (mods &amp;&amp; name == <span class="hljs-string">'modules'</span>) {
						clobber(mods, attr);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aliases &amp;&amp; name == <span class="hljs-string">'aliases'</span>) {
						clobber(aliases, attr);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (groups &amp;&amp; name == <span class="hljs-string">'groups'</span>) {
						clobber(groups, attr);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'win'</span>) {
						config[name] = (attr &amp;&amp; attr.contentWindow) || attr;
						config.doc = config[name] ? config[name].document : <span class="hljs-literal">null</span>;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == <span class="hljs-string">'_yuid'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>preserve the guid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					} <span class="hljs-keyword">else</span> {
						config[name] = attr;
					}
				}
			}

			<span class="hljs-keyword">if</span> (loader) {
				loader._config(o);
			}

		},
		<span class="hljs-comment">/**
		 * Old way to apply a config to the instance (calls `applyConfig` under the hood)
		 * @private
		 * @method _config
		 * @param {Object} o The config to apply
		 */</span>
		_config: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
			<span class="hljs-keyword">this</span>.applyConfig(o);
		},

		<span class="hljs-comment">/**
		 * Initialize this YUI instance
		 * @private
		 * @method _init
		 */</span>
		_init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> filter, el,
				Y = <span class="hljs-keyword">this</span>,
				G_ENV = YUI.Env,
				Env = Y.Env,
				prop;

			<span class="hljs-comment">/**
			 * The version number of the YUI instance.
			 * @property version
			 * @type string
			 */</span>
			Y.version = VERSION;

			<span class="hljs-keyword">if</span> (!Env) {
				Y.Env = {
					<span class="hljs-attr">core</span>: [<span class="hljs-string">'get'</span>, <span class="hljs-string">'features'</span>, <span class="hljs-string">'intl-base'</span>, <span class="hljs-string">'yui-log'</span>, <span class="hljs-string">'yui-later'</span>],
					<span class="hljs-attr">loaderExtras</span>: [<span class="hljs-string">'loader-rollup'</span>, <span class="hljs-string">'loader-yui3'</span>],
					<span class="hljs-attr">mods</span>: {}, <span class="hljs-comment">// flat module map</span>
					versions: {}, <span class="hljs-comment">// version module map</span>
					base: BASE,
					<span class="hljs-attr">cdn</span>: BASE + VERSION + <span class="hljs-string">'/build/'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>bootstrapped: false,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					_idx: <span class="hljs-number">0</span>,
					<span class="hljs-attr">_used</span>: {},
					<span class="hljs-attr">_attached</span>: {},
					<span class="hljs-attr">_missed</span>: [],
					<span class="hljs-attr">_yidx</span>: <span class="hljs-number">0</span>,
					<span class="hljs-attr">_uidx</span>: <span class="hljs-number">0</span>,
					<span class="hljs-attr">_guidp</span>: <span class="hljs-string">'y'</span>,
					<span class="hljs-attr">_loaded</span>: {},</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>serviced: {},
Regex in English:
I’ll start at the \b(simpleyui).</p>
<ol>
<li>Look in the test string for “simpleyui” or “yui” or
“yui-base” or “yui-davglass” or “yui-foobar” that comes after a word break.  That is, it
can’t match “foyui” or “i_heart_simpleyui”. This can be anywhere in the string.</li>
<li>After #1 must come a forward slash followed by the string matched in #1, so
“yui-base/yui-base” or “simpleyui/simpleyui” or “yui-pants/yui-pants”.</li>
<li>The second occurence of the #1 token can optionally be followed by “-debug” or “-min”,
so “yui/yui-min”, “yui/yui-debug”, “yui-base/yui-base-debug”. NOT “yui/yui-tshirt”.</li>
<li>This is followed by “.js”, so “yui/yui.js”, “simpleyui/simpleyui-min.js”</li>
<li>Going back to the beginning, now. If all that stuff in 1-4 comes after a “?” in the string,
then capture the junk between the LAST “&amp;” and the string in 1-4.  So
“blah?foo/yui/yui.js” will capture “foo/“ and “blah?some/thing.js&amp;3.3.0/build/yui-davglass/yui-davglass.js”
will capture “3.3.0/build/“</li>
</ol>
<p>Regex Exploded:
(?:\?             Find a ?
  (?:[^&amp;]*&amp;)      followed by 0..n characters followed by an &amp;</p>
<ul>
<li>in fact, find as many sets of characters followed by a &amp; as you can
([^&amp;]<em>)         capture the stuff after the last &amp; in \1
)?                but it’s ok if all this ?junk&amp;more_junk stuff isn’t even there
\b(simpleyui|     after a word break find either the string “simpleyui” or
yui(?:-\w+)?   the string “yui” optionally followed by a -, then more characters
)                 and store the simpleyui or yui-</em> string in \2
\/\2              then comes a / followed by the simpleyui or yui-* string in \2
(?:-(min|debug))? optionally followed by “-min” or “-debug”
.js               and ending in “.js”</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>					_BASE_RE: <span class="hljs-regexp">/(?:\?(?:[^&amp;]*&amp;)*([^&amp;]*))?\b(simpleyui|yui(?:-\w+)?)\/\2(?:-(min|debug))?\.js/</span>,
					<span class="hljs-attr">parseBasePath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src, pattern</span>) </span>{
						<span class="hljs-keyword">var</span> match = src.match(pattern),
							path, filter;

						<span class="hljs-keyword">if</span> (match) {
							path = <span class="hljs-built_in">RegExp</span>.leftContext || src.slice(<span class="hljs-number">0</span>, src.indexOf(match[<span class="hljs-number">0</span>]));</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>this is to set up the path to the loader.  The file
filter for loader should match the yui include.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							filter = match[<span class="hljs-number">3</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>extract correct path for mixed combo urls
<a href="http://yuilibrary.com/projects/yui3/ticket/2528423">http://yuilibrary.com/projects/yui3/ticket/2528423</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (match[<span class="hljs-number">1</span>]) {
								path += <span class="hljs-string">'?'</span> + match[<span class="hljs-number">1</span>];
							}
							path = {
								<span class="hljs-attr">filter</span>: filter,
								<span class="hljs-attr">path</span>: path
							};
						}
						<span class="hljs-keyword">return</span> path;
					},
					<span class="hljs-attr">getBase</span>: G_ENV &amp;&amp; G_ENV.getBase ||
						<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern</span>) </span>{
							<span class="hljs-keyword">var</span> nodes = (doc &amp;&amp; doc.getElementsByTagName(<span class="hljs-string">'script'</span>)) || [],
								path = Env.cdn, parsed,
								i, len, src;

							<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = nodes.length; i &lt; len; ++i) {
								src = nodes[i].src;
								<span class="hljs-keyword">if</span> (src) {
									parsed = Y.Env.parseBasePath(src, pattern);
									<span class="hljs-keyword">if</span> (parsed) {
										filter = parsed.filter;
										path = parsed.path;
										<span class="hljs-keyword">break</span>;
									}
								}
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>use CDN default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> path;
						}

				};

				Env = Y.Env;

				Env._loaded[VERSION] = {};

				<span class="hljs-keyword">if</span> (G_ENV &amp;&amp; Y !== YUI) {
					Env._yidx = ++G_ENV._yidx;
					Env._guidp = (<span class="hljs-string">'yui_'</span> + VERSION + <span class="hljs-string">'_'</span> +
						Env._yidx + <span class="hljs-string">'_'</span> + time).replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">'_'</span>).replace(<span class="hljs-regexp">/-/g</span>, <span class="hljs-string">'_'</span>);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (YUI._YUI) {

					G_ENV = YUI._YUI.Env;
					Env._yidx += G_ENV._yidx;
					Env._uidx += G_ENV._uidx;

					<span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> G_ENV) {
						<span class="hljs-keyword">if</span> (!(prop <span class="hljs-keyword">in</span> Env)) {
							Env[prop] = G_ENV[prop];
						}
					}

					<span class="hljs-keyword">delete</span> YUI._YUI;
				}

				Y.id = Y.stamp(Y);
				instances[Y.id] = Y;

			}

			Y.constructor = YUI;</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>configuration defaults</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			Y.config = Y.config || {
				<span class="hljs-attr">bootstrap</span>: <span class="hljs-literal">true</span>,
				<span class="hljs-attr">cacheUse</span>: <span class="hljs-literal">true</span>,
				<span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,
				<span class="hljs-attr">doc</span>: doc,
				<span class="hljs-attr">fetchCSS</span>: <span class="hljs-literal">true</span>,
				<span class="hljs-attr">throwFail</span>: <span class="hljs-literal">true</span>,
				<span class="hljs-attr">useBrowserConsole</span>: <span class="hljs-literal">true</span>,
				<span class="hljs-attr">useNativeES5</span>: <span class="hljs-literal">true</span>,
				<span class="hljs-attr">win</span>: win
			};</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Register the CSS stamp element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (doc &amp;&amp; !doc.getElementById(CSS_STAMP_EL)) {
				el = doc.createElement(<span class="hljs-string">'div'</span>);
				el.innerHTML = <span class="hljs-string">'&lt;div id="'</span> + CSS_STAMP_EL + <span class="hljs-string">'" style="position: absolute !important; visibility: hidden !important"&gt;&lt;/div&gt;'</span>;
				YUI.Env.cssStampEl = el.firstChild;
				<span class="hljs-keyword">if</span> (doc.body) {
					doc.body.appendChild(YUI.Env.cssStampEl);
				} <span class="hljs-keyword">else</span> {
					docEl.insertBefore(YUI.Env.cssStampEl, docEl.firstChild);
				}
			}

			Y.config.lang = Y.config.lang || <span class="hljs-string">'en-US'</span>;

			Y.config.base = YUI.config.base || Y.Env.getBase(Y.Env._BASE_RE);

			<span class="hljs-keyword">if</span> (!filter || (!(<span class="hljs-string">'mindebug'</span>).indexOf(filter))) {
				filter = <span class="hljs-string">'min'</span>;
			}
			filter = (filter) ? <span class="hljs-string">'-'</span> + filter : filter;
			Y.config.loaderPath = YUI.config.loaderPath || <span class="hljs-string">'loader/loader'</span> + filter + <span class="hljs-string">'.js'</span>;

		},

		<span class="hljs-comment">/**
		 * Finishes the instance setup. Attaches whatever modules were defined
		 * when the yui modules was registered.
		 * @method _setup
		 * @private
		 */</span>
		_setup: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
			<span class="hljs-keyword">var</span> i, Y = <span class="hljs-keyword">this</span>,
				core = [],
				mods = YUI.Env.mods,
				extras = Y.config.core || [].concat(YUI.Env.core); <span class="hljs-comment">//Clone it..</span>

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; extras.length; i++) {
				<span class="hljs-keyword">if</span> (mods[extras[i]]) {
					core.push(extras[i]);
				}
			}

			Y._attach([<span class="hljs-string">'yui-base'</span>]);
			Y._attach(core);

			<span class="hljs-keyword">if</span> (Y.Loader) {
				getLoader(Y);
			}

		},

		<span class="hljs-comment">/**
		 * Executes a method on a YUI instance with
		 * the specified id if the specified method is whitelisted.
		 * @method applyTo
		 * @param id {String} the YUI instance id.
		 * @param method {String} the name of the method to exectute.
		 * Ex: 'Object.keys'.
		 * @param args {Array} the arguments to apply to the method.
		 * @return {Object} the return value from the applied method or null.
		 */</span>
		applyTo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id, method, args</span>) </span>{
			<span class="hljs-keyword">if</span> (!(method <span class="hljs-keyword">in</span> APPLY_TO_AUTH)) {
				<span class="hljs-keyword">this</span>.log(method + <span class="hljs-string">': applyTo not allowed'</span>, <span class="hljs-string">'warn'</span>, <span class="hljs-string">'yui'</span>);
				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
			}

			<span class="hljs-keyword">var</span> instance = instances[id], nest, m, i;
			<span class="hljs-keyword">if</span> (instance) {
				nest = method.split(<span class="hljs-string">'.'</span>);
				m = instance;
				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nest.length; i = i + <span class="hljs-number">1</span>) {
					m = m[nest[i]];
					<span class="hljs-keyword">if</span> (!m) {
						<span class="hljs-keyword">this</span>.log(<span class="hljs-string">'applyTo not found: '</span> + method, <span class="hljs-string">'warn'</span>, <span class="hljs-string">'yui'</span>);
					}
				}
				<span class="hljs-keyword">return</span> m &amp;&amp; m.apply(instance, args);
			}

			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
		},

		<span class="hljs-comment">/**
		 Registers a module with the YUI global.  The easiest way to create a
		 first-class YUI module is to use the YUI component
		 build tool &lt;a href="http://yui.github.com/shifter/"&gt;Shifter&lt;/a&gt;.

		 The build system will produce the `YUI.add` wrapper for your module, along
		 with any configuration info required for the module.

		 @method add
		 @param name {String} module name.
		 @param fn {Function} entry point into the module that is used to bind module to the YUI instance.
		 @param {YUI} fn.Y The YUI instance this module is executed in.
		 @param {String} fn.name The name of the module
		 @param version {String} version string.
		 @param details {Object} optional config data:
		 @param details.requires {Array} features that must be present before this module can be attached.
		 @param details.optional {Array} optional features that should be present if loadOptional
		 is defined.  Note: modules are not often loaded this way in YUI 3,
		 but this field is still useful to inform the user that certain
		 features in the component will require additional dependencies.
		 @param details.use {Array} features that are included within this module which need to
		 be attached automatically when this module is attached.  This
		 supports the YUI 3 rollup system -- a module with submodules
		 defined will need to have the submodules listed in the 'use'
		 config.  The YUI component build tool does this for you.
		 @return {YUI} the YUI instance.
		 @example

		 YUI.add('davglass', function(Y, name) {
		 Y.davglass = function() {
		 alert('Dav was here!');
		 };
		 }, '3.4.0', { requires: ['yui-base', 'harley-davidson', 'mt-dew'] });

		 */</span>
		add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, fn, version, details</span>) </span>{
			details = details || {};
			<span class="hljs-keyword">var</span> env = YUI.Env,
				mod = {
					<span class="hljs-attr">name</span>: name,
					<span class="hljs-attr">fn</span>: fn,
					<span class="hljs-attr">version</span>: version,
					<span class="hljs-attr">details</span>: details
				},</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Instance hash so we don’t apply it to the same instance twice</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				applied = {},
				loader, inst,
				i, versions = env.versions;

			env.mods[name] = mod;
			versions[version] = versions[version] || {};
			versions[version][name] = mod;

			<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> instances) {
				<span class="hljs-keyword">if</span> (instances.hasOwnProperty(i)) {
					inst = instances[i];
					<span class="hljs-keyword">if</span> (!applied[inst.id]) {
						applied[inst.id] = <span class="hljs-literal">true</span>;
						loader = inst.Env._loader;
						<span class="hljs-keyword">if</span> (loader) {
							<span class="hljs-keyword">if</span> (!loader.moduleInfo[name] || loader.moduleInfo[name].temp) {
								loader.addModule(details, name);
							}
						}
					}
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Executes the function associated with each required
		 * module, binding the module to the YUI instance.
		 * @param {Array} r The array of modules to attach
		 * @param {Boolean} [moot=false] Don't throw a warning if the module is not attached
		 * @method _attach
		 * @private
		 */</span>
		_attach: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r, moot</span>) </span>{
			<span class="hljs-keyword">var</span> i, name, mod, details, req, use, after,
				mods = YUI.Env.mods,
				aliases = YUI.Env.aliases,
				Y = <span class="hljs-keyword">this</span>, j,
				cache = YUI.Env._renderedMods,
				loader = Y.Env._loader,
				done = Y.Env._attached,
				len = r.length, loader, def, go,
				c = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Check for conditional modules (in a second+ instance) and add their requirements
TODO I hate this entire method, it needs to be fixed ASAP (3.5.0) ^davglass</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
				name = r[i];
				mod = mods[name];
				c.push(name);
				<span class="hljs-keyword">if</span> (loader &amp;&amp; loader.conditions[name]) {
					<span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> loader.conditions[name]) {
						<span class="hljs-keyword">if</span> (loader.conditions[name].hasOwnProperty(j)) {
							def = loader.conditions[name][j];
							go = def &amp;&amp; ((def.ua &amp;&amp; Y.UA[def.ua]) || (def.test &amp;&amp; def.test(Y)));
							<span class="hljs-keyword">if</span> (go) {
								c.push(def.name);
							}
						}
					}
				}
			}
			r = c;
			len = r.length;

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
				<span class="hljs-keyword">if</span> (!done[r[i]]) {
					name = r[i];
					mod = mods[name];

					<span class="hljs-keyword">if</span> (aliases &amp;&amp; aliases[name] &amp;&amp; !mod) {
						Y._attach(aliases[name]);
						<span class="hljs-keyword">continue</span>;
					}
					<span class="hljs-keyword">if</span> (!mod) {
						<span class="hljs-keyword">if</span> (loader &amp;&amp; loader.moduleInfo[name]) {
							mod = loader.moduleInfo[name];
							moot = <span class="hljs-literal">true</span>;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>if (!loader || !loader.moduleInfo[name]) {
if ((!loader || !loader.moduleInfo[name]) &amp;&amp; !moot) {</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!moot &amp;&amp; name) {
							<span class="hljs-keyword">if</span> ((name.indexOf(<span class="hljs-string">'skin-'</span>) === <span class="hljs-number">-1</span>) &amp;&amp; (name.indexOf(<span class="hljs-string">'css'</span>) === <span class="hljs-number">-1</span>)) {
								Y.Env._missed.push(name);
								Y.Env._missed = Y.Array.dedupe(Y.Env._missed);
								Y.message(<span class="hljs-string">'NOT loaded: '</span> + name, <span class="hljs-string">'warn'</span>, <span class="hljs-string">'yui'</span>);
							}
						}
					} <span class="hljs-keyword">else</span> {
						done[name] = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Don’t like this, but in case a mod was asked for once, then we fetch it
We need to remove it from the missed list ^davglass</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; Y.Env._missed.length; j++) {
							<span class="hljs-keyword">if</span> (Y.Env._missed[j] === name) {
								Y.message(<span class="hljs-string">'Found: '</span> + name + <span class="hljs-string">' (was reported as missing earlier)'</span>, <span class="hljs-string">'warn'</span>, <span class="hljs-string">'yui'</span>);
								Y.Env._missed.splice(j, <span class="hljs-number">1</span>);
							}
						}
						<span class="hljs-comment">/*
						 If it's a temp module, we need to redo it's requirements if it's already loaded
						 since it may have been loaded by another instance and it's dependencies might
						 have been redefined inside the fetched file.
						 */</span>
						<span class="hljs-keyword">if</span> (loader &amp;&amp; cache &amp;&amp; cache[name] &amp;&amp; cache[name].temp) {
							loader.getRequires(cache[name]);
							req = [];
							<span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> loader.moduleInfo[name].expanded_map) {
								<span class="hljs-keyword">if</span> (loader.moduleInfo[name].expanded_map.hasOwnProperty(j)) {
									req.push(j);
								}
							}
							Y._attach(req);
						}

						details = mod.details;
						req = details.requires;
						use = details.use;
						after = details.after;</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Force Intl load if there is a language (Loader logic) @todo fix this shit</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (details.lang) {
							req = req || [];
							req.unshift(<span class="hljs-string">'intl'</span>);
						}

						<span class="hljs-keyword">if</span> (req) {
							<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; req.length; j++) {
								<span class="hljs-keyword">if</span> (!done[req[j]]) {
									<span class="hljs-keyword">if</span> (!Y._attach(req)) {
										<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
									}
									<span class="hljs-keyword">break</span>;
								}
							}
						}

						<span class="hljs-keyword">if</span> (after) {
							<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; after.length; j++) {
								<span class="hljs-keyword">if</span> (!done[after[j]]) {
									<span class="hljs-keyword">if</span> (!Y._attach(after, <span class="hljs-literal">true</span>)) {
										<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
									}
									<span class="hljs-keyword">break</span>;
								}
							}
						}

						<span class="hljs-keyword">if</span> (mod.fn) {
							<span class="hljs-keyword">if</span> (Y.config.throwFail) {
								mod.fn(Y, name);
							} <span class="hljs-keyword">else</span> {
								<span class="hljs-keyword">try</span> {
									mod.fn(Y, name);
								} <span class="hljs-keyword">catch</span> (e) {
									Y.error(<span class="hljs-string">'Attach error: '</span> + name, e, name);
									<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
								}
							}
						}

						<span class="hljs-keyword">if</span> (use) {
							<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; use.length; j++) {
								<span class="hljs-keyword">if</span> (!done[use[j]]) {
									<span class="hljs-keyword">if</span> (!Y._attach(use)) {
										<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
									}
									<span class="hljs-keyword">break</span>;
								}
							}
						}



					}
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		},
		<span class="hljs-comment">/**
		 * Delays the `use` callback until another event has taken place. Like: window.onload, domready, contentready, available.
		 * @private
		 * @method _delayCallback
		 * @param {Callback} cb The original `use` callback
		 * @param {String|Object} until Either an event (load, domready) or an Object containing event/args keys for contentready/available
		 */</span>
		_delayCallback: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cb, until</span>) </span>{

			<span class="hljs-keyword">var</span> Y = <span class="hljs-keyword">this</span>,
				mod = [<span class="hljs-string">'event-base'</span>];

			until = (Y.Lang.isObject(until) ? until : { <span class="hljs-attr">event</span>: until });

			<span class="hljs-keyword">if</span> (until.event === <span class="hljs-string">'load'</span>) {
				mod.push(<span class="hljs-string">'event-synthetic'</span>);
			}

			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
				Y._use(mod, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					Y.on(until.event, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
						args[<span class="hljs-number">1</span>].delayUntil = until.event;
						cb.apply(Y, args);
					}, until.args);
				});
			};
		},

		<span class="hljs-comment">/**
		 * Attaches one or more modules to the YUI instance.  When this
		 * is executed, the requirements are analyzed, and one of
		 * several things can happen:
		 *
		 *  * All requirements are available on the page --  The modules
		 *   are attached to the instance.  If supplied, the use callback
		 *   is executed synchronously.
		 *
		 *  * Modules are missing, the Get utility is not available OR
		 *   the 'bootstrap' config is false -- A warning is issued about
		 *   the missing modules and all available modules are attached.
		 *
		 *  * Modules are missing, the Loader is not available but the Get
		 *   utility is and boostrap is not false -- The loader is bootstrapped
		 *   before doing the following....
		 *
		 *  * Modules are missing and the Loader is available -- The loader
		 *   expands the dependency tree and fetches missing modules.  When
		 *   the loader is finshed the callback supplied to use is executed
		 *   asynchronously.
		 *
		 * @method use
		 * @param modules* {String|Array} 1-n modules to bind (uses arguments array).
		 * @param [callback] {Function} callback function executed when
		 * the instance has the required functionality.  If included, it
		 * must be the last parameter.
		 * @param callback.Y {YUI} The `YUI` instance created for this sandbox
		 * @param callback.status {Object} Object containing `success`, `msg` and `data` properties
		 *
		 * @example
		 *      // loads and attaches dd and its dependencies
		 *      YUI().use('dd', function(Y) {});
		 *
		 *      // loads and attaches dd and node as well as all of their dependencies (since 3.4.0)
		 *      YUI().use(['dd', 'node'], function(Y) {});
		 *
		 *      // attaches all modules that are available on the page
		 *      YUI().use('*', function(Y) {});
		 *
		 *      // intrinsic YUI gallery support (since 3.1.0)
		 *      YUI().use('gallery-yql', function(Y) {});
		 *
		 *      // intrinsic YUI 2in3 support (since 3.1.0)
		 *      YUI().use('yui2-datatable', function(Y) {});
		 *
		 * @return {YUI} the YUI instance.
		 */</span>
		use: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> args = SLICE.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>),
				callback = args[args.length - <span class="hljs-number">1</span>],
				Y = <span class="hljs-keyword">this</span>,
				i = <span class="hljs-number">0</span>,
				a = [],
				name,
				Env = Y.Env,
				provisioned = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>The last argument supplied to use can be a load complete callback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (Y.Lang.isFunction(callback)) {
				args.pop();
				<span class="hljs-keyword">if</span> (Y.config.delayUntil) {
					callback = Y._delayCallback(callback, Y.config.delayUntil);
				}
			} <span class="hljs-keyword">else</span> {
				callback = <span class="hljs-literal">null</span>;
			}
			<span class="hljs-keyword">if</span> (Y.Lang.isArray(args[<span class="hljs-number">0</span>])) {
				args = args[<span class="hljs-number">0</span>];
			}

			<span class="hljs-keyword">if</span> (Y.config.cacheUse) {
				<span class="hljs-keyword">while</span> ((name = args[i++])) {
					<span class="hljs-keyword">if</span> (!Env._attached[name]) {
						provisioned = <span class="hljs-literal">false</span>;
						<span class="hljs-keyword">break</span>;
					}
				}

				<span class="hljs-keyword">if</span> (provisioned) {
					<span class="hljs-keyword">if</span> (args.length) {
					}
					Y._notify(callback, ALREADY_DONE, args);
					<span class="hljs-keyword">return</span> Y;
				}
			}

			<span class="hljs-keyword">if</span> (Y._loading) {
				Y._useQueue = Y._useQueue || <span class="hljs-keyword">new</span> Y.Queue();
				Y._useQueue.add([args, callback]);
			} <span class="hljs-keyword">else</span> {
				Y._use(args, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y, response</span>) </span>{
					Y._notify(callback, response, args);
				});
			}

			<span class="hljs-keyword">return</span> Y;
		},
		<span class="hljs-comment">/**
		 * Notify handler from Loader for attachment/load errors
		 * @method _notify
		 * @param callback {Function} The callback to pass to the `Y.config.loadErrorFn`
		 * @param response {Object} The response returned from Loader
		 * @param args {Array} The aruments passed from Loader
		 * @private
		 */</span>
		_notify: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, response, args</span>) </span>{
			<span class="hljs-keyword">if</span> (!response.success &amp;&amp; <span class="hljs-keyword">this</span>.config.loadErrorFn) {
				<span class="hljs-keyword">this</span>.config.loadErrorFn.call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>, callback, response, args);
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (callback) {
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.Env._missed &amp;&amp; <span class="hljs-keyword">this</span>.Env._missed.length) {
					response.msg = <span class="hljs-string">'Missing modules: '</span> + <span class="hljs-keyword">this</span>.Env._missed.join();
					response.success = <span class="hljs-literal">false</span>;
				}
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.config.throwFail) {
					callback(<span class="hljs-keyword">this</span>, response);
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">try</span> {
						callback(<span class="hljs-keyword">this</span>, response);
					} <span class="hljs-keyword">catch</span> (e) {
						<span class="hljs-keyword">this</span>.error(<span class="hljs-string">'use callback error'</span>, e, args);
					}
				}
			}
		},

		<span class="hljs-comment">/**
		 * This private method is called from the `use` method queue. To ensure that only one set of loading
		 * logic is performed at a time.
		 * @method _use
		 * @private
		 * @param args* {String} 1-n modules to bind (uses arguments array).
		 * @param *callback {Function} callback function executed when
		 * the instance has the required functionality.  If included, it
		 * must be the last parameter.
		 */</span>
		_use: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args, callback</span>) </span>{

			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.Array) {
				<span class="hljs-keyword">this</span>._attach([<span class="hljs-string">'yui-base'</span>]);
			}

			<span class="hljs-keyword">var</span> len, loader, handleBoot, handleRLS,
				Y = <span class="hljs-keyword">this</span>,
				G_ENV = YUI.Env,
				mods = G_ENV.mods,
				Env = Y.Env,
				used = Env._used,
				aliases = G_ENV.aliases,
				queue = G_ENV._loaderQueue,
				firstArg = args[<span class="hljs-number">0</span>],
				YArray = Y.Array,
				config = Y.config,
				boot = config.bootstrap,
				missing = [],
				i,
				r = [],
				ret = <span class="hljs-literal">true</span>,
				fetchCSS = config.fetchCSS,
				process = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">names, skip</span>) </span>{

					<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, a = [], name, len, m, req, use;

					<span class="hljs-keyword">if</span> (!names.length) {
						<span class="hljs-keyword">return</span>;
					}

					<span class="hljs-keyword">if</span> (aliases) {
						len = names.length;
						<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
							<span class="hljs-keyword">if</span> (aliases[names[i]] &amp;&amp; !mods[names[i]]) {
								a = [].concat(a, aliases[names[i]]);
							} <span class="hljs-keyword">else</span> {
								a.push(names[i]);
							}
						}
						names = a;
					}

					len = names.length;

					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
						name = names[i];
						<span class="hljs-keyword">if</span> (!skip) {
							r.push(name);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>only attach a module once</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (used[name]) {
							<span class="hljs-keyword">continue</span>;
						}

						m = mods[name];
						req = <span class="hljs-literal">null</span>;
						use = <span class="hljs-literal">null</span>;

						<span class="hljs-keyword">if</span> (m) {
							used[name] = <span class="hljs-literal">true</span>;
							req = m.details.requires;
							use = m.details.use;
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>CSS files don’t register themselves, see if it has
been loaded</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (!G_ENV._loaded[VERSION][name]) {
								missing.push(name);
							} <span class="hljs-keyword">else</span> {
								used[name] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// probably css</span>
							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>make sure requirements are attached</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (req &amp;&amp; req.length) {
							process(req);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>make sure we grab the submodule dependencies too</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (use &amp;&amp; use.length) {
							process(use, <span class="hljs-number">1</span>);
						}
					}

				},

				handleLoader = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fromLoader</span>) </span>{
					<span class="hljs-keyword">var</span> response = fromLoader || {
							<span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
							<span class="hljs-attr">msg</span>: <span class="hljs-string">'not dynamic'</span>
						},
						redo, origMissing,
						ret = <span class="hljs-literal">true</span>,
						data = response.data;

					Y._loading = <span class="hljs-literal">false</span>;

					<span class="hljs-keyword">if</span> (data) {
						origMissing = missing;
						missing = [];
						r = [];
						process(data);
						redo = missing.length;
						<span class="hljs-keyword">if</span> (redo) {
							<span class="hljs-keyword">if</span> ([].concat(missing).sort().join() ==
								origMissing.sort().join()) {
								redo = <span class="hljs-literal">false</span>;
							}
						}
					}

					<span class="hljs-keyword">if</span> (redo &amp;&amp; data) {
						Y._loading = <span class="hljs-literal">true</span>;
						Y._use(missing, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
							<span class="hljs-keyword">if</span> (Y._attach(data)) {
								Y._notify(callback, response, data);
							}
						});
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">if</span> (data) {
							ret = Y._attach(data);
						}
						<span class="hljs-keyword">if</span> (ret) {
							Y._notify(callback, response, args);
						}
					}

					<span class="hljs-keyword">if</span> (Y._useQueue &amp;&amp; Y._useQueue.size() &amp;&amp; !Y._loading) {
						Y._use.apply(Y, Y._useQueue.next());
					}

				};</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>YUI().use(‘*’); // bind everything available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (firstArg === <span class="hljs-string">'*'</span>) {
				args = [];
				<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> mods) {
					<span class="hljs-keyword">if</span> (mods.hasOwnProperty(i)) {
						args.push(i);
					}
				}
				ret = Y._attach(args);
				<span class="hljs-keyword">if</span> (ret) {
					handleLoader();
				}
				<span class="hljs-keyword">return</span> Y;
			}

			<span class="hljs-keyword">if</span> ((mods.loader || mods[<span class="hljs-string">'loader-base'</span>]) &amp;&amp; !Y.Loader) {
				Y._attach([<span class="hljs-string">'loader'</span> + ((!mods.loader) ? <span class="hljs-string">'-base'</span> : <span class="hljs-string">''</span>)]);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>use loader to expand dependencies and sort the
requirements if it is available.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (boot &amp;&amp; Y.Loader &amp;&amp; args.length) {
				loader = getLoader(Y);
				loader.require(args);
				loader.ignoreRegistered = <span class="hljs-literal">true</span>;
				loader._boot = <span class="hljs-literal">true</span>;
				loader.calculate(<span class="hljs-literal">null</span>, (fetchCSS) ? <span class="hljs-literal">null</span> : <span class="hljs-string">'js'</span>);
				args = loader.sorted;
				loader._boot = <span class="hljs-literal">false</span>;
			}

			process(args);

			len = missing.length;


			<span class="hljs-keyword">if</span> (len) {
				missing = YArray.dedupe(missing);
				len = missing.length;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>dynamic load</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (boot &amp;&amp; len &amp;&amp; Y.Loader) {
				Y._loading = <span class="hljs-literal">true</span>;
				loader = getLoader(Y);
				loader.onEnd = handleLoader;
				loader.context = Y;
				loader.data = args;
				loader.ignoreRegistered = <span class="hljs-literal">false</span>;
				loader.require(args);
				loader.insert(<span class="hljs-literal">null</span>, (fetchCSS) ? <span class="hljs-literal">null</span> : <span class="hljs-string">'js'</span>);

			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (boot &amp;&amp; len &amp;&amp; Y.Get &amp;&amp; !Env.bootstrapped) {

				Y._loading = <span class="hljs-literal">true</span>;

				handleBoot = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					Y._loading = <span class="hljs-literal">false</span>;
					queue.running = <span class="hljs-literal">false</span>;
					Env.bootstrapped = <span class="hljs-literal">true</span>;
					G_ENV._bootstrapping = <span class="hljs-literal">false</span>;
					<span class="hljs-keyword">if</span> (Y._attach([<span class="hljs-string">'loader'</span>])) {
						Y._use(args, callback);
					}
				};

				<span class="hljs-keyword">if</span> (G_ENV._bootstrapping) {
					queue.add(handleBoot);
				} <span class="hljs-keyword">else</span> {
					G_ENV._bootstrapping = <span class="hljs-literal">true</span>;
					Y.Get.script(config.base + config.loaderPath, {
						<span class="hljs-attr">onEnd</span>: handleBoot
					});
				}

			} <span class="hljs-keyword">else</span> {
				ret = Y._attach(args);
				<span class="hljs-keyword">if</span> (ret) {
					handleLoader();
				}
			}

			<span class="hljs-keyword">return</span> Y;
		},


		<span class="hljs-comment">/**
		 Adds a namespace object onto the YUI global if called statically.

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>creates YUI.your.namespace.here as nested objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 YUI.namespace("your.namespace.here");

		 If called as a method on a YUI &lt;em&gt;instance&lt;/em&gt;, it creates the
		 namespace on the instance.</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>creates Y.property.package</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 Y.namespace("property.package");

		 Dots in the input string cause `namespace` to create nested objects for
		 each token. If any part of the requested namespace already exists, the
		 current object will be left in place.  This allows multiple calls to
		 `namespace` to preserve existing namespaced properties.

		 If the first token in the namespace string is "YAHOO", the token is
		 discarded.

		 Be careful with namespace tokens. Reserved words may work in some browsers
		 and not others. For instance, the following will fail in some browsers
		 because the supported version of JavaScript reserves the word "long":

		 Y.namespace("really.long.nested.namespace");

		 &lt;em&gt;Note: If you pass multiple arguments to create multiple namespaces, only
		 the last one created is returned from this function.&lt;/em&gt;

		 @method namespace
		 @param  {String} namespace* namespaces to create.
		 @return {Object}  A reference to the last namespace object created.
		 **/
		namespace: function() {
			var a = arguments, o, i = 0, j, d, arg;

			for (; i &lt; a.length; i++) {
				o = this; //Reset base object per argument or it will get reused from the last
				arg = a[i];
				if (arg.indexOf(PERIOD) &gt; -1) { //Skip this if no "." is present
					d = arg.split(PERIOD);
					for (j = (d[0] == 'YAHOO') ? 1 : 0; j &lt; d.length; j++) {
						o[d[j]] = o[d[j]] || {};
						o = o[d[j]];
					}
				} else {
					o[arg] = o[arg] || {};
					o = o[arg]; //Reset base object to the new object so it's returned
				}
			}
			return o;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>this is replaced if the log module is included</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		log: NOOP,
		<span class="hljs-attr">message</span>: NOOP,</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>this is replaced if the dump module is included</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		dump: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>+o; },

		<span class="hljs-comment">/**
		 * Report an error.  The reporting mechanism is controlled by
		 * the `throwFail` configuration attribute.  If throwFail is
		 * not specified, the message is written to the Logger, otherwise
		 * a JS error is thrown. If an `errorFn` is specified in the config
		 * it must return `true` to keep the error from being thrown.
		 * @method error
		 * @param msg {String} the error message.
		 * @param e {Error|String} Optional JS error that was caught, or an error string.
		 * @param src Optional additional info (passed to `Y.config.errorFn` and `Y.message`)
		 * and `throwFail` is specified, this error will be re-thrown.
		 * @return {YUI} this YUI instance.
		 */</span>
		error: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, e, src</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>TODO Add check for window.onerror here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
			<span class="hljs-keyword">var</span> Y = <span class="hljs-keyword">this</span>, ret;

			<span class="hljs-keyword">if</span> (Y.config.errorFn) {
				ret = Y.config.errorFn.apply(Y, <span class="hljs-built_in">arguments</span>);
			}

			<span class="hljs-keyword">if</span> (!ret) {
				<span class="hljs-keyword">throw</span> (e || <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(msg));
			} <span class="hljs-keyword">else</span> {
				Y.message(msg, <span class="hljs-string">'error'</span>, <span class="hljs-string">''</span>+src); <span class="hljs-comment">// don't scrub this one</span>
			}

			<span class="hljs-keyword">return</span> Y;
		},

		<span class="hljs-comment">/**
		 * Generate an id that is unique among all YUI instances
		 * @method guid
		 * @param pre {String} optional guid prefix.
		 * @return {String} the guid.
		 */</span>
		guid: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pre</span>) </span>{
			<span class="hljs-keyword">var</span> id = <span class="hljs-keyword">this</span>.Env._guidp + <span class="hljs-string">'_'</span> + (++<span class="hljs-keyword">this</span>.Env._uidx);
			<span class="hljs-keyword">return</span> (pre) ? (pre + id) : id;
		},

		<span class="hljs-comment">/**
		 * Returns a `guid` associated with an object.  If the object
		 * does not have one, a new one is created unless `readOnly`
		 * is specified.
		 * @method stamp
		 * @param o {Object} The object to stamp.
		 * @param readOnly {Boolean} if `true`, a valid guid will only
		 * be returned if the object has one assigned to it.
		 * @return {String} The object's guid or null.
		 */</span>
		stamp: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o, readOnly</span>) </span>{
			<span class="hljs-keyword">var</span> uid;
			<span class="hljs-keyword">if</span> (!o) {
				<span class="hljs-keyword">return</span> o;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>IE generates its own unique ID for dom nodes
The uniqueID property of a document node returns a new ID</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (o.uniqueID &amp;&amp; o.nodeType &amp;&amp; o.nodeType !== <span class="hljs-number">9</span>) {
				uid = o.uniqueID;
			} <span class="hljs-keyword">else</span> {
				uid = (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">'string'</span>) ? o : o._yuid;
			}

			<span class="hljs-keyword">if</span> (!uid) {
				uid = <span class="hljs-keyword">this</span>.guid();
				<span class="hljs-keyword">if</span> (!readOnly) {
					<span class="hljs-keyword">try</span> {
						o._yuid = uid;
					} <span class="hljs-keyword">catch</span> (e) {
						uid = <span class="hljs-literal">null</span>;
					}
				}
			}
			<span class="hljs-keyword">return</span> uid;
		},

		<span class="hljs-comment">/**
		 * Destroys the YUI instance
		 * @method destroy
		 * @since 3.3.0
		 */</span>
		destroy: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> Y = <span class="hljs-keyword">this</span>;
			<span class="hljs-keyword">if</span> (Y.Event) {
				Y.Event._unload();
			}
			<span class="hljs-keyword">delete</span> instances[Y.id];
			<span class="hljs-keyword">delete</span> Y.Env;
			<span class="hljs-keyword">delete</span> Y.config;
		}

		<span class="hljs-comment">/**
		 * instanceof check for objects that works around
		 * memory leak in IE when the item tested is
		 * window/document
		 * @method instanceOf
		 * @param o {Object} The object to check.
		 * @param type {Object} The class to check against.
		 * @since 3.3.0
		 */</span>
	};

	YUI.prototype = proto;</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>inheritance utilities are not available yet</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> proto) {
		<span class="hljs-keyword">if</span> (proto.hasOwnProperty(prop)) {
			YUI[prop] = proto[prop];
		}
	}

	<span class="hljs-comment">/**
	 Static method on the Global YUI object to apply a config to all YUI instances.
	 It's main use case is "mashups" where several third party scripts are trying to write to
	 a global YUI config at the same time. This way they can all call `YUI.applyConfig({})` instead of
	 overwriting other scripts configs.
	 @static
	 @since 3.5.0
	 @method applyConfig
	 @param {Object} o the configuration object.
	 @example

	 YUI.applyConfig({
	 modules: {
	 davglass: {
	 fullpath: './davglass.js'
	 }
	 }
	 });

	 YUI.applyConfig({
	 modules: {
	 foo: {
	 fullpath: './foo.js'
	 }
	 }
	 });

	 YUI().use('davglass', function(Y) {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Module davglass will be available here..</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	 });

	 */
	YUI.applyConfig = function(o) {
		if (!o) {
			return;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>If there is a GlobalConfig, apply it first to set the defaults</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (YUI.GlobalConfig) {
			<span class="hljs-keyword">this</span>.prototype.applyConfig.call(<span class="hljs-keyword">this</span>, YUI.GlobalConfig);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Apply this config to it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">this</span>.prototype.applyConfig.call(<span class="hljs-keyword">this</span>, o);</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Reset GlobalConfig to the combined config</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		YUI.GlobalConfig = <span class="hljs-keyword">this</span>.config;
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>set up the environment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	YUI._init();

	<span class="hljs-keyword">if</span> (hasWin) {</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>add a window load event at load time so we can capture
the case where it fires before dynamic loading is
complete.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		add(<span class="hljs-built_in">window</span>, <span class="hljs-string">'load'</span>, handleLoad);
	} <span class="hljs-keyword">else</span> {
		handleLoad();
	}

	YUI.Env.add = add;
	YUI.Env.remove = remove;

	<span class="hljs-comment">/*global exports*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Support the CommonJS method for exporting our single global</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports == <span class="hljs-string">'object'</span>) {
		exports.YUI = YUI;
	}

}());


<span class="hljs-comment">/**
 * The config object contains all of the configuration options for
 * the `YUI` instance.  This object is supplied by the implementer
 * when instantiating a `YUI` instance.  Some properties have default
 * values if they are not supplied by the implementer.  This should
 * not be updated directly because some values are cached.  Use
 * `applyConfig()` to update the config object on a YUI instance that
 * has already been configured.
 *
 * @class config
 * @static
 */</span>

<span class="hljs-comment">/**
 * Allows the YUI seed file to fetch the loader component and library
 * metadata to dynamically load additional dependencies.
 *
 * @property bootstrap
 * @type boolean
 * @default true
 */</span>

<span class="hljs-comment">/**
 * Turns on writing Ylog messages to the browser console.
 *
 * @property debug
 * @type boolean
 * @default true
 */</span>

<span class="hljs-comment">/**
 * Log to the browser console if debug is on and the browser has a
 * supported console.
 *
 * @property useBrowserConsole
 * @type boolean
 * @default true
 */</span>

<span class="hljs-comment">/**
 * A hash of log sources that should be logged.  If specified, only
 * log messages from these sources will be logged.
 *
 * @property logInclude
 * @type object
 */</span>

<span class="hljs-comment">/**
 * A hash of log sources that should be not be logged.  If specified,
 * all sources are logged if not on this list.
 *
 * @property logExclude
 * @type object
 */</span>

<span class="hljs-comment">/**
 * Set to true if the yui seed file was dynamically loaded in
 * order to bootstrap components relying on the window load event
 * and the `domready` custom event.
 *
 * @property injected
 * @type boolean
 * @default false
 */</span>

<span class="hljs-comment">/**
 * If `throwFail` is set, `Y.error` will generate or re-throw a JS Error.
 * Otherwise the failure is logged.
 *
 * @property throwFail
 * @type boolean
 * @default true
 */</span>

<span class="hljs-comment">/**
 * The window/frame that this instance should operate in.
 *
 * @property win
 * @type Window
 * @default the window hosting YUI
 */</span>

<span class="hljs-comment">/**
 * The document associated with the 'win' configuration.
 *
 * @property doc
 * @type Document
 * @default the document hosting YUI
 */</span>

<span class="hljs-comment">/**
 * A list of modules that defines the YUI core (overrides the default list).
 *
 * @property core
 * @type Array
 * @default [ get,features,intl-base,yui-log,yui-later,loader-base, loader-rollup, loader-yui3 ]
 */</span>

<span class="hljs-comment">/**
 * A list of languages in order of preference. This list is matched against
 * the list of available languages in modules that the YUI instance uses to
 * determine the best possible localization of language sensitive modules.
 * Languages are represented using BCP 47 language tags, such as "en-GB" for
 * English as used in the United Kingdom, or "zh-Hans-CN" for simplified
 * Chinese as used in China. The list can be provided as a comma-separated
 * list or as an array.
 *
 * @property lang
 * @type string|string[]
 */</span>

<span class="hljs-comment">/**
 * The default date format
 * @property dateFormat
 * @type string
 * @deprecated use configuration in `DataType.Date.format()` instead.
 */</span>

<span class="hljs-comment">/**
 * The default locale
 * @property locale
 * @type string
 * @deprecated use `config.lang` instead.
 */</span>

<span class="hljs-comment">/**
 * The default interval when polling in milliseconds.
 * @property pollInterval
 * @type int
 * @default 20
 */</span>

<span class="hljs-comment">/**
 * The number of dynamic nodes to insert by default before
 * automatically removing them.  This applies to script nodes
 * because removing the node will not make the evaluated script
 * unavailable.  Dynamic CSS is not auto purged, because removing
 * a linked style sheet will also remove the style definitions.
 * @property purgethreshold
 * @type int
 * @default 20
 */</span>

<span class="hljs-comment">/**
 * The default interval when polling in milliseconds.
 * @property windowResizeDelay
 * @type int
 * @default 40
 */</span>

<span class="hljs-comment">/**
 * Base directory for dynamic loading
 * @property base
 * @type string
 */</span>

<span class="hljs-comment">/*
 * The secure base dir (not implemented)
 * For dynamic loading.
 * @property secureBase
 * @type string
 */</span>

<span class="hljs-comment">/**
 * The YUI combo service base dir. Ex: `http://yui.yahooapis.com/combo?`
 * For dynamic loading.
 * @property comboBase
 * @type string
 */</span>

<span class="hljs-comment">/**
 * The root path to prepend to module path for the combo service.
 * Ex: 3.0.0b1/build/
 * For dynamic loading.
 * @property root
 * @type string
 */</span>

<span class="hljs-comment">/**
 * A filter to apply to result urls.  This filter will modify the default
 * path for all modules.  The default path for the YUI library is the
 * minified version of the files (e.g., event-min.js).  The filter property
 * can be a predefined filter or a custom filter.  The valid predefined
 * filters are:
 * &lt;dl&gt;
 *  &lt;dt&gt;DEBUG&lt;/dt&gt;
 *  &lt;dd&gt;Selects the debug versions of the library (e.g., event-debug.js).
 *      This option will automatically include the Logger widget&lt;/dd&gt;
 *  &lt;dt&gt;RAW&lt;/dt&gt;
 *  &lt;dd&gt;Selects the non-minified version of the library (e.g., event.js).&lt;/dd&gt;
 * &lt;/dl&gt;
 * You can also define a custom filter, which must be an object literal
 * containing a search expression and a replace string:
 *
 *      myFilter: {
 *          'searchExp': "-min\\.js",
 *          'replaceStr': "-debug.js"
 *      }
 *
 * For dynamic loading.
 *
 * @property filter
 * @type string|object
 */</span>

<span class="hljs-comment">/**
 * The `skin` config let's you configure application level skin
 * customizations.  It contains the following attributes which
 * can be specified to override the defaults:
 *
 *      // The default skin, which is automatically applied if not
 *      // overriden by a component-specific skin definition.
 *      // Change this in to apply a different skin globally
 *      defaultSkin: 'sam',
 *
 *      // This is combined with the loader base property to get
 *      // the default root directory for a skin.
 *      base: 'assets/skins/',
 *
 *      // Any component-specific overrides can be specified here,
 *      // making it possible to load different skins for different
 *      // components.  It is possible to load more than one skin
 *      // for a given component as well.
 *      overrides: {
 *          slider: ['capsule', 'round']
 *      }
 *
 * For dynamic loading.
 *
 *  @property skin
 */</span>

<span class="hljs-comment">/**
 * Hash of per-component filter specification.  If specified for a given
 * component, this overrides the filter config.
 *
 * For dynamic loading.
 *
 * @property filters
 */</span>

<span class="hljs-comment">/**
 * Use the YUI combo service to reduce the number of http connections
 * required to load your dependencies.  Turning this off will
 * disable combo handling for YUI and all module groups configured
 * with a combo service.
 *
 * For dynamic loading.
 *
 * @property combine
 * @type boolean
 * @default true if 'base' is not supplied, false if it is.
 */</span>

<span class="hljs-comment">/**
 * A list of modules that should never be dynamically loaded
 *
 * @property ignore
 * @type string[]
 */</span>

<span class="hljs-comment">/**
 * A list of modules that should always be loaded when required, even if already
 * present on the page.
 *
 * @property force
 * @type string[]
 */</span>

<span class="hljs-comment">/**
 * Node or id for a node that should be used as the insertion point for new
 * nodes.  For dynamic loading.
 *
 * @property insertBefore
 * @type string
 */</span>

<span class="hljs-comment">/**
 * Object literal containing attributes to add to dynamically loaded script
 * nodes.
 * @property jsAttributes
 * @type string
 */</span>

<span class="hljs-comment">/**
 * Object literal containing attributes to add to dynamically loaded link
 * nodes.
 * @property cssAttributes
 * @type string
 */</span>

<span class="hljs-comment">/**
 * Number of milliseconds before a timeout occurs when dynamically
 * loading nodes. If not set, there is no timeout.
 * @property timeout
 * @type int
 */</span>

<span class="hljs-comment">/**
 * Callback for the 'CSSComplete' event.  When dynamically loading YUI
 * components with CSS, this property fires when the CSS is finished
 * loading but script loading is still ongoing.  This provides an
 * opportunity to enhance the presentation of a loading page a little
 * bit before the entire loading process is done.
 *
 * @property onCSS
 * @type function
 */</span>

<span class="hljs-comment">/**
 * A hash of module definitions to add to the list of YUI components.
 * These components can then be dynamically loaded side by side with
 * YUI via the `use()` method. This is a hash, the key is the module
 * name, and the value is an object literal specifying the metdata
 * for the module.  See `Loader.addModule` for the supported module
 * metadata fields.  Also see groups, which provides a way to
 * configure the base and combo spec for a set of modules.
 *
 *      modules: {
 *          mymod1: {
 *              requires: ['node'],
 *              fullpath: '/mymod1/mymod1.js'
 *          },
 *          mymod2: {
 *              requires: ['mymod1'],
 *              fullpath: '/mymod2/mymod2.js'
 *          },
 *          mymod3: '/js/mymod3.js',
 *          mycssmod: '/css/mycssmod.css'
 *      }
 *
 *
 * @property modules
 * @type object
 */</span>

<span class="hljs-comment">/**
 * Aliases are dynamic groups of modules that can be used as
 * shortcuts.
 *
 *      YUI({
 *          aliases: {
 *              davglass: [ 'node', 'yql', 'dd' ],
 *              mine: [ 'davglass', 'autocomplete']
 *          }
 *      }).use('mine', function(Y) {
 *          //Node, YQL, DD &amp;amp; AutoComplete available here..
 *      });
 *
 * @property aliases
 * @type object
 */</span>

<span class="hljs-comment">/**
 * A hash of module group definitions.  It for each group you
 * can specify a list of modules and the base path and
 * combo spec to use when dynamically loading the modules.
 *
 *      groups: {
 *          yui2: {
 *              // specify whether or not this group has a combo service
 *              combine: true,
 *
 *              // The comboSeperator to use with this group's combo handler
 *              comboSep: ';',
 *
 *              // The maxURLLength for this server
 *              maxURLLength: 500,
 *
 *              // the base path for non-combo paths
 *              base: 'http://yui.yahooapis.com/2.8.0r4/build/',
 *
 *              // the path to the combo service
 *              comboBase: 'http://yui.yahooapis.com/combo?',
 *
 *              // a fragment to prepend to the path attribute when
 *              // when building combo urls
 *              root: '2.8.0r4/build/',
 *
 *              // the module definitions
 *              modules:  {
 *                  yui2_yde: {
 *                      path: "yahoo-dom-event/yahoo-dom-event.js"
 *                  },
 *                  yui2_anim: {
 *                      path: "animation/animation.js",
 *                      requires: ['yui2_yde']
 *                  }
 *              }
 *          }
 *      }
 *
 * @property groups
 * @type object
 */</span>

<span class="hljs-comment">/**
 * The loader 'path' attribute to the loader itself.  This is combined
 * with the 'base' attribute to dynamically load the loader component
 * when boostrapping with the get utility alone.
 *
 * @property loaderPath
 * @type string
 * @default loader/loader-min.js
 */</span>

<span class="hljs-comment">/**
 * Specifies whether or not YUI().use(...) will attempt to load CSS
 * resources at all.  Any truthy value will cause CSS dependencies
 * to load when fetching script.  The special value 'force' will
 * cause CSS dependencies to be loaded even if no script is needed.
 *
 * @property fetchCSS
 * @type boolean|string
 * @default true
 */</span>

<span class="hljs-comment">/**
 * The default gallery version to build gallery module urls
 * @property gallery
 * @type string
 * @since 3.1.0
 */</span>

<span class="hljs-comment">/**
 * The default YUI 2 version to build yui2 module urls.  This is for
 * intrinsic YUI 2 support via the 2in3 project.  Also see the '2in3'
 * config for pulling different revisions of the wrapped YUI 2
 * modules.
 * @since 3.1.0
 * @property yui2
 * @type string
 * @default 2.9.0
 */</span>

<span class="hljs-comment">/**
 * The 2in3 project is a deployment of the various versions of YUI 2
 * deployed as first-class YUI 3 modules.  Eventually, the wrapper
 * for the modules will change (but the underlying YUI 2 code will
 * be the same), and you can select a particular version of
 * the wrapper modules via this config.
 * @since 3.1.0
 * @property 2in3
 * @type string
 * @default 4
 */</span>

<span class="hljs-comment">/**
 * Alternative console log function for use in environments without
 * a supported native console.  The function is executed in the
 * YUI instance context.
 * @since 3.1.0
 * @property logFn
 * @type Function
 */</span>

<span class="hljs-comment">/**
 * A callback to execute when Y.error is called.  It receives the
 * error message and an javascript error object if Y.error was
 * executed because a javascript error was caught.  The function
 * is executed in the YUI instance context. Returning `true` from this
 * function will stop the Error from being thrown.
 *
 * @since 3.2.0
 * @property errorFn
 * @type Function
 */</span>

<span class="hljs-comment">/**
 * A callback to execute when the loader fails to load one or
 * more resource.  This could be because of a script load
 * failure.  It can also fail if a javascript module fails
 * to register itself, but only when the 'requireRegistration'
 * is true.  If this function is defined, the use() callback will
 * only be called when the loader succeeds, otherwise it always
 * executes unless there was a javascript error when attaching
 * a module.
 *
 * @since 3.3.0
 * @property loadErrorFn
 * @type Function
 */</span>

<span class="hljs-comment">/**
 * When set to true, the YUI loader will expect that all modules
 * it is responsible for loading will be first-class YUI modules
 * that register themselves with the YUI global.  If this is
 * set to true, loader will fail if the module registration fails
 * to happen after the script is loaded.
 *
 * @since 3.3.0
 * @property requireRegistration
 * @type boolean
 * @default false
 */</span>

<span class="hljs-comment">/**
 * Cache serviced use() requests.
 * @since 3.3.0
 * @property cacheUse
 * @type boolean
 * @default true
 * @deprecated no longer used
 */</span>

<span class="hljs-comment">/**
 * Whether or not YUI should use native ES5 functionality when available for
 * features like `Y.Array.each()`, `Y.Object()`, etc. When `false`, YUI will
 * always use its own fallback implementations instead of relying on ES5
 * functionality, even when it's available.
 *
 * @property useNativeES5
 * @type Boolean
 * @default true
 * @since 3.5.0
 */</span>

<span class="hljs-comment">/**
 Delay the `use` callback until a specific event has passed (`load`, `domready`, `contentready` or `available`)
 @property delayUntil
 @type String|Object
 @since 3.6.0
 @example

 You can use `load` or `domready` strings by default:

 YUI({
 delayUntil: 'domready'
 }, function(Y) {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>This will not fire until ‘domeready’</p>

            </div>
            
            <div class="content"><div class='highlight'><pre> });

 Or you can delay until a node is available (<span class="hljs-keyword">with</span> <span class="hljs-string">`available`</span> or <span class="hljs-string">`contentready`</span>):

 YUI({
 <span class="hljs-attr">delayUntil</span>: {
 <span class="hljs-attr">event</span>: <span class="hljs-string">'available'</span>,
 <span class="hljs-attr">args</span>: <span class="hljs-string">'#foo'</span>
 }
 }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>This will not fire until ‘#foo’ is
available in the DOM</p>

            </div>
            
            <div class="content"><div class='highlight'><pre> });


 */
YUI.add('yui-base', function (Y, NAME) {

	/*
	 * YUI stub
	 * @module yui
	 * @submodule yui-base
	 */
	/**
	 * The YUI module contains the components required for building the YUI
	 * seed file.  This includes the script loading mechanism, a simple queue,
	 * and the core utilities for the library.
	 * @module yui
	 * @submodule yui-base
	 */

	/**
	 * Provides core language utilites and extensions used throughout YUI.
	 *
	 * @class Lang
	 * @static
	 */

	var L = Y.Lang || (Y.Lang = {}),

		STRING_PROTO = String.prototype,
		TOSTRING     = Object.prototype.toString,

		TYPES = {
			'undefined'        : 'undefined',
			'number'           : 'number',
			'boolean'          : 'boolean',
			'string'           : 'string',
			'[object Function]': 'function',
			'[object RegExp]'  : 'regexp',
			'[object Array]'   : 'array',
			'[object Date]'    : 'date',
			'[object Error]'   : 'error'
		},

		SUBREGEX        = /\{\s*([^|}]+?)\s*(?:\|([^}]*))?\s*\}/g,
		TRIMREGEX       = /^\s+|\s+$/g,
		NATIVE_FN_REGEX = /\{\s*\[(?:native code|function)\]\s*\}/i;</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>– Protected Methods ——————————————————–</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-comment">/**
	 Returns `true` if the given function appears to be implemented in native code,
	 `false` otherwise. Will always return `false` -- even in ES5-capable browsers --
	 if the `useNativeES5` YUI config option is set to `false`.

	 This isn't guaranteed to be 100% accurate and won't work for anything other than
	 functions, but it can be useful for determining whether a function like
	 `Array.prototype.forEach` is native or a JS shim provided by another library.

	 There's a great article by @kangax discussing certain flaws with this technique:
	 &lt;http://perfectionkills.com/detecting-built-in-host-methods/&gt;

	 While his points are valid, it's still possible to benefit from this function
	 as long as it's used carefully and sparingly, and in such a way that false
	 negatives have minimal consequences. It's used internally to avoid using
	 potentially broken non-native ES5 shims that have been added to the page by
	 other libraries.

	 @method _isNative
	 @param {Function} fn Function to test.
	 @return {Boolean} `true` if _fn_ appears to be native, `false` otherwise.
	 @static
	 @protected
	 @since 3.5.0
	 **/</span>
	L._isNative = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>{
		<span class="hljs-keyword">return</span> !!(Y.config.useNativeES5 &amp;&amp; fn &amp;&amp; NATIVE_FN_REGEX.test(fn));
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>– Public Methods ———————————————————–</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-comment">/**
	 * Determines whether or not the provided item is an array.
	 *
	 * Returns `false` for array-like collections such as the function `arguments`
	 * collection or `HTMLElement` collections. Use `Y.Array.test()` if you want to
	 * test for an array-like collection.
	 *
	 * @method isArray
	 * @param o The object to test.
	 * @return {boolean} true if o is an array.
	 * @static
	 */</span>
	L.isArray = L._isNative(<span class="hljs-built_in">Array</span>.isArray) ? <span class="hljs-built_in">Array</span>.isArray : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">return</span> L.type(o) === <span class="hljs-string">'array'</span>;
	};

	<span class="hljs-comment">/**
	 * Determines whether or not the provided item is a boolean.
	 * @method isBoolean
	 * @static
	 * @param o The object to test.
	 * @return {boolean} true if o is a boolean.
	 */</span>
	L.isBoolean = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">'boolean'</span>;
	};

	<span class="hljs-comment">/**
	 * Determines whether or not the supplied item is a date instance.
	 * @method isDate
	 * @static
	 * @param o The object to test.
	 * @return {boolean} true if o is a date.
	 */</span>
	L.isDate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">return</span> L.type(o) === <span class="hljs-string">'date'</span> &amp;&amp; o.toString() !== <span class="hljs-string">'Invalid Date'</span> &amp;&amp; !<span class="hljs-built_in">isNaN</span>(o);
	};

	<span class="hljs-comment">/**
	 * &lt;p&gt;
	 * Determines whether or not the provided item is a function.
	 * Note: Internet Explorer thinks certain functions are objects:
	 * &lt;/p&gt;
	 *
	 * &lt;pre&gt;
	 * var obj = document.createElement("object");
	 * Y.Lang.isFunction(obj.getAttribute) // reports false in IE
	 * &amp;nbsp;
	 * var input = document.createElement("input"); // append to body
	 * Y.Lang.isFunction(input.focus) // reports false in IE
	 * &lt;/pre&gt;
	 *
	 * &lt;p&gt;
	 * You will have to implement additional tests if these functions
	 * matter to you.
	 * &lt;/p&gt;
	 *
	 * @method isFunction
	 * @static
	 * @param o The object to test.
	 * @return {boolean} true if o is a function.
	 */</span>
	L.isFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">return</span> L.type(o) === <span class="hljs-string">'function'</span>;
	};

	<span class="hljs-comment">/**
	 * Determines whether or not the provided item is null.
	 * @method isNull
	 * @static
	 * @param o The object to test.
	 * @return {boolean} true if o is null.
	 */</span>
	L.isNull = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">return</span> o === <span class="hljs-literal">null</span>;
	};

	<span class="hljs-comment">/**
	 * Determines whether or not the provided item is a legal number.
	 * @method isNumber
	 * @static
	 * @param o The object to test.
	 * @return {boolean} true if o is a number.
	 */</span>
	L.isNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-built_in">isFinite</span>(o);
	};

	<span class="hljs-comment">/**
	 * Determines whether or not the provided item is of type object
	 * or function. Note that arrays are also objects, so
	 * &lt;code&gt;Y.Lang.isObject([]) === true&lt;/code&gt;.
	 * @method isObject
	 * @static
	 * @param o The object to test.
	 * @param failfn {boolean} fail if the input is a function.
	 * @return {boolean} true if o is an object.
	 * @see isPlainObject
	 */</span>
	L.isObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o, failfn</span>) </span>{
		<span class="hljs-keyword">var</span> t = <span class="hljs-keyword">typeof</span> o;
		<span class="hljs-keyword">return</span> (o &amp;&amp; (t === <span class="hljs-string">'object'</span> ||
			(!failfn &amp;&amp; (t === <span class="hljs-string">'function'</span> || L.isFunction(o))))) || <span class="hljs-literal">false</span>;
	};

	<span class="hljs-comment">/**
	 * Determines whether or not the provided item is a string.
	 * @method isString
	 * @static
	 * @param o The object to test.
	 * @return {boolean} true if o is a string.
	 */</span>
	L.isString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">'string'</span>;
	};

	<span class="hljs-comment">/**
	 * Determines whether or not the provided item is undefined.
	 * @method isUndefined
	 * @static
	 * @param o The object to test.
	 * @return {boolean} true if o is undefined.
	 */</span>
	L.isUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">'undefined'</span>;
	};

	<span class="hljs-comment">/**
	 * A convenience method for detecting a legitimate non-null value.
	 * Returns false for null/undefined/NaN, true for other values,
	 * including 0/false/''
	 * @method isValue
	 * @static
	 * @param o The item to test.
	 * @return {boolean} true if it is not null/undefined/NaN || false.
	 */</span>
	L.isValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">var</span> t = L.type(o);

		<span class="hljs-keyword">switch</span> (t) {
			<span class="hljs-keyword">case</span> <span class="hljs-string">'number'</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-built_in">isFinite</span>(o);

			<span class="hljs-keyword">case</span> <span class="hljs-string">'null'</span>: <span class="hljs-comment">// fallthru</span>
			<span class="hljs-keyword">case</span> <span class="hljs-string">'undefined'</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

			<span class="hljs-keyword">default</span>:
				<span class="hljs-keyword">return</span> !!t;
		}
	};

	<span class="hljs-comment">/**
	 * Returns the current time in milliseconds.
	 *
	 * @method now
	 * @return {Number} Current time in milliseconds.
	 * @static
	 * @since 3.3.0
	 */</span>
	L.now = <span class="hljs-built_in">Date</span>.now || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
	};

	<span class="hljs-comment">/**
	 * Lightweight version of &lt;code&gt;Y.substitute&lt;/code&gt;. Uses the same template
	 * structure as &lt;code&gt;Y.substitute&lt;/code&gt;, but doesn't support recursion,
	 * auto-object coersion, or formats.
	 * @method sub
	 * @param {string} s String to be modified.
	 * @param {object} o Object containing replacement values.
	 * @return {string} the substitute result.
	 * @static
	 * @since 3.2.0
	 */</span>
	L.sub = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, o</span>) </span>{
		<span class="hljs-keyword">return</span> s.replace ? s.replace(SUBREGEX, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, key</span>) </span>{
			<span class="hljs-keyword">return</span> L.isUndefined(o[key]) ? match : o[key];
		}) : s;
	};

	<span class="hljs-comment">/**
	 * Returns a string without any leading or trailing whitespace.  If
	 * the input is not a string, the input will be returned untouched.
	 * @method trim
	 * @static
	 * @param s {string} the string to trim.
	 * @return {string} the trimmed string.
	 */</span>
	L.trim = STRING_PROTO.trim ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
		<span class="hljs-keyword">return</span> s &amp;&amp; s.trim ? s.trim() : s;
	} : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">return</span> s.replace(TRIMREGEX, <span class="hljs-string">''</span>);
		} <span class="hljs-keyword">catch</span> (e) {
			<span class="hljs-keyword">return</span> s;
		}
	};

	<span class="hljs-comment">/**
	 * Returns a string without any leading whitespace.
	 * @method trimLeft
	 * @static
	 * @param s {string} the string to trim.
	 * @return {string} the trimmed string.
	 */</span>
	L.trimLeft = STRING_PROTO.trimLeft ? <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
		<span class="hljs-keyword">return</span> s.trimLeft();
	} : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
		<span class="hljs-keyword">return</span> s.replace(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">''</span>);
	};

	<span class="hljs-comment">/**
	 * Returns a string without any trailing whitespace.
	 * @method trimRight
	 * @static
	 * @param s {string} the string to trim.
	 * @return {string} the trimmed string.
	 */</span>
	L.trimRight = STRING_PROTO.trimRight ? <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
		<span class="hljs-keyword">return</span> s.trimRight();
	} : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
		<span class="hljs-keyword">return</span> s.replace(<span class="hljs-regexp">/\s+$/</span>, <span class="hljs-string">''</span>);
	};

	<span class="hljs-comment">/**
	 Returns one of the following strings, representing the type of the item passed
	 in:

	 * "array"
	 * "boolean"
	 * "date"
	 * "error"
	 * "function"
	 * "null"
	 * "number"
	 * "object"
	 * "regexp"
	 * "string"
	 * "undefined"

	 Known issues:

	 * `typeof HTMLElementCollection` returns function in Safari, but
	 `Y.Lang.type()` reports "object", which could be a good thing --
	 but it actually caused the logic in &lt;code&gt;Y.Lang.isObject&lt;/code&gt; to fail.

	 @method type
	 @param o the item to test.
	 @return {string} the detected type.
	 @static
	 **/</span>
	L.type = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">return</span> TYPES[<span class="hljs-keyword">typeof</span> o] || TYPES[TOSTRING.call(o)] || (o ? <span class="hljs-string">'object'</span> : <span class="hljs-string">'null'</span>);
	};
	<span class="hljs-comment">/**
	 @module yui
	 @submodule yui-base
	 */</span>

	<span class="hljs-keyword">var</span> Lang   = Y.Lang,
		Native = <span class="hljs-built_in">Array</span>.prototype,

		hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;

	<span class="hljs-comment">/**
	 Provides utility methods for working with arrays. Additional array helpers can
	 be found in the `collection` and `array-extras` modules.

	 `Y.Array(thing)` returns a native array created from _thing_. Depending on
	 _thing_'s type, one of the following will happen:

	 * Arrays are returned unmodified unless a non-zero _startIndex_ is
	 specified.
	 * Array-like collections (see `Array.test()`) are converted to arrays.
	 * For everything else, a new array is created with _thing_ as the sole
	 item.

	 Note: elements that are also collections, such as `&lt;form&gt;` and `&lt;select&gt;`
	 elements, are not automatically converted to arrays. To force a conversion,
	 pass `true` as the value of the _force_ parameter.

	 @class Array
	 @constructor
	 @param {Any} thing The thing to arrayify.
	 @param {Number} [startIndex=0] If non-zero and _thing_ is an array or array-like
	 collection, a subset of items starting at the specified index will be
	 returned.
	 @param {Boolean} [force=false] If `true`, _thing_ will be treated as an
	 array-like collection no matter what.
	 @return {Array} A native array created from _thing_, according to the rules
	 described above.
	 **/</span>
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">YArray</span>(<span class="hljs-params">thing, startIndex, force</span>) </span>{
		<span class="hljs-keyword">var</span> len, result;

		startIndex || (startIndex = <span class="hljs-number">0</span>);

		<span class="hljs-keyword">if</span> (force || YArray.test(thing)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>IE throws when trying to slice HTMLElement collections.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">try</span> {
				<span class="hljs-keyword">return</span> Native.slice.call(thing, startIndex);
			} <span class="hljs-keyword">catch</span> (ex) {
				result = [];

				<span class="hljs-keyword">for</span> (len = thing.length; startIndex &lt; len; ++startIndex) {
					result.push(thing[startIndex]);
				}

				<span class="hljs-keyword">return</span> result;
			}
		}

		<span class="hljs-keyword">return</span> [thing];
	}

	Y.Array = YArray;

	<span class="hljs-comment">/**
	 Dedupes an array of strings, returning an array that's guaranteed to contain
	 only one copy of a given string.

	 This method differs from `Array.unique()` in that it's optimized for use only
	 with strings, whereas `unique` may be used with other types (but is slower).
	 Using `dedupe()` with non-string values may result in unexpected behavior.

	 @method dedupe
	 @param {String[]} array Array of strings to dedupe.
	 @return {Array} Deduped copy of _array_.
	 @static
	 @since 3.4.0
	 **/</span>
	YArray.dedupe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">array</span>) </span>{
		<span class="hljs-keyword">var</span> hash    = {},
			results = [],
			i, item, len;

		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = array.length; i &lt; len; ++i) {
			item = array[i];

			<span class="hljs-keyword">if</span> (!hasOwn.call(hash, item)) {
				hash[item] = <span class="hljs-number">1</span>;
				results.push(item);
			}
		}

		<span class="hljs-keyword">return</span> results;
	};

	<span class="hljs-comment">/**
	 Executes the supplied function on each item in the array. This method wraps
	 the native ES5 `Array.forEach()` method if available.

	 @method each
	 @param {Array} array Array to iterate.
	 @param {Function} fn Function to execute on each item in the array. The function
	 will receive the following arguments:
	 @param {Any} fn.item Current array item.
	 @param {Number} fn.index Current array index.
	 @param {Array} fn.array Array being iterated.
	 @param {Object} [thisObj] `this` object to use when calling _fn_.
	 @return {YUI} The YUI instance.
	 @static
	 **/</span>
	YArray.each = YArray.forEach = Lang._isNative(Native.forEach) ? <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">array, fn, thisObj</span>) </span>{
		Native.forEach.call(array || [], fn, thisObj || Y);
		<span class="hljs-keyword">return</span> Y;
	} : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">array, fn, thisObj</span>) </span>{
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = (array &amp;&amp; array.length) || <span class="hljs-number">0</span>; i &lt; len; ++i) {
			<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> array) {
				fn.call(thisObj || Y, array[i], i, array);
			}
		}

		<span class="hljs-keyword">return</span> Y;
	};

	<span class="hljs-comment">/**
	 Alias for `each()`.

	 @method forEach
	 @static
	 **/</span>

	<span class="hljs-comment">/**
	 Returns an object using the first array as keys and the second as values. If
	 the second array is not provided, or if it doesn't contain the same number of
	 values as the first array, then `true` will be used in place of the missing
	 values.

	 @example

	 Y.Array.hash(['a', 'b', 'c'], ['foo', 'bar']);
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>=&gt; {a: ‘foo’, b: ‘bar’, c: true}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	 @method hash
	 @param {String[]} keys Array of strings to use as keys.
	 @param {Array} [values] Array to use as values.
	 @return {Object} Hash using the first array as keys and the second as values.
	 @static
	 **/
	YArray.hash = function (keys, values) {
		var hash = {},
			vlen = (values &amp;&amp; values.length) || 0,
			i, len;

		for (i = 0, len = keys.length; i &lt; len; ++i) {
			if (i in keys) {
				hash[keys[i]] = vlen &gt; i &amp;&amp; i in values ? values[i] : true;
			}
		}

		return hash;
	};

	/**
	 Returns the index of the first item in the array that's equal (using a strict
	 equality check) to the specified _value_, or `-1` if the value isn't found.

	 This method wraps the native ES5 `Array.indexOf()` method if available.

	 @method indexOf
	 @param {Array} array Array to search.
	 @param {Any} value Value to search for.
	 @param {Number} [from=0] The index at which to begin the search.
	 @return {Number} Index of the item strictly equal to _value_, or `-1` if not
	 found.
	 @static
	 **/
	YArray.indexOf = Lang._isNative(Native.indexOf) ? function (array, value, from) {
		return Native.indexOf.call(array, value, from);
	} : function (array, value, from) {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p><a href="http://es5.github.com/#x15.4.4.14">http://es5.github.com/#x15.4.4.14</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> len = array.length;

		<span class="hljs-keyword">from</span> = +<span class="hljs-keyword">from</span> || <span class="hljs-number">0</span>;
		<span class="hljs-keyword">from</span> = (<span class="hljs-keyword">from</span> &gt; <span class="hljs-number">0</span> || <span class="hljs-number">-1</span>) * <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.abs(<span class="hljs-keyword">from</span>));

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> &lt; <span class="hljs-number">0</span>) {
			<span class="hljs-keyword">from</span> += len;

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> &lt; <span class="hljs-number">0</span>) {
				<span class="hljs-keyword">from</span> = <span class="hljs-number">0</span>;
			}
		}

		<span class="hljs-keyword">for</span> (; <span class="hljs-keyword">from</span> &lt; len; ++<span class="hljs-keyword">from</span>) {
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> <span class="hljs-keyword">in</span> array &amp;&amp; array[<span class="hljs-keyword">from</span>] === value) {
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">from</span>;
			}
		}

		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	};

	<span class="hljs-comment">/**
	 Numeric sort convenience function.

	 The native `Array.prototype.sort()` function converts values to strings and
	 sorts them in lexicographic order, which is unsuitable for sorting numeric
	 values. Provide `Array.numericSort` as a custom sort function when you want
	 to sort values in numeric order.

	 @example

	 [42, 23, 8, 16, 4, 15].sort(Y.Array.numericSort);
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>=&gt; [4, 8, 15, 16, 23, 42]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	 @method numericSort
	 @param {Number} a First value to compare.
	 @param {Number} b Second value to compare.
	 @return {Number} Difference between _a_ and _b_.
	 @static
	 **/
	YArray.numericSort = function (a, b) {
		return a - b;
	};

	/**
	 Executes the supplied function on each item in the array. Returning a truthy
	 value from the function will stop the processing of remaining items.

	 @method some
	 @param {Array} array Array to iterate over.
	 @param {Function} fn Function to execute on each item. The function will receive
	 the following arguments:
	 @param {Any} fn.value Current array item.
	 @param {Number} fn.index Current array index.
	 @param {Array} fn.array Array being iterated over.
	 @param {Object} [thisObj] `this` object to use when calling _fn_.
	 @return {Boolean} `true` if the function returns a truthy value on any of the
	 items in the array; `false` otherwise.
	 @static
	 **/
	YArray.some = Lang._isNative(Native.some) ? function (array, fn, thisObj) {
		return Native.some.call(array, fn, thisObj);
	} : function (array, fn, thisObj) {
		for (var i = 0, len = array.length; i &lt; len; ++i) {
			if (i in array &amp;&amp; fn.call(thisObj, array[i], i, array)) {
				return true;
			}
		}

		return false;
	};

	/**
	 Evaluates _obj_ to determine if it's an array, an array-like collection, or
	 something else. This is useful when working with the function `arguments`
	 collection and `HTMLElement` collections.

	 Note: This implementation doesn't consider elements that are also
	 collections, such as `&lt;form&gt;` and `&lt;select&gt;`, to be array-like.

	 @method test
	 @param {Object} obj Object to test.
	 @return {Number} A number indicating the results of the test:

	 * 0: Neither an array nor an array-like collection.
	 * 1: Real array.
	 * 2: Array-like collection.

	 @static
	 **/
	YArray.test = function (obj) {
		var result = 0;

		if (Lang.isArray(obj)) {
			result = 1;
		} else if (Lang.isObject(obj)) {
			try {</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>indexed, but no tagName (element) or scrollTo/document (window. From DOM.isWindow test which we can’t use here),
or functions without apply/call (Safari
HTMLElementCollection bug).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (<span class="hljs-string">'length'</span> <span class="hljs-keyword">in</span> obj &amp;&amp; !obj.tagName &amp;&amp; !(obj.scrollTo &amp;&amp; obj.document) &amp;&amp; !obj.apply) {
					result = <span class="hljs-number">2</span>;
				}
			} <span class="hljs-keyword">catch</span> (ex) {}
		}

		<span class="hljs-keyword">return</span> result;
	};
	<span class="hljs-comment">/**
	 * The YUI module contains the components required for building the YUI
	 * seed file.  This includes the script loading mechanism, a simple queue,
	 * and the core utilities for the library.
	 * @module yui
	 * @submodule yui-base
	 */</span>

	<span class="hljs-comment">/**
	 * A simple FIFO queue.  Items are added to the Queue with add(1..n items) and
	 * removed using next().
	 *
	 * @class Queue
	 * @constructor
	 * @param {MIXED} item* 0..n items to seed the queue.
	 */</span>
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">this</span>._init();
		<span class="hljs-keyword">this</span>.add.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
	}

	Queue.prototype = {
		<span class="hljs-comment">/**
		 * Initialize the queue
		 *
		 * @method _init
		 * @protected
		 */</span>
		_init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-comment">/**
			 * The collection of enqueued items
			 *
			 * @property _q
			 * @type Array
			 * @protected
			 */</span>
			<span class="hljs-keyword">this</span>._q = [];
		},

		<span class="hljs-comment">/**
		 * Get the next item in the queue. FIFO support
		 *
		 * @method next
		 * @return {MIXED} the next item in the queue.
		 */</span>
		next: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._q.shift();
		},

		<span class="hljs-comment">/**
		 * Get the last in the queue. LIFO support.
		 *
		 * @method last
		 * @return {MIXED} the last item in the queue.
		 */</span>
		last: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._q.pop();
		},

		<span class="hljs-comment">/**
		 * Add 0..n items to the end of the queue.
		 *
		 * @method add
		 * @param {MIXED} item* 0..n items.
		 * @return {object} this queue.
		 */</span>
		add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">this</span>._q.push.apply(<span class="hljs-keyword">this</span>._q, <span class="hljs-built_in">arguments</span>);

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Returns the current number of queued items.
		 *
		 * @method size
		 * @return {Number} The size.
		 */</span>
		size: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._q.length;
		}
	};

	Y.Queue = Queue;

	YUI.Env._loaderQueue = YUI.Env._loaderQueue || <span class="hljs-keyword">new</span> Queue();

	<span class="hljs-comment">/**
	 The YUI module contains the components required for building the YUI seed file.
	 This includes the script loading mechanism, a simple queue, and the core
	 utilities for the library.

	 @module yui
	 @submodule yui-base
	 **/</span>

	<span class="hljs-keyword">var</span> CACHED_DELIMITER = <span class="hljs-string">'__'</span>,

		hasOwn   = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty,
		isObject = Y.Lang.isObject;

	<span class="hljs-comment">/**
	 Returns a wrapper for a function which caches the return value of that function,
	 keyed off of the combined string representation of the argument values provided
	 when the wrapper is called.

	 Calling this function again with the same arguments will return the cached value
	 rather than executing the wrapped function.

	 Note that since the cache is keyed off of the string representation of arguments
	 passed to the wrapper function, arguments that aren't strings and don't provide
	 a meaningful `toString()` method may result in unexpected caching behavior. For
	 example, the objects `{}` and `{foo: 'bar'}` would both be converted to the
	 string `[object Object]` when used as a cache key.

	 @method cached
	 @param {Function} source The function to memoize.
	 @param {Object} [cache={}] Object in which to store cached values. You may seed
	 this object with pre-existing cached values if desired.
	 @param {any} [refetch] If supplied, this value is compared with the cached value
	 using a `==` comparison. If the values are equal, the wrapped function is
	 executed again even though a cached value exists.
	 @return {Function} Wrapped function.
	 @for YUI
	 **/</span>
	Y.cached = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source, cache, refetch</span>) </span>{
		cache || (cache = {});

		<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
			<span class="hljs-keyword">var</span> key = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span> ?
				<span class="hljs-built_in">Array</span>.prototype.join.call(<span class="hljs-built_in">arguments</span>, CACHED_DELIMITER) :
				<span class="hljs-built_in">String</span>(arg);

			<span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> cache) || (refetch &amp;&amp; cache[key] == refetch)) {
				cache[key] = source.apply(source, <span class="hljs-built_in">arguments</span>);
			}

			<span class="hljs-keyword">return</span> cache[key];
		};
	};

	<span class="hljs-comment">/**
	 Returns the `location` object from the window/frame in which this YUI instance
	 operates, or `undefined` when executing in a non-browser environment
	 (e.g. Node.js).

	 It is _not_ recommended to hold references to the `window.location` object
	 outside of the scope of a function in which its properties are being accessed or
	 its methods are being called. This is because of a nasty bug/issue that exists
	 in both Safari and MobileSafari browsers:
	 [WebKit Bug 34679](https://bugs.webkit.org/show_bug.cgi?id=34679).

	 @method getLocation
	 @return {location} The `location` object from the window/frame in which this YUI
	 instance operates.
	 @since 3.5.0
	 **/</span>
	Y.getLocation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>It is safer to look this up every time because yui-base is attached to a
YUI instance before a user’s config is applied; i.e. <code>Y.config.win</code> does
not point the correct window object when this file is loaded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> win = Y.config.win;</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>It is not safe to hold a reference to the <code>location</code> object outside the
scope in which it is being used. The WebKit engine used in Safari and
MobileSafari will “disconnect” the <code>location</code> object from the <code>window</code>
when a page is restored from back/forward history cache.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span> win &amp;&amp; win.location;
	};

	<span class="hljs-comment">/**
	 Returns a new object containing all of the properties of all the supplied
	 objects. The properties from later objects will overwrite those in earlier
	 objects.

	 Passing in a single object will create a shallow copy of it. For a deep copy,
	 use `clone()`.

	 @method merge
	 @param {Object} objects* One or more objects to merge.
	 @return {Object} A new merged object.
	 **/</span>
	Y.merge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">var</span> i      = <span class="hljs-number">0</span>,
			len    = <span class="hljs-built_in">arguments</span>.length,
			result = {},
			key,
			obj;

		<span class="hljs-keyword">for</span> (; i &lt; len; ++i) {
			obj = <span class="hljs-built_in">arguments</span>[i];

			<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) {
				<span class="hljs-keyword">if</span> (hasOwn.call(obj, key)) {
					result[key] = obj[key];
				}
			}
		}

		<span class="hljs-keyword">return</span> result;
	};

	<span class="hljs-comment">/**
	 Mixes _supplier_'s properties into _receiver_.

	 Properties on _receiver_ or _receiver_'s prototype will not be overwritten or
	 shadowed unless the _overwrite_ parameter is `true`, and will not be merged
	 unless the _merge_ parameter is `true`.

	 In the default mode (0), only properties the supplier owns are copied (prototype
	 properties are not copied). The following copying modes are available:

	 * `0`: _Default_. Object to object.
	 * `1`: Prototype to prototype.
	 * `2`: Prototype to prototype and object to object.
	 * `3`: Prototype to object.
	 * `4`: Object to prototype.

	 @method mix
	 @param {Function|Object} receiver The object or function to receive the mixed
	 properties.
	 @param {Function|Object} supplier The object or function supplying the
	 properties to be mixed.
	 @param {Boolean} [overwrite=false] If `true`, properties that already exist
	 on the receiver will be overwritten with properties from the supplier.
	 @param {String[]} [whitelist] An array of property names to copy. If
	 specified, only the whitelisted properties will be copied, and all others
	 will be ignored.
	 @param {Number} [mode=0] Mix mode to use. See above for available modes.
	 @param {Boolean} [merge=false] If `true`, objects and arrays that already
	 exist on the receiver will have the corresponding object/array from the
	 supplier merged into them, rather than being skipped or overwritten. When
	 both _overwrite_ and _merge_ are `true`, _merge_ takes precedence.
	 @return {Function|Object|YUI} The receiver, or the YUI instance if the
	 specified receiver is falsy.
	 **/</span>
	Y.mix = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">receiver, supplier, overwrite, whitelist, mode, merge</span>) </span>{
		<span class="hljs-keyword">var</span> alwaysOverwrite, exists, <span class="hljs-keyword">from</span>, i, key, len, to;</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>If no supplier is given, we return the receiver. If no receiver is given,
we return Y. Returning Y doesn’t make much sense to me, but it’s
grandfathered in for backcompat reasons.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!receiver || !supplier) {
			<span class="hljs-keyword">return</span> receiver || Y;
		}

		<span class="hljs-keyword">if</span> (mode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>In mode 2 (prototype to prototype and object to object), we recurse
once to do the proto to proto mix. The object to object mix will be
handled later on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (mode === <span class="hljs-number">2</span>) {
				Y.mix(receiver.prototype, supplier.prototype, overwrite,
					whitelist, <span class="hljs-number">0</span>, merge);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Depending on which mode is specified, we may be copying from or to
the prototypes of the supplier and receiver.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">from</span> = mode === <span class="hljs-number">1</span> || mode === <span class="hljs-number">3</span> ? supplier.prototype : supplier;
			to   = mode === <span class="hljs-number">1</span> || mode === <span class="hljs-number">4</span> ? receiver.prototype : receiver;</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>If either the supplier or receiver doesn’t actually have a
prototype property, then we could end up with an undefined <code>from</code>
or <code>to</code>. If that happens, we abort and return the receiver.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">from</span> || !to) {
				<span class="hljs-keyword">return</span> receiver;
			}
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">from</span> = supplier;
			to   = receiver;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>If <code>overwrite</code> is truthy and <code>merge</code> is falsy, then we can skip a
property existence check on each iteration and save some time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		alwaysOverwrite = overwrite &amp;&amp; !merge;

		<span class="hljs-keyword">if</span> (whitelist) {
			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = whitelist.length; i &lt; len; ++i) {
				key = whitelist[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>We call <code>Object.prototype.hasOwnProperty</code> instead of calling
<code>hasOwnProperty</code> on the object itself, since the object’s
<code>hasOwnProperty</code> method may have been overridden or removed.
Also, some native objects don’t implement a <code>hasOwnProperty</code>
method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!hasOwn.call(<span class="hljs-keyword">from</span>, key)) {
					<span class="hljs-keyword">continue</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>The <code>key in to</code> check here is (sadly) intentional for backwards
compatibility reasons. It prevents undesired shadowing of
prototype members on <code>to</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				exists = alwaysOverwrite ? <span class="hljs-literal">false</span> : key <span class="hljs-keyword">in</span> to;

				<span class="hljs-keyword">if</span> (merge &amp;&amp; exists &amp;&amp; isObject(to[key], <span class="hljs-literal">true</span>)
					&amp;&amp; isObject(<span class="hljs-keyword">from</span>[key], <span class="hljs-literal">true</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>If we’re in merge mode, and the key is present on both
objects, and the value on both objects is either an object or
an array (but not a function), then we recurse to merge the
<code>from</code> value into the <code>to</code> value instead of overwriting it.</p>
<p>Note: It’s intentional that the whitelist isn’t passed to the
recursive call here. This is legacy behavior that lots of
code still depends on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					Y.mix(to[key], <span class="hljs-keyword">from</span>[key], overwrite, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, merge);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (overwrite || !exists) {</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>We’re not in merge mode, so we’ll only copy the <code>from</code> value
to the <code>to</code> value if we’re in overwrite mode or if the
current key doesn’t exist on the <code>to</code> object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					to[key] = <span class="hljs-keyword">from</span>[key];
				}
			}
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> <span class="hljs-keyword">from</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>The code duplication here is for runtime performance reasons.
Combining whitelist and non-whitelist operations into a single
loop or breaking the shared logic out into a function both result
in worse performance, and Y.mix is critical enough that the byte
tradeoff is worth it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!hasOwn.call(<span class="hljs-keyword">from</span>, key)) {
					<span class="hljs-keyword">continue</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>The <code>key in to</code> check here is (sadly) intentional for backwards
compatibility reasons. It prevents undesired shadowing of
prototype members on <code>to</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				exists = alwaysOverwrite ? <span class="hljs-literal">false</span> : key <span class="hljs-keyword">in</span> to;

				<span class="hljs-keyword">if</span> (merge &amp;&amp; exists &amp;&amp; isObject(to[key], <span class="hljs-literal">true</span>)
					&amp;&amp; isObject(<span class="hljs-keyword">from</span>[key], <span class="hljs-literal">true</span>)) {
					Y.mix(to[key], <span class="hljs-keyword">from</span>[key], overwrite, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, merge);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (overwrite || !exists) {
					to[key] = <span class="hljs-keyword">from</span>[key];
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>If this is an IE browser with the JScript enumeration bug, force
enumeration of the buggy properties by making a recursive call with
the buggy properties as the whitelist.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (Y.Object._hasEnumBug) {
				Y.mix(to, <span class="hljs-keyword">from</span>, overwrite, Y.Object._forceEnum, mode, merge);
			}
		}

		<span class="hljs-keyword">return</span> receiver;
	};
	<span class="hljs-comment">/**
	 * The YUI module contains the components required for building the YUI
	 * seed file.  This includes the script loading mechanism, a simple queue,
	 * and the core utilities for the library.
	 * @module yui
	 * @submodule yui-base
	 */</span>

	<span class="hljs-comment">/**
	 * Adds utilities to the YUI instance for working with objects.
	 *
	 * @class Object
	 */</span>

	<span class="hljs-keyword">var</span> Lang   = Y.Lang,
		hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty,

		UNDEFINED, <span class="hljs-comment">// &lt;-- Note the comma. We're still declaring vars.</span>

		<span class="hljs-comment">/**
		 * Returns a new object that uses _obj_ as its prototype. This method wraps the
		 * native ES5 `Object.create()` method if available, but doesn't currently
		 * pass through `Object.create()`'s second argument (properties) in order to
		 * ensure compatibility with older browsers.
		 *
		 * @method ()
		 * @param {Object} obj Prototype object.
		 * @return {Object} New object using _obj_ as its prototype.
		 * @static
		 */</span>
			O = Y.Object = Lang._isNative(<span class="hljs-built_in">Object</span>.create) ? <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>We currently wrap the native Object.create instead of simply aliasing it
to ensure consistency with our fallback shim, which currently doesn’t
support Object.create()’s second argument (properties). Once we have a
safe fallback for the properties arg, we can stop wrapping
Object.create().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(obj);
		} : (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Reusable constructor function for the Object.create() shim.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>The actual shim.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
				F.prototype = obj;
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();
			};
		}()),

		<span class="hljs-comment">/**
		 * Property names that IE doesn't enumerate in for..in loops, even when they
		 * should be enumerable. When `_hasEnumBug` is `true`, it's necessary to
		 * manually enumerate these properties.
		 *
		 * @property _forceEnum
		 * @type String[]
		 * @protected
		 * @static
		 */</span>
			forceEnum = O._forceEnum = [
			<span class="hljs-string">'hasOwnProperty'</span>,
			<span class="hljs-string">'isPrototypeOf'</span>,
			<span class="hljs-string">'propertyIsEnumerable'</span>,
			<span class="hljs-string">'toString'</span>,
			<span class="hljs-string">'toLocaleString'</span>,
			<span class="hljs-string">'valueOf'</span>
		],

		<span class="hljs-comment">/**
		 * `true` if this browser has the JScript enumeration bug that prevents
		 * enumeration of the properties named in the `_forceEnum` array, `false`
		 * otherwise.
		 *
		 * See:
		 *   - &lt;https://developer.mozilla.org/en/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug&gt;
		 *   - &lt;http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation&gt;
		 *
		 * @property _hasEnumBug
		 * @type Boolean
		 * @protected
		 * @static
		 */</span>
			hasEnumBug = O._hasEnumBug = !{<span class="hljs-attr">valueOf</span>: <span class="hljs-number">0</span>}.propertyIsEnumerable(<span class="hljs-string">'valueOf'</span>),

		<span class="hljs-comment">/**
		 * `true` if this browser incorrectly considers the `prototype` property of
		 * functions to be enumerable. Currently known to affect Opera 11.50.
		 *
		 * @property _hasProtoEnumBug
		 * @type Boolean
		 * @protected
		 * @static
		 */</span>
			hasProtoEnumBug = O._hasProtoEnumBug = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}).propertyIsEnumerable(<span class="hljs-string">'prototype'</span>),

		<span class="hljs-comment">/**
		 * Returns `true` if _key_ exists on _obj_, `false` if _key_ doesn't exist or
		 * exists only on _obj_'s prototype. This is essentially a safer version of
		 * `obj.hasOwnProperty()`.
		 *
		 * @method owns
		 * @param {Object} obj Object to test.
		 * @param {String} key Property name to look for.
		 * @return {Boolean} `true` if _key_ exists on _obj_, `false` otherwise.
		 * @static
		 */</span>
			owns = O.owns = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, key</span>) </span>{
			<span class="hljs-keyword">return</span> !!obj &amp;&amp; hasOwn.call(obj, key);
		}; <span class="hljs-comment">// &lt;-- End of var declarations.</span>

	<span class="hljs-comment">/**
	 * Alias for `owns()`.
	 *
	 * @method hasKey
	 * @param {Object} obj Object to test.
	 * @param {String} key Property name to look for.
	 * @return {Boolean} `true` if _key_ exists on _obj_, `false` otherwise.
	 * @static
	 */</span>
	O.hasKey = owns;

	<span class="hljs-comment">/**
	 * Returns an array containing the object's enumerable keys. Does not include
	 * prototype keys or non-enumerable keys.
	 *
	 * Note that keys are returned in enumeration order (that is, in the same order
	 * that they would be enumerated by a `for-in` loop), which may not be the same
	 * as the order in which they were defined.
	 *
	 * This method is an alias for the native ES5 `Object.keys()` method if
	 * available.
	 *
	 * @example
	 *
	 *     Y.Object.keys({a: 'foo', b: 'bar', c: 'baz'});
	 *     // =&gt; ['a', 'b', 'c']
	 *
	 * @method keys
	 * @param {Object} obj An object.
	 * @return {String[]} Array of keys.
	 * @static
	 */</span>
	O.keys = Lang._isNative(<span class="hljs-built_in">Object</span>.keys) ? <span class="hljs-built_in">Object</span>.keys : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
		<span class="hljs-keyword">if</span> (!Lang.isObject(obj)) {
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Object.keys called on a non-object'</span>);
		}

		<span class="hljs-keyword">var</span> keys = [],
			i, key, len;

		<span class="hljs-keyword">if</span> (hasProtoEnumBug &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'function'</span>) {
			<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) {
				<span class="hljs-keyword">if</span> (owns(obj, key) &amp;&amp; key !== <span class="hljs-string">'prototype'</span>) {
					keys.push(key);
				}
			}
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) {
				<span class="hljs-keyword">if</span> (owns(obj, key)) {
					keys.push(key);
				}
			}
		}

		<span class="hljs-keyword">if</span> (hasEnumBug) {
			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = forceEnum.length; i &lt; len; ++i) {
				key = forceEnum[i];

				<span class="hljs-keyword">if</span> (owns(obj, key)) {
					keys.push(key);
				}
			}
		}

		<span class="hljs-keyword">return</span> keys;
	};

	<span class="hljs-comment">/**
	 * Returns an array containing the values of the object's enumerable keys.
	 *
	 * Note that values are returned in enumeration order (that is, in the same
	 * order that they would be enumerated by a `for-in` loop), which may not be the
	 * same as the order in which they were defined.
	 *
	 * @example
	 *
	 *     Y.Object.values({a: 'foo', b: 'bar', c: 'baz'});
	 *     // =&gt; ['foo', 'bar', 'baz']
	 *
	 * @method values
	 * @param {Object} obj An object.
	 * @return {Array} Array of values.
	 * @static
	 */</span>
	O.values = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
		<span class="hljs-keyword">var</span> keys   = O.keys(obj),
			i      = <span class="hljs-number">0</span>,
			len    = keys.length,
			values = [];

		<span class="hljs-keyword">for</span> (; i &lt; len; ++i) {
			values.push(obj[keys[i]]);
		}

		<span class="hljs-keyword">return</span> values;
	};

	<span class="hljs-comment">/**
	 * Returns the number of enumerable keys owned by an object.
	 *
	 * @method size
	 * @param {Object} obj An object.
	 * @return {Number} The object's size.
	 * @static
	 */</span>
	O.size = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">return</span> O.keys(obj).length;
		} <span class="hljs-keyword">catch</span> (ex) {
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Legacy behavior for non-objects.</span>
		}
	};

	<span class="hljs-comment">/**
	 * Returns `true` if the object owns an enumerable property with the specified
	 * value.
	 *
	 * @method hasValue
	 * @param {Object} obj An object.
	 * @param {any} value The value to search for.
	 * @return {Boolean} `true` if _obj_ contains _value_, `false` otherwise.
	 * @static
	 */</span>
	O.hasValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, value</span>) </span>{
		<span class="hljs-keyword">return</span> Y.Array.indexOf(O.values(obj), value) &gt; <span class="hljs-number">-1</span>;
	};

	<span class="hljs-comment">/**
	 * Executes a function on each enumerable property in _obj_. The function
	 * receives the value, the key, and the object itself as parameters (in that
	 * order).
	 *
	 * By default, only properties owned by _obj_ are enumerated. To include
	 * prototype properties, set the _proto_ parameter to `true`.
	 *
	 * @method each
	 * @param {Object} obj Object to enumerate.
	 * @param {Function} fn Function to execute on each enumerable property.
	 *   @param {mixed} fn.value Value of the current property.
	 *   @param {String} fn.key Key of the current property.
	 *   @param {Object} fn.obj Object being enumerated.
	 * @param {Object} [thisObj] `this` object to use when calling _fn_.
	 * @param {Boolean} [proto=false] Include prototype properties.
	 * @return {YUI} the YUI instance.
	 * @chainable
	 * @static
	 */</span>
	O.each = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, fn, thisObj, proto</span>) </span>{
		<span class="hljs-keyword">var</span> key;

		<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) {
			<span class="hljs-keyword">if</span> (proto || owns(obj, key)) {
				fn.call(thisObj || Y, obj[key], key, obj);
			}
		}

		<span class="hljs-keyword">return</span> Y;
	};

	<span class="hljs-comment">/**
	 * Executes a function on each enumerable property in _obj_, but halts if the
	 * function returns a truthy value. The function receives the value, the key,
	 * and the object itself as paramters (in that order).
	 *
	 * By default, only properties owned by _obj_ are enumerated. To include
	 * prototype properties, set the _proto_ parameter to `true`.
	 *
	 * @method some
	 * @param {Object} obj Object to enumerate.
	 * @param {Function} fn Function to execute on each enumerable property.
	 *   @param {mixed} fn.value Value of the current property.
	 *   @param {String} fn.key Key of the current property.
	 *   @param {Object} fn.obj Object being enumerated.
	 * @param {Object} [thisObj] `this` object to use when calling _fn_.
	 * @param {Boolean} [proto=false] Include prototype properties.
	 * @return {Boolean} `true` if any execution of _fn_ returns a truthy value,
	 *   `false` otherwise.
	 * @static
	 */</span>
	O.some = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, fn, thisObj, proto</span>) </span>{
		<span class="hljs-keyword">var</span> key;

		<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) {
			<span class="hljs-keyword">if</span> (proto || owns(obj, key)) {
				<span class="hljs-keyword">if</span> (fn.call(thisObj || Y, obj[key], key, obj)) {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
				}
			}
		}

		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	};

	<span class="hljs-comment">/**
	 * Retrieves the sub value at the provided path,
	 * from the value object provided.
	 *
	 * @method getValue
	 * @static
	 * @param o The object from which to extract the property value.
	 * @param path {Array} A path array, specifying the object traversal path
	 * from which to obtain the sub value.
	 * @return {Any} The value stored in the path, undefined if not found,
	 * undefined if the source is not an object.  Returns the source object
	 * if an empty path is provided.
	 */</span>
	O.getValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o, path</span>) </span>{
		<span class="hljs-keyword">if</span> (!Lang.isObject(o)) {
			<span class="hljs-keyword">return</span> UNDEFINED;
		}

		<span class="hljs-keyword">var</span> i,
			p = Y.Array(path),
			l = p.length;

		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; o !== UNDEFINED &amp;&amp; i &lt; l; i++) {
			o = o[p[i]];
		}

		<span class="hljs-keyword">return</span> o;
	};

	<span class="hljs-comment">/**
	 * Sets the sub-attribute value at the provided path on the
	 * value object.  Returns the modified value object, or
	 * undefined if the path is invalid.
	 *
	 * @method setValue
	 * @static
	 * @param o             The object on which to set the sub value.
	 * @param path {Array}  A path array, specifying the object traversal path
	 *                      at which to set the sub value.
	 * @param val {Any}     The new value for the sub-attribute.
	 * @return {Object}     The modified object, with the new sub value set, or
	 *                      undefined, if the path was invalid.
	 */</span>
	O.setValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o, path, val</span>) </span>{
		<span class="hljs-keyword">var</span> i,
			p = Y.Array(path),
			leafIdx = p.length - <span class="hljs-number">1</span>,
			ref = o;

		<span class="hljs-keyword">if</span> (leafIdx &gt;= <span class="hljs-number">0</span>) {
			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; ref !== UNDEFINED &amp;&amp; i &lt; leafIdx; i++) {
				ref = ref[p[i]];
			}

			<span class="hljs-keyword">if</span> (ref !== UNDEFINED) {
				ref[p[i]] = val;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> UNDEFINED;
			}
		}

		<span class="hljs-keyword">return</span> o;
	};

	<span class="hljs-comment">/**
	 * Returns `true` if the object has no enumerable properties of its own.
	 *
	 * @method isEmpty
	 * @param {Object} obj An object.
	 * @return {Boolean} `true` if the object is empty.
	 * @static
	 * @since 3.2.0
	 */</span>
	O.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
		<span class="hljs-keyword">return</span> !O.keys(<span class="hljs-built_in">Object</span>(obj)).length;
	};
	<span class="hljs-comment">/**
	 * The YUI module contains the components required for building the YUI seed
	 * file.  This includes the script loading mechanism, a simple queue, and the
	 * core utilities for the library.
	 * @module yui
	 * @submodule yui-base
	 */</span>

	<span class="hljs-comment">/**
	 * YUI user agent detection.
	 * Do not fork for a browser if it can be avoided.  Use feature detection when
	 * you can.  Use the user agent as a last resort.  For all fields listed
	 * as @type float, UA stores a version number for the browser engine,
	 * 0 otherwise.  This value may or may not map to the version number of
	 * the browser using the engine.  The value is presented as a float so
	 * that it can easily be used for boolean evaluation as well as for
	 * looking for a particular range of versions.  Because of this,
	 * some of the granularity of the version info may be lost.  The fields that
	 * are @type string default to null.  The API docs list the values that
	 * these fields can have.
	 * @class UA
	 * @static
	 */</span>

	<span class="hljs-comment">/**
	 * Static method on `YUI.Env` for parsing a UA string.  Called at instantiation
	 * to populate `Y.UA`.
	 *
	 * @static
	 * @method parseUA
	 * @param {String} [subUA=navigator.userAgent] UA string to parse
	 * @return {Object} The Y.UA object
	 */</span>
	YUI.Env.parseUA = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">subUA</span>) </span>{

		<span class="hljs-keyword">var</span> numberify = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
				<span class="hljs-keyword">var</span> c = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">return</span> <span class="hljs-built_in">parseFloat</span>(s.replace(<span class="hljs-regexp">/\./g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					<span class="hljs-keyword">return</span> (c++ === <span class="hljs-number">1</span>) ? <span class="hljs-string">''</span> : <span class="hljs-string">'.'</span>;
				}));
			},

			win = Y.config.win,

			nav = win &amp;&amp; win.navigator,

			o = {

				<span class="hljs-comment">/**
				 * Internet Explorer version number or 0.  Example: 6
				 * @property ie
				 * @type float
				 * @static
				 */</span>
				ie: <span class="hljs-number">0</span>,

				<span class="hljs-comment">/**
				 * Opera version number or 0.  Example: 9.2
				 * @property opera
				 * @type float
				 * @static
				 */</span>
				opera: <span class="hljs-number">0</span>,

				<span class="hljs-comment">/**
				 * Gecko engine revision number.  Will evaluate to 1 if Gecko
				 * is detected but the revision could not be found. Other browsers
				 * will be 0.  Example: 1.8
				 * &lt;pre&gt;
				 * Firefox 1.0.0.4: 1.7.8   &lt;-- Reports 1.7
				 * Firefox 1.5.0.9: 1.8.0.9 &lt;-- 1.8
				 * Firefox 2.0.0.3: 1.8.1.3 &lt;-- 1.81
				 * Firefox 3.0   &lt;-- 1.9
				 * Firefox 3.5   &lt;-- 1.91
				 * &lt;/pre&gt;
				 * @property gecko
				 * @type float
				 * @static
				 */</span>
				gecko: <span class="hljs-number">0</span>,

				<span class="hljs-comment">/**
				 * AppleWebKit version.  KHTML browsers that are not WebKit browsers
				 * will evaluate to 1, other browsers 0.  Example: 418.9
				 * &lt;pre&gt;
				 * Safari 1.3.2 (312.6): 312.8.1 &lt;-- Reports 312.8 -- currently the
				 *                                   latest available for Mac OSX 10.3.
				 * Safari 2.0.2:         416     &lt;-- hasOwnProperty introduced
				 * Safari 2.0.4:         418     &lt;-- preventDefault fixed
				 * Safari 2.0.4 (419.3): 418.9.1 &lt;-- One version of Safari may run
				 *                                   different versions of webkit
				 * Safari 2.0.4 (419.3): 419     &lt;-- Tiger installations that have been
				 *                                   updated, but not updated
				 *                                   to the latest patch.
				 * Webkit 212 nightly:   522+    &lt;-- Safari 3.0 precursor (with native
				 * SVG and many major issues fixed).
				 * Safari 3.0.4 (523.12) 523.12  &lt;-- First Tiger release - automatic
				 * update from 2.x via the 10.4.11 OS patch.
				 * Webkit nightly 1/2008:525+    &lt;-- Supports DOMContentLoaded event.
				 *                                   yahoo.com user agent hack removed.
				 * &lt;/pre&gt;
				 * http://en.wikipedia.org/wiki/Safari_version_history
				 * @property webkit
				 * @type float
				 * @static
				 */</span>
				webkit: <span class="hljs-number">0</span>,

				<span class="hljs-comment">/**
				 * Safari will be detected as webkit, but this property will also
				 * be populated with the Safari version number
				 * @property safari
				 * @type float
				 * @static
				 */</span>
				safari: <span class="hljs-number">0</span>,

				<span class="hljs-comment">/**
				 * Chrome will be detected as webkit, but this property will also
				 * be populated with the Chrome version number
				 * @property chrome
				 * @type float
				 * @static
				 */</span>
				chrome: <span class="hljs-number">0</span>,

				<span class="hljs-comment">/**
				 * The mobile property will be set to a string containing any relevant
				 * user agent information when a modern mobile browser is detected.
				 * Currently limited to Safari on the iPhone/iPod Touch, Nokia N-series
				 * devices with the WebKit-based browser, and Opera Mini.
				 * @property mobile
				 * @type string
				 * @default null
				 * @static
				 */</span>
				mobile: <span class="hljs-literal">null</span>,

				<span class="hljs-comment">/**
				 * Adobe AIR version number or 0.  Only populated if webkit is detected.
				 * Example: 1.0
				 * @property air
				 * @type float
				 */</span>
				air: <span class="hljs-number">0</span>,
				<span class="hljs-comment">/**
				 * PhantomJS version number or 0.  Only populated if webkit is detected.
				 * Example: 1.0
				 * @property phantomjs
				 * @type float
				 */</span>
				phantomjs: <span class="hljs-number">0</span>,
				<span class="hljs-comment">/**
				 * Detects Apple iPad's OS version
				 * @property ipad
				 * @type float
				 * @static
				 */</span>
				ipad: <span class="hljs-number">0</span>,
				<span class="hljs-comment">/**
				 * Detects Apple iPhone's OS version
				 * @property iphone
				 * @type float
				 * @static
				 */</span>
				iphone: <span class="hljs-number">0</span>,
				<span class="hljs-comment">/**
				 * Detects Apples iPod's OS version
				 * @property ipod
				 * @type float
				 * @static
				 */</span>
				ipod: <span class="hljs-number">0</span>,
				<span class="hljs-comment">/**
				 * General truthy check for iPad, iPhone or iPod
				 * @property ios
				 * @type Boolean
				 * @default null
				 * @static
				 */</span>
				ios: <span class="hljs-literal">null</span>,
				<span class="hljs-comment">/**
				 * Detects Googles Android OS version
				 * @property android
				 * @type float
				 * @static
				 */</span>
				android: <span class="hljs-number">0</span>,
				<span class="hljs-comment">/**
				 * Detects Kindle Silk
				 * @property silk
				 * @type float
				 * @static
				 */</span>
				silk: <span class="hljs-number">0</span>,
				<span class="hljs-comment">/**
				 * Detects Kindle Silk Acceleration
				 * @property accel
				 * @type Boolean
				 * @static
				 */</span>
				accel: <span class="hljs-literal">false</span>,
				<span class="hljs-comment">/**
				 * Detects Palms WebOS version
				 * @property webos
				 * @type float
				 * @static
				 */</span>
				webos: <span class="hljs-number">0</span>,

				<span class="hljs-comment">/**
				 * Google Caja version number or 0.
				 * @property caja
				 * @type float
				 */</span>
				caja: nav &amp;&amp; nav.cajaVersion,

				<span class="hljs-comment">/**
				 * Set to true if the page appears to be in SSL
				 * @property secure
				 * @type boolean
				 * @static
				 */</span>
				secure: <span class="hljs-literal">false</span>,

				<span class="hljs-comment">/**
				 * The operating system.  Currently only detecting windows or macintosh
				 * @property os
				 * @type string
				 * @default null
				 * @static
				 */</span>
				os: <span class="hljs-literal">null</span>,

				<span class="hljs-comment">/**
				 * The Nodejs Version
				 * @property nodejs
				 * @type float
				 * @default 0
				 * @static
				 */</span>
				nodejs: <span class="hljs-number">0</span>,
				<span class="hljs-comment">/*
				 * Window8/IE10 Application host environment
				 * @property winjs
				 * @type Boolean
				 * @static
				 */</span>
				winjs: !!((<span class="hljs-keyword">typeof</span> Windows !== <span class="hljs-string">"undefined"</span>) &amp;&amp; Windows.System),
				<span class="hljs-comment">/**
				 * Are touch/msPointer events available on this device
				 * @property touchEnabled
				 * @type Boolean
				 * @static
				 */</span>
				touchEnabled: <span class="hljs-literal">false</span>
			},

			ua = subUA || nav &amp;&amp; nav.userAgent,

			loc = win &amp;&amp; win.location,

			href = loc &amp;&amp; loc.href,

			m;

		<span class="hljs-comment">/**
		 * The User Agent string that was parsed
		 * @property userAgent
		 * @type String
		 * @static
		 */</span>
		o.userAgent = ua;


		o.secure = href &amp;&amp; (href.toLowerCase().indexOf(<span class="hljs-string">'https'</span>) === <span class="hljs-number">0</span>);

		<span class="hljs-keyword">if</span> (ua) {

			<span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/windows|win32/i</span>).test(ua)) {
				o.os = <span class="hljs-string">'windows'</span>;
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/macintosh|mac_powerpc/i</span>).test(ua)) {
				o.os = <span class="hljs-string">'macintosh'</span>;
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/android/i</span>).test(ua)) {
				o.os = <span class="hljs-string">'android'</span>;
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/symbos/i</span>).test(ua)) {
				o.os = <span class="hljs-string">'symbos'</span>;
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/linux/i</span>).test(ua)) {
				o.os = <span class="hljs-string">'linux'</span>;
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/rhino/i</span>).test(ua)) {
				o.os = <span class="hljs-string">'rhino'</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Modern KHTML browsers should qualify as Safari X-Grade</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/KHTML/</span>).test(ua)) {
				o.webkit = <span class="hljs-number">1</span>;
			}
			<span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/IEMobile|XBLWP7/</span>).test(ua)) {
				o.mobile = <span class="hljs-string">'windows'</span>;
			}
			<span class="hljs-keyword">if</span> ((<span class="hljs-regexp">/Fennec/</span>).test(ua)) {
				o.mobile = <span class="hljs-string">'gecko'</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Modern WebKit browsers are at least X-Grade</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			m = ua.match(<span class="hljs-regexp">/AppleWebKit\/([^\s]*)/</span>);
			<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
				o.webkit = numberify(m[<span class="hljs-number">1</span>]);
				o.safari = o.webkit;

				<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/PhantomJS/</span>.test(ua)) {
					m = ua.match(<span class="hljs-regexp">/PhantomJS\/([^\s]*)/</span>);
					<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
						o.phantomjs = numberify(m[<span class="hljs-number">1</span>]);
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Mobile browser check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/ Mobile\//</span>.test(ua) || (<span class="hljs-regexp">/iPad|iPod|iPhone/</span>).test(ua)) {
					o.mobile = <span class="hljs-string">'Apple'</span>; <span class="hljs-comment">// iPhone or iPod Touch</span>

					m = ua.match(<span class="hljs-regexp">/OS ([^\s]*)/</span>);
					<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
						m = numberify(m[<span class="hljs-number">1</span>].replace(<span class="hljs-string">'_'</span>, <span class="hljs-string">'.'</span>));
					}
					o.ios = m;
					o.os = <span class="hljs-string">'ios'</span>;
					o.ipad = o.ipod = o.iphone = <span class="hljs-number">0</span>;

					m = ua.match(<span class="hljs-regexp">/iPad|iPod|iPhone/</span>);
					<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">0</span>]) {
						o[m[<span class="hljs-number">0</span>].toLowerCase()] = o.ios;
					}
				} <span class="hljs-keyword">else</span> {
					m = ua.match(<span class="hljs-regexp">/NokiaN[^\/]*|webOS\/\d\.\d/</span>);
					<span class="hljs-keyword">if</span> (m) {</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Nokia N-series, webOS, ex: NokiaN95</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						o.mobile = m[<span class="hljs-number">0</span>];
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/webOS/</span>.test(ua)) {
						o.mobile = <span class="hljs-string">'WebOS'</span>;
						m = ua.match(<span class="hljs-regexp">/webOS\/([^\s]*);/</span>);
						<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
							o.webos = numberify(m[<span class="hljs-number">1</span>]);
						}
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/ Android/</span>.test(ua)) {
						<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Mobile/</span>.test(ua)) {
							o.mobile = <span class="hljs-string">'Android'</span>;
						}
						m = ua.match(<span class="hljs-regexp">/Android ([^\s]*);/</span>);
						<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
							o.android = numberify(m[<span class="hljs-number">1</span>]);
						}

					}
					<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Silk/</span>.test(ua)) {
						m = ua.match(<span class="hljs-regexp">/Silk\/([^\s]*)\)/</span>);
						<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
							o.silk = numberify(m[<span class="hljs-number">1</span>]);
						}
						<span class="hljs-keyword">if</span> (!o.android) {
							o.android = <span class="hljs-number">2.34</span>; <span class="hljs-comment">//Hack for desktop mode in Kindle</span>
							o.os = <span class="hljs-string">'Android'</span>;
						}
						<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Accelerated=true/</span>.test(ua)) {
							o.accel = <span class="hljs-literal">true</span>;
						}
					}
				}

				m = ua.match(<span class="hljs-regexp">/(Chrome|CrMo|CriOS)\/([^\s]*)/</span>);
				<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>] &amp;&amp; m[<span class="hljs-number">2</span>]) {
					o.chrome = numberify(m[<span class="hljs-number">2</span>]); <span class="hljs-comment">// Chrome</span>
					o.safari = <span class="hljs-number">0</span>; <span class="hljs-comment">//Reset safari back to 0</span>
					<span class="hljs-keyword">if</span> (m[<span class="hljs-number">1</span>] === <span class="hljs-string">'CrMo'</span>) {
						o.mobile = <span class="hljs-string">'chrome'</span>;
					}
				} <span class="hljs-keyword">else</span> {
					m = ua.match(<span class="hljs-regexp">/AdobeAIR\/([^\s]*)/</span>);
					<span class="hljs-keyword">if</span> (m) {
						o.air = m[<span class="hljs-number">0</span>]; <span class="hljs-comment">// Adobe AIR 1.0 or better</span>
					}
				}
			}

			<span class="hljs-keyword">if</span> (!o.webkit) { <span class="hljs-comment">// not webkit</span></pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>@todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Opera/</span>.test(ua)) {
					m = ua.match(<span class="hljs-regexp">/Opera[\s\/]([^\s]*)/</span>);
					<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
						o.opera = numberify(m[<span class="hljs-number">1</span>]);
					}
					m = ua.match(<span class="hljs-regexp">/Version\/([^\s]*)/</span>);
					<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
						o.opera = numberify(m[<span class="hljs-number">1</span>]); <span class="hljs-comment">// opera 10+</span>
					}

					<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Opera Mobi/</span>.test(ua)) {
						o.mobile = <span class="hljs-string">'opera'</span>;
						m = ua.replace(<span class="hljs-string">'Opera Mobi'</span>, <span class="hljs-string">''</span>).match(<span class="hljs-regexp">/Opera ([^\s]*)/</span>);
						<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
							o.opera = numberify(m[<span class="hljs-number">1</span>]);
						}
					}
					m = ua.match(<span class="hljs-regexp">/Opera Mini[^;]*/</span>);

					<span class="hljs-keyword">if</span> (m) {
						o.mobile = m[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ex: Opera Mini/2.0.4509/1316</span>
					}
				} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// not opera or webkit</span>
					m = ua.match(<span class="hljs-regexp">/MSIE\s([^;]*)/</span>);
					<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
						o.ie = numberify(m[<span class="hljs-number">1</span>]);
					} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// not opera, webkit, or ie</span>
						m = ua.match(<span class="hljs-regexp">/Gecko\/([^\s]*)/</span>);
						<span class="hljs-keyword">if</span> (m) {
							o.gecko = <span class="hljs-number">1</span>; <span class="hljs-comment">// Gecko detected, look for revision</span>
							m = ua.match(<span class="hljs-regexp">/rv:([^\s\)]*)/</span>);
							<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
								o.gecko = numberify(m[<span class="hljs-number">1</span>]);
							}
						}
					}
				}
			}
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Check for known properties to tell if touch events are enabled on this device or if
the number of MSPointer touchpoints on this device is greater than 0.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (win &amp;&amp; nav &amp;&amp; !(o.chrome &amp;&amp; o.chrome &lt; <span class="hljs-number">6</span>)) {
			o.touchEnabled = ((<span class="hljs-string">"ontouchstart"</span> <span class="hljs-keyword">in</span> win) || ((<span class="hljs-string">"msMaxTouchPoints"</span> <span class="hljs-keyword">in</span> nav) &amp;&amp; (nav.msMaxTouchPoints &gt; <span class="hljs-number">0</span>)));
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>It was a parsed UA, do not assign the global value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!subUA) {

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> process === <span class="hljs-string">'object'</span>) {

				<span class="hljs-keyword">if</span> (process.versions &amp;&amp; process.versions.node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>NodeJS</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					o.os = process.platform;
					o.nodejs = numberify(process.versions.node);
				}
			}

			YUI.Env.UA = o;

		}

		<span class="hljs-keyword">return</span> o;
	};


	Y.UA = YUI.Env.UA || YUI.Env.parseUA();

	<span class="hljs-comment">/**
	 Performs a simple comparison between two version numbers, accounting for
	 standard versioning logic such as the fact that "535.8" is a lower version than
	 "535.24", even though a simple numerical comparison would indicate that it's
	 greater. Also accounts for cases such as "1.1" vs. "1.1.0", which are
	 considered equivalent.

	 Returns -1 if version _a_ is lower than version _b_, 0 if they're equivalent,
	 1 if _a_ is higher than _b_.

	 Versions may be numbers or strings containing numbers and dots. For example,
	 both `535` and `"535.8.10"` are acceptable. A version string containing
	 non-numeric characters, like `"535.8.beta"`, may produce unexpected results.

	 @method compareVersions
	 @param {Number|String} a First version number to compare.
	 @param {Number|String} b Second version number to compare.
	 @return -1 if _a_ is lower than _b_, 0 if they're equivalent, 1 if _a_ is
	 higher than _b_.
	 **/</span>
	Y.UA.compareVersions = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
		<span class="hljs-keyword">var</span> aPart, aParts, bPart, bParts, i, len;

		<span class="hljs-keyword">if</span> (a === b) {
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		}

		aParts = (a + <span class="hljs-string">''</span>).split(<span class="hljs-string">'.'</span>);
		bParts = (b + <span class="hljs-string">''</span>).split(<span class="hljs-string">'.'</span>);

		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">Math</span>.max(aParts.length, bParts.length); i &lt; len; ++i) {
			aPart = <span class="hljs-built_in">parseInt</span>(aParts[i], <span class="hljs-number">10</span>);
			bPart = <span class="hljs-built_in">parseInt</span>(bParts[i], <span class="hljs-number">10</span>);

			<span class="hljs-built_in">isNaN</span>(aPart) &amp;&amp; (aPart = <span class="hljs-number">0</span>);
			<span class="hljs-built_in">isNaN</span>(bPart) &amp;&amp; (bPart = <span class="hljs-number">0</span>);

			<span class="hljs-keyword">if</span> (aPart &lt; bPart) {
				<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
			}

			<span class="hljs-keyword">if</span> (aPart &gt; bPart) {
				<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
			}
		}

		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	};
	YUI.Env.aliases = {
		<span class="hljs-string">"anim"</span>: [<span class="hljs-string">"anim-base"</span>,<span class="hljs-string">"anim-color"</span>,<span class="hljs-string">"anim-curve"</span>,<span class="hljs-string">"anim-easing"</span>,<span class="hljs-string">"anim-node-plugin"</span>,<span class="hljs-string">"anim-scroll"</span>,<span class="hljs-string">"anim-xy"</span>],
		<span class="hljs-string">"anim-shape-transform"</span>: [<span class="hljs-string">"anim-shape"</span>],
		<span class="hljs-string">"app"</span>: [<span class="hljs-string">"app-base"</span>,<span class="hljs-string">"app-content"</span>,<span class="hljs-string">"app-transitions"</span>,<span class="hljs-string">"lazy-model-list"</span>,<span class="hljs-string">"model"</span>,<span class="hljs-string">"model-list"</span>,<span class="hljs-string">"model-sync-rest"</span>,<span class="hljs-string">"router"</span>,<span class="hljs-string">"view"</span>,<span class="hljs-string">"view-node-map"</span>],
		<span class="hljs-string">"attribute"</span>: [<span class="hljs-string">"attribute-base"</span>,<span class="hljs-string">"attribute-complex"</span>],
		<span class="hljs-string">"autocomplete"</span>: [<span class="hljs-string">"autocomplete-base"</span>,<span class="hljs-string">"autocomplete-sources"</span>,<span class="hljs-string">"autocomplete-list"</span>,<span class="hljs-string">"autocomplete-plugin"</span>],
		<span class="hljs-string">"base"</span>: [<span class="hljs-string">"base-base"</span>,<span class="hljs-string">"base-pluginhost"</span>,<span class="hljs-string">"base-build"</span>],
		<span class="hljs-string">"cache"</span>: [<span class="hljs-string">"cache-base"</span>,<span class="hljs-string">"cache-offline"</span>,<span class="hljs-string">"cache-plugin"</span>],
		<span class="hljs-string">"collection"</span>: [<span class="hljs-string">"array-extras"</span>,<span class="hljs-string">"arraylist"</span>,<span class="hljs-string">"arraylist-add"</span>,<span class="hljs-string">"arraylist-filter"</span>,<span class="hljs-string">"array-invoke"</span>],
		<span class="hljs-string">"controller"</span>: [<span class="hljs-string">"router"</span>],
		<span class="hljs-string">"dataschema"</span>: [<span class="hljs-string">"dataschema-base"</span>,<span class="hljs-string">"dataschema-json"</span>,<span class="hljs-string">"dataschema-xml"</span>,<span class="hljs-string">"dataschema-array"</span>,<span class="hljs-string">"dataschema-text"</span>],
		<span class="hljs-string">"datasource"</span>: [<span class="hljs-string">"datasource-local"</span>,<span class="hljs-string">"datasource-io"</span>,<span class="hljs-string">"datasource-get"</span>,<span class="hljs-string">"datasource-function"</span>,<span class="hljs-string">"datasource-cache"</span>,<span class="hljs-string">"datasource-jsonschema"</span>,<span class="hljs-string">"datasource-xmlschema"</span>,<span class="hljs-string">"datasource-arrayschema"</span>,<span class="hljs-string">"datasource-textschema"</span>,<span class="hljs-string">"datasource-polling"</span>],
		<span class="hljs-string">"datatable"</span>: [<span class="hljs-string">"datatable-core"</span>,<span class="hljs-string">"datatable-table"</span>,<span class="hljs-string">"datatable-head"</span>,<span class="hljs-string">"datatable-body"</span>,<span class="hljs-string">"datatable-base"</span>,<span class="hljs-string">"datatable-column-widths"</span>,<span class="hljs-string">"datatable-message"</span>,<span class="hljs-string">"datatable-mutable"</span>,<span class="hljs-string">"datatable-sort"</span>,<span class="hljs-string">"datatable-datasource"</span>],
		<span class="hljs-string">"datatable-deprecated"</span>: [<span class="hljs-string">"datatable-base-deprecated"</span>,<span class="hljs-string">"datatable-datasource-deprecated"</span>,<span class="hljs-string">"datatable-sort-deprecated"</span>,<span class="hljs-string">"datatable-scroll-deprecated"</span>],
		<span class="hljs-string">"datatype"</span>: [<span class="hljs-string">"datatype-date"</span>,<span class="hljs-string">"datatype-number"</span>,<span class="hljs-string">"datatype-xml"</span>],
		<span class="hljs-string">"datatype-date"</span>: [<span class="hljs-string">"datatype-date-parse"</span>,<span class="hljs-string">"datatype-date-format"</span>,<span class="hljs-string">"datatype-date-math"</span>],
		<span class="hljs-string">"datatype-number"</span>: [<span class="hljs-string">"datatype-number-parse"</span>,<span class="hljs-string">"datatype-number-format"</span>],
		<span class="hljs-string">"datatype-xml"</span>: [<span class="hljs-string">"datatype-xml-parse"</span>,<span class="hljs-string">"datatype-xml-format"</span>],
		<span class="hljs-string">"dd"</span>: [<span class="hljs-string">"dd-ddm-base"</span>,<span class="hljs-string">"dd-ddm"</span>,<span class="hljs-string">"dd-ddm-drop"</span>,<span class="hljs-string">"dd-drag"</span>,<span class="hljs-string">"dd-proxy"</span>,<span class="hljs-string">"dd-constrain"</span>,<span class="hljs-string">"dd-drop"</span>,<span class="hljs-string">"dd-scroll"</span>,<span class="hljs-string">"dd-delegate"</span>],
		<span class="hljs-string">"dom"</span>: [<span class="hljs-string">"dom-base"</span>,<span class="hljs-string">"dom-screen"</span>,<span class="hljs-string">"dom-style"</span>,<span class="hljs-string">"selector-native"</span>,<span class="hljs-string">"selector"</span>],
		<span class="hljs-string">"editor"</span>: [<span class="hljs-string">"frame"</span>,<span class="hljs-string">"editor-selection"</span>,<span class="hljs-string">"exec-command"</span>,<span class="hljs-string">"editor-base"</span>,<span class="hljs-string">"editor-para"</span>,<span class="hljs-string">"editor-br"</span>,<span class="hljs-string">"editor-bidi"</span>,<span class="hljs-string">"editor-tab"</span>,<span class="hljs-string">"createlink-base"</span>],
		<span class="hljs-string">"event"</span>: [<span class="hljs-string">"event-base"</span>,<span class="hljs-string">"event-delegate"</span>,<span class="hljs-string">"event-synthetic"</span>,<span class="hljs-string">"event-mousewheel"</span>,<span class="hljs-string">"event-mouseenter"</span>,<span class="hljs-string">"event-key"</span>,<span class="hljs-string">"event-focus"</span>,<span class="hljs-string">"event-resize"</span>,<span class="hljs-string">"event-hover"</span>,<span class="hljs-string">"event-outside"</span>,<span class="hljs-string">"event-touch"</span>,<span class="hljs-string">"event-move"</span>,<span class="hljs-string">"event-flick"</span>,<span class="hljs-string">"event-valuechange"</span>,<span class="hljs-string">"event-tap"</span>],
		<span class="hljs-string">"event-custom"</span>: [<span class="hljs-string">"event-custom-base"</span>,<span class="hljs-string">"event-custom-complex"</span>],
		<span class="hljs-string">"event-gestures"</span>: [<span class="hljs-string">"event-flick"</span>,<span class="hljs-string">"event-move"</span>],
		<span class="hljs-string">"handlebars"</span>: [<span class="hljs-string">"handlebars-compiler"</span>],
		<span class="hljs-string">"highlight"</span>: [<span class="hljs-string">"highlight-base"</span>,<span class="hljs-string">"highlight-accentfold"</span>],
		<span class="hljs-string">"history"</span>: [<span class="hljs-string">"history-base"</span>,<span class="hljs-string">"history-hash"</span>,<span class="hljs-string">"history-hash-ie"</span>,<span class="hljs-string">"history-html5"</span>],
		<span class="hljs-string">"io"</span>: [<span class="hljs-string">"io-base"</span>,<span class="hljs-string">"io-xdr"</span>,<span class="hljs-string">"io-form"</span>,<span class="hljs-string">"io-upload-iframe"</span>,<span class="hljs-string">"io-queue"</span>],
		<span class="hljs-string">"json"</span>: [<span class="hljs-string">"json-parse"</span>,<span class="hljs-string">"json-stringify"</span>],
		<span class="hljs-string">"loader"</span>: [<span class="hljs-string">"loader-base"</span>,<span class="hljs-string">"loader-rollup"</span>,<span class="hljs-string">"loader-yui3"</span>],
		<span class="hljs-string">"node"</span>: [<span class="hljs-string">"node-base"</span>,<span class="hljs-string">"node-event-delegate"</span>,<span class="hljs-string">"node-pluginhost"</span>,<span class="hljs-string">"node-screen"</span>,<span class="hljs-string">"node-style"</span>],
		<span class="hljs-string">"pluginhost"</span>: [<span class="hljs-string">"pluginhost-base"</span>,<span class="hljs-string">"pluginhost-config"</span>],
		<span class="hljs-string">"querystring"</span>: [<span class="hljs-string">"querystring-parse"</span>,<span class="hljs-string">"querystring-stringify"</span>],
		<span class="hljs-string">"recordset"</span>: [<span class="hljs-string">"recordset-base"</span>,<span class="hljs-string">"recordset-sort"</span>,<span class="hljs-string">"recordset-filter"</span>,<span class="hljs-string">"recordset-indexer"</span>],
		<span class="hljs-string">"resize"</span>: [<span class="hljs-string">"resize-base"</span>,<span class="hljs-string">"resize-proxy"</span>,<span class="hljs-string">"resize-constrain"</span>],
		<span class="hljs-string">"slider"</span>: [<span class="hljs-string">"slider-base"</span>,<span class="hljs-string">"slider-value-range"</span>,<span class="hljs-string">"clickable-rail"</span>,<span class="hljs-string">"range-slider"</span>],
		<span class="hljs-string">"text"</span>: [<span class="hljs-string">"text-accentfold"</span>,<span class="hljs-string">"text-wordbreak"</span>],
		<span class="hljs-string">"widget"</span>: [<span class="hljs-string">"widget-base"</span>,<span class="hljs-string">"widget-htmlparser"</span>,<span class="hljs-string">"widget-skin"</span>,<span class="hljs-string">"widget-uievents"</span>]
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"use"</span>: [<span class="hljs-string">"get"</span>, <span class="hljs-string">"features"</span>, <span class="hljs-string">"intl-base"</span>, <span class="hljs-string">"yui-log"</span>, <span class="hljs-string">"yui-later"</span>]});
YUI.add(<span class="hljs-string">'get'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/*jslint boss:true, expr:true, laxbreak: true */</span>

	<span class="hljs-comment">/**
	 Provides dynamic loading of remote JavaScript and CSS resources.

	 @module get
	 @class Get
	 @static
	 **/</span>

	<span class="hljs-keyword">var</span> Lang = Y.Lang,

		CUSTOM_ATTRS, <span class="hljs-comment">// defined lazily in Y.Get.Transaction._createNode()</span>

		Get, Transaction;

	Y.Get = Get = {</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>– Public Properties —————————————————-</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 Default options for CSS requests. Options specified here will override
		 global defaults for CSS requests.

		 See the `options` property for all available options.

		 @property cssOptions
		 @type Object
		 @static
		 @since 3.5.0
		 **/</span>
		cssOptions: {
			<span class="hljs-attr">attributes</span>: {
				<span class="hljs-attr">rel</span>: <span class="hljs-string">'stylesheet'</span>
			},

			<span class="hljs-attr">doc</span>         : Y.config.linkDoc || Y.config.doc,
			<span class="hljs-attr">pollInterval</span>: <span class="hljs-number">50</span>
		},

		<span class="hljs-comment">/**
		 Default options for JS requests. Options specified here will override global
		 defaults for JS requests.

		 See the `options` property for all available options.

		 @property jsOptions
		 @type Object
		 @static
		 @since 3.5.0
		 **/</span>
		jsOptions: {
			<span class="hljs-attr">autopurge</span>: <span class="hljs-literal">true</span>,
			<span class="hljs-attr">doc</span>      : Y.config.scriptDoc || Y.config.doc
		},

		<span class="hljs-comment">/**
		 Default options to use for all requests.

		 Note that while all available options are documented here for ease of
		 discovery, some options (like callback functions) only make sense at the
		 transaction level.

		 Callback functions specified via the options object or the `options`
		 parameter of the `css()`, `js()`, or `load()` methods will receive the
		 transaction object as a parameter. See `Y.Get.Transaction` for details on
		 the properties and methods available on transactions.

		 @static
		 @since 3.5.0
		 @property {Object} options

		 @property {Boolean} [options.async=false] Whether or not to load scripts
		 asynchronously, meaning they're requested in parallel and execution
		 order is not guaranteed. Has no effect on CSS, since CSS is always
		 loaded asynchronously.

		 @property {Object} [options.attributes] HTML attribute name/value pairs that
		 should be added to inserted nodes. By default, the `charset` attribute
		 will be set to "utf-8" and nodes will be given an auto-generated `id`
		 attribute, but you can override these with your own values if desired.

		 @property {Boolean} [options.autopurge] Whether or not to automatically
		 purge inserted nodes after the purge threshold is reached. This is
		 `true` by default for JavaScript, but `false` for CSS since purging a
		 CSS node will also remove any styling applied by the referenced file.

		 @property {Object} [options.context] `this` object to use when calling
		 callback functions. Defaults to the transaction object.

		 @property {Mixed} [options.data] Arbitrary data object to pass to "on*"
		 callbacks.

		 @property {Document} [options.doc] Document into which nodes should be
		 inserted. By default, the current document is used.

		 @property {HTMLElement|String} [options.insertBefore] HTML element or id
		 string of an element before which all generated nodes should be
		 inserted. If not specified, Get will automatically determine the best
		 place to insert nodes for maximum compatibility.

		 @property {Function} [options.onEnd] Callback to execute after a transaction
		 is complete, regardless of whether it succeeded or failed.

		 @property {Function} [options.onFailure] Callback to execute after a
		 transaction fails, times out, or is aborted.

		 @property {Function} [options.onProgress] Callback to execute after each
		 individual request in a transaction either succeeds or fails.

		 @property {Function} [options.onSuccess] Callback to execute after a
		 transaction completes successfully with no errors. Note that in browsers
		 that don't support the `error` event on CSS `&lt;link&gt;` nodes, a failed CSS
		 request may still be reported as a success because in these browsers
		 it can be difficult or impossible to distinguish between success and
		 failure for CSS resources.

		 @property {Function} [options.onTimeout] Callback to execute after a
		 transaction times out.

		 @property {Number} [options.pollInterval=50] Polling interval (in
		 milliseconds) for detecting CSS load completion in browsers that don't
		 support the `load` event on `&lt;link&gt;` nodes. This isn't used for
		 JavaScript.

		 @property {Number} [options.purgethreshold=20] Number of nodes to insert
		 before triggering an automatic purge when `autopurge` is `true`.

		 @property {Number} [options.timeout] Number of milliseconds to wait before
		 aborting a transaction. When a timeout occurs, the `onTimeout` callback
		 is called, followed by `onFailure` and finally `onEnd`. By default,
		 there is no timeout.

		 @property {String} [options.type] Resource type ("css" or "js"). This option
		 is set automatically by the `css()` and `js()` functions and will be
		 ignored there, but may be useful when using the `load()` function. If
		 not specified, the type will be inferred from the URL, defaulting to
		 "js" if the URL doesn't contain a recognizable file extension.
		 **/</span>
		options: {
			<span class="hljs-attr">attributes</span>: {
				<span class="hljs-attr">charset</span>: <span class="hljs-string">'utf-8'</span>
			},

			<span class="hljs-attr">purgethreshold</span>: <span class="hljs-number">20</span>
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>– Protected Properties ————————————————-</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 Regex that matches a CSS URL. Used to guess the file type when it's not
		 specified.

		 @property REGEX_CSS
		 @type RegExp
		 @final
		 @protected
		 @static
		 @since 3.5.0
		 **/</span>
		REGEX_CSS: <span class="hljs-regexp">/\.css(?:[?;].*)?$/i</span>,

		<span class="hljs-comment">/**
		 Regex that matches a JS URL. Used to guess the file type when it's not
		 specified.

		 @property REGEX_JS
		 @type RegExp
		 @final
		 @protected
		 @static
		 @since 3.5.0
		 **/</span>
		REGEX_JS : <span class="hljs-regexp">/\.js(?:[?;].*)?$/i</span>,

		<span class="hljs-comment">/**
		 Contains information about the current environment, such as what script and
		 link injection features it supports.

		 This object is created and populated the first time the `_getEnv()` method
		 is called.

		 @property _env
		 @type Object
		 @protected
		 @static
		 @since 3.5.0
		 **/</span>

		<span class="hljs-comment">/**
		 Mapping of document _yuid strings to &lt;head&gt; or &lt;base&gt; node references so we
		 don't have to look the node up each time we want to insert a request node.

		 @property _insertCache
		 @type Object
		 @protected
		 @static
		 @since 3.5.0
		 **/</span>
		_insertCache: {},

		<span class="hljs-comment">/**
		 Information about the currently pending transaction, if any.

		 This is actually an object with two properties: `callback`, containing the
		 optional callback passed to `css()`, `load()`, or `js()`; and `transaction`,
		 containing the actual transaction instance.

		 @property _pending
		 @type Object
		 @protected
		 @static
		 @since 3.5.0
		 **/</span>
		_pending: <span class="hljs-literal">null</span>,

		<span class="hljs-comment">/**
		 HTML nodes eligible to be purged next time autopurge is triggered.

		 @property _purgeNodes
		 @type HTMLElement[]
		 @protected
		 @static
		 @since 3.5.0
		 **/</span>
		_purgeNodes: [],

		<span class="hljs-comment">/**
		 Queued transactions and associated callbacks.

		 @property _queue
		 @type Object[]
		 @protected
		 @static
		 @since 3.5.0
		 **/</span>
		_queue: [],</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>– Public Methods ——————————————————-</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 Aborts the specified transaction.

		 This will cause the transaction's `onFailure` callback to be called and
		 will prevent any new script and link nodes from being added to the document,
		 but any resources that have already been requested will continue loading
		 (there's no safe way to prevent this, unfortunately).

		 *Note:* This method is deprecated as of 3.5.0, and will be removed in a
		 future version of YUI. Use the transaction-level `abort()` method instead.

		 @method abort
		 @param {Get.Transaction} transaction Transaction to abort.
		 @deprecated Use the `abort()` method on the transaction instead.
		 @static
		 **/</span>
		abort: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">transaction</span>) </span>{
			<span class="hljs-keyword">var</span> i, id, item, len, pending;


			<span class="hljs-keyword">if</span> (!transaction.abort) {
				id          = transaction;
				pending     = <span class="hljs-keyword">this</span>._pending;
				transaction = <span class="hljs-literal">null</span>;

				<span class="hljs-keyword">if</span> (pending &amp;&amp; pending.transaction.id === id) {
					transaction   = pending.transaction;
					<span class="hljs-keyword">this</span>._pending = <span class="hljs-literal">null</span>;
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = <span class="hljs-keyword">this</span>._queue.length; i &lt; len; ++i) {
						item = <span class="hljs-keyword">this</span>._queue[i].transaction;

						<span class="hljs-keyword">if</span> (item.id === id) {
							transaction = item;
							<span class="hljs-keyword">this</span>._queue.splice(i, <span class="hljs-number">1</span>);
							<span class="hljs-keyword">break</span>;
						}
					}
				}
			}

			transaction &amp;&amp; transaction.abort();
		},

		<span class="hljs-comment">/**
		 Loads one or more CSS files.

		 The _urls_ parameter may be provided as a URL string, a request object,
		 or an array of URL strings and/or request objects.

		 A request object is just an object that contains a `url` property and zero
		 or more options that should apply specifically to that request.
		 Request-specific options take priority over transaction-level options and
		 default options.

		 URLs may be relative or absolute, and do not have to have the same origin
		 as the current page.

		 The `options` parameter may be omitted completely and a callback passed in
		 its place, if desired.

		 @example

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Load a single CSS file and log a message on completion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 Y.Get.css(<span class="hljs-string">'foo.css'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
		 <span class="hljs-keyword">if</span> (err) {
		 } <span class="hljs-keyword">else</span> {
		 }
		 });</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Load multiple CSS files and log a message when all have finished
loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 <span class="hljs-keyword">var</span> urls = [<span class="hljs-string">'foo.css'</span>, <span class="hljs-string">'http://example.com/bar.css'</span>, <span class="hljs-string">'baz/quux.css'</span>];

		 Y.Get.css(urls, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
		 <span class="hljs-keyword">if</span> (err) {
		 } <span class="hljs-keyword">else</span> {
		 }
		 });</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>Specify transaction-level options, which will apply to all requests
within the transaction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 Y.Get.css(urls, {
		 <span class="hljs-attr">attributes</span>: {<span class="hljs-string">'class'</span>: <span class="hljs-string">'my-css'</span>},
		 <span class="hljs-attr">timeout</span>   : <span class="hljs-number">5000</span>
		 });</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>Specify per-request options, which override transaction-level and
default options.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 Y.Get.css([
		 {url: 'foo.css', attributes: {id: 'foo'}},
		 {url: 'bar.css', attributes: {id: 'bar', charset: 'iso-8859-1'}}
		 ]);

		 @method css
		 @param {String|Object|Array} urls URL string, request object, or array
		 of URLs and/or request objects to load.
		 @param {Object} [options] Options for this transaction. See the
		 `Y.Get.options` property for a complete list of available options.
		 @param {Function} [callback] Callback function to be called on completion.
		 This is a general callback and will be called before any more granular
		 callbacks (`onSuccess`, `onFailure`, etc.) specified in the `options`
		 object.

		 @param {Array|null} callback.err Array of errors that occurred during
		 the transaction, or `null` on success.
		 @param {Get.Transaction} callback.transaction Transaction object.

		 @return {Get.Transaction} Transaction object.
		 @static
		 **/
		css: function (urls, options, callback) {
			return this._load('css', urls, options, callback);
		},

		/**
		 Loads one or more JavaScript resources.

		 The _urls_ parameter may be provided as a URL string, a request object,
		 or an array of URL strings and/or request objects.

		 A request object is just an object that contains a `url` property and zero
		 or more options that should apply specifically to that request.
		 Request-specific options take priority over transaction-level options and
		 default options.

		 URLs may be relative or absolute, and do not have to have the same origin
		 as the current page.

		 The `options` parameter may be omitted completely and a callback passed in
		 its place, if desired.

		 Scripts will be executed in the order they're specified unless the `async`
		 option is `true`, in which case they'll be loaded in parallel and executed
		 in whatever order they finish loading.

		 @example</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>Load a single JS file and log a message on completion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 Y.Get.js(<span class="hljs-string">'foo.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
		 <span class="hljs-keyword">if</span> (err) {
		 } <span class="hljs-keyword">else</span> {
		 }
		 });</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Load multiple JS files, execute them in order, and log a message when
all have finished loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 <span class="hljs-keyword">var</span> urls = [<span class="hljs-string">'foo.js'</span>, <span class="hljs-string">'http://example.com/bar.js'</span>, <span class="hljs-string">'baz/quux.js'</span>];

		 Y.Get.js(urls, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
		 <span class="hljs-keyword">if</span> (err) {
		 } <span class="hljs-keyword">else</span> {
		 }
		 });</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>Specify transaction-level options, which will apply to all requests
within the transaction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 Y.Get.js(urls, {
		 <span class="hljs-attr">attributes</span>: {<span class="hljs-string">'class'</span>: <span class="hljs-string">'my-js'</span>},
		 <span class="hljs-attr">timeout</span>   : <span class="hljs-number">5000</span>
		 });</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Specify per-request options, which override transaction-level and
default options.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 Y.Get.js([
		 {url: 'foo.js', attributes: {id: 'foo'}},
		 {url: 'bar.js', attributes: {id: 'bar', charset: 'iso-8859-1'}}
		 ]);

		 @method js
		 @param {String|Object|Array} urls URL string, request object, or array
		 of URLs and/or request objects to load.
		 @param {Object} [options] Options for this transaction. See the
		 `Y.Get.options` property for a complete list of available options.
		 @param {Function} [callback] Callback function to be called on completion.
		 This is a general callback and will be called before any more granular
		 callbacks (`onSuccess`, `onFailure`, etc.) specified in the `options`
		 object.

		 @param {Array|null} callback.err Array of errors that occurred during
		 the transaction, or `null` on success.
		 @param {Get.Transaction} callback.transaction Transaction object.

		 @return {Get.Transaction} Transaction object.
		 @since 3.5.0
		 @static
		 **/
		js: function (urls, options, callback) {
			return this._load('js', urls, options, callback);
		},

		/**
		 Loads one or more CSS and/or JavaScript resources in the same transaction.

		 Use this method when you want to load both CSS and JavaScript in a single
		 transaction and be notified when all requested URLs have finished loading,
		 regardless of type.

		 Behavior and options are the same as for the `css()` and `js()` methods. If
		 a resource type isn't specified in per-request options or transaction-level
		 options, Get will guess the file type based on the URL's extension (`.css`
		 or `.js`, with or without a following query string). If the file type can't
		 be guessed from the URL, a warning will be logged and Get will assume the
		 URL is a JavaScript resource.

		 @example</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Load both CSS and JS files in a single transaction, and log a message
when all files have finished loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 Y.Get.load(['foo.css', 'bar.js', 'baz.css'], function (err) {
		 if (err) {
		 } else {
		 }
		 });

		 @method load
		 @param {String|Object|Array} urls URL string, request object, or array
		 of URLs and/or request objects to load.
		 @param {Object} [options] Options for this transaction. See the
		 `Y.Get.options` property for a complete list of available options.
		 @param {Function} [callback] Callback function to be called on completion.
		 This is a general callback and will be called before any more granular
		 callbacks (`onSuccess`, `onFailure`, etc.) specified in the `options`
		 object.

		 @param {Array|null} err Array of errors that occurred during the
		 transaction, or `null` on success.
		 @param {Get.Transaction} Transaction object.

		 @return {Get.Transaction} Transaction object.
		 @since 3.5.0
		 @static
		 **/
		load: function (urls, options, callback) {
			return this._load(null, urls, options, callback);
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>– Protected Methods —————————————————-</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 Triggers an automatic purge if the purge threshold has been reached.

		 @method _autoPurge
		 @param {Number} threshold Purge threshold to use, in milliseconds.
		 @protected
		 @since 3.5.0
		 @static
		 **/</span>
		_autoPurge: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">threshold</span>) </span>{
			<span class="hljs-keyword">if</span> (threshold &amp;&amp; <span class="hljs-keyword">this</span>._purgeNodes.length &gt;= threshold) {
				<span class="hljs-keyword">this</span>._purge(<span class="hljs-keyword">this</span>._purgeNodes);
			}
		},

		<span class="hljs-comment">/**
		 Populates the `_env` property with information about the current
		 environment.

		 @method _getEnv
		 @return {Object} Environment information.
		 @protected
		 @since 3.5.0
		 @static
		 **/</span>
		_getEnv: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> doc = Y.config.doc,
				ua  = Y.UA;</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Note: some of these checks require browser sniffs since it’s not
feasible to load test files on every pageview just to perform a
feature test. I’m sorry if this makes you sad.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>._env = {</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>True if this is a browser that supports disabling async mode on
dynamically created script nodes. See
<a href="https://developer.mozilla.org/En/HTML/Element/Script#Attributes">https://developer.mozilla.org/En/HTML/Element/Script#Attributes</a></p>

            </div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>IE10 doesn’t return true for the MDN feature test, so setting it explicitly,
because it is async by default, and allows you to disable async by setting it to false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">async</span>: (doc &amp;&amp; doc.createElement(<span class="hljs-string">'script'</span>).async === <span class="hljs-literal">true</span>) || (ua.ie &gt;= <span class="hljs-number">10</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>True if this browser fires an event when a dynamically injected
link node fails to load. This is currently true for Firefox 9+
and WebKit 535.24+</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				cssFail: ua.gecko &gt;= <span class="hljs-number">9</span> || ua.compareVersions(ua.webkit, <span class="hljs-number">535.24</span>) &gt;= <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>True if this browser fires an event when a dynamically injected
link node finishes loading. This is currently true for IE, Opera,
Firefox 9+, and WebKit 535.24+. Note that IE versions &lt;9 fire the
DOM 0 “onload” event, but not “load”. All versions of IE fire
“onload”.
davglass: Seems that Chrome on Android needs this to be false.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				cssLoad: (
					(!ua.gecko &amp;&amp; !ua.webkit) || ua.gecko &gt;= <span class="hljs-number">9</span> ||
						ua.compareVersions(ua.webkit, <span class="hljs-number">535.24</span>) &gt;= <span class="hljs-number">0</span>
					) &amp;&amp; !(ua.chrome &amp;&amp; ua.chrome &lt;= <span class="hljs-number">18</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>True if this browser preserves script execution order while
loading scripts in parallel as long as the script node’s <code>async</code>
attribute is set to false to explicitly disable async execution.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				preservesScriptOrder: !!(ua.gecko || ua.opera || (ua.ie &amp;&amp; ua.ie &gt;= <span class="hljs-number">10</span>))
			});
		},

		<span class="hljs-attr">_getTransaction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">urls, options</span>) </span>{
			<span class="hljs-keyword">var</span> requests = [],
				i, len, req, url;

			<span class="hljs-keyword">if</span> (!Lang.isArray(urls)) {
				urls = [urls];
			}

			options = Y.merge(<span class="hljs-keyword">this</span>.options, options);</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Clone the attributes object so we don’t end up modifying it by ref.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			options.attributes = Y.merge(<span class="hljs-keyword">this</span>.options.attributes,
				options.attributes);

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = urls.length; i &lt; len; ++i) {
				url = urls[i];
				req = {<span class="hljs-attr">attributes</span>: {}};</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>If <code>url</code> is a string, we create a URL object for it, then mix in
global options and request-specific options. If it’s an object
with a “url” property, we assume it’s a request object containing
URL-specific options.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> url === <span class="hljs-string">'string'</span>) {
					req.url = url;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url.url) {</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>URL-specific options override both global defaults and
request-specific options.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					Y.mix(req, url, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
					url = url.url; <span class="hljs-comment">// Make url a string so we can use it later.</span>
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">continue</span>;
				}

				Y.mix(req, options, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>If we didn’t get an explicit type for this URL either in the
request options or the URL-specific options, try to determine
one from the file extension.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!req.type) {
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.REGEX_CSS.test(url)) {
						req.type = <span class="hljs-string">'css'</span>;
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.REGEX_JS.test(url)) {
						}

						req.type = <span class="hljs-string">'js'</span>;
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Mix in type-specific default options, but don’t overwrite any
options that have already been set.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				Y.mix(req, req.type === <span class="hljs-string">'js'</span> ? <span class="hljs-keyword">this</span>.jsOptions : <span class="hljs-keyword">this</span>.cssOptions,
					<span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>Give the node an id attribute if it doesn’t already have one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				req.attributes.id || (req.attributes.id = Y.guid());</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Backcompat for &lt;3.5.0 behavior.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (req.win) {
					req.doc = req.win.document;
				} <span class="hljs-keyword">else</span> {
					req.win = req.doc.defaultView || req.doc.parentWindow;
				}

				<span class="hljs-keyword">if</span> (req.charset) {
					req.attributes.charset = req.charset;
				}

				requests.push(req);
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Transaction(requests, options);
		},

		<span class="hljs-attr">_load</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, urls, options, callback</span>) </span>{
			<span class="hljs-keyword">var</span> transaction;</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>Allow callback as third param.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'function'</span>) {
				callback = options;
				options  = {};
			}

			options || (options = {});
			options.type = type;

			options._onFinish = Get._onTransactionFinish;

			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._env) {
				<span class="hljs-keyword">this</span>._getEnv();
			}

			transaction = <span class="hljs-keyword">this</span>._getTransaction(urls, options);

			<span class="hljs-keyword">this</span>._queue.push({
				<span class="hljs-attr">callback</span>   : callback,
				<span class="hljs-attr">transaction</span>: transaction
			});

			<span class="hljs-keyword">this</span>._next();

			<span class="hljs-keyword">return</span> transaction;
		},

		<span class="hljs-attr">_onTransactionFinish</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			Get._pending = <span class="hljs-literal">null</span>;
			Get._next();
		},

		<span class="hljs-attr">_next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> item;

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._pending) {
				<span class="hljs-keyword">return</span>;
			}

			item = <span class="hljs-keyword">this</span>._queue.shift();

			<span class="hljs-keyword">if</span> (item) {
				<span class="hljs-keyword">this</span>._pending = item;
				item.transaction.execute(item.callback);
			}
		},

		<span class="hljs-attr">_purge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodes</span>) </span>{
			<span class="hljs-keyword">var</span> purgeNodes    = <span class="hljs-keyword">this</span>._purgeNodes,
				isTransaction = nodes !== purgeNodes,
				index, node;

			<span class="hljs-keyword">while</span> (node = nodes.pop()) { <span class="hljs-comment">// assignment</span></pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Don’t purge nodes that haven’t finished loading (or errored out),
since this can hang the transaction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!node._yuiget_finished) {
					<span class="hljs-keyword">continue</span>;
				}

				node.parentNode &amp;&amp; node.parentNode.removeChild(node);</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>If this is a transaction-level purge and this node also exists in
the Get-level _purgeNodes array, we need to remove it from
_purgeNodes to avoid creating a memory leak. The indexOf lookup
sucks, but until we get WeakMaps, this is the least troublesome
way to do this (we can’t just hold onto node ids because they may
not be in the same document).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (isTransaction) {
					index = Y.Array.indexOf(purgeNodes, node);

					<span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">-1</span>) {
						purgeNodes.splice(index, <span class="hljs-number">1</span>);
					}
				}
			}
		}
	};

	<span class="hljs-comment">/**
	 Alias for `js()`.

	 @method script
	 @static
	 **/</span>
	Get.script = Get.js;

	<span class="hljs-comment">/**
	 Represents a Get transaction, which may contain requests for one or more JS or
	 CSS files.

	 This class should not be instantiated manually. Instances will be created and
	 returned as needed by Y.Get's `css()`, `js()`, and `load()` methods.

	 @class Get.Transaction
	 @constructor
	 @since 3.5.0
	 **/</span>
	Get.Transaction = Transaction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">requests, options</span>) </span>{
		<span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

		self.id       = Transaction._lastId += <span class="hljs-number">1</span>;
		self.data     = options.data;
		self.errors   = [];
		self.nodes    = [];
		self.options  = options;
		self.requests = requests;

		self._callbacks = []; <span class="hljs-comment">// callbacks to call after execution finishes</span>
		self._queue     = [];
		self._reqsWaiting   = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>Deprecated pre-3.5.0 properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		self.tId = self.id; <span class="hljs-comment">// Use `id` instead.</span>
		self.win = options.win || Y.config.win;
	};

	<span class="hljs-comment">/**
	 Arbitrary data object associated with this transaction.

	 This object comes from the options passed to `Get.css()`, `Get.js()`, or
	 `Get.load()`, and will be `undefined` if no data object was specified.

	 @property {Object} data
	 **/</span>

	<span class="hljs-comment">/**
	 Array of errors that have occurred during this transaction, if any.

	 @since 3.5.0
	 @property {Object[]} errors
	 @property {String} errors.error Error message.
	 @property {Object} errors.request Request object related to the error.
	 **/</span>

	<span class="hljs-comment">/**
	 Numeric id for this transaction, unique among all transactions within the same
	 YUI sandbox in the current pageview.

	 @property {Number} id
	 @since 3.5.0
	 **/</span>

	<span class="hljs-comment">/**
	 HTMLElement nodes (native ones, not YUI Node instances) that have been inserted
	 during the current transaction.

	 @property {HTMLElement[]} nodes
	 **/</span>

	<span class="hljs-comment">/**
	 Options associated with this transaction.

	 See `Get.options` for the full list of available options.

	 @property {Object} options
	 @since 3.5.0
	 **/</span>

	<span class="hljs-comment">/**
	 Request objects contained in this transaction. Each request object represents
	 one CSS or JS URL that will be (or has been) requested and loaded into the page.

	 @property {Object} requests
	 @since 3.5.0
	 **/</span>

	<span class="hljs-comment">/**
	 Id of the most recent transaction.

	 @property _lastId
	 @type Number
	 @protected
	 @static
	 **/</span>
	Transaction._lastId = <span class="hljs-number">0</span>;

	Transaction.prototype = {</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>– Public Properties —————————————————-</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 Current state of this transaction. One of "new", "executing", or "done".

		 @property _state
		 @type String
		 @protected
		 **/</span>
		_state: <span class="hljs-string">'new'</span>, <span class="hljs-comment">// "new", "executing", or "done"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>– Public Methods ——————————————————-</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 Aborts this transaction.

		 This will cause the transaction's `onFailure` callback to be called and
		 will prevent any new script and link nodes from being added to the document,
		 but any resources that have already been requested will continue loading
		 (there's no safe way to prevent this, unfortunately).

		 @method abort
		 @param {String} [msg="Aborted."] Optional message to use in the `errors`
		 array describing why the transaction was aborted.
		 **/</span>
		abort: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>{
			<span class="hljs-keyword">this</span>._pending    = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">this</span>._pendingCSS = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">this</span>._pollTimer  = clearTimeout(<span class="hljs-keyword">this</span>._pollTimer);
			<span class="hljs-keyword">this</span>._queue      = [];
			<span class="hljs-keyword">this</span>._reqsWaiting    = <span class="hljs-number">0</span>;

			<span class="hljs-keyword">this</span>.errors.push({<span class="hljs-attr">error</span>: msg || <span class="hljs-string">'Aborted'</span>});
			<span class="hljs-keyword">this</span>._finish();
		},

		<span class="hljs-comment">/**
		 Begins execting the transaction.

		 There's usually no reason to call this manually, since Get will call it
		 automatically when other pending transactions have finished. If you really
		 want to execute your transaction before Get does, you can, but be aware that
		 this transaction's scripts may end up executing before the scripts in other
		 pending transactions.

		 If the transaction is already executing, the specified callback (if any)
		 will be queued and called after execution finishes. If the transaction has
		 already finished, the callback will be called immediately (the transaction
		 will not be executed again).

		 @method execute
		 @param {Function} callback Callback function to execute after all requests
		 in the transaction are complete, or after the transaction is aborted.
		 **/</span>
		execute: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
			<span class="hljs-keyword">var</span> self     = <span class="hljs-keyword">this</span>,
				requests = self.requests,
				state    = self._state,
				i, len, queue, req;

			<span class="hljs-keyword">if</span> (state === <span class="hljs-string">'done'</span>) {
				callback &amp;&amp; callback(self.errors.length ? self.errors : <span class="hljs-literal">null</span>, self);
				<span class="hljs-keyword">return</span>;
			} <span class="hljs-keyword">else</span> {
				callback &amp;&amp; self._callbacks.push(callback);

				<span class="hljs-keyword">if</span> (state === <span class="hljs-string">'executing'</span>) {
					<span class="hljs-keyword">return</span>;
				}
			}

			self._state = <span class="hljs-string">'executing'</span>;
			self._queue = queue = [];

			<span class="hljs-keyword">if</span> (self.options.timeout) {
				self._timeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
					self.abort(<span class="hljs-string">'Timeout'</span>);
				}, self.options.timeout);
			}

			self._reqsWaiting = requests.length;

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = requests.length; i &lt; len; ++i) {
				req = requests[i];

				<span class="hljs-keyword">if</span> (req.async || req.type === <span class="hljs-string">'css'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>No need to queue CSS or fully async JS.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					self._insert(req);
				} <span class="hljs-keyword">else</span> {
					queue.push(req);
				}
			}

			self._next();
		},

		<span class="hljs-comment">/**
		 Manually purges any `&lt;script&gt;` or `&lt;link&gt;` nodes this transaction has
		 created.

		 Be careful when purging a transaction that contains CSS requests, since
		 removing `&lt;link&gt;` nodes will also remove any styles they applied.

		 @method purge
		 **/</span>
		purge: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
			Get._purge(<span class="hljs-keyword">this</span>.nodes);
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>– Protected Methods —————————————————-</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_createNode: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, attrs, doc</span>) </span>{
			<span class="hljs-keyword">var</span> node = doc.createElement(name),
				attr, testEl;

			<span class="hljs-keyword">if</span> (!CUSTOM_ATTRS) {</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>IE6 and IE7 expect property names rather than attribute names for
certain attributes. Rather than sniffing, we do a quick feature
test the first time _createNode() runs to determine whether we
need to provide a workaround.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				testEl = doc.createElement(<span class="hljs-string">'div'</span>);
				testEl.setAttribute(<span class="hljs-string">'class'</span>, <span class="hljs-string">'a'</span>);

				CUSTOM_ATTRS = testEl.className === <span class="hljs-string">'a'</span> ? {} : {
					<span class="hljs-string">'for'</span>  : <span class="hljs-string">'htmlFor'</span>,
					<span class="hljs-string">'class'</span>: <span class="hljs-string">'className'</span>
				};
			}

			<span class="hljs-keyword">for</span> (attr <span class="hljs-keyword">in</span> attrs) {
				<span class="hljs-keyword">if</span> (attrs.hasOwnProperty(attr)) {
					node.setAttribute(CUSTOM_ATTRS[attr] || attr, attrs[attr]);
				}
			}

			<span class="hljs-keyword">return</span> node;
		},

		<span class="hljs-attr">_finish</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> errors  = <span class="hljs-keyword">this</span>.errors.length ? <span class="hljs-keyword">this</span>.errors : <span class="hljs-literal">null</span>,
				options = <span class="hljs-keyword">this</span>.options,
				thisObj = options.context || <span class="hljs-keyword">this</span>,
				data, i, len;

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._state === <span class="hljs-string">'done'</span>) {
				<span class="hljs-keyword">return</span>;
			}

			<span class="hljs-keyword">this</span>._state = <span class="hljs-string">'done'</span>;

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = <span class="hljs-keyword">this</span>._callbacks.length; i &lt; len; ++i) {
				<span class="hljs-keyword">this</span>._callbacks[i].call(thisObj, errors, <span class="hljs-keyword">this</span>);
			}

			data = <span class="hljs-keyword">this</span>._getEventData();

			<span class="hljs-keyword">if</span> (errors) {
				<span class="hljs-keyword">if</span> (options.onTimeout &amp;&amp; errors[errors.length - <span class="hljs-number">1</span>].error === <span class="hljs-string">'Timeout'</span>) {
					options.onTimeout.call(thisObj, data);
				}

				<span class="hljs-keyword">if</span> (options.onFailure) {
					options.onFailure.call(thisObj, data);
				}
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.onSuccess) {
				options.onSuccess.call(thisObj, data);
			}

			<span class="hljs-keyword">if</span> (options.onEnd) {
				options.onEnd.call(thisObj, data);
			}

			<span class="hljs-keyword">if</span> (options._onFinish) {
				options._onFinish();
			}
		},

		<span class="hljs-attr">_getEventData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req</span>) </span>{
			<span class="hljs-keyword">if</span> (req) {</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>This merge is necessary for backcompat. I hate it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> Y.merge(<span class="hljs-keyword">this</span>, {
					<span class="hljs-attr">abort</span>  : <span class="hljs-keyword">this</span>.abort, <span class="hljs-comment">// have to copy these because the prototype isn't preserved</span>
					purge  : <span class="hljs-keyword">this</span>.purge,
					<span class="hljs-attr">request</span>: req,
					<span class="hljs-attr">url</span>    : req.url,
					<span class="hljs-attr">win</span>    : req.win
				});
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
			}
		},

		<span class="hljs-attr">_getInsertBefore</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req</span>) </span>{
			<span class="hljs-keyword">var</span> doc = req.doc,
				el  = req.insertBefore,
				cache, cachedNode, docStamp;

			<span class="hljs-keyword">if</span> (el) {
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span> ? doc.getElementById(el) : el;
			}

			cache    = Get._insertCache;
			docStamp = Y.stamp(doc);

			<span class="hljs-keyword">if</span> ((el = cache[docStamp])) { <span class="hljs-comment">// assignment</span>
				<span class="hljs-keyword">return</span> el;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>Inserting before a <base> tag apparently works around an IE bug
(according to a comment from pre-3.5.0 Y.Get), but I’m not sure what
bug that is, exactly. Better safe than sorry?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ((el = doc.getElementsByTagName(<span class="hljs-string">'base'</span>)[<span class="hljs-number">0</span>])) { <span class="hljs-comment">// assignment</span>
				<span class="hljs-keyword">return</span> (cache[docStamp] = el);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>Look for a <head> element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			el = doc.head || doc.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>];

			<span class="hljs-keyword">if</span> (el) {</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>Create a marker node at the end of <head> to use as an insertion
point. Inserting before this node will ensure that all our CSS
gets inserted in the correct order, to maintain style precedence.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				el.appendChild(doc.createTextNode(<span class="hljs-string">''</span>));
				<span class="hljs-keyword">return</span> (cache[docStamp] = el.lastChild);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>If all else fails, just insert before the first script node on the
page, which is virtually guaranteed to exist.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> (cache[docStamp] = doc.getElementsByTagName(<span class="hljs-string">'script'</span>)[<span class="hljs-number">0</span>]);
		},

		<span class="hljs-attr">_insert</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req</span>) </span>{
			<span class="hljs-keyword">var</span> env          = Get._env,
				insertBefore = <span class="hljs-keyword">this</span>._getInsertBefore(req),
				isScript     = req.type === <span class="hljs-string">'js'</span>,
				node         = req.node,
				self         = <span class="hljs-keyword">this</span>,
				ua           = Y.UA,
				cssTimeout, nodeType;

			<span class="hljs-keyword">if</span> (!node) {
				<span class="hljs-keyword">if</span> (isScript) {
					nodeType = <span class="hljs-string">'script'</span>;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!env.cssLoad &amp;&amp; ua.gecko) {
					nodeType = <span class="hljs-string">'style'</span>;
				} <span class="hljs-keyword">else</span> {
					nodeType = <span class="hljs-string">'link'</span>;
				}

				node = req.node = <span class="hljs-keyword">this</span>._createNode(nodeType, req.attributes,
					req.doc);
			}

			<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onError</span>(<span class="hljs-params"></span>) </span>{
				self._progress(<span class="hljs-string">'Failed to load '</span> + req.url, req);
			}

			<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLoad</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">if</span> (cssTimeout) {
					clearTimeout(cssTimeout);
				}

				self._progress(<span class="hljs-literal">null</span>, req);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>Deal with script asynchronicity.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (isScript) {
				node.setAttribute(<span class="hljs-string">'src'</span>, req.url);

				<span class="hljs-keyword">if</span> (req.async) {</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>Explicitly indicate that we want the browser to execute this
script asynchronously. This is necessary for older browsers
like Firefox &lt;4.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node.async = <span class="hljs-literal">true</span>;
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">if</span> (env.async) {</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>This browser treats injected scripts as async by default
(standard HTML5 behavior) but asynchronous loading isn’t
desired, so tell the browser not to mark this script as
async.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						node.async = <span class="hljs-literal">false</span>;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>If this browser doesn’t preserve script execution order based
on insertion order, we’ll need to avoid inserting other
scripts until this one finishes loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!env.preservesScriptOrder) {
						<span class="hljs-keyword">this</span>._pending = req;
					}
				}
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">if</span> (!env.cssLoad &amp;&amp; ua.gecko) {</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>In Firefox <9, we can import the requested URL into a <style>
node and poll for the existence of node.sheet.cssRules. This
gives us a reliable way to determine CSS load completion that
also works for cross-domain stylesheets.</p>
<p>Props to Zach Leatherman for calling my attention to this
technique.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node.innerHTML = (req.attributes.charset ?
						<span class="hljs-string">'@charset "'</span> + req.attributes.charset + <span class="hljs-string">'";'</span> : <span class="hljs-string">''</span>) +
						<span class="hljs-string">'@import "'</span> + req.url + <span class="hljs-string">'";'</span>;
				} <span class="hljs-keyword">else</span> {
					node.setAttribute(<span class="hljs-string">'href'</span>, req.url);
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>Inject the node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (isScript &amp;&amp; ua.ie &amp;&amp; (ua.ie &lt; <span class="hljs-number">9</span> || (<span class="hljs-built_in">document</span>.documentMode &amp;&amp; <span class="hljs-built_in">document</span>.documentMode &lt; <span class="hljs-number">9</span>))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>Script on IE &lt; 9, and IE 9+ when in IE 8 or older modes, including quirks mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				node.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
					<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/loaded|complete/</span>.test(node.readyState)) {
						node.onreadystatechange = <span class="hljs-literal">null</span>;
						onLoad();
					}
				};
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isScript &amp;&amp; !env.cssLoad) {</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>CSS on Firefox &lt;9 or WebKit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>._poll(req);
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>Script or CSS on everything else. Using DOM 0 events because that
evens the playing field with older IEs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
				<span class="hljs-keyword">if</span> (ua.ie &gt;= <span class="hljs-number">10</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>We currently need to introduce a timeout for IE10, since it 
calls onerror/onload synchronously for 304s - messing up existing
program flow. </p>

            </div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>Remove this block if the following bug gets fixed by GA
<a href="https://connect.microsoft.com/IE/feedback/details/763871/dynamically-loaded-scripts-with-304s-responses-interrupt-the-currently-executing-js-thread-onload">https://connect.microsoft.com/IE/feedback/details/763871/dynamically-loaded-scripts-with-304s-responses-interrupt-the-currently-executing-js-thread-onload</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					node.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ setTimeout(onError, <span class="hljs-number">0</span>); };
					node.onload  = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ setTimeout(onLoad, <span class="hljs-number">0</span>); };
				} <span class="hljs-keyword">else</span> {
					node.onerror = onError;
					node.onload  = onLoad;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>If this browser doesn’t fire an event when CSS fails to load,
fail after a timeout to avoid blocking the transaction queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!env.cssFail &amp;&amp; !isScript) {
					cssTimeout = setTimeout(onError, req.timeout || <span class="hljs-number">3000</span>);
				}
			}

			<span class="hljs-keyword">this</span>.nodes.push(node);
			insertBefore.parentNode.insertBefore(node, insertBefore);
		},

		<span class="hljs-attr">_next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._pending) {
				<span class="hljs-keyword">return</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>If there are requests in the queue, insert the next queued request.
Otherwise, if we’re waiting on already-inserted requests to finish,
wait longer. If there are no queued requests and we’re not waiting
for anything to load, then we’re done!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._queue.length) {
				<span class="hljs-keyword">this</span>._insert(<span class="hljs-keyword">this</span>._queue.shift());
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._reqsWaiting) {
				<span class="hljs-keyword">this</span>._finish();
			}
		},

		<span class="hljs-attr">_poll</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newReq</span>) </span>{
			<span class="hljs-keyword">var</span> self       = <span class="hljs-keyword">this</span>,
				pendingCSS = self._pendingCSS,
				isWebKit   = Y.UA.webkit,
				i, hasRules, j, nodeHref, req, sheets;

			<span class="hljs-keyword">if</span> (newReq) {
				pendingCSS || (pendingCSS = self._pendingCSS = []);
				pendingCSS.push(newReq);

				<span class="hljs-keyword">if</span> (self._pollTimer) {</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>A poll timeout is already pending, so no need to create a
new one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span>;
				}
			}

			self._pollTimer = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>Note: in both the WebKit and Gecko hacks below, a CSS URL that 404s
will still be treated as a success. There’s no good workaround for
this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; pendingCSS.length; ++i) {
				req = pendingCSS[i];

				<span class="hljs-keyword">if</span> (isWebKit) {</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>Look for a stylesheet matching the pending URL.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					sheets   = req.doc.styleSheets;
					j        = sheets.length;
					nodeHref = req.node.href;

					<span class="hljs-keyword">while</span> (--j &gt;= <span class="hljs-number">0</span>) {
						<span class="hljs-keyword">if</span> (sheets[j].href === nodeHref) {
							pendingCSS.splice(i, <span class="hljs-number">1</span>);
							i -= <span class="hljs-number">1</span>;
							self._progress(<span class="hljs-literal">null</span>, req);
							<span class="hljs-keyword">break</span>;
						}
					}
				} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>Many thanks to Zach Leatherman for calling my attention to
the @import-based cross-domain technique used here, and to
Oleg Slobodskoi for an earlier same-domain implementation.</p>
<p>See Zach’s blog for more details:
<a href="http://www.zachleat.com/web/2010/07/29/load-css-dynamically/">http://www.zachleat.com/web/2010/07/29/load-css-dynamically/</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>We don’t really need to store this value since we never
use it again, but if we don’t store it, Closure Compiler
assumes the code is useless and removes it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						hasRules = !!req.node.sheet.cssRules;</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>If we get here, the stylesheet has loaded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						pendingCSS.splice(i, <span class="hljs-number">1</span>);
						i -= <span class="hljs-number">1</span>;
						self._progress(<span class="hljs-literal">null</span>, req);
					} <span class="hljs-keyword">catch</span> (ex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>An exception means the stylesheet is still loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					}
				}
			}

			<span class="hljs-keyword">if</span> (pendingCSS.length) {
				self._pollTimer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
					self._poll.call(self);
				}, self.options.pollInterval);
			}
		},

		<span class="hljs-attr">_progress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, req</span>) </span>{
			<span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options;

			<span class="hljs-keyword">if</span> (err) {
				req.error = err;

				<span class="hljs-keyword">this</span>.errors.push({
					<span class="hljs-attr">error</span>  : err,
					<span class="hljs-attr">request</span>: req
				});

			}

			req.node._yuiget_finished = req.finished = <span class="hljs-literal">true</span>;

			<span class="hljs-keyword">if</span> (options.onProgress) {
				options.onProgress.call(options.context || <span class="hljs-keyword">this</span>,
					<span class="hljs-keyword">this</span>._getEventData(req));
			}

			<span class="hljs-keyword">if</span> (req.autopurge) {</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>Pre-3.5.0 Get always excludes the most recent node from an
autopurge. I find this odd, but I’m keeping that behavior for
the sake of backcompat.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				Get._autoPurge(<span class="hljs-keyword">this</span>.options.purgethreshold);
				Get._purgeNodes.push(req.node);
			}

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._pending === req) {
				<span class="hljs-keyword">this</span>._pending = <span class="hljs-literal">null</span>;
			}

			<span class="hljs-keyword">this</span>._reqsWaiting -= <span class="hljs-number">1</span>;

			<span class="hljs-keyword">this</span>._next();
		}
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
YUI.add(<span class="hljs-string">'features'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-keyword">var</span> feature_tests = {};

	<span class="hljs-comment">/**
	 Contains the core of YUI's feature test architecture.
	 @module features
	 */</span>

	<span class="hljs-comment">/**
	 * Feature detection
	 * @class Features
	 * @static
	 */</span>

	Y.mix(Y.namespace(<span class="hljs-string">'Features'</span>), {

		<span class="hljs-comment">/**
		 * Object hash of all registered feature tests
		 * @property tests
		 * @type Object
		 */</span>
		tests: feature_tests,

		<span class="hljs-comment">/**
		 * Add a test to the system
		 *
		 *   ```
		 *   Y.Features.add("load", "1", {});
		 *   ```
		 *
		 * @method add
		 * @param {String} cat The category, right now only 'load' is supported
		 * @param {String} name The number sequence of the test, how it's reported in the URL or config: 1, 2, 3
		 * @param {Object} o Object containing test properties
		 * @param {String} o.name The name of the test
		 * @param {Function} o.test The test function to execute, the only argument to the function is the `Y` instance
		 * @param {String} o.trigger The module that triggers this test.
		 */</span>
		add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cat, name, o</span>) </span>{
			feature_tests[cat] = feature_tests[cat] || {};
			feature_tests[cat][name] = o;
		},
		<span class="hljs-comment">/**
		 * Execute all tests of a given category and return the serialized results
		 *
		 *   ```
		 *   caps=1:1;2:1;3:0
		 *   ```
		 * @method all
		 * @param {String} cat The category to execute
		 * @param {Array} args The arguments to pass to the test function
		 * @return {String} A semi-colon separated string of tests and their success/failure: 1:1;2:1;3:0
		 */</span>
		all: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cat, args</span>) </span>{
			<span class="hljs-keyword">var</span> cat_o = feature_tests[cat],</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>results = {};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				result = [];
			<span class="hljs-keyword">if</span> (cat_o) {
				Y.Object.each(cat_o, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, k</span>) </span>{
					result.push(k + <span class="hljs-string">':'</span> + (Y.Features.test(cat, k, args) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));
				});
			}

			<span class="hljs-keyword">return</span> (result.length) ? result.join(<span class="hljs-string">';'</span>) : <span class="hljs-string">''</span>;
		},
		<span class="hljs-comment">/**
		 * Run a sepecific test and return a Boolean response.
		 *
		 *   ```
		 *   Y.Features.test("load", "1");
		 *   ```
		 *
		 * @method test
		 * @param {String} cat The category of the test to run
		 * @param {String} name The name of the test to run
		 * @param {Array} args The arguments to pass to the test function
		 * @return {Boolean} True or false if the test passed/failed.
		 */</span>
		test: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cat, name, args</span>) </span>{
			args = args || [];
			<span class="hljs-keyword">var</span> result, ua, test,
				cat_o = feature_tests[cat],
				feature = cat_o &amp;&amp; cat_o[name];

			<span class="hljs-keyword">if</span> (!feature) {
			} <span class="hljs-keyword">else</span> {

				result = feature.result;

				<span class="hljs-keyword">if</span> (Y.Lang.isUndefined(result)) {

					ua = feature.ua;
					<span class="hljs-keyword">if</span> (ua) {
						result = (Y.UA[ua]);
					}

					test = feature.test;
					<span class="hljs-keyword">if</span> (test &amp;&amp; ((!ua) || result)) {
						result = test.apply(Y, args);
					}

					feature.result = result;
				}
			}

			<span class="hljs-keyword">return</span> result;
		}
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>Y.Features.add(“load”, “1”, {});
Y.Features.test(“load”, “1”);
caps=1:1;2:0;3:1;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-comment">/* This file is auto-generated by src/loader/scripts/meta_join.js */</span>
	<span class="hljs-keyword">var</span> add = Y.Features.add;</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p>app-transitions-native</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'0'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"app-transitions-native"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> doc  = Y.config.doc,
				node = doc ? doc.documentElement : <span class="hljs-literal">null</span>;

			<span class="hljs-keyword">if</span> (node &amp;&amp; node.style) {
				<span class="hljs-keyword">return</span> (<span class="hljs-string">'MozTransition'</span> <span class="hljs-keyword">in</span> node.style || <span class="hljs-string">'WebkitTransition'</span> <span class="hljs-keyword">in</span> node.style || <span class="hljs-string">'transition'</span> <span class="hljs-keyword">in</span> node.style);
			}

			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"app-transitions"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>autocomplete-list-keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'1'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"autocomplete-list-keys"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>Only add keyboard support to autocomplete-list if this doesn’t appear to
be an iOS or Android-based mobile device.</p>
<p>There’s currently no feasible way to actually detect whether a device has
a hardware keyboard, so this sniff will have to do. It can easily be
overridden by manually loading the autocomplete-list-keys module.</p>
<p>Worth noting: even though iOS supports bluetooth keyboards, Mobile Safari
doesn’t fire the keyboard events used by AutoCompleteList, so there’s
no point loading the -keys module even when a bluetooth keyboard may be
available.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> !(Y.UA.ios || Y.UA.android);
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"autocomplete-list"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>dd-gestures</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'2'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"dd-gestures"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"dd-drag"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"touchEnabled"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>dom-style-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'3'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"dom-style-ie"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{

			<span class="hljs-keyword">var</span> testFeature = Y.Features.test,
				addFeature = Y.Features.add,
				WINDOW = Y.config.win,
				DOCUMENT = Y.config.doc,
				DOCUMENT_ELEMENT = <span class="hljs-string">'documentElement'</span>,
				ret = <span class="hljs-literal">false</span>;

			addFeature(<span class="hljs-string">'style'</span>, <span class="hljs-string">'computedStyle'</span>, {
				<span class="hljs-attr">test</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					<span class="hljs-keyword">return</span> WINDOW &amp;&amp; <span class="hljs-string">'getComputedStyle'</span> <span class="hljs-keyword">in</span> WINDOW;
				}
			});

			addFeature(<span class="hljs-string">'style'</span>, <span class="hljs-string">'opacity'</span>, {
				<span class="hljs-attr">test</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					<span class="hljs-keyword">return</span> DOCUMENT &amp;&amp; <span class="hljs-string">'opacity'</span> <span class="hljs-keyword">in</span> DOCUMENT[DOCUMENT_ELEMENT].style;
				}
			});

			ret =  (!testFeature(<span class="hljs-string">'style'</span>, <span class="hljs-string">'opacity'</span>) &amp;&amp;
				!testFeature(<span class="hljs-string">'style'</span>, <span class="hljs-string">'computedStyle'</span>));

			<span class="hljs-keyword">return</span> ret;
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"dom-style"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>editor-para-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'4'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"editor-para-ie"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"editor-para"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"ie"</span>,
		<span class="hljs-string">"when"</span>: <span class="hljs-string">"instead"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>event-base-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'5'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"event-base-ie"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> imp = Y.config.doc &amp;&amp; Y.config.doc.implementation;
			<span class="hljs-keyword">return</span> (imp &amp;&amp; (!imp.hasFeature(<span class="hljs-string">'Events'</span>, <span class="hljs-string">'2.0'</span>)));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"node-base"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>graphics-canvas</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'6'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-canvas"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				useCanvas = Y.config.defaultGraphicEngine &amp;&amp; Y.config.defaultGraphicEngine == <span class="hljs-string">"canvas"</span>,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>),
				svg = (DOCUMENT &amp;&amp; DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>));
			<span class="hljs-keyword">return</span> (!svg || useCanvas) &amp;&amp; (canvas &amp;&amp; canvas.getContext &amp;&amp; canvas.getContext(<span class="hljs-string">"2d"</span>));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>graphics-canvas-default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'7'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-canvas-default"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				useCanvas = Y.config.defaultGraphicEngine &amp;&amp; Y.config.defaultGraphicEngine == <span class="hljs-string">"canvas"</span>,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>),
				svg = (DOCUMENT &amp;&amp; DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>));
			<span class="hljs-keyword">return</span> (!svg || useCanvas) &amp;&amp; (canvas &amp;&amp; canvas.getContext &amp;&amp; canvas.getContext(<span class="hljs-string">"2d"</span>));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>graphics-svg</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'8'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-svg"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				useSVG = !Y.config.defaultGraphicEngine || Y.config.defaultGraphicEngine != <span class="hljs-string">"canvas"</span>,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>),
				svg = (DOCUMENT &amp;&amp; DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>));

			<span class="hljs-keyword">return</span> svg &amp;&amp; (useSVG || !canvas);
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>graphics-svg-default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'9'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-svg-default"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				useSVG = !Y.config.defaultGraphicEngine || Y.config.defaultGraphicEngine != <span class="hljs-string">"canvas"</span>,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>),
				svg = (DOCUMENT &amp;&amp; DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>));

			<span class="hljs-keyword">return</span> svg &amp;&amp; (useSVG || !canvas);
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>graphics-vml</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'10'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-vml"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>);
			<span class="hljs-keyword">return</span> (DOCUMENT &amp;&amp; !DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>) &amp;&amp; (!canvas || !canvas.getContext || !canvas.getContext(<span class="hljs-string">"2d"</span>)));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>graphics-vml-default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'11'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-vml-default"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>);
			<span class="hljs-keyword">return</span> (DOCUMENT &amp;&amp; !DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>) &amp;&amp; (!canvas || !canvas.getContext || !canvas.getContext(<span class="hljs-string">"2d"</span>)));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>history-hash-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'12'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"history-hash-ie"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> docMode = Y.config.doc &amp;&amp; Y.config.doc.documentMode;

			<span class="hljs-keyword">return</span> Y.UA.ie &amp;&amp; (!(<span class="hljs-string">'onhashchange'</span> <span class="hljs-keyword">in</span> Y.config.win) ||
				!docMode || docMode &lt; <span class="hljs-number">8</span>);
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"history-hash"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <p>io-nodejs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'13'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"io-nodejs"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"io-base"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"nodejs"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <p>scrollview-base-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'14'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"scrollview-base-ie"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"scrollview-base"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"ie"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>selector-css2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'15'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"selector-css2"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				ret = DOCUMENT &amp;&amp; !(<span class="hljs-string">'querySelectorAll'</span> <span class="hljs-keyword">in</span> DOCUMENT);

			<span class="hljs-keyword">return</span> ret;
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"selector"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p>transition-timer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'16'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"transition-timer"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				node = (DOCUMENT) ? DOCUMENT.documentElement: <span class="hljs-literal">null</span>,
				ret = <span class="hljs-literal">true</span>;

			<span class="hljs-keyword">if</span> (node &amp;&amp; node.style) {
				ret = !(<span class="hljs-string">'MozTransition'</span> <span class="hljs-keyword">in</span> node.style || <span class="hljs-string">'WebkitTransition'</span> <span class="hljs-keyword">in</span> node.style || <span class="hljs-string">'transition'</span> <span class="hljs-keyword">in</span> node.style);
			}

			<span class="hljs-keyword">return</span> ret;
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"transition"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>widget-base-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'17'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"widget-base-ie"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"widget-base"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"ie"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <p>yql-nodejs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'18'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"yql-nodejs"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"yql"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"nodejs"</span>,
		<span class="hljs-string">"when"</span>: <span class="hljs-string">"after"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>yql-winjs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'19'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"yql-winjs"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"yql"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"winjs"</span>,
		<span class="hljs-string">"when"</span>: <span class="hljs-string">"after"</span>
	});

}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
YUI.add(<span class="hljs-string">'intl-base'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * The Intl utility provides a central location for managing sets of
	 * localized resources (strings and formatting patterns).
	 *
	 * @class Intl
	 * @uses EventTarget
	 * @static
	 */</span>

	<span class="hljs-keyword">var</span> SPLIT_REGEX = <span class="hljs-regexp">/[, ]/</span>;

	Y.mix(Y.namespace(<span class="hljs-string">'Intl'</span>), {

		<span class="hljs-comment">/**
		 * Returns the language among those available that
		 * best matches the preferred language list, using the Lookup
		 * algorithm of BCP 47.
		 * If none of the available languages meets the user's preferences,
		 * then "" is returned.
		 * Extended language ranges are not supported.
		 *
		 * @method lookupBestLang
		 * @param {String[] | String} preferredLanguages The list of preferred
		 * languages in descending preference order, represented as BCP 47
		 * language tags. A string array or a comma-separated list.
		 * @param {String[]} availableLanguages The list of languages
		 * that the application supports, represented as BCP 47 language
		 * tags.
		 *
		 * @return {String} The available language that best matches the
		 * preferred language list, or "".
		 * @since 3.1.0
		 */</span>
		lookupBestLang: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">preferredLanguages, availableLanguages</span>) </span>{

			<span class="hljs-keyword">var</span> i, language, result, index;</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>check whether the list of available languages contains language;
if so return it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scan</span>(<span class="hljs-params">language</span>) </span>{
				<span class="hljs-keyword">var</span> i;
				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; availableLanguages.length; i += <span class="hljs-number">1</span>) {
					<span class="hljs-keyword">if</span> (language.toLowerCase() ===
						availableLanguages[i].toLowerCase()) {
						<span class="hljs-keyword">return</span> availableLanguages[i];
					}
				}
			}

			<span class="hljs-keyword">if</span> (Y.Lang.isString(preferredLanguages)) {
				preferredLanguages = preferredLanguages.split(SPLIT_REGEX);
			}

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; preferredLanguages.length; i += <span class="hljs-number">1</span>) {
				language = preferredLanguages[i];
				<span class="hljs-keyword">if</span> (!language || language === <span class="hljs-string">'*'</span>) {
					<span class="hljs-keyword">continue</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>check the fallback sequence for one language</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">while</span> (language.length &gt; <span class="hljs-number">0</span>) {
					result = scan(language);
					<span class="hljs-keyword">if</span> (result) {
						<span class="hljs-keyword">return</span> result;
					} <span class="hljs-keyword">else</span> {
						index = language.lastIndexOf(<span class="hljs-string">'-'</span>);
						<span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
							language = language.substring(<span class="hljs-number">0</span>, index);</pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <p>one-character subtags get cut along with the
following subtag</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">2</span> &amp;&amp; language.charAt(index - <span class="hljs-number">2</span>) === <span class="hljs-string">'-'</span>) {
								language = language.substring(<span class="hljs-number">0</span>, index - <span class="hljs-number">2</span>);
							}
						} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>nothing available for this language</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">break</span>;
						}
					}
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
		}
	});


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
YUI.add(<span class="hljs-string">'yui-log'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Provides console log capability and exposes a custom event for
	 * console implementations. This module is a `core` YUI module, &lt;a href="../classes/YUI.html#method_log"&gt;it's documentation is located under the YUI class&lt;/a&gt;.
	 *
	 * @module yui
	 * @submodule yui-log
	 */</span>

	<span class="hljs-keyword">var</span> INSTANCE = Y,
		LOGEVENT = <span class="hljs-string">'yui:log'</span>,
		UNDEFINED = <span class="hljs-string">'undefined'</span>,
		LEVELS = { <span class="hljs-attr">debug</span>: <span class="hljs-number">1</span>,
			<span class="hljs-attr">info</span>: <span class="hljs-number">1</span>,
			<span class="hljs-attr">warn</span>: <span class="hljs-number">1</span>,
			<span class="hljs-attr">error</span>: <span class="hljs-number">1</span> };

	<span class="hljs-comment">/**
	 * If the 'debug' config is true, a 'yui:log' event will be
	 * dispatched, which the Console widget and anything else
	 * can consume.  If the 'useBrowserConsole' config is true, it will
	 * write to the browser console if available.  YUI-specific log
	 * messages will only be present in the -debug versions of the
	 * JS files.  The build system is supposed to remove log statements
	 * from the raw and minified versions of the files.
	 *
	 * @method log
	 * @for YUI
	 * @param  {String}  msg  The message to log.
	 * @param  {String}  cat  The log category for the message.  Default
	 *                        categories are "info", "warn", "error", time".
	 *                        Custom categories can be used as well. (opt).
	 * @param  {String}  src  The source of the the message (opt).
	 * @param  {boolean} silent If true, the log event won't fire.
	 * @return {YUI}      YUI instance.
	 */</span>
	INSTANCE.log = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, cat, src, silent</span>) </span>{
		<span class="hljs-keyword">var</span> bail, excl, incl, m, f,
			Y = INSTANCE,
			c = Y.config,
			publisher = (Y.fire) ? Y : YUI.Env.globalEvents;</pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p>suppress log message if the config is off or the event stack
or the event call stack contains a consumer of the yui:log event</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (c.debug) {</pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p>apply source filters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			src = src || <span class="hljs-string">""</span>;
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> src !== <span class="hljs-string">"undefined"</span>) {
				excl = c.logExclude;
				incl = c.logInclude;
				<span class="hljs-keyword">if</span> (incl &amp;&amp; !(src <span class="hljs-keyword">in</span> incl)) {
					bail = <span class="hljs-number">1</span>;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (incl &amp;&amp; (src <span class="hljs-keyword">in</span> incl)) {
					bail = !incl[src];
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (excl &amp;&amp; (src <span class="hljs-keyword">in</span> excl)) {
					bail = excl[src];
				}
			}
			<span class="hljs-keyword">if</span> (!bail) {
				<span class="hljs-keyword">if</span> (c.useBrowserConsole) {
					m = (src) ? src + <span class="hljs-string">': '</span> + msg : msg;
					<span class="hljs-keyword">if</span> (Y.Lang.isFunction(c.logFn)) {
						c.logFn.call(Y, msg, cat, src);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> != UNDEFINED &amp;&amp; <span class="hljs-built_in">console</span>.log) {
						f = (cat &amp;&amp; <span class="hljs-built_in">console</span>[cat] &amp;&amp; (cat <span class="hljs-keyword">in</span> LEVELS)) ? cat : <span class="hljs-string">'log'</span>;
						<span class="hljs-built_in">console</span>[f](m);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> opera != UNDEFINED) {
						opera.postError(m);
					}
				}

				<span class="hljs-keyword">if</span> (publisher &amp;&amp; !silent) {

					<span class="hljs-keyword">if</span> (publisher == Y &amp;&amp; (!publisher.getEvent(LOGEVENT))) {
						publisher.publish(LOGEVENT, {
							<span class="hljs-attr">broadcast</span>: <span class="hljs-number">2</span>
						});
					}

					publisher.fire(LOGEVENT, {
						<span class="hljs-attr">msg</span>: msg,
						<span class="hljs-attr">cat</span>: cat,
						<span class="hljs-attr">src</span>: src
					});
				}
			}
		}

		<span class="hljs-keyword">return</span> Y;
	};

	<span class="hljs-comment">/**
	 * Write a system message.  This message will be preserved in the
	 * minified and raw versions of the YUI files, unlike log statements.
	 * @method message
	 * @for YUI
	 * @param  {String}  msg  The message to log.
	 * @param  {String}  cat  The log category for the message.  Default
	 *                        categories are "info", "warn", "error", time".
	 *                        Custom categories can be used as well. (opt).
	 * @param  {String}  src  The source of the the message (opt).
	 * @param  {boolean} silent If true, the log event won't fire.
	 * @return {YUI}      YUI instance.
	 */</span>
	INSTANCE.message = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">return</span> INSTANCE.log.apply(INSTANCE, <span class="hljs-built_in">arguments</span>);
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
YUI.add(<span class="hljs-string">'yui-later'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Provides a setTimeout/setInterval wrapper. This module is a `core` YUI module, &lt;a href="../classes/YUI.html#method_later"&gt;it's documentation is located under the YUI class&lt;/a&gt;.
	 *
	 * @module yui
	 * @submodule yui-later
	 */</span>

	<span class="hljs-keyword">var</span> NO_ARGS = [];

	<span class="hljs-comment">/**
	 * Executes the supplied function in the context of the supplied
	 * object 'when' milliseconds later.  Executes the function a
	 * single time unless periodic is set to true.
	 * @for YUI
	 * @method later
	 * @param when {int} the number of milliseconds to wait until the fn
	 * is executed.
	 * @param o the context object.
	 * @param fn {Function|String} the function to execute or the name of
	 * the method in the 'o' object to execute.
	 * @param data [Array] data that is provided to the function.  This
	 * accepts either a single item or an array.  If an array is provided,
	 * the function is executed with one parameter for each array item.
	 * If you need to pass a single array parameter, it needs to be wrapped
	 * in an array [myarray].
	 *
	 * Note: native methods in IE may not have the call and apply methods.
	 * In this case, it will work, but you are limited to four arguments.
	 *
	 * @param periodic {boolean} if true, executes continuously at supplied
	 * interval until canceled.
	 * @return {object} a timer object. Call the cancel() method on this
	 * object to stop the timer.
	 */</span>
	Y.later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">when, o, fn, data, periodic</span>) </span>{
		when = when || <span class="hljs-number">0</span>;
		data = (!Y.Lang.isUndefined(data)) ? Y.Array(data) : NO_ARGS;
		o = o || Y.config.win || Y;

		<span class="hljs-keyword">var</span> cancelled = <span class="hljs-literal">false</span>,
			method = (o &amp;&amp; Y.Lang.isString(fn)) ? o[fn] : fn,
			wrapper = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <p>IE 8- may execute a setInterval callback one last time
after clearInterval was called, so in order to preserve
the cancel() === no more runny-run, we have to jump through
an extra hoop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!cancelled) {
					<span class="hljs-keyword">if</span> (!method.apply) {
						method(data[<span class="hljs-number">0</span>], data[<span class="hljs-number">1</span>], data[<span class="hljs-number">2</span>], data[<span class="hljs-number">3</span>]);
					} <span class="hljs-keyword">else</span> {
						method.apply(o, data || NO_ARGS);
					}
				}
			},
			id = (periodic) ? setInterval(wrapper, when) : setTimeout(wrapper, when);

		<span class="hljs-keyword">return</span> {
			<span class="hljs-attr">id</span>: id,
			<span class="hljs-attr">interval</span>: periodic,
			<span class="hljs-attr">cancel</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				cancelled = <span class="hljs-literal">true</span>;
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.interval) {
					clearInterval(id);
				} <span class="hljs-keyword">else</span> {
					clearTimeout(id);
				}
			}
		};
	};

	Y.Lang.later = Y.later;



}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
YUI.add(<span class="hljs-string">'yui'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"use"</span>: [<span class="hljs-string">"get"</span>, <span class="hljs-string">"features"</span>, <span class="hljs-string">"intl-base"</span>, <span class="hljs-string">"yui-log"</span>, <span class="hljs-string">"yui-later"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'oop'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 Adds object inheritance and manipulation utilities to the YUI instance. This
	 module is required by most YUI components.

	 @module oop
	 **/</span>

	<span class="hljs-keyword">var</span> L            = Y.Lang,
		A            = Y.Array,
		OP           = <span class="hljs-built_in">Object</span>.prototype,
		CLONE_MARKER = <span class="hljs-string">'_~yuim~_'</span>,

		hasOwn   = OP.hasOwnProperty,
		toString = OP.toString;

	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">o, f, c, proto, action</span>) </span>{
		<span class="hljs-keyword">if</span> (o &amp;&amp; o[action] &amp;&amp; o !== Y) {
			<span class="hljs-keyword">return</span> o[action].call(o, f, c);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">switch</span> (A.test(o)) {
				<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
					<span class="hljs-keyword">return</span> A[action](o, f, c);
				<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
					<span class="hljs-keyword">return</span> A[action](Y.Array(o, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>), f, c);
				<span class="hljs-keyword">default</span>:
					<span class="hljs-keyword">return</span> Y.Object[action](o, f, c, proto);
			}
		}
	}

	<span class="hljs-comment">/**
	 Augments the _receiver_ with prototype properties from the _supplier_. The
	 receiver may be a constructor function or an object. The supplier must be a
	 constructor function.

	 If the _receiver_ is an object, then the _supplier_ constructor will be called
	 immediately after _receiver_ is augmented, with _receiver_ as the `this` object.

	 If the _receiver_ is a constructor function, then all prototype methods of
	 _supplier_ that are copied to _receiver_ will be sequestered, and the
	 _supplier_ constructor will not be called immediately. The first time any
	 sequestered method is called on the _receiver_'s prototype, all sequestered
	 methods will be immediately copied to the _receiver_'s prototype, the
	 _supplier_'s constructor will be executed, and finally the newly unsequestered
	 method that was called will be executed.

	 This sequestering logic sounds like a bunch of complicated voodoo, but it makes
	 it cheap to perform frequent augmentation by ensuring that suppliers'
	 constructors are only called if a supplied method is actually used. If none of
	 the supplied methods is ever used, then there's no need to take the performance
	 hit of calling the _supplier_'s constructor.

	 @method augment
	 @param {Function|Object} receiver Object or function to be augmented.
	 @param {Function} supplier Function that supplies the prototype properties with
	 which to augment the _receiver_.
	 @param {Boolean} [overwrite=false] If `true`, properties already on the receiver
	 will be overwritten if found on the supplier's prototype.
	 @param {String[]} [whitelist] An array of property names. If specified,
	 only the whitelisted prototype properties will be applied to the receiver, and
	 all others will be ignored.
	 @param {Array|any} [args] Argument or array of arguments to pass to the
	 supplier's constructor when initializing.
	 @return {Function} Augmented object.
	 @for YUI
	 **/</span>
	Y.augment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">receiver, supplier, overwrite, whitelist, args</span>) </span>{
		<span class="hljs-keyword">var</span> rProto    = receiver.prototype,
			sequester = rProto &amp;&amp; supplier,
			sProto    = supplier.prototype,
			to        = rProto || receiver,

			copy,
			newPrototype,
			replacements,
			sequestered,
			unsequester;

		args = args ? Y.Array(args) : [];

		<span class="hljs-keyword">if</span> (sequester) {
			newPrototype = {};
			replacements = {};
			sequestered  = {};

			copy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, key</span>) </span>{
				<span class="hljs-keyword">if</span> (overwrite || !(key <span class="hljs-keyword">in</span> rProto)) {
					<span class="hljs-keyword">if</span> (toString.call(value) === <span class="hljs-string">'[object Function]'</span>) {
						sequestered[key] = value;

						newPrototype[key] = replacements[key] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
							<span class="hljs-keyword">return</span> unsequester(<span class="hljs-keyword">this</span>, value, <span class="hljs-built_in">arguments</span>);
						};
					} <span class="hljs-keyword">else</span> {
						newPrototype[key] = value;
					}
				}
			};

			unsequester = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">instance, fn, fnArgs</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <p>Unsequester all sequestered functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> sequestered) {
					<span class="hljs-keyword">if</span> (hasOwn.call(sequestered, key)
						&amp;&amp; instance[key] === replacements[key]) {

						instance[key] = sequestered[key];
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <p>Execute the supplier constructor.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				supplier.apply(instance, args);</pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>Finally, execute the original sequestered function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> fn.apply(instance, fnArgs);
			};

			<span class="hljs-keyword">if</span> (whitelist) {
				Y.Array.each(whitelist, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
					<span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> sProto) {
						copy(sProto[name], name);
					}
				});
			} <span class="hljs-keyword">else</span> {
				Y.Object.each(sProto, copy, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
			}
		}

		Y.mix(to, newPrototype || sProto, overwrite, whitelist);

		<span class="hljs-keyword">if</span> (!sequester) {
			supplier.apply(to, args);
		}

		<span class="hljs-keyword">return</span> receiver;
	};

	<span class="hljs-comment">/**
	 * Copies object properties from the supplier to the receiver. If the target has
	 * the property, and the property is an object, the target object will be
	 * augmented with the supplier's value.
	 *
	 * @method aggregate
	 * @param {Object} receiver Object to receive the augmentation.
	 * @param {Object} supplier Object that supplies the properties with which to
	 *     augment the receiver.
	 * @param {Boolean} [overwrite=false] If `true`, properties already on the receiver
	 *     will be overwritten if found on the supplier.
	 * @param {String[]} [whitelist] Whitelist. If supplied, only properties in this
	 *     list will be applied to the receiver.
	 * @return {Object} Augmented object.
	 */</span>
	Y.aggregate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r, s, ov, wl</span>) </span>{
		<span class="hljs-keyword">return</span> Y.mix(r, s, ov, wl, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
	};

	<span class="hljs-comment">/**
	 * Utility to set up the prototype, constructor and superclass properties to
	 * support an inheritance strategy that can chain constructors and methods.
	 * Static members will not be inherited.
	 *
	 * @method extend
	 * @param {function} r   the object to modify.
	 * @param {function} s the object to inherit.
	 * @param {object} px prototype properties to add/override.
	 * @param {object} sx static properties to add/override.
	 * @return {object} the extended object.
	 */</span>
	Y.extend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r, s, px, sx</span>) </span>{
		<span class="hljs-keyword">if</span> (!s || !r) {
			Y.error(<span class="hljs-string">'extend failed, verify dependencies'</span>);
		}

		<span class="hljs-keyword">var</span> sp = s.prototype, rp = Y.Object(sp);
		r.prototype = rp;

		rp.constructor = r;
		r.superclass = sp;</pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <p>assign constructor property</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (s != <span class="hljs-built_in">Object</span> &amp;&amp; sp.constructor == OP.constructor) {
			sp.constructor = s;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <p>add prototype overrides</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (px) {
			Y.mix(rp, px, <span class="hljs-literal">true</span>);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <p>add object overrides</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (sx) {
			Y.mix(r, sx, <span class="hljs-literal">true</span>);
		}

		<span class="hljs-keyword">return</span> r;
	};

	<span class="hljs-comment">/**
	 * Executes the supplied function for each item in
	 * a collection.  Supports arrays, objects, and
	 * NodeLists
	 * @method each
	 * @param {object} o the object to iterate.
	 * @param {function} f the function to execute.  This function
	 * receives the value, key, and object as parameters.
	 * @param {object} c the execution context for the function.
	 * @param {boolean} proto if true, prototype properties are
	 * iterated on objects.
	 * @return {YUI} the YUI instance.
	 */</span>
	Y.each = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o, f, c, proto</span>) </span>{
		<span class="hljs-keyword">return</span> dispatch(o, f, c, proto, <span class="hljs-string">'each'</span>);
	};

	<span class="hljs-comment">/**
	 * Executes the supplied function for each item in
	 * a collection.  The operation stops if the function
	 * returns true. Supports arrays, objects, and
	 * NodeLists.
	 * @method some
	 * @param {object} o the object to iterate.
	 * @param {function} f the function to execute.  This function
	 * receives the value, key, and object as parameters.
	 * @param {object} c the execution context for the function.
	 * @param {boolean} proto if true, prototype properties are
	 * iterated on objects.
	 * @return {boolean} true if the function ever returns true,
	 * false otherwise.
	 */</span>
	Y.some = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o, f, c, proto</span>) </span>{
		<span class="hljs-keyword">return</span> dispatch(o, f, c, proto, <span class="hljs-string">'some'</span>);
	};

	<span class="hljs-comment">/**
	 * Deep object/array copy.  Function clones are actually
	 * wrappers around the original function.
	 * Array-like objects are treated as arrays.
	 * Primitives are returned untouched.  Optionally, a
	 * function can be provided to handle other data types,
	 * filter keys, validate values, etc.
	 *
	 * <span class="hljs-doctag">NOTE:</span> Cloning a non-trivial object is a reasonably heavy operation, due to
	 * the need to recurrsively iterate down non-primitive properties. Clone
	 * should be used only when a deep clone down to leaf level properties
	 * is explicitly required.
	 *
	 * In many cases (for example, when trying to isolate objects used as
	 * hashes for configuration properties), a shallow copy, using Y.merge is
	 * normally sufficient. If more than one level of isolation is required,
	 * Y.merge can be used selectively at each level which needs to be
	 * isolated from the original without going all the way to leaf properties.
	 *
	 * @method clone
	 * @param {object} o what to clone.
	 * @param {boolean} safe if true, objects will not have prototype
	 * items from the source.  If false, they will.  In this case, the
	 * original is initially protected, but the clone is not completely
	 * immune from changes to the source object prototype.  Also, cloned
	 * prototype items that are deleted from the clone will result
	 * in the value of the source prototype being exposed.  If operating
	 * on a non-safe clone, items should be nulled out rather than deleted.
	 * @param {function} f optional function to apply to each item in a
	 * collection; it will be executed prior to applying the value to
	 * the new object.  Return false to prevent the copy.
	 * @param {object} c optional execution context for f.
	 * @param {object} owner Owner object passed when clone is iterating
	 * an object.  Used to set up context for cloned functions.
	 * @param {object} cloned hash of previously cloned objects to avoid
	 * multiple clones.
	 * @return {Array|Object} the cloned object.
	 */</span>
	Y.clone = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o, safe, f, c, owner, cloned</span>) </span>{

		<span class="hljs-keyword">if</span> (!L.isObject(o)) {
			<span class="hljs-keyword">return</span> o;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <p>@todo cloning YUI instances doesn’t currently work</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (Y.instanceOf(o, YUI)) {
			<span class="hljs-keyword">return</span> o;
		}

		<span class="hljs-keyword">var</span> o2, marked = cloned || {}, stamp,
			yeach = Y.each;

		<span class="hljs-keyword">switch</span> (L.type(o)) {
			<span class="hljs-keyword">case</span> <span class="hljs-string">'date'</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(o);
			<span class="hljs-keyword">case</span> <span class="hljs-string">'regexp'</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>if we do this we need to set the flags too
return new RegExp(o.source);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> o;
			<span class="hljs-keyword">case</span> <span class="hljs-string">'function'</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <p>o2 = Y.bind(o, owner);
break;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> o;
			<span class="hljs-keyword">case</span> <span class="hljs-string">'array'</span>:
				o2 = [];
				<span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">default</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <p>#2528250 only one clone of a given object should be created.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (o[CLONE_MARKER]) {
					<span class="hljs-keyword">return</span> marked[o[CLONE_MARKER]];
				}

				stamp = Y.guid();

				o2 = (safe) ? {} : Y.Object(o);

				o[CLONE_MARKER] = stamp;
				marked[stamp] = o;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <p>#2528250 don’t try to clone element properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!o.addEventListener &amp;&amp; !o.attachEvent) {
			yeach(o, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, k</span>) </span>{
				<span class="hljs-keyword">if</span> ((k || k === <span class="hljs-number">0</span>) &amp;&amp; (!f || (f.call(c || <span class="hljs-keyword">this</span>, v, k, <span class="hljs-keyword">this</span>, o) !== <span class="hljs-literal">false</span>))) {
					<span class="hljs-keyword">if</span> (k !== CLONE_MARKER) {
						<span class="hljs-keyword">if</span> (k == <span class="hljs-string">'prototype'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p>skip the prototype
} else if (o[k] === o) {
    this[k] = this;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">this</span>[k] =
								Y.clone(v, safe, f, c, owner || o, marked);
						}
					}
				}
			}, o2);
		}

		<span class="hljs-keyword">if</span> (!cloned) {
			Y.Object.each(marked, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, k</span>) </span>{
				<span class="hljs-keyword">if</span> (v[CLONE_MARKER]) {
					<span class="hljs-keyword">try</span> {
						<span class="hljs-keyword">delete</span> v[CLONE_MARKER];
					} <span class="hljs-keyword">catch</span> (e) {
						v[CLONE_MARKER] = <span class="hljs-literal">null</span>;
					}
				}
			}, <span class="hljs-keyword">this</span>);
			marked = <span class="hljs-literal">null</span>;
		}

		<span class="hljs-keyword">return</span> o2;
	};


	<span class="hljs-comment">/**
	 * Returns a function that will execute the supplied function in the
	 * supplied object's context, optionally adding any additional
	 * supplied parameters to the beginning of the arguments collection the
	 * supplied to the function.
	 *
	 * @method bind
	 * @param {Function|String} f the function to bind, or a function name
	 * to execute on the context object.
	 * @param {object} c the execution context.
	 * @param {any} args* 0..n arguments to include before the arguments the
	 * function is executed with.
	 * @return {function} the wrapped function.
	 */</span>
	Y.bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f, c</span>) </span>{
		<span class="hljs-keyword">var</span> xargs = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span> ?
			Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>) : <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> fn = L.isString(f) ? c[f] : f,
				args = (xargs) ?
					xargs.concat(Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>)) : <span class="hljs-built_in">arguments</span>;
			<span class="hljs-keyword">return</span> fn.apply(c || fn, args);
		};
	};

	<span class="hljs-comment">/**
	 * Returns a function that will execute the supplied function in the
	 * supplied object's context, optionally adding any additional
	 * supplied parameters to the end of the arguments the function
	 * is executed with.
	 *
	 * @method rbind
	 * @param {Function|String} f the function to bind, or a function name
	 * to execute on the context object.
	 * @param {object} c the execution context.
	 * @param {any} args* 0..n arguments to append to the end of
	 * arguments collection supplied to the function.
	 * @return {function} the wrapped function.
	 */</span>
	Y.rbind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f, c</span>) </span>{
		<span class="hljs-keyword">var</span> xargs = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span> ? Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>) : <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> fn = L.isString(f) ? c[f] : f,
				args = (xargs) ?
					Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>).concat(xargs) : <span class="hljs-built_in">arguments</span>;
			<span class="hljs-keyword">return</span> fn.apply(c || fn, args);
		};
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'event-custom-base'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
	 * events.
	 * @module event-custom
	 */</span>

	Y.Env.evt = {
		<span class="hljs-attr">handles</span>: {},
		<span class="hljs-attr">plugins</span>: {}
	};


	<span class="hljs-comment">/**
	 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
	 * events.
	 * @module event-custom
	 * @submodule event-custom-base
	 */</span>

	<span class="hljs-comment">/**
	 * Allows for the insertion of methods that are executed before or after
	 * a specified method
	 * @class Do
	 * @static
	 */</span>

	<span class="hljs-keyword">var</span> DO_BEFORE = <span class="hljs-number">0</span>,
		DO_AFTER = <span class="hljs-number">1</span>,

		DO = {

			<span class="hljs-comment">/**
			 * Cache of objects touched by the utility
			 * @property objs
			 * @static
			 * @deprecated Since 3.6.0. The `_yuiaop` property on the AOP'd object
			 * replaces the role of this property, but is considered to be private, and
			 * is only mentioned to provide a migration path.
			 *
			 * If you have a use case which warrants migration to the _yuiaop property,
			 * please file a ticket to let us know what it's used for and we can see if
			 * we need to expose hooks for that functionality more formally.
			 */</span>
			objs: <span class="hljs-literal">null</span>,

			<span class="hljs-comment">/**
			 * &lt;p&gt;Execute the supplied method before the specified function.  Wrapping
			 * function may optionally return an instance of the following classes to
			 * further alter runtime behavior:&lt;/p&gt;
			 * &lt;dl&gt;
			 *     &lt;dt&gt;&lt;/code&gt;Y.Do.Halt(message, returnValue)&lt;/code&gt;&lt;/dt&gt;
			 *         &lt;dd&gt;Immediatly stop execution and return
			 *         &lt;code&gt;returnValue&lt;/code&gt;.  No other wrapping functions will be
			 *         executed.&lt;/dd&gt;
			 *     &lt;dt&gt;&lt;/code&gt;Y.Do.AlterArgs(message, newArgArray)&lt;/code&gt;&lt;/dt&gt;
			 *         &lt;dd&gt;Replace the arguments that the original function will be
			 *         called with.&lt;/dd&gt;
			 *     &lt;dt&gt;&lt;/code&gt;Y.Do.Prevent(message)&lt;/code&gt;&lt;/dt&gt;
			 *         &lt;dd&gt;Don't execute the wrapped function.  Other before phase
			 *         wrappers will be executed.&lt;/dd&gt;
			 * &lt;/dl&gt;
			 *
			 * @method before
			 * @param fn {Function} the function to execute
			 * @param obj the object hosting the method to displace
			 * @param sFn {string} the name of the method to displace
			 * @param c The execution context for fn
			 * @param arg* {mixed} 0..n additional arguments to supply to the subscriber
			 * when the event fires.
			 * @return {string} handle for the subscription
			 * @static
			 */</span>
			before: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, obj, sFn, c</span>) </span>{
				<span class="hljs-keyword">var</span> f = fn, a;
				<span class="hljs-keyword">if</span> (c) {
					a = [fn, c].concat(Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>));
					f = Y.rbind.apply(Y, a);
				}

				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._inject(DO_BEFORE, f, obj, sFn);
			},

			<span class="hljs-comment">/**
			 * &lt;p&gt;Execute the supplied method after the specified function.  Wrapping
			 * function may optionally return an instance of the following classes to
			 * further alter runtime behavior:&lt;/p&gt;
			 * &lt;dl&gt;
			 *     &lt;dt&gt;&lt;/code&gt;Y.Do.Halt(message, returnValue)&lt;/code&gt;&lt;/dt&gt;
			 *         &lt;dd&gt;Immediatly stop execution and return
			 *         &lt;code&gt;returnValue&lt;/code&gt;.  No other wrapping functions will be
			 *         executed.&lt;/dd&gt;
			 *     &lt;dt&gt;&lt;/code&gt;Y.Do.AlterReturn(message, returnValue)&lt;/code&gt;&lt;/dt&gt;
			 *         &lt;dd&gt;Return &lt;code&gt;returnValue&lt;/code&gt; instead of the wrapped
			 *         method's original return value.  This can be further altered by
			 *         other after phase wrappers.&lt;/dd&gt;
			 * &lt;/dl&gt;
			 *
			 * &lt;p&gt;The static properties &lt;code&gt;Y.Do.originalRetVal&lt;/code&gt; and
			 * &lt;code&gt;Y.Do.currentRetVal&lt;/code&gt; will be populated for reference.&lt;/p&gt;
			 *
			 * @method after
			 * @param fn {Function} the function to execute
			 * @param obj the object hosting the method to displace
			 * @param sFn {string} the name of the method to displace
			 * @param c The execution context for fn
			 * @param arg* {mixed} 0..n additional arguments to supply to the subscriber
			 * @return {string} handle for the subscription
			 * @static
			 */</span>
			after: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, obj, sFn, c</span>) </span>{
				<span class="hljs-keyword">var</span> f = fn, a;
				<span class="hljs-keyword">if</span> (c) {
					a = [fn, c].concat(Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>));
					f = Y.rbind.apply(Y, a);
				}

				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._inject(DO_AFTER, f, obj, sFn);
			},

			<span class="hljs-comment">/**
			 * Execute the supplied method before or after the specified function.
			 * Used by &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt;.
			 *
			 * @method _inject
			 * @param when {string} before or after
			 * @param fn {Function} the function to execute
			 * @param obj the object hosting the method to displace
			 * @param sFn {string} the name of the method to displace
			 * @param c The execution context for fn
			 * @return {string} handle for the subscription
			 * @private
			 * @static
			 */</span>
			_inject: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">when, fn, obj, sFn</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <p>object id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> id = Y.stamp(obj), o, sid;

				<span class="hljs-keyword">if</span> (!obj._yuiaop) {</pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>create a map entry for the obj if it doesn’t exist, to hold overridden methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					obj._yuiaop = {};
				}

				o = obj._yuiaop;

				<span class="hljs-keyword">if</span> (!o[sFn]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <p>create a map entry for the method if it doesn’t exist</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					o[sFn] = <span class="hljs-keyword">new</span> Y.Do.Method(obj, sFn);</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <p>re-route the method to our wrapper</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					obj[sFn] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
						<span class="hljs-keyword">return</span> o[sFn].exec.apply(o[sFn], <span class="hljs-built_in">arguments</span>);
					};
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>subscriber id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				sid = id + Y.stamp(fn) + sFn;</pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <p>register the callback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				o[sFn].register(sid, fn, when);

				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Y.EventHandle(o[sFn], sid);
			},

			<span class="hljs-comment">/**
			 * Detach a before or after subscription.
			 *
			 * @method detach
			 * @param handle {string} the subscription handle
			 * @static
			 */</span>
			detach: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handle</span>) </span>{
				<span class="hljs-keyword">if</span> (handle.detach) {
					handle.detach();
				}
			},

			<span class="hljs-attr">_unload</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, me</span>) </span>{
			}
		};

	Y.Do = DO;</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <p>////////////////////////////////////////////////////////////////////////</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-comment">/**
	 * Contains the return value from the wrapped method, accessible
	 * by 'after' event listeners.
	 *
	 * @property originalRetVal
	 * @static
	 * @since 3.2.0
	 */</span>

	<span class="hljs-comment">/**
	 * Contains the current state of the return value, consumable by
	 * 'after' event listeners, and updated if an after subscriber
	 * changes the return value generated by the wrapped function.
	 *
	 * @property currentRetVal
	 * @static
	 * @since 3.2.0
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <p>////////////////////////////////////////////////////////////////////////</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-comment">/**
	 * Wrapper for a displaced method with aop enabled
	 * @class Do.Method
	 * @constructor
	 * @param obj The object to operate on
	 * @param sFn The name of the method to displace
	 */</span>
	DO.Method = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, sFn</span>) </span>{
		<span class="hljs-keyword">this</span>.obj = obj;
		<span class="hljs-keyword">this</span>.methodName = sFn;
		<span class="hljs-keyword">this</span>.method = obj[sFn];
		<span class="hljs-keyword">this</span>.before = {};
		<span class="hljs-keyword">this</span>.after = {};
	};

	<span class="hljs-comment">/**
	 * Register a aop subscriber
	 * @method register
	 * @param sid {string} the subscriber id
	 * @param fn {Function} the function to execute
	 * @param when {string} when to execute the function
	 */</span>
	DO.Method.prototype.register = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sid, fn, when</span>) </span>{
		<span class="hljs-keyword">if</span> (when) {
			<span class="hljs-keyword">this</span>.after[sid] = fn;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">this</span>.before[sid] = fn;
		}
	};

	<span class="hljs-comment">/**
	 * Unregister a aop subscriber
	 * @method delete
	 * @param sid {string} the subscriber id
	 * @param fn {Function} the function to execute
	 * @param when {string} when to execute the function
	 */</span>
	DO.Method.prototype._delete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sid</span>) </span>{
		<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.before[sid];
		<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.after[sid];
	};

	<span class="hljs-comment">/**
	 * &lt;p&gt;Execute the wrapped method.  All arguments are passed into the wrapping
	 * functions.  If any of the before wrappers return an instance of
	 * &lt;code&gt;Y.Do.Halt&lt;/code&gt; or &lt;code&gt;Y.Do.Prevent&lt;/code&gt;, neither the wrapped
	 * function nor any after phase subscribers will be executed.&lt;/p&gt;
	 *
	 * &lt;p&gt;The return value will be the return value of the wrapped function or one
	 * provided by a wrapper function via an instance of &lt;code&gt;Y.Do.Halt&lt;/code&gt; or
	 * &lt;code&gt;Y.Do.AlterReturn&lt;/code&gt;.
	 *
	 * @method exec
	 * @param arg* {any} Arguments are passed to the wrapping and wrapped functions
	 * @return {any} Return value of wrapped function unless overwritten (see above)
	 */</span>
	DO.Method.prototype.exec = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

		<span class="hljs-keyword">var</span> args = Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>),
			i, ret, newRet,
			bf = <span class="hljs-keyword">this</span>.before,
			af = <span class="hljs-keyword">this</span>.after,
			prevented = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <p>execute before</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> bf) {
			<span class="hljs-keyword">if</span> (bf.hasOwnProperty(i)) {
				ret = bf[i].apply(<span class="hljs-keyword">this</span>.obj, args);
				<span class="hljs-keyword">if</span> (ret) {
					<span class="hljs-keyword">switch</span> (ret.constructor) {
						<span class="hljs-keyword">case</span> DO.Halt:
							<span class="hljs-keyword">return</span> ret.retVal;
						<span class="hljs-keyword">case</span> DO.AlterArgs:
							args = ret.newArgs;
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> DO.Prevent:
							prevented = <span class="hljs-literal">true</span>;
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">default</span>:
					}
				}
			}
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <p>execute method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!prevented) {
			ret = <span class="hljs-keyword">this</span>.method.apply(<span class="hljs-keyword">this</span>.obj, args);
		}

		DO.originalRetVal = ret;
		DO.currentRetVal = ret;</pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <p>execute after methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> af) {
			<span class="hljs-keyword">if</span> (af.hasOwnProperty(i)) {
				newRet = af[i].apply(<span class="hljs-keyword">this</span>.obj, args);</pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <p>Stop processing if a Halt object is returned</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (newRet &amp;&amp; newRet.constructor == DO.Halt) {
					<span class="hljs-keyword">return</span> newRet.retVal;</pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <p>Check for a new return value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newRet &amp;&amp; newRet.constructor == DO.AlterReturn) {
					ret = newRet.newRetVal;</pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>Update the static retval state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					DO.currentRetVal = ret;
				}
			}
		}

		<span class="hljs-keyword">return</span> ret;
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <p>////////////////////////////////////////////////////////////////////////</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-comment">/**
	 * Return an AlterArgs object when you want to change the arguments that
	 * were passed into the function.  Useful for Do.before subscribers.  An
	 * example would be a service that scrubs out illegal characters prior to
	 * executing the core business logic.
	 * @class Do.AlterArgs
	 * @constructor
	 * @param msg {String} (optional) Explanation of the altered return value
	 * @param newArgs {Array} Call parameters to be used for the original method
	 *                        instead of the arguments originally passed in.
	 */</span>
	DO.AlterArgs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, newArgs</span>) </span>{
		<span class="hljs-keyword">this</span>.msg = msg;
		<span class="hljs-keyword">this</span>.newArgs = newArgs;
	};

	<span class="hljs-comment">/**
	 * Return an AlterReturn object when you want to change the result returned
	 * from the core method to the caller.  Useful for Do.after subscribers.
	 * @class Do.AlterReturn
	 * @constructor
	 * @param msg {String} (optional) Explanation of the altered return value
	 * @param newRetVal {any} Return value passed to code that invoked the wrapped
	 *                      function.
	 */</span>
	DO.AlterReturn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, newRetVal</span>) </span>{
		<span class="hljs-keyword">this</span>.msg = msg;
		<span class="hljs-keyword">this</span>.newRetVal = newRetVal;
	};

	<span class="hljs-comment">/**
	 * Return a Halt object when you want to terminate the execution
	 * of all subsequent subscribers as well as the wrapped method
	 * if it has not exectued yet.  Useful for Do.before subscribers.
	 * @class Do.Halt
	 * @constructor
	 * @param msg {String} (optional) Explanation of why the termination was done
	 * @param retVal {any} Return value passed to code that invoked the wrapped
	 *                      function.
	 */</span>
	DO.Halt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, retVal</span>) </span>{
		<span class="hljs-keyword">this</span>.msg = msg;
		<span class="hljs-keyword">this</span>.retVal = retVal;
	};

	<span class="hljs-comment">/**
	 * Return a Prevent object when you want to prevent the wrapped function
	 * from executing, but want the remaining listeners to execute.  Useful
	 * for Do.before subscribers.
	 * @class Do.Prevent
	 * @constructor
	 * @param msg {String} (optional) Explanation of why the termination was done
	 */</span>
	DO.Prevent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span>{
		<span class="hljs-keyword">this</span>.msg = msg;
	};

	<span class="hljs-comment">/**
	 * Return an Error object when you want to terminate the execution
	 * of all subsequent method calls.
	 * @class Do.Error
	 * @constructor
	 * @param msg {String} (optional) Explanation of the altered return value
	 * @param retVal {any} Return value passed to code that invoked the wrapped
	 *                      function.
	 * @deprecated use Y.Do.Halt or Y.Do.Prevent
	 */</span>
	DO.Error = DO.Halt;</pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>
              <p>////////////////////////////////////////////////////////////////////////</p>

            </div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <p>Y[“Event”] &amp;&amp; Y.Event.addListener(window, “unload”, Y.Do._unload, Y.Do);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

	<span class="hljs-comment">/**
	 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
	 * events.
	 * @module event-custom
	 * @submodule event-custom-base
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>
              <p>var onsubscribeType = “_event:onsub”,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> YArray = Y.Array,

		AFTER = <span class="hljs-string">'after'</span>,
		CONFIGS = [
			<span class="hljs-string">'broadcast'</span>,
			<span class="hljs-string">'monitored'</span>,
			<span class="hljs-string">'bubbles'</span>,
			<span class="hljs-string">'context'</span>,
			<span class="hljs-string">'contextFn'</span>,
			<span class="hljs-string">'currentTarget'</span>,
			<span class="hljs-string">'defaultFn'</span>,
			<span class="hljs-string">'defaultTargetOnly'</span>,
			<span class="hljs-string">'details'</span>,
			<span class="hljs-string">'emitFacade'</span>,
			<span class="hljs-string">'fireOnce'</span>,
			<span class="hljs-string">'async'</span>,
			<span class="hljs-string">'host'</span>,
			<span class="hljs-string">'preventable'</span>,
			<span class="hljs-string">'preventedFn'</span>,
			<span class="hljs-string">'queuable'</span>,
			<span class="hljs-string">'silent'</span>,
			<span class="hljs-string">'stoppedFn'</span>,
			<span class="hljs-string">'target'</span>,
			<span class="hljs-string">'type'</span>
		],

		CONFIGS_HASH = YArray.hash(CONFIGS),

		nativeSlice = <span class="hljs-built_in">Array</span>.prototype.slice,

		YUI3_SIGNATURE = <span class="hljs-number">9</span>,
		YUI_LOG = <span class="hljs-string">'yui:log'</span>,

		mixConfigs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r, s, ov</span>) </span>{
			<span class="hljs-keyword">var</span> p;

			<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> s) {
				<span class="hljs-keyword">if</span> (CONFIGS_HASH[p] &amp;&amp; (ov || !(p <span class="hljs-keyword">in</span> r))) {
					r[p] = s[p];
				}
			}

			<span class="hljs-keyword">return</span> r;
		};

	<span class="hljs-comment">/**
	 * The CustomEvent class lets you define events for your application
	 * that can be subscribed to by one or more independent component.
	 *
	 * @param {String} type The type of event, which is passed to the callback
	 * when the event fires.
	 * @param {object} o configuration object.
	 * @class CustomEvent
	 * @constructor
	 */</span>
	Y.CustomEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, o</span>) </span>{

		<span class="hljs-keyword">this</span>._kds = Y.CustomEvent.keepDeprecatedSubs;

		o = o || {};

		<span class="hljs-keyword">this</span>.id = Y.stamp(<span class="hljs-keyword">this</span>);

		<span class="hljs-comment">/**
		 * The type of event, returned to subscribers when the event fires
		 * @property type
		 * @type string
		 */</span>
		<span class="hljs-keyword">this</span>.type = type;

		<span class="hljs-comment">/**
		 * The context the the event will fire from by default.  Defaults to the YUI
		 * instance.
		 * @property context
		 * @type object
		 */</span>
		<span class="hljs-keyword">this</span>.context = Y;

		<span class="hljs-comment">/**
		 * Monitor when an event is attached or detached.
		 *
		 * @property monitored
		 * @type boolean
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>
              <p>this.monitored = false;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-keyword">this</span>.logSystem = (type == YUI_LOG);

		<span class="hljs-comment">/**
		 * If 0, this event does not broadcast.  If 1, the YUI instance is notified
		 * every time this event fires.  If 2, the YUI instance and the YUI global
		 * (if event is enabled on the global) are notified every time this event
		 * fires.
		 * @property broadcast
		 * @type int
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <p>this.broadcast = 0;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * By default all custom events are logged in the debug build, set silent
		 * to true to disable debug outpu for this event.
		 * @property silent
		 * @type boolean
		 */</span>
		<span class="hljs-keyword">this</span>.silent = <span class="hljs-keyword">this</span>.logSystem;

		<span class="hljs-comment">/**
		 * Specifies whether this event should be queued when the host is actively
		 * processing an event.  This will effect exectution order of the callbacks
		 * for the various events.
		 * @property queuable
		 * @type boolean
		 * @default false
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>
              <p>this.queuable = false;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * The subscribers to this event
		 * @property subscribers
		 * @type Subscriber {}
		 * @deprecated
		 */</span>
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._kds) {
			<span class="hljs-keyword">this</span>.subscribers = {};
		}

		<span class="hljs-comment">/**
		 * The subscribers to this event
		 * @property _subscribers
		 * @type Subscriber []
		 * @private
		 */</span>
		<span class="hljs-keyword">this</span>._subscribers = [];

		<span class="hljs-comment">/**
		 * 'After' subscribers
		 * @property afters
		 * @type Subscriber {}
		 */</span>
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._kds) {
			<span class="hljs-keyword">this</span>.afters = {};
		}

		<span class="hljs-comment">/**
		 * 'After' subscribers
		 * @property _afters
		 * @type Subscriber []
		 * @private
		 */</span>
		<span class="hljs-keyword">this</span>._afters = [];

		<span class="hljs-comment">/**
		 * This event has fired if true
		 *
		 * @property fired
		 * @type boolean
		 * @default false;
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>
              <p>this.fired = false;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * An array containing the arguments the custom event
		 * was last fired with.
		 * @property firedWith
		 * @type Array
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <p>this.firedWith;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * This event should only fire one time if true, and if
		 * it has fired, any new subscribers should be notified
		 * immediately.
		 *
		 * @property fireOnce
		 * @type boolean
		 * @default false;
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <p>this.fireOnce = false;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * fireOnce listeners will fire syncronously unless async
		 * is set to true
		 * @property async
		 * @type boolean
		 * @default false
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>
              <p>this.async = false;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * Flag for stopPropagation that is modified during fire()
		 * 1 means to stop propagation to bubble targets.  2 means
		 * to also stop additional subscribers on this target.
		 * @property stopped
		 * @type int
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>
              <p>this.stopped = 0;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * Flag for preventDefault that is modified during fire().
		 * if it is not 0, the default behavior for this event
		 * @property prevented
		 * @type int
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <p>this.prevented = 0;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * Specifies the host for this custom event.  This is used
		 * to enable event bubbling
		 * @property host
		 * @type EventTarget
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <p>this.host = null;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * The default function to execute after event listeners
		 * have fire, but only if the default action was not
		 * prevented.
		 * @property defaultFn
		 * @type Function
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>
              <p>this.defaultFn = null;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * The function to execute if a subscriber calls
		 * stopPropagation or stopImmediatePropagation
		 * @property stoppedFn
		 * @type Function
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>
              <p>this.stoppedFn = null;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * The function to execute if a subscriber calls
		 * preventDefault
		 * @property preventedFn
		 * @type Function
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <p>this.preventedFn = null;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * Specifies whether or not this event's default function
		 * can be cancelled by a subscriber by executing preventDefault()
		 * on the event facade
		 * @property preventable
		 * @type boolean
		 * @default true
		 */</span>
		<span class="hljs-keyword">this</span>.preventable = <span class="hljs-literal">true</span>;

		<span class="hljs-comment">/**
		 * Specifies whether or not a subscriber can stop the event propagation
		 * via stopPropagation(), stopImmediatePropagation(), or halt()
		 *
		 * Events can only bubble if emitFacade is true.
		 *
		 * @property bubbles
		 * @type boolean
		 * @default true
		 */</span>
		<span class="hljs-keyword">this</span>.bubbles = <span class="hljs-literal">true</span>;

		<span class="hljs-comment">/**
		 * Supports multiple options for listener signatures in order to
		 * port YUI 2 apps.
		 * @property signature
		 * @type int
		 * @default 9
		 */</span>
		<span class="hljs-keyword">this</span>.signature = YUI3_SIGNATURE;</pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>
              <p>this.subCount = 0;
this.afterCount = 0;</p>

            </div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>
              <p>this.hasSubscribers = false;
this.hasAfters = false;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * If set to true, the custom event will deliver an EventFacade object
		 * that is similar to a DOM event object.
		 * @property emitFacade
		 * @type boolean
		 * @default false
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <p>this.emitFacade = false;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-keyword">this</span>.applyConfig(o, <span class="hljs-literal">true</span>);


	};

	<span class="hljs-comment">/**
	 * Static flag to enable population of the &lt;a href="#property_subscribers"&gt;`subscribers`&lt;/a&gt;
	 * and  &lt;a href="#property_subscribers"&gt;`afters`&lt;/a&gt; properties held on a `CustomEvent` instance.
	 *
	 * These properties were changed to private properties (`_subscribers` and `_afters`), and
	 * converted from objects to arrays for performance reasons.
	 *
	 * Setting this property to true will populate the deprecated `subscribers` and `afters`
	 * properties for people who may be using them (which is expected to be rare). There will
	 * be a performance hit, compared to the new array based implementation.
	 *
	 * If you are using these deprecated properties for a use case which the public API
	 * does not support, please file an enhancement request, and we can provide an alternate
	 * public implementation which doesn't have the performance cost required to maintiain the
	 * properties as objects.
	 *
	 * @property keepDeprecatedSubs
	 * @static
	 * @for CustomEvent
	 * @type boolean
	 * @default false
	 * @deprecated
	 */</span>
	Y.CustomEvent.keepDeprecatedSubs = <span class="hljs-literal">false</span>;

	Y.CustomEvent.mixConfigs = mixConfigs;

	Y.CustomEvent.prototype = {

		<span class="hljs-attr">constructor</span>: Y.CustomEvent,

		<span class="hljs-comment">/**
		 * Returns the number of subscribers for this event as the sum of the on()
		 * subscribers and after() subscribers.
		 *
		 * @method hasSubs
		 * @return Number
		 */</span>
		hasSubs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">when</span>) </span>{
			<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>._subscribers.length, a = <span class="hljs-keyword">this</span>._afters.length, sib = <span class="hljs-keyword">this</span>.sibling;

			<span class="hljs-keyword">if</span> (sib) {
				s += sib._subscribers.length;
				a += sib._afters.length;
			}

			<span class="hljs-keyword">if</span> (when) {
				<span class="hljs-keyword">return</span> (when == <span class="hljs-string">'after'</span>) ? a : s;
			}

			<span class="hljs-keyword">return</span> (s + a);
		},

		<span class="hljs-comment">/**
		 * Monitor the event state for the subscribed event.  The first parameter
		 * is what should be monitored, the rest are the normal parameters when
		 * subscribing to an event.
		 * @method monitor
		 * @param what {string} what to monitor ('detach', 'attach', 'publish').
		 * @return {EventHandle} return value from the monitor event subscription.
		 */</span>
		monitor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">what</span>) </span>{
			<span class="hljs-keyword">this</span>.monitored = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>.id + <span class="hljs-string">'|'</span> + <span class="hljs-keyword">this</span>.type + <span class="hljs-string">'_'</span> + what,
				args = nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);
			args[<span class="hljs-number">0</span>] = type;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.host.on.apply(<span class="hljs-keyword">this</span>.host, args);
		},

		<span class="hljs-comment">/**
		 * Get all of the subscribers to this event and any sibling event
		 * @method getSubs
		 * @return {Array} first item is the on subscribers, second the after.
		 */</span>
		getSubs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">this</span>._subscribers, a = <span class="hljs-keyword">this</span>._afters, sib = <span class="hljs-keyword">this</span>.sibling;

			s = (sib) ? s.concat(sib._subscribers) : s.concat();
			a = (sib) ? a.concat(sib._afters) : a.concat();

			<span class="hljs-keyword">return</span> [s, a];
		},

		<span class="hljs-comment">/**
		 * Apply configuration properties.  Only applies the CONFIG whitelist
		 * @method applyConfig
		 * @param o hash of properties to apply.
		 * @param force {boolean} if true, properties that exist on the event
		 * will be overwritten.
		 */</span>
		applyConfig: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o, force</span>) </span>{
			mixConfigs(<span class="hljs-keyword">this</span>, o, force);
		},

		<span class="hljs-comment">/**
		 * Create the Subscription for subscribing function, context, and bound
		 * arguments.  If this is a fireOnce event, the subscriber is immediately
		 * notified.
		 *
		 * @method _on
		 * @param fn {Function} Subscription callback
		 * @param [context] {Object} Override `this` in the callback
		 * @param [args] {Array} bound arguments that will be passed to the callback after the arguments generated by fire()
		 * @param [when] {String} "after" to slot into after subscribers
		 * @return {EventHandle}
		 * @protected
		 */</span>
		_on: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context, args, when</span>) </span>{


			<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Y.Subscriber(fn, context, args, when);

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fireOnce &amp;&amp; <span class="hljs-keyword">this</span>.fired) {
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.async) {
					setTimeout(Y.bind(<span class="hljs-keyword">this</span>._notify, <span class="hljs-keyword">this</span>, s, <span class="hljs-keyword">this</span>.firedWith), <span class="hljs-number">0</span>);
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">this</span>._notify(s, <span class="hljs-keyword">this</span>.firedWith);
				}
			}

			<span class="hljs-keyword">if</span> (when == AFTER) {
				<span class="hljs-keyword">this</span>._afters.push(s);
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">this</span>._subscribers.push(s);
			}

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._kds) {
				<span class="hljs-keyword">if</span> (when == AFTER) {
					<span class="hljs-keyword">this</span>.afters[s.id] = s;
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">this</span>.subscribers[s.id] = s;
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Y.EventHandle(<span class="hljs-keyword">this</span>, s);
		},

		<span class="hljs-comment">/**
		 * Listen for this event
		 * @method subscribe
		 * @param {Function} fn The function to execute.
		 * @return {EventHandle} Unsubscribe handle.
		 * @deprecated use on.
		 */</span>
		subscribe: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context</span>) </span>{
			<span class="hljs-keyword">var</span> a = (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span>) ? nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>) : <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._on(fn, context, a, <span class="hljs-literal">true</span>);
		},

		<span class="hljs-comment">/**
		 * Listen for this event
		 * @method on
		 * @param {Function} fn The function to execute.
		 * @param {object} context optional execution context.
		 * @param {mixed} arg* 0..n additional arguments to supply to the subscriber
		 * when the event fires.
		 * @return {EventHandle} An object with a detach method to detch the handler(s).
		 */</span>
		on: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context</span>) </span>{
			<span class="hljs-keyword">var</span> a = (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span>) ? nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>) : <span class="hljs-literal">null</span>;

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.monitored &amp;&amp; <span class="hljs-keyword">this</span>.host) {
				<span class="hljs-keyword">this</span>.host._monitor(<span class="hljs-string">'attach'</span>, <span class="hljs-keyword">this</span>, {
					<span class="hljs-attr">args</span>: <span class="hljs-built_in">arguments</span>
				});
			}
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._on(fn, context, a, <span class="hljs-literal">true</span>);
		},

		<span class="hljs-comment">/**
		 * Listen for this event after the normal subscribers have been notified and
		 * the default behavior has been applied.  If a normal subscriber prevents the
		 * default behavior, it also prevents after listeners from firing.
		 * @method after
		 * @param {Function} fn The function to execute.
		 * @param {object} context optional execution context.
		 * @param {mixed} arg* 0..n additional arguments to supply to the subscriber
		 * when the event fires.
		 * @return {EventHandle} handle Unsubscribe handle.
		 */</span>
		after: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context</span>) </span>{
			<span class="hljs-keyword">var</span> a = (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span>) ? nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>) : <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._on(fn, context, a, AFTER);
		},

		<span class="hljs-comment">/**
		 * Detach listeners.
		 * @method detach
		 * @param {Function} fn  The subscribed function to remove, if not supplied
		 *                       all will be removed.
		 * @param {Object}   context The context object passed to subscribe.
		 * @return {int} returns the number of subscribers unsubscribed.
		 */</span>
		detach: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>
              <p>unsubscribe handle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (fn &amp;&amp; fn.detach) {
				<span class="hljs-keyword">return</span> fn.detach();
			}

			<span class="hljs-keyword">var</span> i, s,
				found = <span class="hljs-number">0</span>,
				subs = <span class="hljs-keyword">this</span>._subscribers,
				afters = <span class="hljs-keyword">this</span>._afters;

			<span class="hljs-keyword">for</span> (i = subs.length; i &gt;= <span class="hljs-number">0</span>; i--) {
				s = subs[i];
				<span class="hljs-keyword">if</span> (s &amp;&amp; (!fn || fn === s.fn)) {
					<span class="hljs-keyword">this</span>._delete(s, subs, i);
					found++;
				}
			}

			<span class="hljs-keyword">for</span> (i = afters.length; i &gt;= <span class="hljs-number">0</span>; i--) {
				s = afters[i];
				<span class="hljs-keyword">if</span> (s &amp;&amp; (!fn || fn === s.fn)) {
					<span class="hljs-keyword">this</span>._delete(s, afters, i);
					found++;
				}
			}

			<span class="hljs-keyword">return</span> found;
		},

		<span class="hljs-comment">/**
		 * Detach listeners.
		 * @method unsubscribe
		 * @param {Function} fn  The subscribed function to remove, if not supplied
		 *                       all will be removed.
		 * @param {Object}   context The context object passed to subscribe.
		 * @return {int|undefined} returns the number of subscribers unsubscribed.
		 * @deprecated use detach.
		 */</span>
		unsubscribe: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.detach.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
		},

		<span class="hljs-comment">/**
		 * Notify a single subscriber
		 * @method _notify
		 * @param {Subscriber} s the subscriber.
		 * @param {Array} args the arguments array to apply to the listener.
		 * @protected
		 */</span>
		_notify: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, args, ef</span>) </span>{


			<span class="hljs-keyword">var</span> ret;

			ret = s.notify(args, <span class="hljs-keyword">this</span>);

			<span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> === ret || <span class="hljs-keyword">this</span>.stopped &gt; <span class="hljs-number">1</span>) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
			}

			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		},

		<span class="hljs-comment">/**
		 * Logger abstraction to centralize the application of the silent flag
		 * @method log
		 * @param {string} msg message to log.
		 * @param {string} cat log category.
		 */</span>
		log: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, cat</span>) </span>{
		},

		<span class="hljs-comment">/**
		 * Notifies the subscribers.  The callback functions will be executed
		 * from the context specified when the event was created, and with the
		 * following parameters:
		 *   &lt;ul&gt;
		 *   &lt;li&gt;The type of event&lt;/li&gt;
		 *   &lt;li&gt;All of the arguments fire() was executed with as an array&lt;/li&gt;
		 *   &lt;li&gt;The custom object (if any) that was passed into the subscribe()
		 *       method&lt;/li&gt;
		 *   &lt;/ul&gt;
		 * @method fire
		 * @param {Object*} arguments an arbitrary set of parameters to pass to
		 *                            the handler.
		 * @return {boolean} false if one of the subscribers returned false,
		 *                   true otherwise.
		 *
		 */</span>
		fire: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fireOnce &amp;&amp; <span class="hljs-keyword">this</span>.fired) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
			} <span class="hljs-keyword">else</span> {

				<span class="hljs-keyword">var</span> args = nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-223">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-223">&#182;</a>
              </div>
              <p>this doesn’t happen if the event isn’t published
this.host._monitor(‘fire’, this.type, args);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
				<span class="hljs-keyword">this</span>.fired = <span class="hljs-literal">true</span>;

				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fireOnce) {
					<span class="hljs-keyword">this</span>.firedWith = args;
				}

				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.emitFacade) {
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fireComplex(args);
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fireSimple(args);
				}
			}
		},

		<span class="hljs-comment">/**
		 * Set up for notifying subscribers of non-emitFacade events.
		 *
		 * @method fireSimple
		 * @param args {Array} Arguments passed to fire()
		 * @return Boolean false if a subscriber returned false
		 * @protected
		 */</span>
		fireSimple: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{
			<span class="hljs-keyword">this</span>.stopped = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">this</span>.prevented = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasSubs()) {
				<span class="hljs-keyword">var</span> subs = <span class="hljs-keyword">this</span>.getSubs();
				<span class="hljs-keyword">this</span>._procSubs(subs[<span class="hljs-number">0</span>], args);
				<span class="hljs-keyword">this</span>._procSubs(subs[<span class="hljs-number">1</span>], args);
			}
			<span class="hljs-keyword">this</span>._broadcast(args);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stopped ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-224">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-224">&#182;</a>
              </div>
              <p>Requires the event-custom-complex module for full funcitonality.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		fireComplex: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{
			args[<span class="hljs-number">0</span>] = args[<span class="hljs-number">0</span>] || {};
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fireSimple(args);
		},

		<span class="hljs-comment">/**
		 * Notifies a list of subscribers.
		 *
		 * @method _procSubs
		 * @param subs {Array} List of subscribers
		 * @param args {Array} Arguments passed to fire()
		 * @param ef {}
		 * @return Boolean false if a subscriber returns false or stops the event
		 *              propagation via e.stopPropagation(),
		 *              e.stopImmediatePropagation(), or e.halt()
		 * @private
		 */</span>
		_procSubs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">subs, args, ef</span>) </span>{
			<span class="hljs-keyword">var</span> s, i, l;

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) {
				s = subs[i];
				<span class="hljs-keyword">if</span> (s &amp;&amp; s.fn) {
					<span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> === <span class="hljs-keyword">this</span>._notify(s, args, ef)) {
						<span class="hljs-keyword">this</span>.stopped = <span class="hljs-number">2</span>;
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stopped == <span class="hljs-number">2</span>) {
						<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
					}
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		},

		<span class="hljs-comment">/**
		 * Notifies the YUI instance if the event is configured with broadcast = 1,
		 * and both the YUI instance and Y.Global if configured with broadcast = 2.
		 *
		 * @method _broadcast
		 * @param args {Array} Arguments sent to fire()
		 * @private
		 */</span>
		_broadcast: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{
			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stopped &amp;&amp; <span class="hljs-keyword">this</span>.broadcast) {

				<span class="hljs-keyword">var</span> a = args.concat();
				a.unshift(<span class="hljs-keyword">this</span>.type);

				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.host !== Y) {
					Y.fire.apply(Y, a);
				}

				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.broadcast == <span class="hljs-number">2</span>) {
					Y.Global.fire.apply(Y.Global, a);
				}
			}
		},

		<span class="hljs-comment">/**
		 * Removes all listeners
		 * @method unsubscribeAll
		 * @return {int} The number of listeners unsubscribed.
		 * @deprecated use detachAll.
		 */</span>
		unsubscribeAll: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.detachAll.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
		},

		<span class="hljs-comment">/**
		 * Removes all listeners
		 * @method detachAll
		 * @return {int} The number of listeners unsubscribed.
		 */</span>
		detachAll: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.detach();
		},

		<span class="hljs-comment">/**
		 * Deletes the subscriber from the internal store of on() and after()
		 * subscribers.
		 *
		 * @method _delete
		 * @param s subscriber object.
		 * @param [subs] on or after subscriber array
		 * @param [index] The index found.
		 * @private
		 */</span>
		_delete: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, subs, i</span>) </span>{
			<span class="hljs-keyword">var</span> when = s._when;

			<span class="hljs-keyword">if</span> (!subs) {
				subs = (when === AFTER) ? <span class="hljs-keyword">this</span>._afters : <span class="hljs-keyword">this</span>._subscribers;
				i = YArray.indexOf(subs, s, <span class="hljs-number">0</span>);
			}

			<span class="hljs-keyword">if</span> (s &amp;&amp; subs[i] === s) {
				subs.splice(i, <span class="hljs-number">1</span>);
			}

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._kds) {
				<span class="hljs-keyword">if</span> (when === AFTER) {
					<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.afters[s.id];
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.subscribers[s.id];
				}
			}

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.monitored &amp;&amp; <span class="hljs-keyword">this</span>.host) {
				<span class="hljs-keyword">this</span>.host._monitor(<span class="hljs-string">'detach'</span>, <span class="hljs-keyword">this</span>, {
					<span class="hljs-attr">ce</span>: <span class="hljs-keyword">this</span>,
					<span class="hljs-attr">sub</span>: s
				});
			}

			<span class="hljs-keyword">if</span> (s) {
				s.deleted = <span class="hljs-literal">true</span>;
			}
		}
	};
	<span class="hljs-comment">/**
	 * Stores the subscriber information to be used when the event fires.
	 * @param {Function} fn       The wrapped function to execute.
	 * @param {Object}   context  The value of the keyword 'this' in the listener.
	 * @param {Array} args*       0..n additional arguments to supply the listener.
	 *
	 * @class Subscriber
	 * @constructor
	 */</span>
	Y.Subscriber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context, args, when</span>) </span>{

		<span class="hljs-comment">/**
		 * The callback that will be execute when the event fires
		 * This is wrapped by Y.rbind if obj was supplied.
		 * @property fn
		 * @type Function
		 */</span>
		<span class="hljs-keyword">this</span>.fn = fn;

		<span class="hljs-comment">/**
		 * Optional 'this' keyword for the listener
		 * @property context
		 * @type Object
		 */</span>
		<span class="hljs-keyword">this</span>.context = context;

		<span class="hljs-comment">/**
		 * Unique subscriber id
		 * @property id
		 * @type String
		 */</span>
		<span class="hljs-keyword">this</span>.id = Y.stamp(<span class="hljs-keyword">this</span>);

		<span class="hljs-comment">/**
		 * Additional arguments to propagate to the subscriber
		 * @property args
		 * @type Array
		 */</span>
		<span class="hljs-keyword">this</span>.args = args;

		<span class="hljs-keyword">this</span>._when = when;

		<span class="hljs-comment">/**
		 * Custom events for a given fire transaction.
		 * @property events
		 * @type {EventTarget}
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-225">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-225">&#182;</a>
              </div>
              <p>this.events = null;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * This listener only reacts to the event once
		 * @property once
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-226">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-226">&#182;</a>
              </div>
              <p>this.once = false;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	};

	Y.Subscriber.prototype = {
		<span class="hljs-attr">constructor</span>: Y.Subscriber,

		<span class="hljs-attr">_notify</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c, args, ce</span>) </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.deleted &amp;&amp; !<span class="hljs-keyword">this</span>.postponed) {
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.postponed) {
					<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.fn;
					<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.context;
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.postponed;
					<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
				}
			}
			<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">this</span>.args, ret;
			<span class="hljs-keyword">switch</span> (ce.signature) {
				<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
					ret = <span class="hljs-keyword">this</span>.fn.call(c, ce.type, args, c);
					<span class="hljs-keyword">break</span>;
				<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
					ret = <span class="hljs-keyword">this</span>.fn.call(c, args[<span class="hljs-number">0</span>] || <span class="hljs-literal">null</span>, c);
					<span class="hljs-keyword">break</span>;
				<span class="hljs-keyword">default</span>:
					<span class="hljs-keyword">if</span> (a || args) {
						args = args || [];
						a = (a) ? args.concat(a) : args;
						ret = <span class="hljs-keyword">this</span>.fn.apply(c, a);
					} <span class="hljs-keyword">else</span> {
						ret = <span class="hljs-keyword">this</span>.fn.call(c);
					}
			}

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.once) {
				ce._delete(<span class="hljs-keyword">this</span>);
			}

			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-comment">/**
		 * Executes the subscriber.
		 * @method notify
		 * @param args {Array} Arguments array for the subscriber.
		 * @param ce {CustomEvent} The custom event that sent the notification.
		 */</span>
		notify: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args, ce</span>) </span>{
			<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">this</span>.context,
				ret = <span class="hljs-literal">true</span>;

			<span class="hljs-keyword">if</span> (!c) {
				c = (ce.contextFn) ? ce.contextFn() : ce.context;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-227">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-227">&#182;</a>
              </div>
              <p>only catch errors if we will not re-throw them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (Y.config &amp;&amp; Y.config.throwFail) {
				ret = <span class="hljs-keyword">this</span>._notify(c, args, ce);
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">try</span> {
					ret = <span class="hljs-keyword">this</span>._notify(c, args, ce);
				} <span class="hljs-keyword">catch</span> (e) {
					Y.error(<span class="hljs-keyword">this</span> + <span class="hljs-string">' failed: '</span> + e.message, e);
				}
			}

			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-comment">/**
		 * Returns true if the fn and obj match this objects properties.
		 * Used by the unsubscribe method to match the right subscriber.
		 *
		 * @method contains
		 * @param {Function} fn the function to execute.
		 * @param {Object} context optional 'this' keyword for the listener.
		 * @return {boolean} true if the supplied arguments match this
		 *                   subscriber's signature.
		 */</span>
		contains: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context</span>) </span>{
			<span class="hljs-keyword">if</span> (context) {
				<span class="hljs-keyword">return</span> ((<span class="hljs-keyword">this</span>.fn == fn) &amp;&amp; <span class="hljs-keyword">this</span>.context == context);
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.fn == fn);
			}
		},

		<span class="hljs-attr">valueOf</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;
		}

	};
	<span class="hljs-comment">/**
	 * Return value from all subscribe operations
	 * @class EventHandle
	 * @constructor
	 * @param {CustomEvent} evt the custom event.
	 * @param {Subscriber} sub the subscriber.
	 */</span>
	Y.EventHandle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt, sub</span>) </span>{

		<span class="hljs-comment">/**
		 * The custom event
		 *
		 * @property evt
		 * @type CustomEvent
		 */</span>
		<span class="hljs-keyword">this</span>.evt = evt;

		<span class="hljs-comment">/**
		 * The subscriber object
		 *
		 * @property sub
		 * @type Subscriber
		 */</span>
		<span class="hljs-keyword">this</span>.sub = sub;
	};

	Y.EventHandle.prototype = {
		<span class="hljs-attr">batch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f, c</span>) </span>{
			f.call(c || <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);
			<span class="hljs-keyword">if</span> (Y.Lang.isArray(<span class="hljs-keyword">this</span>.evt)) {
				Y.Array.each(<span class="hljs-keyword">this</span>.evt, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">h</span>) </span>{
					h.batch.call(c || h, f);
				});
			}
		},

		<span class="hljs-comment">/**
		 * Detaches this subscriber
		 * @method detach
		 * @return {int} the number of detached listeners
		 */</span>
		detach: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> evt = <span class="hljs-keyword">this</span>.evt, detached = <span class="hljs-number">0</span>, i;
			<span class="hljs-keyword">if</span> (evt) {
				<span class="hljs-keyword">if</span> (Y.Lang.isArray(evt)) {
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; evt.length; i++) {
						detached += evt[i].detach();
					}
				} <span class="hljs-keyword">else</span> {
					evt._delete(<span class="hljs-keyword">this</span>.sub);
					detached = <span class="hljs-number">1</span>;
				}

			}

			<span class="hljs-keyword">return</span> detached;
		},

		<span class="hljs-comment">/**
		 * Monitor the event state for the subscribed event.  The first parameter
		 * is what should be monitored, the rest are the normal parameters when
		 * subscribing to an event.
		 * @method monitor
		 * @param what {string} what to monitor ('attach', 'detach', 'publish').
		 * @return {EventHandle} return value from the monitor event subscription.
		 */</span>
		monitor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">what</span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.evt.monitor.apply(<span class="hljs-keyword">this</span>.evt, <span class="hljs-built_in">arguments</span>);
		}
	};

	<span class="hljs-comment">/**
	 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
	 * events.
	 * @module event-custom
	 * @submodule event-custom-base
	 */</span>

	<span class="hljs-comment">/**
	 * EventTarget provides the implementation for any object to
	 * publish, subscribe and fire to custom events, and also
	 * alows other EventTargets to target the object with events
	 * sourced from the other object.
	 * EventTarget is designed to be used with Y.augment to wrap
	 * EventCustom in an interface that allows events to be listened to
	 * and fired by name.  This makes it possible for implementing code to
	 * subscribe to an event that either has not been created yet, or will
	 * not be created at all.
	 * @class EventTarget
	 * @param opts a configuration object
	 * @config emitFacade {boolean} if true, all events will emit event
	 * facade payloads by default (default false)
	 * @config prefix {String} the prefix to apply to non-prefixed event names
	 */</span>

	<span class="hljs-keyword">var</span> L = Y.Lang,
		PREFIX_DELIMITER = <span class="hljs-string">':'</span>,
		CATEGORY_DELIMITER = <span class="hljs-string">'|'</span>,
		AFTER_PREFIX = <span class="hljs-string">'~AFTER~'</span>,
		WILD_TYPE_RE = <span class="hljs-regexp">/(.*?)(:)(.*?)/</span>,

		_wildType = Y.cached(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) </span>{
			<span class="hljs-keyword">return</span> type.replace(WILD_TYPE_RE, <span class="hljs-string">"*$2$3"</span>);
		}),

		<span class="hljs-comment">/**
		 * If the instance has a prefix attribute and the
		 * event type is not prefixed, the instance prefix is
		 * applied to the supplied type.
		 * @method _getType
		 * @private
		 */</span>
			_getType = Y.cached(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, pre</span>) </span>{

			<span class="hljs-keyword">if</span> (!pre || (<span class="hljs-keyword">typeof</span> type !== <span class="hljs-string">"string"</span>) || type.indexOf(PREFIX_DELIMITER) &gt; <span class="hljs-number">-1</span>) {
				<span class="hljs-keyword">return</span> type;
			}

			<span class="hljs-keyword">return</span> pre + PREFIX_DELIMITER + type;
		}),

		<span class="hljs-comment">/**
		 * Returns an array with the detach key (if provided),
		 * and the prefixed event name from _getType
		 * Y.on('detachcategory| menu:click', fn)
		 * @method _parseType
		 * @private
		 */</span>
			_parseType = Y.cached(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, pre</span>) </span>{

			<span class="hljs-keyword">var</span> t = type, detachcategory, after, i;

			<span class="hljs-keyword">if</span> (!L.isString(t)) {
				<span class="hljs-keyword">return</span> t;
			}

			i = t.indexOf(AFTER_PREFIX);

			<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">-1</span>) {
				after = <span class="hljs-literal">true</span>;
				t = t.substr(AFTER_PREFIX.length);
			}

			i = t.indexOf(CATEGORY_DELIMITER);

			<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">-1</span>) {
				detachcategory = t.substr(<span class="hljs-number">0</span>, (i));
				t = t.substr(i+<span class="hljs-number">1</span>);
				<span class="hljs-keyword">if</span> (t == <span class="hljs-string">'*'</span>) {
					t = <span class="hljs-literal">null</span>;
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-228">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-228">&#182;</a>
              </div>
              <p>detach category, full type with instance prefix, is this an after listener, short type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> [detachcategory, (pre) ? _getType(t, pre) : t, after, t];
		}),

		ET = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">opts</span>) </span>{


			<span class="hljs-keyword">var</span> o = (L.isObject(opts)) ? opts : {};

			<span class="hljs-keyword">this</span>._yuievt = <span class="hljs-keyword">this</span>._yuievt || {

				<span class="hljs-attr">id</span>: Y.guid(),

				<span class="hljs-attr">events</span>: {},

				<span class="hljs-attr">targets</span>: {},

				<span class="hljs-attr">config</span>: o,

				<span class="hljs-attr">chain</span>: (<span class="hljs-string">'chain'</span> <span class="hljs-keyword">in</span> o) ? o.chain : Y.config.chain,

				<span class="hljs-attr">bubbling</span>: <span class="hljs-literal">false</span>,

				<span class="hljs-attr">defaults</span>: {
					<span class="hljs-attr">context</span>: o.context || <span class="hljs-keyword">this</span>,
					<span class="hljs-attr">host</span>: <span class="hljs-keyword">this</span>,
					<span class="hljs-attr">emitFacade</span>: o.emitFacade,
					<span class="hljs-attr">fireOnce</span>: o.fireOnce,
					<span class="hljs-attr">queuable</span>: o.queuable,
					<span class="hljs-attr">monitored</span>: o.monitored,
					<span class="hljs-attr">broadcast</span>: o.broadcast,
					<span class="hljs-attr">defaultTargetOnly</span>: o.defaultTargetOnly,
					<span class="hljs-attr">bubbles</span>: (<span class="hljs-string">'bubbles'</span> <span class="hljs-keyword">in</span> o) ? o.bubbles : <span class="hljs-literal">true</span>
				}
			};
		};


	ET.prototype = {
		<span class="hljs-attr">constructor</span>: ET,

		<span class="hljs-comment">/**
		 * Listen to a custom event hosted by this object one time.
		 * This is the equivalent to &lt;code&gt;on&lt;/code&gt; except the
		 * listener is immediatelly detached when it is executed.
		 * @method once
		 * @param {String} type The name of the event
		 * @param {Function} fn The callback to execute in response to the event
		 * @param {Object} [context] Override `this` object in callback
		 * @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
		 * @return {EventHandle} A subscription handle capable of detaching the
		 *                       subscription
		 */</span>
		once: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> handle = <span class="hljs-keyword">this</span>.on.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			handle.batch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hand</span>) </span>{
				<span class="hljs-keyword">if</span> (hand.sub) {
					hand.sub.once = <span class="hljs-literal">true</span>;
				}
			});
			<span class="hljs-keyword">return</span> handle;
		},

		<span class="hljs-comment">/**
		 * Listen to a custom event hosted by this object one time.
		 * This is the equivalent to &lt;code&gt;after&lt;/code&gt; except the
		 * listener is immediatelly detached when it is executed.
		 * @method onceAfter
		 * @param {String} type The name of the event
		 * @param {Function} fn The callback to execute in response to the event
		 * @param {Object} [context] Override `this` object in callback
		 * @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
		 * @return {EventHandle} A subscription handle capable of detaching that
		 *                       subscription
		 */</span>
		onceAfter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> handle = <span class="hljs-keyword">this</span>.after.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			handle.batch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hand</span>) </span>{
				<span class="hljs-keyword">if</span> (hand.sub) {
					hand.sub.once = <span class="hljs-literal">true</span>;
				}
			});
			<span class="hljs-keyword">return</span> handle;
		},

		<span class="hljs-comment">/**
		 * Takes the type parameter passed to 'on' and parses out the
		 * various pieces that could be included in the type.  If the
		 * event type is passed without a prefix, it will be expanded
		 * to include the prefix one is supplied or the event target
		 * is configured with a default prefix.
		 * @method parseType
		 * @param {String} type the type
		 * @param {String} [pre=this._yuievt.config.prefix] the prefix
		 * @since 3.3.0
		 * @return {Array} an array containing:
		 *  * the detach category, if supplied,
		 *  * the prefixed event type,
		 *  * whether or not this is an after listener,
		 *  * the supplied event type
		 */</span>
		parseType: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, pre</span>) </span>{
			<span class="hljs-keyword">return</span> _parseType(type, pre || <span class="hljs-keyword">this</span>._yuievt.config.prefix);
		},

		<span class="hljs-comment">/**
		 * Subscribe a callback function to a custom event fired by this object or
		 * from an object that bubbles its events to this object.
		 *
		 * Callback functions for events published with `emitFacade = true` will
		 * receive an `EventFacade` as the first argument (typically named "e").
		 * These callbacks can then call `e.preventDefault()` to disable the
		 * behavior published to that event's `defaultFn`.  See the `EventFacade`
		 * API for all available properties and methods. Subscribers to
		 * non-`emitFacade` events will receive the arguments passed to `fire()`
		 * after the event name.
		 *
		 * To subscribe to multiple events at once, pass an object as the first
		 * argument, where the key:value pairs correspond to the eventName:callback,
		 * or pass an array of event names as the first argument to subscribe to
		 * all listed events with the same callback.
		 *
		 * Returning `false` from a callback is supported as an alternative to
		 * calling `e.preventDefault(); e.stopPropagation();`.  However, it is
		 * recommended to use the event methods whenever possible.
		 *
		 * @method on
		 * @param {String} type The name of the event
		 * @param {Function} fn The callback to execute in response to the event
		 * @param {Object} [context] Override `this` object in callback
		 * @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
		 * @return {EventHandle} A subscription handle capable of detaching that
		 *                       subscription
		 */</span>
		on: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, fn, context</span>) </span>{

			<span class="hljs-keyword">var</span> yuievt = <span class="hljs-keyword">this</span>._yuievt,
				parts = _parseType(type, yuievt.config.prefix), f, c, args, ret, ce,
				detachcategory, handle, store = Y.Env.evt.handles, after, adapt, shorttype,
				Node = Y.Node, n, domevent, isArr;</pre></div></div>
            
        </li>
        
        
        <li id="section-229">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-229">&#182;</a>
              </div>
              <p>full name, args, detachcategory, after</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>._monitor(<span class="hljs-string">'attach'</span>, parts[<span class="hljs-number">1</span>], {
				<span class="hljs-attr">args</span>: <span class="hljs-built_in">arguments</span>,
				<span class="hljs-attr">category</span>: parts[<span class="hljs-number">0</span>],
				<span class="hljs-attr">after</span>: parts[<span class="hljs-number">2</span>]
			});

			<span class="hljs-keyword">if</span> (L.isObject(type)) {

				<span class="hljs-keyword">if</span> (L.isFunction(type)) {
					<span class="hljs-keyword">return</span> Y.Do.before.apply(Y.Do, <span class="hljs-built_in">arguments</span>);
				}

				f = fn;
				c = context;
				args = nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);
				ret = [];

				<span class="hljs-keyword">if</span> (L.isArray(type)) {
					isArr = <span class="hljs-literal">true</span>;
				}

				after = type._after;
				<span class="hljs-keyword">delete</span> type._after;

				Y.each(type, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, k</span>) </span>{

					<span class="hljs-keyword">if</span> (L.isObject(v)) {
						f = v.fn || ((L.isFunction(v)) ? v : f);
						c = v.context || c;
					}

					<span class="hljs-keyword">var</span> nv = (after) ? AFTER_PREFIX : <span class="hljs-string">''</span>;

					args[<span class="hljs-number">0</span>] = nv + ((isArr) ? v : k);
					args[<span class="hljs-number">1</span>] = f;
					args[<span class="hljs-number">2</span>] = c;

					ret.push(<span class="hljs-keyword">this</span>.on.apply(<span class="hljs-keyword">this</span>, args));

				}, <span class="hljs-keyword">this</span>);

				<span class="hljs-keyword">return</span> (yuievt.chain) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> Y.EventHandle(ret);
			}

			detachcategory = parts[<span class="hljs-number">0</span>];
			after = parts[<span class="hljs-number">2</span>];
			shorttype = parts[<span class="hljs-number">3</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-230">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-230">&#182;</a>
              </div>
              <p>extra redirection so we catch adaptor events too.  take a look at this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (Node &amp;&amp; Y.instanceOf(<span class="hljs-keyword">this</span>, Node) &amp;&amp; (shorttype <span class="hljs-keyword">in</span> Node.DOM_EVENTS)) {
				args = nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);
				args.splice(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, Node.getDOMNode(<span class="hljs-keyword">this</span>));
				<span class="hljs-keyword">return</span> Y.on.apply(Y, args);
			}

			type = parts[<span class="hljs-number">1</span>];

			<span class="hljs-keyword">if</span> (Y.instanceOf(<span class="hljs-keyword">this</span>, YUI)) {

				adapt = Y.Env.evt.plugins[type];
				args  = nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);
				args[<span class="hljs-number">0</span>] = shorttype;

				<span class="hljs-keyword">if</span> (Node) {
					n = args[<span class="hljs-number">2</span>];

					<span class="hljs-keyword">if</span> (Y.instanceOf(n, Y.NodeList)) {
						n = Y.NodeList.getDOMNodes(n);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Y.instanceOf(n, Node)) {
						n = Node.getDOMNode(n);
					}

					domevent = (shorttype <span class="hljs-keyword">in</span> Node.DOM_EVENTS);</pre></div></div>
            
        </li>
        
        
        <li id="section-231">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-231">&#182;</a>
              </div>
              <p>Captures both DOM events and event plugins.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (domevent) {
						args[<span class="hljs-number">2</span>] = n;
					}
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-232">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-232">&#182;</a>
              </div>
              <p>check for the existance of an event adaptor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (adapt) {
					handle = adapt.on.apply(Y, args);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((!type) || domevent) {
					handle = Y.Event._attach(args);
				}

			}

			<span class="hljs-keyword">if</span> (!handle) {
				ce = yuievt.events[type] || <span class="hljs-keyword">this</span>.publish(type);
				handle = ce._on(fn, context, (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">3</span>) ? nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">3</span>) : <span class="hljs-literal">null</span>, (after) ? <span class="hljs-string">'after'</span> : <span class="hljs-literal">true</span>);
			}

			<span class="hljs-keyword">if</span> (detachcategory) {
				store[detachcategory] = store[detachcategory] || {};
				store[detachcategory][type] = store[detachcategory][type] || [];
				store[detachcategory][type].push(handle);
			}

			<span class="hljs-keyword">return</span> (yuievt.chain) ? <span class="hljs-keyword">this</span> : handle;

		},

		<span class="hljs-comment">/**
		 * subscribe to an event
		 * @method subscribe
		 * @deprecated use on
		 */</span>
		subscribe: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.on.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
		},

		<span class="hljs-comment">/**
		 * Detach one or more listeners the from the specified event
		 * @method detach
		 * @param type {string|Object}   Either the handle to the subscriber or the
		 *                        type of event.  If the type
		 *                        is not specified, it will attempt to remove
		 *                        the listener from all hosted events.
		 * @param fn   {Function} The subscribed function to unsubscribe, if not
		 *                          supplied, all subscribers will be removed.
		 * @param context  {Object}   The custom object passed to subscribe.  This is
		 *                        optional, but if supplied will be used to
		 *                        disambiguate multiple listeners that are the same
		 *                        (e.g., you subscribe many object using a function
		 *                        that lives on the prototype)
		 * @return {EventTarget} the host
		 */</span>
		detach: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, fn, context</span>) </span>{
			<span class="hljs-keyword">var</span> evts = <span class="hljs-keyword">this</span>._yuievt.events, i,
				Node = Y.Node, isNode = Node &amp;&amp; (Y.instanceOf(<span class="hljs-keyword">this</span>, Node));</pre></div></div>
            
        </li>
        
        
        <li id="section-233">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-233">&#182;</a>
              </div>
              <p>detachAll disabled on the Y instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!type &amp;&amp; (<span class="hljs-keyword">this</span> !== Y)) {
				<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> evts) {
					<span class="hljs-keyword">if</span> (evts.hasOwnProperty(i)) {
						evts[i].detach(fn, context);
					}
				}
				<span class="hljs-keyword">if</span> (isNode) {
					Y.Event.purgeElement(Node.getDOMNode(<span class="hljs-keyword">this</span>));
				}

				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
			}

			<span class="hljs-keyword">var</span> parts = _parseType(type, <span class="hljs-keyword">this</span>._yuievt.config.prefix),
				detachcategory = L.isArray(parts) ? parts[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>,
				shorttype = (parts) ? parts[<span class="hljs-number">3</span>] : <span class="hljs-literal">null</span>,
				adapt, store = Y.Env.evt.handles, detachhost, cat, args,
				ce,

				keyDetacher = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lcat, ltype, host</span>) </span>{
					<span class="hljs-keyword">var</span> handles = lcat[ltype], ce, i;
					<span class="hljs-keyword">if</span> (handles) {
						<span class="hljs-keyword">for</span> (i = handles.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
							ce = handles[i].evt;
							<span class="hljs-keyword">if</span> (ce.host === host || ce.el === host) {
								handles[i].detach();
							}
						}
					}
				};

			<span class="hljs-keyword">if</span> (detachcategory) {

				cat = store[detachcategory];
				type = parts[<span class="hljs-number">1</span>];
				detachhost = (isNode) ? Y.Node.getDOMNode(<span class="hljs-keyword">this</span>) : <span class="hljs-keyword">this</span>;

				<span class="hljs-keyword">if</span> (cat) {
					<span class="hljs-keyword">if</span> (type) {
						keyDetacher(cat, type, detachhost);
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> cat) {
							<span class="hljs-keyword">if</span> (cat.hasOwnProperty(i)) {
								keyDetacher(cat, i, detachhost);
							}
						}
					}

					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-234">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-234">&#182;</a>
              </div>
              <p>If this is an event handle, use it to detach</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (L.isObject(type) &amp;&amp; type.detach) {
				type.detach();
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-235">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-235">&#182;</a>
              </div>
              <p>extra redirection so we catch adaptor events too.  take a look at this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isNode &amp;&amp; ((!shorttype) || (shorttype <span class="hljs-keyword">in</span> Node.DOM_EVENTS))) {
				args = nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);
				args[<span class="hljs-number">2</span>] = Node.getDOMNode(<span class="hljs-keyword">this</span>);
				Y.detach.apply(Y, args);
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
			}

			adapt = Y.Env.evt.plugins[shorttype];</pre></div></div>
            
        </li>
        
        
        <li id="section-236">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-236">&#182;</a>
              </div>
              <p>The YUI instance handles DOM events and adaptors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (Y.instanceOf(<span class="hljs-keyword">this</span>, YUI)) {
				args = nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-237">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-237">&#182;</a>
              </div>
              <p>use the adaptor specific detach code if</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (adapt &amp;&amp; adapt.detach) {
					adapt.detach.apply(Y, args);
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-238">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-238">&#182;</a>
              </div>
              <p>DOM event fork</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!type || (!adapt &amp;&amp; Node &amp;&amp; (type <span class="hljs-keyword">in</span> Node.DOM_EVENTS))) {
					args[<span class="hljs-number">0</span>] = type;
					Y.Event.detach.apply(Y.Event, args);
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-239">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-239">&#182;</a>
              </div>
              <p>ce = evts[type];</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			ce = evts[parts[<span class="hljs-number">1</span>]];
			<span class="hljs-keyword">if</span> (ce) {
				ce.detach(fn, context);
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * detach a listener
		 * @method unsubscribe
		 * @deprecated use detach
		 */</span>
		unsubscribe: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.detach.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
		},

		<span class="hljs-comment">/**
		 * Removes all listeners from the specified event.  If the event type
		 * is not specified, all listeners from all hosted custom events will
		 * be removed.
		 * @method detachAll
		 * @param type {String}   The type, or name of the event
		 */</span>
		detachAll: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.detach(type);
		},

		<span class="hljs-comment">/**
		 * Removes all listeners from the specified event.  If the event type
		 * is not specified, all listeners from all hosted custom events will
		 * be removed.
		 * @method unsubscribeAll
		 * @param type {String}   The type, or name of the event
		 * @deprecated use detachAll
		 */</span>
		unsubscribeAll: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.detachAll.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
		},

		<span class="hljs-comment">/**
		 * Creates a new custom event of the specified type.  If a custom event
		 * by that name already exists, it will not be re-created.  In either
		 * case the custom event is returned.
		 *
		 * @method publish
		 *
		 * @param type {String} the type, or name of the event
		 * @param opts {object} optional config params.  Valid properties are:
		 *
		 *  &lt;ul&gt;
		 *    &lt;li&gt;
		 *   'broadcast': whether or not the YUI instance and YUI global are notified when the event is fired (false)
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'bubbles': whether or not this event bubbles (true)
		 *              Events can only bubble if emitFacade is true.
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'context': the default execution context for the listeners (this)
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'defaultFn': the default function to execute when this event fires if preventDefault was not called
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'emitFacade': whether or not this event emits a facade (false)
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'prefix': the prefix for this targets events, e.g., 'menu' in 'menu:click'
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'fireOnce': if an event is configured to fire once, new subscribers after
		 *   the fire will be notified immediately.
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'async': fireOnce event listeners will fire synchronously if the event has already
		 *    fired unless async is true.
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'preventable': whether or not preventDefault() has an effect (true)
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'preventedFn': a function that is executed when preventDefault is called
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'queuable': whether or not this event can be queued during bubbling (false)
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'silent': if silent is true, debug messages are not provided for this event.
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'stoppedFn': a function that is executed when stopPropagation is called
		 *    &lt;/li&gt;
		 *
		 *    &lt;li&gt;
		 *   'monitored': specifies whether or not this event should send notifications about
		 *   when the event has been attached, detached, or published.
		 *    &lt;/li&gt;
		 *    &lt;li&gt;
		 *   'type': the event type (valid option if not provided as the first parameter to publish)
		 *    &lt;/li&gt;
		 *  &lt;/ul&gt;
		 *
		 *  @return {CustomEvent} the custom event
		 *
		 */</span>
		publish: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, opts</span>) </span>{
			<span class="hljs-keyword">var</span> events, ce, ret, defaults,
				edata = <span class="hljs-keyword">this</span>._yuievt,
				pre = edata.config.prefix;

			<span class="hljs-keyword">if</span> (L.isObject(type)) {
				ret = {};
				Y.each(type, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, k</span>) </span>{
					ret[k] = <span class="hljs-keyword">this</span>.publish(k, v || opts);
				}, <span class="hljs-keyword">this</span>);

				<span class="hljs-keyword">return</span> ret;
			}

			type = (pre) ? _getType(type, pre) : type;

			events = edata.events;
			ce = events[type];

			<span class="hljs-keyword">this</span>._monitor(<span class="hljs-string">'publish'</span>, type, {
				<span class="hljs-attr">args</span>: <span class="hljs-built_in">arguments</span>
			});

			<span class="hljs-keyword">if</span> (ce) {</pre></div></div>
            
        </li>
        
        
        <li id="section-240">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-240">&#182;</a>
              </div>
              <p>ce.log(“publish applying new config to published event: ‘“+type+”‘ exists”, ‘info’, ‘event’);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (opts) {
					ce.applyConfig(opts, <span class="hljs-literal">true</span>);
				}
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-241">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-241">&#182;</a>
              </div>
              <p>TODO: Lazy publish goes here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				defaults = edata.defaults;</pre></div></div>
            
        </li>
        
        
        <li id="section-242">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-242">&#182;</a>
              </div>
              <p>apply defaults</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				ce = <span class="hljs-keyword">new</span> Y.CustomEvent(type, defaults);
				<span class="hljs-keyword">if</span> (opts) {
					ce.applyConfig(opts, <span class="hljs-literal">true</span>);
				}

				events[type] = ce;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-243">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-243">&#182;</a>
              </div>
              <p>make sure we turn the broadcast flag off if this
event was published as a result of bubbling
if (opts instanceof Y.CustomEvent) {
  events[type].broadcast = false;
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
			<span class="hljs-keyword">return</span> events[type];
		},

		<span class="hljs-comment">/**
		 * This is the entry point for the event monitoring system.
		 * You can monitor 'attach', 'detach', 'fire', and 'publish'.
		 * When configured, these events generate an event.  click -&gt;
		 * click_attach, click_detach, click_publish -- these can
		 * be subscribed to like other events to monitor the event
		 * system.  Inividual published events can have monitoring
		 * turned on or off (publish can't be turned off before it
		 * it published) by setting the events 'monitor' config.
		 *
		 * @method _monitor
		 * @param what {String} 'attach', 'detach', 'fire', or 'publish'
		 * @param eventType {String|CustomEvent} The prefixed name of the event being monitored, or the CustomEvent object.
		 * @param o {Object} Information about the event interaction, such as
		 *                  fire() args, subscription category, publish config
		 * @private
		 */</span>
		_monitor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">what, eventType, o</span>) </span>{
			<span class="hljs-keyword">var</span> monitorevt, ce, type;

			<span class="hljs-keyword">if</span> (eventType) {
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> eventType === <span class="hljs-string">"string"</span>) {
					type = eventType;
					ce = <span class="hljs-keyword">this</span>.getEvent(eventType, <span class="hljs-literal">true</span>);
				} <span class="hljs-keyword">else</span> {
					ce = eventType;
					type = eventType.type;
				}

				<span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>._yuievt.config.monitored &amp;&amp; (!ce || ce.monitored)) || (ce &amp;&amp; ce.monitored)) {
					monitorevt = type + <span class="hljs-string">'_'</span> + what;
					o.monitored = what;
					<span class="hljs-keyword">this</span>.fire.call(<span class="hljs-keyword">this</span>, monitorevt, o);
				}
			}
		},

		<span class="hljs-comment">/**
		 * Fire a custom event by name.  The callback functions will be executed
		 * from the context specified when the event was created, and with the
		 * following parameters.
		 *
		 * If the custom event object hasn't been created, then the event hasn't
		 * been published and it has no subscribers.  For performance sake, we
		 * immediate exit in this case.  This means the event won't bubble, so
		 * if the intention is that a bubble target be notified, the event must
		 * be published on this object first.
		 *
		 * The first argument is the event type, and any additional arguments are
		 * passed to the listeners as parameters.  If the first of these is an
		 * object literal, and the event is configured to emit an event facade,
		 * that object is mixed into the event facade and the facade is provided
		 * in place of the original object.
		 *
		 * @method fire
		 * @param type {String|Object} The type of the event, or an object that contains
		 * a 'type' property.
		 * @param arguments {Object*} an arbitrary set of parameters to pass to
		 * the handler.  If the first of these is an object literal and the event is
		 * configured to emit an event facade, the event facade will replace that
		 * parameter after the properties the object literal contains are copied to
		 * the event facade.
		 * @return {EventTarget} the event host
		 */</span>
		fire: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) </span>{

			<span class="hljs-keyword">var</span> typeIncluded = L.isString(type),
				t = (typeIncluded) ? type : (type &amp;&amp; type.type),
				yuievt = <span class="hljs-keyword">this</span>._yuievt,
				pre = yuievt.config.prefix,
				ce, ret,
				ce2,
				args = (typeIncluded) ? nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>) : <span class="hljs-built_in">arguments</span>;

			t = (pre) ? _getType(t, pre) : t;

			ce = <span class="hljs-keyword">this</span>.getEvent(t, <span class="hljs-literal">true</span>);
			ce2 = <span class="hljs-keyword">this</span>.getSibling(t, ce);

			<span class="hljs-keyword">if</span> (ce2 &amp;&amp; !ce) {
				ce = <span class="hljs-keyword">this</span>.publish(t);
			}

			<span class="hljs-keyword">this</span>._monitor(<span class="hljs-string">'fire'</span>, (ce || t), {
				<span class="hljs-attr">args</span>: args
			});</pre></div></div>
            
        </li>
        
        
        <li id="section-244">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-244">&#182;</a>
              </div>
              <p>this event has not been published or subscribed to</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!ce) {
				<span class="hljs-keyword">if</span> (yuievt.hasTargets) {
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.bubble({ <span class="hljs-attr">type</span>: t }, args, <span class="hljs-keyword">this</span>);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-245">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-245">&#182;</a>
              </div>
              <p>otherwise there is nothing to be done</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				ret = <span class="hljs-literal">true</span>;
			} <span class="hljs-keyword">else</span> {
				ce.sibling = ce2;
				ret = ce.fire.apply(ce, args);
			}

			<span class="hljs-keyword">return</span> (yuievt.chain) ? <span class="hljs-keyword">this</span> : ret;
		},

		<span class="hljs-attr">getSibling</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, ce</span>) </span>{
			<span class="hljs-keyword">var</span> ce2;</pre></div></div>
            
        </li>
        
        
        <li id="section-246">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-246">&#182;</a>
              </div>
              <p>delegate to *:type events if there are subscribers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (type.indexOf(PREFIX_DELIMITER) &gt; <span class="hljs-number">-1</span>) {
				type = _wildType(type);</pre></div></div>
            
        </li>
        
        
        <li id="section-247">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-247">&#182;</a>
              </div>
              <p>console.log(type);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				ce2 = <span class="hljs-keyword">this</span>.getEvent(type, <span class="hljs-literal">true</span>);
				<span class="hljs-keyword">if</span> (ce2) {</pre></div></div>
            
        </li>
        
        
        <li id="section-248">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-248">&#182;</a>
              </div>
              <p>console.log(“GOT ONE: “ + type);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					ce2.applyConfig(ce);
					ce2.bubbles = <span class="hljs-literal">false</span>;
					ce2.broadcast = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-249">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-249">&#182;</a>
              </div>
              <p>ret = ce2.fire.apply(ce2, a);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				}
			}

			<span class="hljs-keyword">return</span> ce2;
		},

		<span class="hljs-comment">/**
		 * Returns the custom event of the provided type has been created, a
		 * falsy value otherwise
		 * @method getEvent
		 * @param type {String} the type, or name of the event
		 * @param prefixed {String} if true, the type is prefixed already
		 * @return {CustomEvent} the custom event or null
		 */</span>
		getEvent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, prefixed</span>) </span>{
			<span class="hljs-keyword">var</span> pre, e;
			<span class="hljs-keyword">if</span> (!prefixed) {
				pre = <span class="hljs-keyword">this</span>._yuievt.config.prefix;
				type = (pre) ? _getType(type, pre) : type;
			}
			e = <span class="hljs-keyword">this</span>._yuievt.events;
			<span class="hljs-keyword">return</span> e[type] || <span class="hljs-literal">null</span>;
		},

		<span class="hljs-comment">/**
		 * Subscribe to a custom event hosted by this object.  The
		 * supplied callback will execute after any listeners add
		 * via the subscribe method, and after the default function,
		 * if configured for the event, has executed.
		 *
		 * @method after
		 * @param {String} type The name of the event
		 * @param {Function} fn The callback to execute in response to the event
		 * @param {Object} [context] Override `this` object in callback
		 * @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
		 * @return {EventHandle} A subscription handle capable of detaching the
		 *                       subscription
		 */</span>
		after: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, fn</span>) </span>{

			<span class="hljs-keyword">var</span> a = nativeSlice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);

			<span class="hljs-keyword">switch</span> (L.type(type)) {
				<span class="hljs-keyword">case</span> <span class="hljs-string">'function'</span>:
					<span class="hljs-keyword">return</span> Y.Do.after.apply(Y.Do, <span class="hljs-built_in">arguments</span>);
				<span class="hljs-keyword">case</span> <span class="hljs-string">'array'</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-250">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-250">&#182;</a>
              </div>
              <pre><code>YArray.each(a[<span class="hljs-number">0</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
    v = AFTER_PREFIX + v;
});
<span class="hljs-keyword">break</span>;
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:
					a[<span class="hljs-number">0</span>]._after = <span class="hljs-literal">true</span>;
					<span class="hljs-keyword">break</span>;
				<span class="hljs-keyword">default</span>:
					a[<span class="hljs-number">0</span>] = AFTER_PREFIX + type;
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.on.apply(<span class="hljs-keyword">this</span>, a);

		},

		<span class="hljs-comment">/**
		 * Executes the callback before a DOM event, custom event
		 * or method.  If the first argument is a function, it
		 * is assumed the target is a method.  For DOM and custom
		 * events, this is an alias for Y.on.
		 *
		 * For DOM and custom events:
		 * type, callback, context, 0-n arguments
		 *
		 * For methods:
		 * callback, object (method host), methodName, context, 0-n arguments
		 *
		 * @method before
		 * @return detach handle
		 */</span>
		before: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.on.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
		}

	};

	Y.EventTarget = ET;</pre></div></div>
            
        </li>
        
        
        <li id="section-251">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-251">&#182;</a>
              </div>
              <p>make Y an event target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	Y.mix(Y, ET.prototype);
	ET.call(Y, { <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">false</span> });

	YUI.Env.globalEvents = YUI.Env.globalEvents || <span class="hljs-keyword">new</span> ET();

	<span class="hljs-comment">/**
	 * Hosts YUI page level events.  This is where events bubble to
	 * when the broadcast config is set to 2.  This property is
	 * only available if the custom event module is loaded.
	 * @property Global
	 * @type EventTarget
	 * @for YUI
	 */</span>
	Y.Global = YUI.Env.globalEvents;</pre></div></div>
            
        </li>
        
        
        <li id="section-252">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-252">&#182;</a>
              </div>
              <p>@TODO implement a global namespace function on Y.Global?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-comment">/**
	 `Y.on()` can do many things:

	 &lt;ul&gt;
	 &lt;li&gt;Subscribe to custom events `publish`ed and `fire`d from Y&lt;/li&gt;
	 &lt;li&gt;Subscribe to custom events `publish`ed with `broadcast` 1 or 2 and
	 `fire`d from any object in the YUI instance sandbox&lt;/li&gt;
	 &lt;li&gt;Subscribe to DOM events&lt;/li&gt;
	 &lt;li&gt;Subscribe to the execution of a method on any object, effectively
	 treating that method as an event&lt;/li&gt;
	 &lt;/ul&gt;

	 For custom event subscriptions, pass the custom event name as the first argument and callback as the second. The `this` object in the callback will be `Y` unless an override is passed as the third argument.

	 Y.on('io:complete', function () {
	 Y.MyApp.updateStatus('Transaction complete');
	 });

	 To subscribe to DOM events, pass the name of a DOM event as the first argument
	 and a CSS selector string as the third argument after the callback function.
	 Alternately, the third argument can be a `Node`, `NodeList`, `HTMLElement`,
	 array, or simply omitted (the default is the `window` object).

	 Y.on('click', function (e) {
	 e.preventDefault();

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-253">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-253">&#182;</a>
              </div>
              <p>proceed with ajax form submission</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	 var url = this.get('action');
	 ...
	 }, '#my-form');

	 The `this` object in DOM event callbacks will be the `Node` targeted by the CSS
	 selector or other identifier.

	 `on()` subscribers for DOM events or custom events `publish`ed with a
	 `defaultFn` can prevent the default behavior with `e.preventDefault()` from the
	 event object passed as the first parameter to the subscription callback.

	 To subscribe to the execution of an object method, pass arguments corresponding to the call signature for
	 &lt;a href="../classes/Do.html#methods_before"&gt;`Y.Do.before(...)`&lt;/a&gt;.

	 NOTE: The formal parameter list below is for events, not for function
	 injection.  See `Y.Do.before` for that signature.

	 @method on
	 @param {String} type DOM or custom event name
	 @param {Function} fn The callback to execute in response to the event
	 @param {Object} [context] Override `this` object in callback
	 @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
	 @return {EventHandle} A subscription handle capable of detaching the
	 subscription
	 @see Do.before
	 @for YUI
	 **/

	/**
	 Listen for an event one time.  Equivalent to `on()`, except that
	 the listener is immediately detached when executed.

	 See the &lt;a href="#methods_on"&gt;`on()` method&lt;/a&gt; for additional subscription
	 options.

	 @see on
	 @method once
	 @param {String} type DOM or custom event name
	 @param {Function} fn The callback to execute in response to the event
	 @param {Object} [context] Override `this` object in callback
	 @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
	 @return {EventHandle} A subscription handle capable of detaching the
	 subscription
	 @for YUI
	 **/

	/**
	 Listen for an event one time.  Equivalent to `once()`, except, like `after()`,
	 the subscription callback executes after all `on()` subscribers and the event's
	 `defaultFn` (if configured) have executed.  Like `after()` if any `on()` phase
	 subscriber calls `e.preventDefault()`, neither the `defaultFn` nor the `after()`
	 subscribers will execute.

	 The listener is immediately detached when executed.

	 See the &lt;a href="#methods_on"&gt;`on()` method&lt;/a&gt; for additional subscription
	 options.

	 @see once
	 @method onceAfter
	 @param {String} type The custom event name
	 @param {Function} fn The callback to execute in response to the event
	 @param {Object} [context] Override `this` object in callback
	 @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
	 @return {EventHandle} A subscription handle capable of detaching the
	 subscription
	 @for YUI
	 **/

	/**
	 Like `on()`, this method creates a subscription to a custom event or to the
	 execution of a method on an object.

	 For events, `after()` subscribers are executed after the event's
	 `defaultFn` unless `e.preventDefault()` was called from an `on()` subscriber.

	 See the &lt;a href="#methods_on"&gt;`on()` method&lt;/a&gt; for additional subscription
	 options.

	 NOTE: The subscription signature shown is for events, not for function
	 injection.  See &lt;a href="../classes/Do.html#methods_after"&gt;`Y.Do.after`&lt;/a&gt;
	 for that signature.

	 @see on
	 @see Do.after
	 @method after
	 @param {String} type The custom event name
	 @param {Function} fn The callback to execute in response to the event
	 @param {Object} [context] Override `this` object in callback
	 @param {Any} [args*] 0..n additional arguments to supply to the subscriber
	 @return {EventHandle} A subscription handle capable of detaching the
	 subscription
	 @for YUI
	 **/


}, '3.7.3', {"requires": ["oop"]});
/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */
YUI.add('features', function (Y, NAME) {

	var feature_tests = {};

	/**
	 Contains the core of YUI's feature test architecture.
	 @module features
	 */

	/**
	 * Feature detection
	 * @class Features
	 * @static
	 */

	Y.mix(Y.namespace('Features'), {

		/**
		 * Object hash of all registered feature tests
		 * @property tests
		 * @type Object
		 */
		tests: feature_tests,

		/**
		 * Add a test to the system
		 *
		 *   ```
		 *   Y.Features.add("load", "1", {});
		 *   ```
		 *
		 * @method add
		 * @param {String} cat The category, right now only 'load' is supported
		 * @param {String} name The number sequence of the test, how it's reported in the URL or config: 1, 2, 3
		 * @param {Object} o Object containing test properties
		 * @param {String} o.name The name of the test
		 * @param {Function} o.test The test function to execute, the only argument to the function is the `Y` instance
		 * @param {String} o.trigger The module that triggers this test.
		 */
		add: function(cat, name, o) {
			feature_tests[cat] = feature_tests[cat] || {};
			feature_tests[cat][name] = o;
		},
		/**
		 * Execute all tests of a given category and return the serialized results
		 *
		 *   ```
		 *   caps=1:1;2:1;3:0
		 *   ```
		 * @method all
		 * @param {String} cat The category to execute
		 * @param {Array} args The arguments to pass to the test function
		 * @return {String} A semi-colon separated string of tests and their success/failure: 1:1;2:1;3:0
		 */
		all: function(cat, args) {
			var cat_o = feature_tests[cat],</pre></div></div>
            
        </li>
        
        
        <li id="section-254">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-254">&#182;</a>
              </div>
              <p>results = {};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				result = [];
			<span class="hljs-keyword">if</span> (cat_o) {
				Y.Object.each(cat_o, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, k</span>) </span>{
					result.push(k + <span class="hljs-string">':'</span> + (Y.Features.test(cat, k, args) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));
				});
			}

			<span class="hljs-keyword">return</span> (result.length) ? result.join(<span class="hljs-string">';'</span>) : <span class="hljs-string">''</span>;
		},
		<span class="hljs-comment">/**
		 * Run a sepecific test and return a Boolean response.
		 *
		 *   ```
		 *   Y.Features.test("load", "1");
		 *   ```
		 *
		 * @method test
		 * @param {String} cat The category of the test to run
		 * @param {String} name The name of the test to run
		 * @param {Array} args The arguments to pass to the test function
		 * @return {Boolean} True or false if the test passed/failed.
		 */</span>
		test: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cat, name, args</span>) </span>{
			args = args || [];
			<span class="hljs-keyword">var</span> result, ua, test,
				cat_o = feature_tests[cat],
				feature = cat_o &amp;&amp; cat_o[name];

			<span class="hljs-keyword">if</span> (!feature) {
			} <span class="hljs-keyword">else</span> {

				result = feature.result;

				<span class="hljs-keyword">if</span> (Y.Lang.isUndefined(result)) {

					ua = feature.ua;
					<span class="hljs-keyword">if</span> (ua) {
						result = (Y.UA[ua]);
					}

					test = feature.test;
					<span class="hljs-keyword">if</span> (test &amp;&amp; ((!ua) || result)) {
						result = test.apply(Y, args);
					}

					feature.result = result;
				}
			}

			<span class="hljs-keyword">return</span> result;
		}
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-255">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-255">&#182;</a>
              </div>
              <p>Y.Features.add(“load”, “1”, {});
Y.Features.test(“load”, “1”);
caps=1:1;2:0;3:1;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-comment">/* This file is auto-generated by src/loader/scripts/meta_join.js */</span>
	<span class="hljs-keyword">var</span> add = Y.Features.add;</pre></div></div>
            
        </li>
        
        
        <li id="section-256">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-256">&#182;</a>
              </div>
              <p>app-transitions-native</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'0'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"app-transitions-native"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> doc  = Y.config.doc,
				node = doc ? doc.documentElement : <span class="hljs-literal">null</span>;

			<span class="hljs-keyword">if</span> (node &amp;&amp; node.style) {
				<span class="hljs-keyword">return</span> (<span class="hljs-string">'MozTransition'</span> <span class="hljs-keyword">in</span> node.style || <span class="hljs-string">'WebkitTransition'</span> <span class="hljs-keyword">in</span> node.style || <span class="hljs-string">'transition'</span> <span class="hljs-keyword">in</span> node.style);
			}

			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"app-transitions"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-257">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-257">&#182;</a>
              </div>
              <p>autocomplete-list-keys</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'1'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"autocomplete-list-keys"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-258">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-258">&#182;</a>
              </div>
              <p>Only add keyboard support to autocomplete-list if this doesn’t appear to
be an iOS or Android-based mobile device.</p>
<p>There’s currently no feasible way to actually detect whether a device has
a hardware keyboard, so this sniff will have to do. It can easily be
overridden by manually loading the autocomplete-list-keys module.</p>
<p>Worth noting: even though iOS supports bluetooth keyboards, Mobile Safari
doesn’t fire the keyboard events used by AutoCompleteList, so there’s
no point loading the -keys module even when a bluetooth keyboard may be
available.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> !(Y.UA.ios || Y.UA.android);
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"autocomplete-list"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-259">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-259">&#182;</a>
              </div>
              <p>dd-gestures</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'2'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"dd-gestures"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"dd-drag"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"touchEnabled"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-260">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-260">&#182;</a>
              </div>
              <p>dom-style-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'3'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"dom-style-ie"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{

			<span class="hljs-keyword">var</span> testFeature = Y.Features.test,
				addFeature = Y.Features.add,
				WINDOW = Y.config.win,
				DOCUMENT = Y.config.doc,
				DOCUMENT_ELEMENT = <span class="hljs-string">'documentElement'</span>,
				ret = <span class="hljs-literal">false</span>;

			addFeature(<span class="hljs-string">'style'</span>, <span class="hljs-string">'computedStyle'</span>, {
				<span class="hljs-attr">test</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					<span class="hljs-keyword">return</span> WINDOW &amp;&amp; <span class="hljs-string">'getComputedStyle'</span> <span class="hljs-keyword">in</span> WINDOW;
				}
			});

			addFeature(<span class="hljs-string">'style'</span>, <span class="hljs-string">'opacity'</span>, {
				<span class="hljs-attr">test</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					<span class="hljs-keyword">return</span> DOCUMENT &amp;&amp; <span class="hljs-string">'opacity'</span> <span class="hljs-keyword">in</span> DOCUMENT[DOCUMENT_ELEMENT].style;
				}
			});

			ret =  (!testFeature(<span class="hljs-string">'style'</span>, <span class="hljs-string">'opacity'</span>) &amp;&amp;
				!testFeature(<span class="hljs-string">'style'</span>, <span class="hljs-string">'computedStyle'</span>));

			<span class="hljs-keyword">return</span> ret;
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"dom-style"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-261">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-261">&#182;</a>
              </div>
              <p>editor-para-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'4'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"editor-para-ie"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"editor-para"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"ie"</span>,
		<span class="hljs-string">"when"</span>: <span class="hljs-string">"instead"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-262">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-262">&#182;</a>
              </div>
              <p>event-base-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'5'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"event-base-ie"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> imp = Y.config.doc &amp;&amp; Y.config.doc.implementation;
			<span class="hljs-keyword">return</span> (imp &amp;&amp; (!imp.hasFeature(<span class="hljs-string">'Events'</span>, <span class="hljs-string">'2.0'</span>)));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"node-base"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-263">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-263">&#182;</a>
              </div>
              <p>graphics-canvas</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'6'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-canvas"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				useCanvas = Y.config.defaultGraphicEngine &amp;&amp; Y.config.defaultGraphicEngine == <span class="hljs-string">"canvas"</span>,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>),
				svg = (DOCUMENT &amp;&amp; DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>));
			<span class="hljs-keyword">return</span> (!svg || useCanvas) &amp;&amp; (canvas &amp;&amp; canvas.getContext &amp;&amp; canvas.getContext(<span class="hljs-string">"2d"</span>));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-264">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-264">&#182;</a>
              </div>
              <p>graphics-canvas-default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'7'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-canvas-default"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				useCanvas = Y.config.defaultGraphicEngine &amp;&amp; Y.config.defaultGraphicEngine == <span class="hljs-string">"canvas"</span>,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>),
				svg = (DOCUMENT &amp;&amp; DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>));
			<span class="hljs-keyword">return</span> (!svg || useCanvas) &amp;&amp; (canvas &amp;&amp; canvas.getContext &amp;&amp; canvas.getContext(<span class="hljs-string">"2d"</span>));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-265">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-265">&#182;</a>
              </div>
              <p>graphics-svg</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'8'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-svg"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				useSVG = !Y.config.defaultGraphicEngine || Y.config.defaultGraphicEngine != <span class="hljs-string">"canvas"</span>,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>),
				svg = (DOCUMENT &amp;&amp; DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>));

			<span class="hljs-keyword">return</span> svg &amp;&amp; (useSVG || !canvas);
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-266">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-266">&#182;</a>
              </div>
              <p>graphics-svg-default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'9'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-svg-default"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				useSVG = !Y.config.defaultGraphicEngine || Y.config.defaultGraphicEngine != <span class="hljs-string">"canvas"</span>,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>),
				svg = (DOCUMENT &amp;&amp; DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>));

			<span class="hljs-keyword">return</span> svg &amp;&amp; (useSVG || !canvas);
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-267">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-267">&#182;</a>
              </div>
              <p>graphics-vml</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'10'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-vml"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>);
			<span class="hljs-keyword">return</span> (DOCUMENT &amp;&amp; !DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>) &amp;&amp; (!canvas || !canvas.getContext || !canvas.getContext(<span class="hljs-string">"2d"</span>)));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-268">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-268">&#182;</a>
              </div>
              <p>graphics-vml-default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'11'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"graphics-vml-default"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				canvas = DOCUMENT &amp;&amp; DOCUMENT.createElement(<span class="hljs-string">"canvas"</span>);
			<span class="hljs-keyword">return</span> (DOCUMENT &amp;&amp; !DOCUMENT.implementation.hasFeature(<span class="hljs-string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="hljs-string">"1.1"</span>) &amp;&amp; (!canvas || !canvas.getContext || !canvas.getContext(<span class="hljs-string">"2d"</span>)));
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"graphics"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-269">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-269">&#182;</a>
              </div>
              <p>history-hash-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'12'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"history-hash-ie"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> docMode = Y.config.doc &amp;&amp; Y.config.doc.documentMode;

			<span class="hljs-keyword">return</span> Y.UA.ie &amp;&amp; (!(<span class="hljs-string">'onhashchange'</span> <span class="hljs-keyword">in</span> Y.config.win) ||
				!docMode || docMode &lt; <span class="hljs-number">8</span>);
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"history-hash"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-270">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-270">&#182;</a>
              </div>
              <p>io-nodejs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'13'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"io-nodejs"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"io-base"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"nodejs"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-271">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-271">&#182;</a>
              </div>
              <p>scrollview-base-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'14'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"scrollview-base-ie"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"scrollview-base"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"ie"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-272">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-272">&#182;</a>
              </div>
              <p>selector-css2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'15'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"selector-css2"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				ret = DOCUMENT &amp;&amp; !(<span class="hljs-string">'querySelectorAll'</span> <span class="hljs-keyword">in</span> DOCUMENT);

			<span class="hljs-keyword">return</span> ret;
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"selector"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-273">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-273">&#182;</a>
              </div>
              <p>transition-timer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'16'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"transition-timer"</span>,
		<span class="hljs-string">"test"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y</span>) </span>{
			<span class="hljs-keyword">var</span> DOCUMENT = Y.config.doc,
				node = (DOCUMENT) ? DOCUMENT.documentElement: <span class="hljs-literal">null</span>,
				ret = <span class="hljs-literal">true</span>;

			<span class="hljs-keyword">if</span> (node &amp;&amp; node.style) {
				ret = !(<span class="hljs-string">'MozTransition'</span> <span class="hljs-keyword">in</span> node.style || <span class="hljs-string">'WebkitTransition'</span> <span class="hljs-keyword">in</span> node.style || <span class="hljs-string">'transition'</span> <span class="hljs-keyword">in</span> node.style);
			}

			<span class="hljs-keyword">return</span> ret;
		},
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"transition"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-274">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-274">&#182;</a>
              </div>
              <p>widget-base-ie</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'17'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"widget-base-ie"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"widget-base"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"ie"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-275">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-275">&#182;</a>
              </div>
              <p>yql-nodejs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'18'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"yql-nodejs"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"yql"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"nodejs"</span>,
		<span class="hljs-string">"when"</span>: <span class="hljs-string">"after"</span>
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-276">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-276">&#182;</a>
              </div>
              <p>yql-winjs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	add(<span class="hljs-string">'load'</span>, <span class="hljs-string">'19'</span>, {
		<span class="hljs-string">"name"</span>: <span class="hljs-string">"yql-winjs"</span>,
		<span class="hljs-string">"trigger"</span>: <span class="hljs-string">"yql"</span>,
		<span class="hljs-string">"ua"</span>: <span class="hljs-string">"winjs"</span>,
		<span class="hljs-string">"when"</span>: <span class="hljs-string">"after"</span>
	});

}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'dom-core'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-keyword">var</span> NODE_TYPE = <span class="hljs-string">'nodeType'</span>,
		OWNER_DOCUMENT = <span class="hljs-string">'ownerDocument'</span>,
		DOCUMENT_ELEMENT = <span class="hljs-string">'documentElement'</span>,
		DEFAULT_VIEW = <span class="hljs-string">'defaultView'</span>,
		PARENT_WINDOW = <span class="hljs-string">'parentWindow'</span>,
		TAG_NAME = <span class="hljs-string">'tagName'</span>,
		PARENT_NODE = <span class="hljs-string">'parentNode'</span>,
		PREVIOUS_SIBLING = <span class="hljs-string">'previousSibling'</span>,
		NEXT_SIBLING = <span class="hljs-string">'nextSibling'</span>,
		CONTAINS = <span class="hljs-string">'contains'</span>,
		COMPARE_DOCUMENT_POSITION = <span class="hljs-string">'compareDocumentPosition'</span>,
		EMPTY_ARRAY = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-277">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-277">&#182;</a>
              </div>
              <p>IE &lt; 8 throws on node.contains(textNode)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		supportsContainsTextNode = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> node = Y.config.doc.createElement(<span class="hljs-string">'div'</span>),
				textNode = node.appendChild(Y.config.doc.createTextNode(<span class="hljs-string">''</span>)),
				result = <span class="hljs-literal">false</span>;

			<span class="hljs-keyword">try</span> {
				result = node.contains(textNode);
			} <span class="hljs-keyword">catch</span>(e) {}

			<span class="hljs-keyword">return</span> result;
		})(),

	<span class="hljs-comment">/**
	 * The DOM utility provides a cross-browser abtraction layer
	 * normalizing DOM tasks, and adds extra helper functionality
	 * for other common tasks.
	 * @module dom
	 * @main dom
	 * @submodule dom-base
	 * @for DOM
	 *
	 */</span>

		<span class="hljs-comment">/**
		 * Provides DOM helper methods.
		 * @class DOM
		 *
		 */</span>

			Y_DOM = {
			<span class="hljs-comment">/**
			 * Returns the HTMLElement with the given ID (Wrapper for document.getElementById).
			 * @method byId
			 * @param {String} id the id attribute
			 * @param {Object} doc optional The document to search. Defaults to current document
			 * @return {HTMLElement | null} The HTMLElement with the id, or null if none found.
			 */</span>
			byId: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id, doc</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-278">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-278">&#182;</a>
              </div>
              <p>handle dupe IDs and IE name collision</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> Y_DOM.allById(id, doc)[<span class="hljs-number">0</span>] || <span class="hljs-literal">null</span>;
			},

			<span class="hljs-attr">getId</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">var</span> id;</pre></div></div>
            
        </li>
        
        
        <li id="section-279">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-279">&#182;</a>
              </div>
              <p>HTMLElement returned from FORM when INPUT name === “id”
IE &lt; 8: HTMLCollection returned when INPUT id === “id”
via both getAttribute and form.id </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (node.id &amp;&amp; !node.id.tagName &amp;&amp; !node.id.item) {
					id = node.id;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.attributes &amp;&amp; node.attributes.id) {
					id = node.attributes.id.value;
				}

				<span class="hljs-keyword">return</span> id;
			},

			<span class="hljs-attr">setId</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, id</span>) </span>{
				<span class="hljs-keyword">if</span> (node.setAttribute) {
					node.setAttribute(<span class="hljs-string">'id'</span>, id);
				} <span class="hljs-keyword">else</span> {
					node.id = id;
				}
			},

			<span class="hljs-comment">/*
			 * Finds the ancestor of the element.
			 * @method ancestor
			 * @param {HTMLElement} element The html element.
			 * @param {Function} fn optional An optional boolean test to apply.
			 * The optional function is passed the current DOM node being tested as its only argument.
			 * If no function is given, the parentNode is returned.
			 * @param {Boolean} testSelf optional Whether or not to include the element in the scan 
			 * @return {HTMLElement | null} The matching DOM node or null if none found. 
			 */</span>
			ancestor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, fn, testSelf, stopFn</span>) </span>{
				<span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;
				<span class="hljs-keyword">if</span> (testSelf) {
					ret = (!fn || fn(element)) ? element : <span class="hljs-literal">null</span>;

				}
				<span class="hljs-keyword">return</span> ret || Y_DOM.elementByAxis(element, PARENT_NODE, fn, <span class="hljs-literal">null</span>, stopFn);
			},

			<span class="hljs-comment">/*
			 * Finds the ancestors of the element.
			 * @method ancestors
			 * @param {HTMLElement} element The html element.
			 * @param {Function} fn optional An optional boolean test to apply.
			 * The optional function is passed the current DOM node being tested as its only argument.
			 * If no function is given, all ancestors are returned.
			 * @param {Boolean} testSelf optional Whether or not to include the element in the scan 
			 * @return {Array} An array containing all matching DOM nodes.
			 */</span>
			ancestors: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, fn, testSelf, stopFn</span>) </span>{
				<span class="hljs-keyword">var</span> ancestor = element,
					ret = [];

				<span class="hljs-keyword">while</span> ((ancestor = Y_DOM.ancestor(ancestor, fn, testSelf, stopFn))) {
					testSelf = <span class="hljs-literal">false</span>;
					<span class="hljs-keyword">if</span> (ancestor) {
						ret.unshift(ancestor);

						<span class="hljs-keyword">if</span> (stopFn &amp;&amp; stopFn(ancestor)) {
							<span class="hljs-keyword">return</span> ret;
						}
					}
				}

				<span class="hljs-keyword">return</span> ret;
			},

			<span class="hljs-comment">/**
			 * Searches the element by the given axis for the first matching element.
			 * @method elementByAxis
			 * @param {HTMLElement} element The html element.
			 * @param {String} axis The axis to search (parentNode, nextSibling, previousSibling).
			 * @param {Function} fn optional An optional boolean test to apply.
			 * @param {Boolean} all optional Whether all node types should be returned, or just element nodes.
			 * The optional function is passed the current HTMLElement being tested as its only argument.
			 * If no function is given, the first element is returned.
			 * @return {HTMLElement | null} The matching element or null if none found.
			 */</span>
			elementByAxis: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, axis, fn, all, stopAt</span>) </span>{
				<span class="hljs-keyword">while</span> (element &amp;&amp; (element = element[axis])) { <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> assignment</span>
					<span class="hljs-keyword">if</span> ( (all || element[TAG_NAME]) &amp;&amp; (!fn || fn(element)) ) {
						<span class="hljs-keyword">return</span> element;
					}

					<span class="hljs-keyword">if</span> (stopAt &amp;&amp; stopAt(element)) {
						<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
					}
				}
				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
			},

			<span class="hljs-comment">/**
			 * Determines whether or not one HTMLElement is or contains another HTMLElement.
			 * @method contains
			 * @param {HTMLElement} element The containing html element.
			 * @param {HTMLElement} needle The html element that may be contained.
			 * @return {Boolean} Whether or not the element is or contains the needle.
			 */</span>
			contains: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, needle</span>) </span>{
				<span class="hljs-keyword">var</span> ret = <span class="hljs-literal">false</span>;

				<span class="hljs-keyword">if</span> ( !needle || !element || !needle[NODE_TYPE] || !element[NODE_TYPE]) {
					ret = <span class="hljs-literal">false</span>;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element[CONTAINS] &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-280">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-280">&#182;</a>
              </div>
              <p>IE &lt; 8 throws on node.contains(textNode) so fall back to brute.
Falling back for other nodeTypes as well.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					(needle[NODE_TYPE] === <span class="hljs-number">1</span> || supportsContainsTextNode)) {
					ret = element[CONTAINS](needle);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element[COMPARE_DOCUMENT_POSITION]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-281">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-281">&#182;</a>
              </div>
              <p>Match contains behavior (node.contains(node) === true).
Needed for Firefox &lt; 4.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (element === needle || !!(element[COMPARE_DOCUMENT_POSITION](needle) &amp; <span class="hljs-number">16</span>)) {
						ret = <span class="hljs-literal">true</span>;
					}
				} <span class="hljs-keyword">else</span> {
					ret = Y_DOM._bruteContains(element, needle);
				}

				<span class="hljs-keyword">return</span> ret;
			},

			<span class="hljs-comment">/**
			 * Determines whether or not the HTMLElement is part of the document.
			 * @method inDoc
			 * @param {HTMLElement} element The containing html element.
			 * @param {HTMLElement} doc optional The document to check.
			 * @return {Boolean} Whether or not the element is attached to the document.
			 */</span>
			inDoc: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, doc</span>) </span>{
				<span class="hljs-keyword">var</span> ret = <span class="hljs-literal">false</span>,
					rootNode;

				<span class="hljs-keyword">if</span> (element &amp;&amp; element.nodeType) {
					(doc) || (doc = element[OWNER_DOCUMENT]);

					rootNode = doc[DOCUMENT_ELEMENT];</pre></div></div>
            
        </li>
        
        
        <li id="section-282">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-282">&#182;</a>
              </div>
              <p>contains only works with HTML_ELEMENT</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (rootNode &amp;&amp; rootNode.contains &amp;&amp; element.tagName) {
						ret = rootNode.contains(element);
					} <span class="hljs-keyword">else</span> {
						ret = Y_DOM.contains(rootNode, element);
					}
				}

				<span class="hljs-keyword">return</span> ret;

			},

			<span class="hljs-attr">allById</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id, root</span>) </span>{
				root = root || Y.config.doc;
				<span class="hljs-keyword">var</span> nodes = [],
					ret = [],
					i,
					node;

				<span class="hljs-keyword">if</span> (root.querySelectorAll) {
					ret = root.querySelectorAll(<span class="hljs-string">'[id="'</span> + id + <span class="hljs-string">'"]'</span>);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.all) {
					nodes = root.all(id);

					<span class="hljs-keyword">if</span> (nodes) {</pre></div></div>
            
        </li>
        
        
        <li id="section-283">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-283">&#182;</a>
              </div>
              <p>root.all may return HTMLElement or HTMLCollection.
some elements are also HTMLCollection (FORM, SELECT).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (nodes.nodeName) {
							<span class="hljs-keyword">if</span> (nodes.id === id) { <span class="hljs-comment">// avoid false positive on name</span>
								ret.push(nodes);
								nodes = EMPTY_ARRAY; <span class="hljs-comment">// done, no need to filter</span>
							} <span class="hljs-keyword">else</span> { <span class="hljs-comment">//  prep for filtering</span>
								nodes = [nodes];
							}
						}

						<span class="hljs-keyword">if</span> (nodes.length) {</pre></div></div>
            
        </li>
        
        
        <li id="section-284">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-284">&#182;</a>
              </div>
              <p>filter out matches on node.name
and element.id as reference to element with id === ‘id’</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; node = nodes[i++];) {
								<span class="hljs-keyword">if</span> (node.id === id  ||
									(node.attributes &amp;&amp; node.attributes.id &amp;&amp;
										node.attributes.id.value === id)) {
									ret.push(node);
								}
							}
						}
					}
				} <span class="hljs-keyword">else</span> {
					ret = [Y_DOM._getDoc(root).getElementById(id)];
				}

				<span class="hljs-keyword">return</span> ret;
			},


			<span class="hljs-attr">isWindow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
				<span class="hljs-keyword">return</span> !!(obj &amp;&amp; obj.scrollTo &amp;&amp; obj.document);
			},

			<span class="hljs-attr">_removeChildNodes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">while</span> (node.firstChild) {
					node.removeChild(node.firstChild);
				}
			},

			<span class="hljs-attr">siblings</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, fn</span>) </span>{
				<span class="hljs-keyword">var</span> nodes = [],
					sibling = node;

				<span class="hljs-keyword">while</span> ((sibling = sibling[PREVIOUS_SIBLING])) {
					<span class="hljs-keyword">if</span> (sibling[TAG_NAME] &amp;&amp; (!fn || fn(sibling))) {
						nodes.unshift(sibling);
					}
				}

				sibling = node;
				<span class="hljs-keyword">while</span> ((sibling = sibling[NEXT_SIBLING])) {
					<span class="hljs-keyword">if</span> (sibling[TAG_NAME] &amp;&amp; (!fn || fn(sibling))) {
						nodes.push(sibling);
					}
				}

				<span class="hljs-keyword">return</span> nodes;
			},

			<span class="hljs-comment">/**
			 * Brute force version of contains.
			 * Used for browsers without contains support for non-HTMLElement Nodes (textNodes, etc).
			 * @method _bruteContains
			 * @private
			 * @param {HTMLElement} element The containing html element.
			 * @param {HTMLElement} needle The html element that may be contained.
			 * @return {Boolean} Whether or not the element is or contains the needle.
			 */</span>
			_bruteContains: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, needle</span>) </span>{
				<span class="hljs-keyword">while</span> (needle) {
					<span class="hljs-keyword">if</span> (element === needle) {
						<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
					}
					needle = needle.parentNode;
				}
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-285">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-285">&#182;</a>
              </div>
              <p>TODO: move to Lang?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * Memoizes dynamic regular expressions to boost runtime performance.
			 * @method _getRegExp
			 * @private
			 * @param {String} str The string to convert to a regular expression.
			 * @param {String} flags optional An optinal string of flags.
			 * @return {RegExp} An instance of RegExp
			 */</span>
			_getRegExp: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str, flags</span>) </span>{
				flags = flags || <span class="hljs-string">''</span>;
				Y_DOM._regexCache = Y_DOM._regexCache || {};
				<span class="hljs-keyword">if</span> (!Y_DOM._regexCache[str + flags]) {
					Y_DOM._regexCache[str + flags] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(str, flags);
				}
				<span class="hljs-keyword">return</span> Y_DOM._regexCache[str + flags];
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-286">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-286">&#182;</a>
              </div>
              <p>TODO: make getDoc/Win true privates?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * returns the appropriate document.
			 * @method _getDoc
			 * @private
			 * @param {HTMLElement} element optional Target element.
			 * @return {Object} The document for the given element or the default document.
			 */</span>
			_getDoc: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
				<span class="hljs-keyword">var</span> doc = Y.config.doc;
				<span class="hljs-keyword">if</span> (element) {
					doc = (element[NODE_TYPE] === <span class="hljs-number">9</span>) ? element : <span class="hljs-comment">// element === document</span>
						element[OWNER_DOCUMENT] || <span class="hljs-comment">// element === DOM node</span>
							element.document || <span class="hljs-comment">// element === window</span>
							Y.config.doc; <span class="hljs-comment">// default</span>
				}

				<span class="hljs-keyword">return</span> doc;
			},

			<span class="hljs-comment">/**
			 * returns the appropriate window.
			 * @method _getWin
			 * @private
			 * @param {HTMLElement} element optional Target element.
			 * @return {Object} The window for the given element or the default window.
			 */</span>
			_getWin: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
				<span class="hljs-keyword">var</span> doc = Y_DOM._getDoc(element);
				<span class="hljs-keyword">return</span> doc[DEFAULT_VIEW] || doc[PARENT_WINDOW] || Y.config.win;
			},

			<span class="hljs-attr">_batch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodes, fn, arg1, arg2, arg3, etc</span>) </span>{
				fn = (<span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">'string'</span>) ? Y_DOM[fn] : fn;
				<span class="hljs-keyword">var</span> result,
					i = <span class="hljs-number">0</span>,
					node,
					ret;

				<span class="hljs-keyword">if</span> (fn &amp;&amp; nodes) {
					<span class="hljs-keyword">while</span> ((node = nodes[i++])) {
						result = result = fn.call(Y_DOM, node, arg1, arg2, arg3, etc);
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result !== <span class="hljs-string">'undefined'</span>) {
							(ret) || (ret = []);
							ret.push(result);
						}
					}
				}

				<span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> ret !== <span class="hljs-string">'undefined'</span>) ? ret : nodes;
			},

			<span class="hljs-attr">generateID</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>) </span>{
				<span class="hljs-keyword">var</span> id = el.id;

				<span class="hljs-keyword">if</span> (!id) {
					id = Y.stamp(el);
					el.id = id;
				}

				<span class="hljs-keyword">return</span> id;
			}
		};


	Y.DOM = Y_DOM;


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"oop"</span>, <span class="hljs-string">"features"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'dom-base'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * @for DOM
	 * @module dom
	 */</span>
	<span class="hljs-keyword">var</span> documentElement = Y.config.doc.documentElement,
		Y_DOM = Y.DOM,
		TAG_NAME = <span class="hljs-string">'tagName'</span>,
		OWNER_DOCUMENT = <span class="hljs-string">'ownerDocument'</span>,
		EMPTY_STRING = <span class="hljs-string">''</span>,
		addFeature = Y.Features.add,
		testFeature = Y.Features.test;

	Y.mix(Y_DOM, {
		<span class="hljs-comment">/**
		 * Returns the text content of the HTMLElement.
		 * @method getText
		 * @param {HTMLElement} element The html element.
		 * @return {String} The text content of the element (includes text of any descending elements).
		 */</span>
		getText: (documentElement.textContent !== <span class="hljs-literal">undefined</span>) ?
			<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
				<span class="hljs-keyword">var</span> ret = <span class="hljs-string">''</span>;
				<span class="hljs-keyword">if</span> (element) {
					ret = element.textContent;
				}
				<span class="hljs-keyword">return</span> ret || <span class="hljs-string">''</span>;
			} : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
			<span class="hljs-keyword">var</span> ret = <span class="hljs-string">''</span>;
			<span class="hljs-keyword">if</span> (element) {
				ret = element.innerText || element.nodeValue; <span class="hljs-comment">// might be a textNode</span>
			}
			<span class="hljs-keyword">return</span> ret || <span class="hljs-string">''</span>;
		},

		<span class="hljs-comment">/**
		 * Sets the text content of the HTMLElement.
		 * @method setText
		 * @param {HTMLElement} element The html element.
		 * @param {String} content The content to add.
		 */</span>
		setText: (documentElement.textContent !== <span class="hljs-literal">undefined</span>) ?
			<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, content</span>) </span>{
				<span class="hljs-keyword">if</span> (element) {
					element.textContent = content;
				}
			} : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, content</span>) </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-string">'innerText'</span> <span class="hljs-keyword">in</span> element) {
				element.innerText = content;
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'nodeValue'</span> <span class="hljs-keyword">in</span> element) {
				element.nodeValue = content;
			}
		},

		<span class="hljs-attr">CUSTOM_ATTRIBUTES</span>: (!documentElement.hasAttribute) ? { <span class="hljs-comment">// IE &lt; 8</span>
			<span class="hljs-string">'for'</span>: <span class="hljs-string">'htmlFor'</span>,
			<span class="hljs-string">'class'</span>: <span class="hljs-string">'className'</span>
		} : { <span class="hljs-comment">// w3c</span>
			<span class="hljs-string">'htmlFor'</span>: <span class="hljs-string">'for'</span>,
			<span class="hljs-string">'className'</span>: <span class="hljs-string">'class'</span>
		},

		<span class="hljs-comment">/**
		 * Provides a normalized attribute interface.
		 * @method setAttribute
		 * @param {HTMLElement} el The target element for the attribute.
		 * @param {String} attr The attribute to set.
		 * @param {String} val The value of the attribute.
		 */</span>
		setAttribute: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, attr, val, ieAttr</span>) </span>{
			<span class="hljs-keyword">if</span> (el &amp;&amp; attr &amp;&amp; el.setAttribute) {
				attr = Y_DOM.CUSTOM_ATTRIBUTES[attr] || attr;
				el.setAttribute(attr, val, ieAttr);
			}
		},


		<span class="hljs-comment">/**
		 * Provides a normalized attribute interface.
		 * @method getAttribute
		 * @param {HTMLElement} el The target element for the attribute.
		 * @param {String} attr The attribute to get.
		 * @return {String} The current value of the attribute.
		 */</span>
		getAttribute: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, attr, ieAttr</span>) </span>{
			ieAttr = (ieAttr !== <span class="hljs-literal">undefined</span>) ? ieAttr : <span class="hljs-number">2</span>;
			<span class="hljs-keyword">var</span> ret = <span class="hljs-string">''</span>;
			<span class="hljs-keyword">if</span> (el &amp;&amp; attr &amp;&amp; el.getAttribute) {
				attr = Y_DOM.CUSTOM_ATTRIBUTES[attr] || attr;
				ret = el.getAttribute(attr, ieAttr);

				<span class="hljs-keyword">if</span> (ret === <span class="hljs-literal">null</span>) {
					ret = <span class="hljs-string">''</span>; <span class="hljs-comment">// per DOM spec</span>
				}
			}
			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-attr">VALUE_SETTERS</span>: {},

		<span class="hljs-attr">VALUE_GETTERS</span>: {},

		<span class="hljs-attr">getValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			<span class="hljs-keyword">var</span> ret = <span class="hljs-string">''</span>, <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> return null?</span>
				getter;

			<span class="hljs-keyword">if</span> (node &amp;&amp; node[TAG_NAME]) {
				getter = Y_DOM.VALUE_GETTERS[node[TAG_NAME].toLowerCase()];

				<span class="hljs-keyword">if</span> (getter) {
					ret = getter(node);
				} <span class="hljs-keyword">else</span> {
					ret = node.value;
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-287">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-287">&#182;</a>
              </div>
              <p>workaround for IE8 JSON stringify bug
which converts empty string values to null</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (ret === EMPTY_STRING) {
				ret = EMPTY_STRING; <span class="hljs-comment">// for real</span>
			}

			<span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">'string'</span>) ? ret : <span class="hljs-string">''</span>;
		},

		<span class="hljs-attr">setValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, val</span>) </span>{
			<span class="hljs-keyword">var</span> setter;

			<span class="hljs-keyword">if</span> (node &amp;&amp; node[TAG_NAME]) {
				setter = Y_DOM.VALUE_SETTERS[node[TAG_NAME].toLowerCase()];

				<span class="hljs-keyword">if</span> (setter) {
					setter(node, val);
				} <span class="hljs-keyword">else</span> {
					node.value = val;
				}
			}
		},

		<span class="hljs-attr">creators</span>: {}
	});

	addFeature(<span class="hljs-string">'value-set'</span>, <span class="hljs-string">'select'</span>, {
		<span class="hljs-attr">test</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> node = Y.config.doc.createElement(<span class="hljs-string">'select'</span>);
			node.innerHTML = <span class="hljs-string">'&lt;option&gt;1&lt;/option&gt;&lt;option&gt;2&lt;/option&gt;'</span>;
			node.value = <span class="hljs-string">'2'</span>;
			<span class="hljs-keyword">return</span> (node.value &amp;&amp; node.value === <span class="hljs-string">'2'</span>);
		}
	});

	<span class="hljs-keyword">if</span> (!testFeature(<span class="hljs-string">'value-set'</span>, <span class="hljs-string">'select'</span>)) {
		Y_DOM.VALUE_SETTERS.select = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, val</span>) </span>{
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, options = node.getElementsByTagName(<span class="hljs-string">'option'</span>), option;
			     option = options[i++];) {
				<span class="hljs-keyword">if</span> (Y_DOM.getValue(option) === val) {
					option.selected = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-288">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-288">&#182;</a>
              </div>
              <p>Y_DOM.setAttribute(option, ‘selected’, ‘selected’);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">break</span>;
				}
			}
		};
	}

	Y.mix(Y_DOM.VALUE_GETTERS, {
		<span class="hljs-attr">button</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			<span class="hljs-keyword">return</span> (node.attributes &amp;&amp; node.attributes.value) ? node.attributes.value.value : <span class="hljs-string">''</span>;
		}
	});

	Y.mix(Y_DOM.VALUE_SETTERS, {</pre></div></div>
            
        </li>
        
        
        <li id="section-289">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-289">&#182;</a>
              </div>
              <p>IE: node.value changes the button text, which should be handled via innerHTML</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		button: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, val</span>) </span>{
			<span class="hljs-keyword">var</span> attr = node.attributes.value;
			<span class="hljs-keyword">if</span> (!attr) {
				attr = node[OWNER_DOCUMENT].createAttribute(<span class="hljs-string">'value'</span>);
				node.setAttributeNode(attr);
			}

			attr.value = val;
		}
	});


	Y.mix(Y_DOM.VALUE_GETTERS, {
		<span class="hljs-attr">option</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			<span class="hljs-keyword">var</span> attrs = node.attributes;
			<span class="hljs-keyword">return</span> (attrs.value &amp;&amp; attrs.value.specified) ? node.value : node.text;
		},

		<span class="hljs-attr">select</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			<span class="hljs-keyword">var</span> val = node.value,
				options = node.options;

			<span class="hljs-keyword">if</span> (options &amp;&amp; options.length) {</pre></div></div>
            
        </li>
        
        
        <li id="section-290">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-290">&#182;</a>
              </div>
              <p>TODO: implement multipe select</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (node.multiple) {
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.selectedIndex &gt; <span class="hljs-number">-1</span>) {
					val = Y_DOM.getValue(options[node.selectedIndex]);
				}
			}

			<span class="hljs-keyword">return</span> val;
		}
	});
	<span class="hljs-keyword">var</span> addClass, hasClass, removeClass;

	Y.mix(Y.DOM, {
		<span class="hljs-comment">/**
		 * Determines whether a DOM element has the given className.
		 * @method hasClass
		 * @for DOM
		 * @param {HTMLElement} element The DOM element.
		 * @param {String} className the class name to search for
		 * @return {Boolean} Whether or not the element has the given class.
		 */</span>
		hasClass: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, className</span>) </span>{
			<span class="hljs-keyword">var</span> re = Y.DOM._getRegExp(<span class="hljs-string">'(?:^|\\s+)'</span> + className + <span class="hljs-string">'(?:\\s+|$)'</span>);
			<span class="hljs-keyword">return</span> re.test(node.className);
		},

		<span class="hljs-comment">/**
		 * Adds a class name to a given DOM element.
		 * @method addClass
		 * @for DOM
		 * @param {HTMLElement} element The DOM element.
		 * @param {String} className the class name to add to the class attribute
		 */</span>
		addClass: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, className</span>) </span>{
			<span class="hljs-keyword">if</span> (!Y.DOM.hasClass(node, className)) { <span class="hljs-comment">// skip if already present </span>
				node.className = Y.Lang.trim([node.className, className].join(<span class="hljs-string">' '</span>));
			}
		},

		<span class="hljs-comment">/**
		 * Removes a class name from a given element.
		 * @method removeClass
		 * @for DOM
		 * @param {HTMLElement} element The DOM element.
		 * @param {String} className the class name to remove from the class attribute
		 */</span>
		removeClass: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, className</span>) </span>{
			<span class="hljs-keyword">if</span> (className &amp;&amp; hasClass(node, className)) {
				node.className = Y.Lang.trim(node.className.replace(Y.DOM._getRegExp(<span class="hljs-string">'(?:^|\\s+)'</span> +
					className + <span class="hljs-string">'(?:\\s+|$)'</span>), <span class="hljs-string">' '</span>));

				<span class="hljs-keyword">if</span> ( hasClass(node, className) ) { <span class="hljs-comment">// in case of multiple adjacent</span>
					removeClass(node, className);
				}
			}
		},

		<span class="hljs-comment">/**
		 * Replace a class with another class for a given element.
		 * If no oldClassName is present, the newClassName is simply added.
		 * @method replaceClass
		 * @for DOM
		 * @param {HTMLElement} element The DOM element
		 * @param {String} oldClassName the class name to be replaced
		 * @param {String} newClassName the class name that will be replacing the old class name
		 */</span>
		replaceClass: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, oldC, newC</span>) </span>{
			removeClass(node, oldC); <span class="hljs-comment">// remove first in case oldC === newC</span>
			addClass(node, newC);
		},

		<span class="hljs-comment">/**
		 * If the className exists on the node it is removed, if it doesn't exist it is added.
		 * @method toggleClass
		 * @for DOM
		 * @param {HTMLElement} element The DOM element
		 * @param {String} className the class name to be toggled
		 * @param {Boolean} addClass optional boolean to indicate whether class
		 * should be added or removed regardless of current state
		 */</span>
		toggleClass: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, className, force</span>) </span>{
			<span class="hljs-keyword">var</span> add = (force !== <span class="hljs-literal">undefined</span>) ? force :
				!(hasClass(node, className));

			<span class="hljs-keyword">if</span> (add) {
				addClass(node, className);
			} <span class="hljs-keyword">else</span> {
				removeClass(node, className);
			}
		}
	});

	hasClass = Y.DOM.hasClass;
	removeClass = Y.DOM.removeClass;
	addClass = Y.DOM.addClass;

	<span class="hljs-keyword">var</span> re_tag = <span class="hljs-regexp">/&lt;([a-z]+)/i</span>,

		Y_DOM = Y.DOM,

		addFeature = Y.Features.add,
		testFeature = Y.Features.test,

		creators = {},

		createFromDIV = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, tag</span>) </span>{
			<span class="hljs-keyword">var</span> div = Y.config.doc.createElement(<span class="hljs-string">'div'</span>),
				ret = <span class="hljs-literal">true</span>;

			div.innerHTML = html;
			<span class="hljs-keyword">if</span> (!div.firstChild || div.firstChild.tagName !== tag.toUpperCase()) {
				ret = <span class="hljs-literal">false</span>;
			}

			<span class="hljs-keyword">return</span> ret;
		},

		re_tbody = <span class="hljs-regexp">/(?:\/(?:thead|tfoot|tbody|caption|col|colgroup)&gt;)+\s*&lt;tbody/</span>,

		TABLE_OPEN = <span class="hljs-string">'&lt;table&gt;'</span>,
		TABLE_CLOSE = <span class="hljs-string">'&lt;/table&gt;'</span>;

	Y.mix(Y.DOM, {
		<span class="hljs-attr">_fragClones</span>: {},

		<span class="hljs-attr">_create</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, doc, tag</span>) </span>{
			tag = tag || <span class="hljs-string">'div'</span>;

			<span class="hljs-keyword">var</span> frag = Y_DOM._fragClones[tag];
			<span class="hljs-keyword">if</span> (frag) {
				frag = frag.cloneNode(<span class="hljs-literal">false</span>);
			} <span class="hljs-keyword">else</span> {
				frag = Y_DOM._fragClones[tag] = doc.createElement(tag);
			}
			frag.innerHTML = html;
			<span class="hljs-keyword">return</span> frag;
		},

		<span class="hljs-attr">_children</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, tag</span>) </span>{
			<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
				children = node.children,
				childNodes,
				hasComments,
				child;

			<span class="hljs-keyword">if</span> (children &amp;&amp; children.tags) { <span class="hljs-comment">// use tags filter when possible</span>
				<span class="hljs-keyword">if</span> (tag) {
					children = node.children.tags(tag);
				} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// IE leaks comments into children</span>
					hasComments = children.tags(<span class="hljs-string">'!'</span>).length;
				}
			}

			<span class="hljs-keyword">if</span> (!children || (!children.tags &amp;&amp; tag) || hasComments) {
				childNodes = children || node.childNodes;
				children = [];
				<span class="hljs-keyword">while</span> ((child = childNodes[i++])) {
					<span class="hljs-keyword">if</span> (child.nodeType === <span class="hljs-number">1</span>) {
						<span class="hljs-keyword">if</span> (!tag || tag === child.tagName) {
							children.push(child);
						}
					}
				}
			}

			<span class="hljs-keyword">return</span> children || [];
		},

		<span class="hljs-comment">/**
		 * Creates a new dom node using the provided markup string.
		 * @method create
		 * @param {String} html The markup used to create the element
		 * @param {HTMLDocument} doc An optional document context
		 * @return {HTMLElement|DocumentFragment} returns a single HTMLElement
		 * when creating one node, and a documentFragment when creating
		 * multiple nodes.
		 */</span>
		create: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, doc</span>) </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> html === <span class="hljs-string">'string'</span>) {
				html = Y.Lang.trim(html); <span class="hljs-comment">// match IE which trims whitespace from innerHTML</span>

			}

			doc = doc || Y.config.doc;
			<span class="hljs-keyword">var</span> m = re_tag.exec(html),
				create = Y_DOM._create,
				custom = creators,
				ret = <span class="hljs-literal">null</span>,
				creator,
				tag, nodes;

			<span class="hljs-keyword">if</span> (html != <span class="hljs-literal">undefined</span>) { <span class="hljs-comment">// not undefined or null</span>
				<span class="hljs-keyword">if</span> (m &amp;&amp; m[<span class="hljs-number">1</span>]) {
					creator = custom[m[<span class="hljs-number">1</span>].toLowerCase()];
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> creator === <span class="hljs-string">'function'</span>) {
						create = creator;
					} <span class="hljs-keyword">else</span> {
						tag = creator;
					}
				}

				nodes = create(html, doc, tag).childNodes;

				<span class="hljs-keyword">if</span> (nodes.length === <span class="hljs-number">1</span>) { <span class="hljs-comment">// return single node, breaking parentNode ref from "fragment"</span>
					ret = nodes[<span class="hljs-number">0</span>].parentNode.removeChild(nodes[<span class="hljs-number">0</span>]);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes[<span class="hljs-number">0</span>] &amp;&amp; nodes[<span class="hljs-number">0</span>].className === <span class="hljs-string">'yui3-big-dummy'</span>) { <span class="hljs-comment">// using dummy node to preserve some attributes (e.g. OPTION not selected)</span>
					<span class="hljs-keyword">if</span> (nodes.length === <span class="hljs-number">2</span>) {
						ret = nodes[<span class="hljs-number">0</span>].nextSibling;
					} <span class="hljs-keyword">else</span> {
						nodes[<span class="hljs-number">0</span>].parentNode.removeChild(nodes[<span class="hljs-number">0</span>]);
						ret = Y_DOM._nl2frag(nodes, doc);
					}
				} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// return multiple nodes as a fragment</span>
					ret = Y_DOM._nl2frag(nodes, doc);
				}

			}

			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-attr">_nl2frag</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodes, doc</span>) </span>{
			<span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>,
				i, len;

			<span class="hljs-keyword">if</span> (nodes &amp;&amp; (nodes.push || nodes.item) &amp;&amp; nodes[<span class="hljs-number">0</span>]) {
				doc = doc || nodes[<span class="hljs-number">0</span>].ownerDocument;
				ret = doc.createDocumentFragment();

				<span class="hljs-keyword">if</span> (nodes.item) { <span class="hljs-comment">// convert live list to static array</span>
					nodes = Y.Array(nodes, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
				}

				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = nodes.length; i &lt; len; i++) {
					ret.appendChild(nodes[i]);
				}
			} <span class="hljs-comment">// else inline with log for minification</span>
			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-comment">/**
		 * Inserts content in a node at the given location
		 * @method addHTML
		 * @param {HTMLElement} node The node to insert into
		 * @param {HTMLElement | Array | HTMLCollection} content The content to be inserted
		 * @param {HTMLElement} where Where to insert the content
		 * If no "where" is given, content is appended to the node
		 * Possible values for "where"
		 * &lt;dl&gt;
		 * &lt;dt&gt;HTMLElement&lt;/dt&gt;
		 * &lt;dd&gt;The element to insert before&lt;/dd&gt;
		 * &lt;dt&gt;"replace"&lt;/dt&gt;
		 * &lt;dd&gt;Replaces the existing HTML&lt;/dd&gt;
		 * &lt;dt&gt;"before"&lt;/dt&gt;
		 * &lt;dd&gt;Inserts before the existing HTML&lt;/dd&gt;
		 * &lt;dt&gt;"before"&lt;/dt&gt;
		 * &lt;dd&gt;Inserts content before the node&lt;/dd&gt;
		 * &lt;dt&gt;"after"&lt;/dt&gt;
		 * &lt;dd&gt;Inserts content after the node&lt;/dd&gt;
		 * &lt;/dl&gt;
		 */</span>
		addHTML: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, content, where</span>) </span>{
			<span class="hljs-keyword">var</span> nodeParent = node.parentNode,
				i = <span class="hljs-number">0</span>,
				item,
				ret = content,
				newNode;


			<span class="hljs-keyword">if</span> (content != <span class="hljs-literal">undefined</span>) { <span class="hljs-comment">// not null or undefined (maybe 0)</span>
				<span class="hljs-keyword">if</span> (content.nodeType) { <span class="hljs-comment">// DOM node, just add it</span>
					newNode = content;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> content == <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> content == <span class="hljs-string">'number'</span>) {
					ret = newNode = Y_DOM.create(content);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (content[<span class="hljs-number">0</span>] &amp;&amp; content[<span class="hljs-number">0</span>].nodeType) { <span class="hljs-comment">// array or collection </span>
					newNode = Y.config.doc.createDocumentFragment();
					<span class="hljs-keyword">while</span> ((item = content[i++])) {
						newNode.appendChild(item); <span class="hljs-comment">// append to fragment for insertion</span>
					}
				}
			}

			<span class="hljs-keyword">if</span> (where) {
				<span class="hljs-keyword">if</span> (newNode &amp;&amp; where.parentNode) { <span class="hljs-comment">// insert regardless of relationship to node</span>
					where.parentNode.insertBefore(newNode, where);
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">switch</span> (where) {
						<span class="hljs-keyword">case</span> <span class="hljs-string">'replace'</span>:
							<span class="hljs-keyword">while</span> (node.firstChild) {
								node.removeChild(node.firstChild);
							}
							<span class="hljs-keyword">if</span> (newNode) { <span class="hljs-comment">// allow empty content to clear node</span>
								node.appendChild(newNode);
							}
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'before'</span>:
							<span class="hljs-keyword">if</span> (newNode) {
								nodeParent.insertBefore(newNode, node);
							}
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">case</span> <span class="hljs-string">'after'</span>:
							<span class="hljs-keyword">if</span> (newNode) {
								<span class="hljs-keyword">if</span> (node.nextSibling) { <span class="hljs-comment">// IE errors if refNode is null</span>
									nodeParent.insertBefore(newNode, node.nextSibling);
								} <span class="hljs-keyword">else</span> {
									nodeParent.appendChild(newNode);
								}
							}
							<span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">default</span>:
							<span class="hljs-keyword">if</span> (newNode) {
								node.appendChild(newNode);
							}
					}
				}
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNode) {
				node.appendChild(newNode);
			}

			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-attr">wrap</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, html</span>) </span>{
			<span class="hljs-keyword">var</span> parent = (html &amp;&amp; html.nodeType) ? html : Y.DOM.create(html),
				nodes = parent.getElementsByTagName(<span class="hljs-string">'*'</span>);

			<span class="hljs-keyword">if</span> (nodes.length) {
				parent = nodes[nodes.length - <span class="hljs-number">1</span>];
			}

			<span class="hljs-keyword">if</span> (node.parentNode) {
				node.parentNode.replaceChild(parent, node);
			}
			parent.appendChild(node);
		},

		<span class="hljs-attr">unwrap</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			<span class="hljs-keyword">var</span> parent = node.parentNode,
				lastChild = parent.lastChild,
				next = node,
				grandparent;

			<span class="hljs-keyword">if</span> (parent) {
				grandparent = parent.parentNode;
				<span class="hljs-keyword">if</span> (grandparent) {
					node = parent.firstChild;
					<span class="hljs-keyword">while</span> (node !== lastChild) {
						next = node.nextSibling;
						grandparent.insertBefore(node, parent);
						node = next;
					}
					grandparent.replaceChild(lastChild, parent);
				} <span class="hljs-keyword">else</span> {
					parent.removeChild(node);
				}
			}
		}
	});

	addFeature(<span class="hljs-string">'innerhtml'</span>, <span class="hljs-string">'table'</span>, {
		<span class="hljs-attr">test</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> node = Y.config.doc.createElement(<span class="hljs-string">'table'</span>);
			<span class="hljs-keyword">try</span> {
				node.innerHTML = <span class="hljs-string">'&lt;tbody&gt;&lt;/tbody&gt;'</span>;
			} <span class="hljs-keyword">catch</span>(e) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
			}
			<span class="hljs-keyword">return</span> (node.firstChild &amp;&amp; node.firstChild.nodeName === <span class="hljs-string">'TBODY'</span>);
		}
	});

	addFeature(<span class="hljs-string">'innerhtml-div'</span>, <span class="hljs-string">'tr'</span>, {
		<span class="hljs-attr">test</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> createFromDIV(<span class="hljs-string">'&lt;tr&gt;&lt;/tr&gt;'</span>, <span class="hljs-string">'tr'</span>);
		}
	});

	addFeature(<span class="hljs-string">'innerhtml-div'</span>, <span class="hljs-string">'script'</span>, {
		<span class="hljs-attr">test</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> createFromDIV(<span class="hljs-string">'&lt;script&gt;&lt;/script&gt;'</span>, <span class="hljs-string">'script'</span>);
		}
	});

	<span class="hljs-keyword">if</span> (!testFeature(<span class="hljs-string">'innerhtml'</span>, <span class="hljs-string">'table'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-291">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-291">&#182;</a>
              </div>
              <p>TODO: thead/tfoot with nested tbody
IE adds TBODY when creating TABLE elements (which may share this impl)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		creators.tbody = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, doc</span>) </span>{
			<span class="hljs-keyword">var</span> frag = Y_DOM.create(TABLE_OPEN + html + TABLE_CLOSE, doc),
				tb = Y.DOM._children(frag, <span class="hljs-string">'tbody'</span>)[<span class="hljs-number">0</span>];

			<span class="hljs-keyword">if</span> (frag.children.length &gt; <span class="hljs-number">1</span> &amp;&amp; tb &amp;&amp; !re_tbody.test(html)) {
				tb.parentNode.removeChild(tb); <span class="hljs-comment">// strip extraneous tbody</span>
			}
			<span class="hljs-keyword">return</span> frag;
		};
	}

	<span class="hljs-keyword">if</span> (!testFeature(<span class="hljs-string">'innerhtml-div'</span>, <span class="hljs-string">'script'</span>)) {
		creators.script = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, doc</span>) </span>{
			<span class="hljs-keyword">var</span> frag = doc.createElement(<span class="hljs-string">'div'</span>);

			frag.innerHTML = <span class="hljs-string">'-'</span> + html;
			frag.removeChild(frag.firstChild);
			<span class="hljs-keyword">return</span> frag;
		};

		creators.link = creators.style = creators.script;
	}

	<span class="hljs-keyword">if</span> (!testFeature(<span class="hljs-string">'innerhtml-div'</span>, <span class="hljs-string">'tr'</span>)) {
		Y.mix(creators, {
			<span class="hljs-attr">option</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, doc</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.create(<span class="hljs-string">'&lt;select&gt;&lt;option class="yui3-big-dummy" selected&gt;&lt;/option&gt;'</span> + html + <span class="hljs-string">'&lt;/select&gt;'</span>, doc);
			},

			<span class="hljs-attr">tr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, doc</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.create(<span class="hljs-string">'&lt;tbody&gt;'</span> + html + <span class="hljs-string">'&lt;/tbody&gt;'</span>, doc);
			},

			<span class="hljs-attr">td</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, doc</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.create(<span class="hljs-string">'&lt;tr&gt;'</span> + html + <span class="hljs-string">'&lt;/tr&gt;'</span>, doc);
			},

			<span class="hljs-attr">col</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, doc</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.create(<span class="hljs-string">'&lt;colgroup&gt;'</span> + html + <span class="hljs-string">'&lt;/colgroup&gt;'</span>, doc);
			},

			<span class="hljs-attr">tbody</span>: <span class="hljs-string">'table'</span>
		});

		Y.mix(creators, {
			<span class="hljs-attr">legend</span>: <span class="hljs-string">'fieldset'</span>,
			<span class="hljs-attr">th</span>: creators.td,
			<span class="hljs-attr">thead</span>: creators.tbody,
			<span class="hljs-attr">tfoot</span>: creators.tbody,
			<span class="hljs-attr">caption</span>: creators.tbody,
			<span class="hljs-attr">colgroup</span>: creators.tbody,
			<span class="hljs-attr">optgroup</span>: creators.option
		});
	}

	Y_DOM.creators = creators;
	Y.mix(Y.DOM, {
		<span class="hljs-comment">/**
		 * Sets the width of the element to the given size, regardless
		 * of box model, border, padding, etc.
		 * @method setWidth
		 * @param {HTMLElement} element The DOM element.
		 * @param {String|Number} size The pixel height to size to
		 */</span>

		setWidth: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, size</span>) </span>{
			Y.DOM._setSize(node, <span class="hljs-string">'width'</span>, size);
		},

		<span class="hljs-comment">/**
		 * Sets the height of the element to the given size, regardless
		 * of box model, border, padding, etc.
		 * @method setHeight
		 * @param {HTMLElement} element The DOM element.
		 * @param {String|Number} size The pixel height to size to
		 */</span>

		setHeight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, size</span>) </span>{
			Y.DOM._setSize(node, <span class="hljs-string">'height'</span>, size);
		},

		<span class="hljs-attr">_setSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, prop, val</span>) </span>{
			val = (val &gt; <span class="hljs-number">0</span>) ? val : <span class="hljs-number">0</span>;
			<span class="hljs-keyword">var</span> size = <span class="hljs-number">0</span>;

			node.style[prop] = val + <span class="hljs-string">'px'</span>;
			size = (prop === <span class="hljs-string">'height'</span>) ? node.offsetHeight : node.offsetWidth;

			<span class="hljs-keyword">if</span> (size &gt; val) {
				val = val - (size - val);

				<span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) {
					val = <span class="hljs-number">0</span>;
				}

				node.style[prop] = val + <span class="hljs-string">'px'</span>;
			}
		}
	});


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"dom-core"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'selector-native'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
		<span class="hljs-comment">/**
		 * The selector-native module provides support for native querySelector
		 * @module dom
		 * @submodule selector-native
		 * @for Selector
		 */</span>

		<span class="hljs-comment">/**
		 * Provides support for using CSS selectors to query the DOM
		 * @class Selector
		 * @static
		 * @for Selector
		 */</span>

		Y.namespace(<span class="hljs-string">'Selector'</span>); <span class="hljs-comment">// allow native module to standalone</span>

		<span class="hljs-keyword">var</span> COMPARE_DOCUMENT_POSITION = <span class="hljs-string">'compareDocumentPosition'</span>,
			OWNER_DOCUMENT = <span class="hljs-string">'ownerDocument'</span>;

		<span class="hljs-keyword">var</span> Selector = {
			<span class="hljs-attr">_types</span>: {
				<span class="hljs-attr">esc</span>: {
					<span class="hljs-attr">token</span>: <span class="hljs-string">'\uE000'</span>,
					<span class="hljs-attr">re</span>: <span class="hljs-regexp">/\\[:\[\]\(\)#\.\'\&gt;+~"]/gi</span>
				},

				<span class="hljs-attr">attr</span>: {
					<span class="hljs-attr">token</span>: <span class="hljs-string">'\uE001'</span>,
					<span class="hljs-attr">re</span>: <span class="hljs-regexp">/(\[[^\]]*\])/g</span>
				},

				<span class="hljs-attr">pseudo</span>: {
					<span class="hljs-attr">token</span>: <span class="hljs-string">'\uE002'</span>,
					<span class="hljs-attr">re</span>: <span class="hljs-regexp">/(\([^\)]*\))/g</span>
				}
			},

			<span class="hljs-attr">useNative</span>: <span class="hljs-literal">true</span>,

			<span class="hljs-attr">_escapeId</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>{
				<span class="hljs-keyword">if</span> (id) {
					id = id.replace(<span class="hljs-regexp">/([:\[\]\(\)#\.'&lt;&gt;+~"])/g</span>,<span class="hljs-string">'\\$1'</span>);
				}
				<span class="hljs-keyword">return</span> id;
			},

			<span class="hljs-attr">_compare</span>: (<span class="hljs-string">'sourceIndex'</span> <span class="hljs-keyword">in</span> Y.config.doc.documentElement) ?
				<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodeA, nodeB</span>) </span>{
					<span class="hljs-keyword">var</span> a = nodeA.sourceIndex,
						b = nodeB.sourceIndex;

					<span class="hljs-keyword">if</span> (a === b) {
						<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &gt; b) {
						<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
					}

					<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

				} : (Y.config.doc.documentElement[COMPARE_DOCUMENT_POSITION] ?
				<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodeA, nodeB</span>) </span>{
					<span class="hljs-keyword">if</span> (nodeA[COMPARE_DOCUMENT_POSITION](nodeB) &amp; <span class="hljs-number">4</span>) {
						<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
					}
				} :
				<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodeA, nodeB</span>) </span>{
					<span class="hljs-keyword">var</span> rangeA, rangeB, compare;
					<span class="hljs-keyword">if</span> (nodeA &amp;&amp; nodeB) {
						rangeA = nodeA[OWNER_DOCUMENT].createRange();
						rangeA.setStart(nodeA, <span class="hljs-number">0</span>);
						rangeB = nodeB[OWNER_DOCUMENT].createRange();
						rangeB.setStart(nodeB, <span class="hljs-number">0</span>);
						compare = rangeA.compareBoundaryPoints(<span class="hljs-number">1</span>, rangeB); <span class="hljs-comment">// 1 === Range.START_TO_END</span>
					}

					<span class="hljs-keyword">return</span> compare;

				}),

			<span class="hljs-attr">_sort</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodes</span>) </span>{
				<span class="hljs-keyword">if</span> (nodes) {
					nodes = Y.Array(nodes, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
					<span class="hljs-keyword">if</span> (nodes.sort) {
						nodes.sort(Selector._compare);
					}
				}

				<span class="hljs-keyword">return</span> nodes;
			},

			<span class="hljs-attr">_deDupe</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodes</span>) </span>{
				<span class="hljs-keyword">var</span> ret = [],
					i, node;

				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (node = nodes[i++]);) {
					<span class="hljs-keyword">if</span> (!node._found) {
						ret[ret.length] = node;
						node._found = <span class="hljs-literal">true</span>;
					}
				}

				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (node = ret[i++]);) {
					node._found = <span class="hljs-literal">null</span>;
					node.removeAttribute(<span class="hljs-string">'_found'</span>);
				}

				<span class="hljs-keyword">return</span> ret;
			},

			<span class="hljs-comment">/**
			 * Retrieves a set of nodes based on a given CSS selector.
			 * @method query
			 *
			 * @param {string} selector The CSS Selector to test the node against.
			 * @param {HTMLElement} root optional An HTMLElement to start the query from. Defaults to Y.config.doc
			 * @param {Boolean} firstOnly optional Whether or not to return only the first match.
			 * @return {Array} An array of nodes that match the given selector.
			 * @static
			 */</span>
			query: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector, root, firstOnly, skipNative</span>) </span>{
				root = root || Y.config.doc;
				<span class="hljs-keyword">var</span> ret = [],
					useNative = (Y.Selector.useNative &amp;&amp; Y.config.doc.querySelector &amp;&amp; !skipNative),
					queries = [[selector, root]],
					query,
					result,
					i,
					fn = (useNative) ? Y.Selector._nativeQuery : Y.Selector._bruteQuery;

				<span class="hljs-keyword">if</span> (selector &amp;&amp; fn) {</pre></div></div>
            
        </li>
        
        
        <li id="section-292">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-292">&#182;</a>
              </div>
              <p>split group into seperate queries</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!skipNative &amp;&amp; <span class="hljs-comment">// already done if skipping</span>
						(!useNative || root.tagName)) { <span class="hljs-comment">// split native when element scoping is needed</span>
						queries = Selector._splitQueries(selector, root);
					}

					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (query = queries[i++]);) {
						result = fn(query[<span class="hljs-number">0</span>], query[<span class="hljs-number">1</span>], firstOnly);
						<span class="hljs-keyword">if</span> (!firstOnly) { <span class="hljs-comment">// coerce DOM Collection to Array</span>
							result = Y.Array(result, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
						}
						<span class="hljs-keyword">if</span> (result) {
							ret = ret.concat(result);
						}
					}

					<span class="hljs-keyword">if</span> (queries.length &gt; <span class="hljs-number">1</span>) { <span class="hljs-comment">// remove dupes and sort by doc order </span>
						ret = Selector._sort(Selector._deDupe(ret));
					}
				}

				<span class="hljs-keyword">return</span> (firstOnly) ? (ret[<span class="hljs-number">0</span>] || <span class="hljs-literal">null</span>) : ret;

			},

			<span class="hljs-attr">_replaceSelector</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
				<span class="hljs-keyword">var</span> esc = Y.Selector._parse(<span class="hljs-string">'esc'</span>, selector), <span class="hljs-comment">// pull escaped colon, brackets, etc. </span>
					attrs,
					pseudos;</pre></div></div>
            
        </li>
        
        
        <li id="section-293">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-293">&#182;</a>
              </div>
              <p>first replace escaped chars, which could be present in attrs or pseudos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				selector = Y.Selector._replace(<span class="hljs-string">'esc'</span>, selector);</pre></div></div>
            
        </li>
        
        
        <li id="section-294">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-294">&#182;</a>
              </div>
              <p>then replace pseudos before attrs to avoid replacing :not([foo])</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				pseudos = Y.Selector._parse(<span class="hljs-string">'pseudo'</span>, selector);
				selector = Selector._replace(<span class="hljs-string">'pseudo'</span>, selector);

				attrs = Y.Selector._parse(<span class="hljs-string">'attr'</span>, selector);
				selector = Y.Selector._replace(<span class="hljs-string">'attr'</span>, selector);

				<span class="hljs-keyword">return</span> {
					<span class="hljs-attr">esc</span>: esc,
					<span class="hljs-attr">attrs</span>: attrs,
					<span class="hljs-attr">pseudos</span>: pseudos,
					<span class="hljs-attr">selector</span>: selector
				};
			},

			<span class="hljs-attr">_restoreSelector</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">replaced</span>) </span>{
				<span class="hljs-keyword">var</span> selector = replaced.selector;
				selector = Y.Selector._restore(<span class="hljs-string">'attr'</span>, selector, replaced.attrs);
				selector = Y.Selector._restore(<span class="hljs-string">'pseudo'</span>, selector, replaced.pseudos);
				selector = Y.Selector._restore(<span class="hljs-string">'esc'</span>, selector, replaced.esc);
				<span class="hljs-keyword">return</span> selector;
			},

			<span class="hljs-attr">_replaceCommas</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
				<span class="hljs-keyword">var</span> replaced = Y.Selector._replaceSelector(selector),
					selector = replaced.selector;

				<span class="hljs-keyword">if</span> (selector) {
					selector = selector.replace(<span class="hljs-regexp">/,/g</span>, <span class="hljs-string">'\uE007'</span>);
					replaced.selector = selector;
					selector = Y.Selector._restoreSelector(replaced);
				}
				<span class="hljs-keyword">return</span> selector;
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-295">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-295">&#182;</a>
              </div>
              <p>allows element scoped queries to begin with combinator
e.g. query(‘&gt; p’, document.body) === query(‘body &gt; p’)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			_splitQueries: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector, node</span>) </span>{
				<span class="hljs-keyword">if</span> (selector.indexOf(<span class="hljs-string">','</span>) &gt; <span class="hljs-number">-1</span>) {
					selector = Y.Selector._replaceCommas(selector);
				}

				<span class="hljs-keyword">var</span> groups = selector.split(<span class="hljs-string">'\uE007'</span>), <span class="hljs-comment">// split on replaced comma token</span>
					queries = [],
					prefix = <span class="hljs-string">''</span>,
					id,
					i,
					len;

				<span class="hljs-keyword">if</span> (node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-296">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-296">&#182;</a>
              </div>
              <p>enforce for element scoping</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span>) { <span class="hljs-comment">// Elements only</span>
						id = Y.Selector._escapeId(Y.DOM.getId(node));

						<span class="hljs-keyword">if</span> (!id) {
							id = Y.guid();
							Y.DOM.setId(node, id);
						}

						prefix = <span class="hljs-string">'[id="'</span> + id + <span class="hljs-string">'"] '</span>;
					}

					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = groups.length; i &lt; len; ++i) {
						selector =  prefix + groups[i];
						queries.push([selector, node]);
					}
				}

				<span class="hljs-keyword">return</span> queries;
			},

			<span class="hljs-attr">_nativeQuery</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector, root, one</span>) </span>{
				<span class="hljs-keyword">if</span> (Y.UA.webkit &amp;&amp; selector.indexOf(<span class="hljs-string">':checked'</span>) &gt; <span class="hljs-number">-1</span> &amp;&amp;
					(Y.Selector.pseudos &amp;&amp; Y.Selector.pseudos.checked)) { <span class="hljs-comment">// webkit (chrome, safari) fails to pick up "selected"  with "checked"</span>
					<span class="hljs-keyword">return</span> Y.Selector.query(selector, root, one, <span class="hljs-literal">true</span>); <span class="hljs-comment">// redo with skipNative true to try brute query</span>
				}
				<span class="hljs-keyword">try</span> {
					<span class="hljs-keyword">return</span> root[<span class="hljs-string">'querySelector'</span> + (one ? <span class="hljs-string">''</span> : <span class="hljs-string">'All'</span>)](selector);
				} <span class="hljs-keyword">catch</span>(e) { <span class="hljs-comment">// fallback to brute if available</span>
					<span class="hljs-keyword">return</span> Y.Selector.query(selector, root, one, <span class="hljs-literal">true</span>); <span class="hljs-comment">// redo with skipNative true</span>
				}
			},

			<span class="hljs-attr">filter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodes, selector</span>) </span>{
				<span class="hljs-keyword">var</span> ret = [],
					i, node;

				<span class="hljs-keyword">if</span> (nodes &amp;&amp; selector) {
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (node = nodes[i++]);) {
						<span class="hljs-keyword">if</span> (Y.Selector.test(node, selector)) {
							ret[ret.length] = node;
						}
					}
				} <span class="hljs-keyword">else</span> {
				}

				<span class="hljs-keyword">return</span> ret;
			},

			<span class="hljs-attr">test</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, selector, root</span>) </span>{
				<span class="hljs-keyword">var</span> ret = <span class="hljs-literal">false</span>,
					useFrag = <span class="hljs-literal">false</span>,
					groups,
					parent,
					item,
					items,
					frag,
					id,
					i, j, group;

				<span class="hljs-keyword">if</span> (node &amp;&amp; node.tagName) { <span class="hljs-comment">// only test HTMLElements</span>

					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selector == <span class="hljs-string">'function'</span>) { <span class="hljs-comment">// test with function</span>
						ret = selector.call(node, node);
					} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// test with query</span></pre></div></div>
            
        </li>
        
        
        <li id="section-297">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-297">&#182;</a>
              </div>
              <p>we need a root if off-doc</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						groups = selector.split(<span class="hljs-string">','</span>);
						<span class="hljs-keyword">if</span> (!root &amp;&amp; !Y.DOM.inDoc(node)) {
							parent = node.parentNode;
							<span class="hljs-keyword">if</span> (parent) {
								root = parent;
							} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// only use frag when no parent to query</span>
								frag = node[OWNER_DOCUMENT].createDocumentFragment();
								frag.appendChild(node);
								root = frag;
								useFrag = <span class="hljs-literal">true</span>;
							}
						}
						root = root || node[OWNER_DOCUMENT];

						id = Y.Selector._escapeId(Y.DOM.getId(node));
						<span class="hljs-keyword">if</span> (!id) {
							id = Y.guid();
							Y.DOM.setId(node, id);
						}

						<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (group = groups[i++]);) { <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> off-dom test</span>
							group += <span class="hljs-string">'[id="'</span> + id + <span class="hljs-string">'"]'</span>;
							items = Y.Selector.query(group, root);

							<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; item = items[j++];) {
								<span class="hljs-keyword">if</span> (item === node) {
									ret = <span class="hljs-literal">true</span>;
									<span class="hljs-keyword">break</span>;
								}
							}
							<span class="hljs-keyword">if</span> (ret) {
								<span class="hljs-keyword">break</span>;
							}
						}

						<span class="hljs-keyword">if</span> (useFrag) { <span class="hljs-comment">// cleanup</span>
							frag.removeChild(node);
						}
					};
				}

				<span class="hljs-keyword">return</span> ret;
			},

			<span class="hljs-comment">/**
			 * A convenience function to emulate Y.Node's aNode.ancestor(selector).
			 * @param {HTMLElement} element An HTMLElement to start the query from.
			 * @param {String} selector The CSS selector to test the node against.
			 * @return {HTMLElement} The ancestor node matching the selector, or null.
			 * @param {Boolean} testSelf optional Whether or not to include the element in the scan
			 * @static
			 * @method ancestor
			 */</span>
			ancestor: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, selector, testSelf</span>) </span>{
				<span class="hljs-keyword">return</span> Y.DOM.ancestor(element, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
					<span class="hljs-keyword">return</span> Y.Selector.test(n, selector);
				}, testSelf);
			},

			<span class="hljs-attr">_parse</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, selector</span>) </span>{
				<span class="hljs-keyword">return</span> selector.match(Y.Selector._types[name].re);
			},

			<span class="hljs-attr">_replace</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, selector</span>) </span>{
				<span class="hljs-keyword">var</span> o = Y.Selector._types[name];
				<span class="hljs-keyword">return</span> selector.replace(o.re, o.token);
			},

			<span class="hljs-attr">_restore</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, selector, items</span>) </span>{
				<span class="hljs-keyword">if</span> (items) {
					<span class="hljs-keyword">var</span> token = Y.Selector._types[name].token,
						i, len;
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = items.length; i &lt; len; ++i) {
						selector = selector.replace(token, items[i]);
					}
				}
				<span class="hljs-keyword">return</span> selector;
			}
		};

		Y.mix(Y.Selector, Selector, <span class="hljs-literal">true</span>);

	})(Y);


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"dom-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'selector-css2'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * The selector module provides helper methods allowing CSS2 Selectors to be used with DOM elements.
	 * @module dom
	 * @submodule selector-css2
	 * @for Selector
	 */</span>

	<span class="hljs-comment">/*
	 * Provides helper methods for collecting and filtering DOM elements.
	 */</span>

	<span class="hljs-keyword">var</span> PARENT_NODE = <span class="hljs-string">'parentNode'</span>,
		TAG_NAME = <span class="hljs-string">'tagName'</span>,
		ATTRIBUTES = <span class="hljs-string">'attributes'</span>,
		COMBINATOR = <span class="hljs-string">'combinator'</span>,
		PSEUDOS = <span class="hljs-string">'pseudos'</span>,

		Selector = Y.Selector,

		SelectorCSS2 = {
			<span class="hljs-attr">_reRegExpTokens</span>: <span class="hljs-regexp">/([\^\$\?\[\]\*\+\-\.\(\)\|\\])/</span>,
			<span class="hljs-attr">SORT_RESULTS</span>: <span class="hljs-literal">true</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-298">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-298">&#182;</a>
              </div>
              <p>TODO: better detection, document specific</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			_isXML: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">var</span> isXML = (Y.config.doc.createElement(<span class="hljs-string">'div'</span>).tagName !== <span class="hljs-string">'DIV'</span>);
				<span class="hljs-keyword">return</span> isXML;
			}()),

			<span class="hljs-comment">/**
			 * Mapping of shorthand tokens to corresponding attribute selector
			 * @property shorthand
			 * @type object
			 */</span>
			shorthand: {
				<span class="hljs-string">'\\#(-?[_a-z0-9]+[-\\w\\uE000]*)'</span>: <span class="hljs-string">'[id=$1]'</span>,
				<span class="hljs-string">'\\.(-?[_a-z]+[-\\w\\uE000]*)'</span>: <span class="hljs-string">'[className~=$1]'</span>
			},

			<span class="hljs-comment">/**
			 * List of operators and corresponding boolean functions.
			 * These functions are passed the attribute and the current node's value of the attribute.
			 * @property operators
			 * @type object
			 */</span>
			operators: {
				<span class="hljs-string">''</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, attr</span>) </span>{ <span class="hljs-keyword">return</span> Y.DOM.getAttribute(node, attr) !== <span class="hljs-string">''</span>; }, <span class="hljs-comment">// Just test for existence of attribute</span>
				<span class="hljs-string">'~='</span>: <span class="hljs-string">'(?:^|\\s+){val}(?:\\s+|$)'</span>, <span class="hljs-comment">// space-delimited</span>
				<span class="hljs-string">'|='</span>: <span class="hljs-string">'^{val}-?'</span> <span class="hljs-comment">// optional hyphen-delimited</span>
			},

			<span class="hljs-attr">pseudos</span>: {
				<span class="hljs-string">'first-child'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
					<span class="hljs-keyword">return</span> Y.DOM._children(node[PARENT_NODE])[<span class="hljs-number">0</span>] === node;
				}
			},

			<span class="hljs-attr">_bruteQuery</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector, root, firstOnly</span>) </span>{
				<span class="hljs-keyword">var</span> ret = [],
					nodes = [],
					tokens = Selector._tokenize(selector),
					token = tokens[tokens.length - <span class="hljs-number">1</span>],
					rootDoc = Y.DOM._getDoc(root),
					child,
					id,
					className,
					tagName;

				<span class="hljs-keyword">if</span> (token) {</pre></div></div>
            
        </li>
        
        
        <li id="section-299">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-299">&#182;</a>
              </div>
              <p>prefilter nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					id = token.id;
					className = token.className;
					tagName = token.tagName || <span class="hljs-string">'*'</span>;

					<span class="hljs-keyword">if</span> (root.getElementsByTagName) { <span class="hljs-comment">// non-IE lacks DOM api on doc frags</span></pre></div></div>
            
        </li>
        
        
        <li id="section-300">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-300">&#182;</a>
              </div>
              <p>try ID first, unless no root.all &amp;&amp; root not in document
(root.all works off document, but not getElementById)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (id &amp;&amp; (root.all || (root.nodeType === <span class="hljs-number">9</span> || Y.DOM.inDoc(root)))) {
							nodes = Y.DOM.allById(id, root);</pre></div></div>
            
        </li>
        
        
        <li id="section-301">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-301">&#182;</a>
              </div>
              <p>try className</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (className) {
							nodes = root.getElementsByClassName(className);
						} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// default to tagName</span>
							nodes = root.getElementsByTagName(tagName);
						}

					} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// brute getElementsByTagName()</span>
						child = root.firstChild;
						<span class="hljs-keyword">while</span> (child) {</pre></div></div>
            
        </li>
        
        
        <li id="section-302">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-302">&#182;</a>
              </div>
              <p>only collect HTMLElements
match tag to supplement missing getElementsByTagName</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (child.tagName &amp;&amp; (tagName === <span class="hljs-string">'*'</span> || child.tagName === tagName)) {
								nodes.push(child);
							}
							child = child.nextSibling || child.firstChild;
						}
					}
					<span class="hljs-keyword">if</span> (nodes.length) {
						ret = Selector._filterNodes(nodes, tokens, firstOnly);
					}
				}

				<span class="hljs-keyword">return</span> ret;
			},

			<span class="hljs-attr">_filterNodes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodes, tokens, firstOnly</span>) </span>{
				<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
					j,
					len = tokens.length,
					n = len - <span class="hljs-number">1</span>,
					result = [],
					node = nodes[<span class="hljs-number">0</span>],
					tmpNode = node,
					getters = Y.Selector.getters,
					operator,
					combinator,
					token,
					path,
					pass,
					value,
					tests,
					test;

				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (tmpNode = node = nodes[i++]);) {
					n = len - <span class="hljs-number">1</span>;
					path = <span class="hljs-literal">null</span>;

					testLoop:
						<span class="hljs-keyword">while</span> (tmpNode &amp;&amp; tmpNode.tagName) {
							token = tokens[n];
							tests = token.tests;
							j = tests.length;
							<span class="hljs-keyword">if</span> (j &amp;&amp; !pass) {
								<span class="hljs-keyword">while</span> ((test = tests[--j])) {
									operator = test[<span class="hljs-number">1</span>];
									<span class="hljs-keyword">if</span> (getters[test[<span class="hljs-number">0</span>]]) {
										value = getters[test[<span class="hljs-number">0</span>]](tmpNode, test[<span class="hljs-number">0</span>]);
									} <span class="hljs-keyword">else</span> {
										value = tmpNode[test[<span class="hljs-number">0</span>]];
										<span class="hljs-keyword">if</span> (test[<span class="hljs-number">0</span>] === <span class="hljs-string">'tagName'</span> &amp;&amp; !Selector._isXML) {
											value = value.toUpperCase();
										}
										<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value != <span class="hljs-string">'string'</span> &amp;&amp; value !== <span class="hljs-literal">undefined</span> &amp;&amp; value.toString) {
											value = value.toString(); <span class="hljs-comment">// coerce for comparison</span>
										} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">undefined</span> &amp;&amp; tmpNode.getAttribute) {</pre></div></div>
            
        </li>
        
        
        <li id="section-303">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-303">&#182;</a>
              </div>
              <p>use getAttribute for non-standard attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>											value = tmpNode.getAttribute(test[<span class="hljs-number">0</span>], <span class="hljs-number">2</span>); <span class="hljs-comment">// 2 === force string for IE</span>
										}
									}

									<span class="hljs-keyword">if</span> ((operator === <span class="hljs-string">'='</span> &amp;&amp; value !== test[<span class="hljs-number">2</span>]) ||  <span class="hljs-comment">// fast path for equality</span>
										(<span class="hljs-keyword">typeof</span> operator !== <span class="hljs-string">'string'</span> &amp;&amp; <span class="hljs-comment">// protect against String.test monkey-patch (Moo)</span>
											operator.test &amp;&amp; !operator.test(value)) ||  <span class="hljs-comment">// regex test</span>
										(!operator.test &amp;&amp; <span class="hljs-comment">// protect against RegExp as function (webkit)</span>
											<span class="hljs-keyword">typeof</span> operator === <span class="hljs-string">'function'</span> &amp;&amp; !operator(tmpNode, test[<span class="hljs-number">0</span>], test[<span class="hljs-number">2</span>]))) { <span class="hljs-comment">// function test</span></pre></div></div>
            
        </li>
        
        
        <li id="section-304">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-304">&#182;</a>
              </div>
              <p>skip non element nodes or non-matching tags</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										<span class="hljs-keyword">if</span> ((tmpNode = tmpNode[path])) {
											<span class="hljs-keyword">while</span> (tmpNode &amp;&amp;
												(!tmpNode.tagName ||
													(token.tagName &amp;&amp; token.tagName !== tmpNode.tagName))
												) {
												tmpNode = tmpNode[path];
											}
										}
										<span class="hljs-keyword">continue</span> testLoop;
									}
								}
							}

							n--; <span class="hljs-comment">// move to next token</span></pre></div></div>
            
        </li>
        
        
        <li id="section-305">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-305">&#182;</a>
              </div>
              <p>now that we’ve passed the test, move up the tree by combinator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (!pass &amp;&amp; (combinator = token.combinator)) {
								path = combinator.axis;
								tmpNode = tmpNode[path];</pre></div></div>
            
        </li>
        
        
        <li id="section-306">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-306">&#182;</a>
              </div>
              <p>skip non element nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">while</span> (tmpNode &amp;&amp; !tmpNode.tagName) {
									tmpNode = tmpNode[path];
								}

								<span class="hljs-keyword">if</span> (combinator.direct) { <span class="hljs-comment">// one pass only</span>
									path = <span class="hljs-literal">null</span>;
								}

							} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// success if we made it this far</span>
								result.push(node);
								<span class="hljs-keyword">if</span> (firstOnly) {
									<span class="hljs-keyword">return</span> result;
								}
								<span class="hljs-keyword">break</span>;
							}
						}
				}
				node = tmpNode = <span class="hljs-literal">null</span>;
				<span class="hljs-keyword">return</span> result;
			},

			<span class="hljs-attr">combinators</span>: {
				<span class="hljs-string">' '</span>: {
					<span class="hljs-attr">axis</span>: <span class="hljs-string">'parentNode'</span>
				},

				<span class="hljs-string">'&gt;'</span>: {
					<span class="hljs-attr">axis</span>: <span class="hljs-string">'parentNode'</span>,
					<span class="hljs-attr">direct</span>: <span class="hljs-literal">true</span>
				},


				<span class="hljs-string">'+'</span>: {
					<span class="hljs-attr">axis</span>: <span class="hljs-string">'previousSibling'</span>,
					<span class="hljs-attr">direct</span>: <span class="hljs-literal">true</span>
				}
			},

			<span class="hljs-attr">_parsers</span>: [
				{
					<span class="hljs-attr">name</span>: ATTRIBUTES,
					<span class="hljs-attr">re</span>: <span class="hljs-regexp">/^\uE003(-?[a-z]+[\w\-]*)+([~\|\^\$\*!=]=?)?['"]?([^\uE004'"]*)['"]?\uE004/i</span>,
					<span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, token</span>) </span>{
						<span class="hljs-keyword">var</span> operator = match[<span class="hljs-number">2</span>] || <span class="hljs-string">''</span>,
							operators = Selector.operators,
							escVal = (match[<span class="hljs-number">3</span>]) ? match[<span class="hljs-number">3</span>].replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">''</span>) : <span class="hljs-string">''</span>,
							test;</pre></div></div>
            
        </li>
        
        
        <li id="section-307">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-307">&#182;</a>
              </div>
              <p>add prefiltering for ID and CLASS</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> ((match[<span class="hljs-number">1</span>] === <span class="hljs-string">'id'</span> &amp;&amp; operator === <span class="hljs-string">'='</span>) ||
							(match[<span class="hljs-number">1</span>] === <span class="hljs-string">'className'</span> &amp;&amp;
								Y.config.doc.documentElement.getElementsByClassName &amp;&amp;
								(operator === <span class="hljs-string">'~='</span> || operator === <span class="hljs-string">'='</span>))) {
							token.prefilter = match[<span class="hljs-number">1</span>];


							match[<span class="hljs-number">3</span>] = escVal;</pre></div></div>
            
        </li>
        
        
        <li id="section-308">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-308">&#182;</a>
              </div>
              <p>escape all but ID for prefilter, which may run through QSA (via Dom.allById)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							token[match[<span class="hljs-number">1</span>]] = (match[<span class="hljs-number">1</span>] === <span class="hljs-string">'id'</span>) ? match[<span class="hljs-number">3</span>] : escVal;

						}</pre></div></div>
            
        </li>
        
        
        <li id="section-309">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-309">&#182;</a>
              </div>
              <p>add tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (operator <span class="hljs-keyword">in</span> operators) {
							test = operators[operator];
							<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> test === <span class="hljs-string">'string'</span>) {
								match[<span class="hljs-number">3</span>] = escVal.replace(Selector._reRegExpTokens, <span class="hljs-string">'\\$1'</span>);
								test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(test.replace(<span class="hljs-string">'{val}'</span>, match[<span class="hljs-number">3</span>]));
							}
							match[<span class="hljs-number">2</span>] = test;
						}
						<span class="hljs-keyword">if</span> (!token.last || token.prefilter !== match[<span class="hljs-number">1</span>]) {
							<span class="hljs-keyword">return</span> match.slice(<span class="hljs-number">1</span>);
						}
					}
				},
				{
					<span class="hljs-attr">name</span>: TAG_NAME,
					<span class="hljs-attr">re</span>: <span class="hljs-regexp">/^((?:-?[_a-z]+[\w-]*)|\*)/i</span>,
					<span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, token</span>) </span>{
						<span class="hljs-keyword">var</span> tag = match[<span class="hljs-number">1</span>];

						<span class="hljs-keyword">if</span> (!Selector._isXML) {
							tag = tag.toUpperCase();
						}

						token.tagName = tag;

						<span class="hljs-keyword">if</span> (tag !== <span class="hljs-string">'*'</span> &amp;&amp; (!token.last || token.prefilter)) {
							<span class="hljs-keyword">return</span> [TAG_NAME, <span class="hljs-string">'='</span>, tag];
						}
						<span class="hljs-keyword">if</span> (!token.prefilter) {
							token.prefilter = <span class="hljs-string">'tagName'</span>;
						}
					}
				},
				{
					<span class="hljs-attr">name</span>: COMBINATOR,
					<span class="hljs-attr">re</span>: <span class="hljs-regexp">/^\s*([&gt;+~]|\s)\s*/</span>,
					<span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, token</span>) </span>{
					}
				},
				{
					<span class="hljs-attr">name</span>: PSEUDOS,
					<span class="hljs-attr">re</span>: <span class="hljs-regexp">/^:([\-\w]+)(?:\uE005['"]?([^\uE005]*)['"]?\uE006)*/i</span>,
					<span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, token</span>) </span>{
						<span class="hljs-keyword">var</span> test = Selector[PSEUDOS][match[<span class="hljs-number">1</span>]];
						<span class="hljs-keyword">if</span> (test) { <span class="hljs-comment">// reorder match array and unescape special chars for tests</span>
							<span class="hljs-keyword">if</span> (match[<span class="hljs-number">2</span>]) {
								match[<span class="hljs-number">2</span>] = match[<span class="hljs-number">2</span>].replace(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">''</span>);
							}
							<span class="hljs-keyword">return</span> [match[<span class="hljs-number">2</span>], test];
						} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// selector token not supported (possibly missing CSS3 module)</span>
							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						}
					}
				}
			],

			<span class="hljs-attr">_getToken</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">token</span>) </span>{
				<span class="hljs-keyword">return</span> {
					<span class="hljs-attr">tagName</span>: <span class="hljs-literal">null</span>,
					<span class="hljs-attr">id</span>: <span class="hljs-literal">null</span>,
					<span class="hljs-attr">className</span>: <span class="hljs-literal">null</span>,
					<span class="hljs-attr">attributes</span>: {},
					<span class="hljs-attr">combinator</span>: <span class="hljs-literal">null</span>,
					<span class="hljs-attr">tests</span>: []
				};
			},

			<span class="hljs-comment">/*
			 Break selector into token units per simple selector.
			 Combinator is attached to the previous token.
			 */</span>
			_tokenize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
				selector = selector || <span class="hljs-string">''</span>;
				selector = Selector._parseSelector(Y.Lang.trim(selector));
				<span class="hljs-keyword">var</span> token = Selector._getToken(),     <span class="hljs-comment">// one token per simple selector (left selector holds combinator)</span>
					query = selector, <span class="hljs-comment">// original query for debug report</span>
					tokens = [],    <span class="hljs-comment">// array of tokens</span>
					found = <span class="hljs-literal">false</span>,  <span class="hljs-comment">// whether or not any matches were found this pass</span>
					match,         <span class="hljs-comment">// the regex match</span>
					test,
					i, parser;

				<span class="hljs-comment">/*
				 Search for selector patterns, store, and strip them from the selector string
				 until no patterns match (invalid selector) or we run out of chars.

				 Multiple attributes and pseudos are allowed, in any order.
				 for example:
				 'form:first-child[type=button]:not(button)[lang|=en]'
				 */</span>
				outer:
					<span class="hljs-keyword">do</span> {
						found = <span class="hljs-literal">false</span>; <span class="hljs-comment">// reset after full pass</span>
						<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (parser = Selector._parsers[i++]);) {
							<span class="hljs-keyword">if</span> ( (match = parser.re.exec(selector)) ) { <span class="hljs-comment">// note assignment</span>
								<span class="hljs-keyword">if</span> (parser.name !== COMBINATOR ) {
									token.selector = selector;
								}
								selector = selector.replace(match[<span class="hljs-number">0</span>], <span class="hljs-string">''</span>); <span class="hljs-comment">// strip current match from selector</span>
								<span class="hljs-keyword">if</span> (!selector.length) {
									token.last = <span class="hljs-literal">true</span>;
								}

								<span class="hljs-keyword">if</span> (Selector._attrFilters[match[<span class="hljs-number">1</span>]]) { <span class="hljs-comment">// convert class to className, etc.</span>
									match[<span class="hljs-number">1</span>] = Selector._attrFilters[match[<span class="hljs-number">1</span>]];
								}

								test = parser.fn(match, token);
								<span class="hljs-keyword">if</span> (test === <span class="hljs-literal">false</span>) { <span class="hljs-comment">// selector not supported</span>
									found = <span class="hljs-literal">false</span>;
									<span class="hljs-keyword">break</span> outer;
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (test) {
									token.tests.push(test);
								}

								<span class="hljs-keyword">if</span> (!selector.length || parser.name === COMBINATOR) {
									tokens.push(token);
									token = Selector._getToken(token);
									<span class="hljs-keyword">if</span> (parser.name === COMBINATOR) {
										token.combinator = Y.Selector.combinators[match[<span class="hljs-number">1</span>]];
									}
								}
								found = <span class="hljs-literal">true</span>;
							}
						}
					} <span class="hljs-keyword">while</span> (found &amp;&amp; selector.length);

				<span class="hljs-keyword">if</span> (!found || selector.length) { <span class="hljs-comment">// not fully parsed</span>
					tokens = [];
				}
				<span class="hljs-keyword">return</span> tokens;
			},

			<span class="hljs-attr">_replaceMarkers</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
				selector = selector.replace(<span class="hljs-regexp">/\[/g</span>, <span class="hljs-string">'\uE003'</span>);
				selector = selector.replace(<span class="hljs-regexp">/\]/g</span>, <span class="hljs-string">'\uE004'</span>);

				selector = selector.replace(<span class="hljs-regexp">/\(/g</span>, <span class="hljs-string">'\uE005'</span>);
				selector = selector.replace(<span class="hljs-regexp">/\)/g</span>, <span class="hljs-string">'\uE006'</span>);
				<span class="hljs-keyword">return</span> selector;
			},

			<span class="hljs-attr">_replaceShorthand</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
				<span class="hljs-keyword">var</span> shorthand = Y.Selector.shorthand,
					re;

				<span class="hljs-keyword">for</span> (re <span class="hljs-keyword">in</span> shorthand) {
					<span class="hljs-keyword">if</span> (shorthand.hasOwnProperty(re)) {
						selector = selector.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(re, <span class="hljs-string">'gi'</span>), shorthand[re]);
					}
				}

				<span class="hljs-keyword">return</span> selector;
			},

			<span class="hljs-attr">_parseSelector</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
				<span class="hljs-keyword">var</span> replaced = Y.Selector._replaceSelector(selector),
					selector = replaced.selector;</pre></div></div>
            
        </li>
        
        
        <li id="section-310">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-310">&#182;</a>
              </div>
              <p>replace shorthand (“.foo, #bar”) after pseudos and attrs
to avoid replacing unescaped chars</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				selector = Y.Selector._replaceShorthand(selector);

				selector = Y.Selector._restore(<span class="hljs-string">'attr'</span>, selector, replaced.attrs);
				selector = Y.Selector._restore(<span class="hljs-string">'pseudo'</span>, selector, replaced.pseudos);</pre></div></div>
            
        </li>
        
        
        <li id="section-311">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-311">&#182;</a>
              </div>
              <p>replace braces and parens before restoring escaped chars
to avoid replacing ecaped markers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				selector = Y.Selector._replaceMarkers(selector);
				selector = Y.Selector._restore(<span class="hljs-string">'esc'</span>, selector, replaced.esc);

				<span class="hljs-keyword">return</span> selector;
			},

			<span class="hljs-attr">_attrFilters</span>: {
				<span class="hljs-string">'class'</span>: <span class="hljs-string">'className'</span>,
				<span class="hljs-string">'for'</span>: <span class="hljs-string">'htmlFor'</span>
			},

			<span class="hljs-attr">getters</span>: {
				<span class="hljs-attr">href</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, attr</span>) </span>{
					<span class="hljs-keyword">return</span> Y.DOM.getAttribute(node, attr);
				},

				<span class="hljs-attr">id</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, attr</span>) </span>{
					<span class="hljs-keyword">return</span> Y.DOM.getId(node);
				}
			}
		};

	Y.mix(Y.Selector, SelectorCSS2, <span class="hljs-literal">true</span>);
	Y.Selector.getters.src = Y.Selector.getters.rel = Y.Selector.getters.href;</pre></div></div>
            
        </li>
        
        
        <li id="section-312">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-312">&#182;</a>
              </div>
              <p>IE wants class with native queries</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (Y.Selector.useNative &amp;&amp; Y.config.doc.querySelector) {
		Y.Selector.shorthand[<span class="hljs-string">'\\.(-?[_a-z]+[-\\w]*)'</span>] = <span class="hljs-string">'[class~=$1]'</span>;
	}



}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"selector-native"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'selector'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{



}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"selector-native"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'node-core'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * The Node Utility provides a DOM-like interface for interacting with DOM nodes.
	 * @module node
	 * @main node
	 * @submodule node-core
	 */</span>

	<span class="hljs-comment">/**
	 * The Node class provides a wrapper for manipulating DOM Nodes.
	 * Node properties can be accessed via the set/get methods.
	 * Use `Y.one()` to retrieve Node instances.
	 *
	 * &lt;strong&gt;<span class="hljs-doctag">NOTE:</span>&lt;/strong&gt; Node properties are accessed using
	 * the &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt; methods.
	 *
	 * @class Node
	 * @constructor
	 * @param {DOMNode} node the DOM node to be mapped to the Node instance.
	 * @uses EventTarget
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-313">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-313">&#182;</a>
              </div>
              <p>“globals”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> DOT = <span class="hljs-string">'.'</span>,
		NODE_NAME = <span class="hljs-string">'nodeName'</span>,
		NODE_TYPE = <span class="hljs-string">'nodeType'</span>,
		OWNER_DOCUMENT = <span class="hljs-string">'ownerDocument'</span>,
		TAG_NAME = <span class="hljs-string">'tagName'</span>,
		UID = <span class="hljs-string">'_yuid'</span>,
		EMPTY_OBJ = {},

		_slice = <span class="hljs-built_in">Array</span>.prototype.slice,

		Y_DOM = Y.DOM,

		Y_Node = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.getDOMNode) { <span class="hljs-comment">// support optional "new"</span>
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Y_Node(node);
			}

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node == <span class="hljs-string">'string'</span>) {
				node = Y_Node._fromString(node);
				<span class="hljs-keyword">if</span> (!node) {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> return</span>
				}
			}

			<span class="hljs-keyword">var</span> uid = (node.nodeType !== <span class="hljs-number">9</span>) ? node.uniqueID : node[UID];

			<span class="hljs-keyword">if</span> (uid &amp;&amp; Y_Node._instances[uid] &amp;&amp; Y_Node._instances[uid]._node !== node) {
				node[UID] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// unset existing uid to prevent collision (via clone or hack)</span>
			}

			uid = uid || Y.stamp(node);
			<span class="hljs-keyword">if</span> (!uid) { <span class="hljs-comment">// stamp failed; likely IE non-HTMLElement</span>
				uid = Y.guid();
			}

			<span class="hljs-keyword">this</span>[UID] = uid;

			<span class="hljs-comment">/**
			 * The underlying DOM node bound to the Y.Node instance
			 * @property _node
			 * @type DOMNode
			 * @private
			 */</span>
			<span class="hljs-keyword">this</span>._node = node;

			<span class="hljs-keyword">this</span>._stateProxy = node; <span class="hljs-comment">// when augmented with Attribute</span>

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._initPlugins) { <span class="hljs-comment">// when augmented with Plugin.Host</span>
				<span class="hljs-keyword">this</span>._initPlugins();
			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-314">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-314">&#182;</a>
              </div>
              <p>used with previous/next/ancestor tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_wrapFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
			<span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">if</span> (fn) {
				ret = (<span class="hljs-keyword">typeof</span> fn == <span class="hljs-string">'string'</span>) ?
					<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
						<span class="hljs-keyword">return</span> Y.Selector.test(n, fn);
					} :
					<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
						<span class="hljs-keyword">return</span> fn(Y.one(n));
					};
			}

			<span class="hljs-keyword">return</span> ret;
		};</pre></div></div>
            
        </li>
        
        
        <li id="section-315">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-315">&#182;</a>
              </div>
              <p>end “globals”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	Y_Node.ATTRS = {};
	Y_Node.DOM_EVENTS = {};

	Y_Node._fromString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
		<span class="hljs-keyword">if</span> (node) {
			<span class="hljs-keyword">if</span> (node.indexOf(<span class="hljs-string">'doc'</span>) === <span class="hljs-number">0</span>) { <span class="hljs-comment">// doc OR document</span>
				node = Y.config.doc;
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.indexOf(<span class="hljs-string">'win'</span>) === <span class="hljs-number">0</span>) { <span class="hljs-comment">// win OR window</span>
				node = Y.config.win;
			} <span class="hljs-keyword">else</span> {
				node = Y.Selector.query(node, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
			}
		}

		<span class="hljs-keyword">return</span> node || <span class="hljs-literal">null</span>;
	};

	<span class="hljs-comment">/**
	 * The name of the component
	 * @static
	 * @type String
	 * @property NAME
	 */</span>
	Y_Node.NAME = <span class="hljs-string">'node'</span>;

	<span class="hljs-comment">/*
	 * The pattern used to identify ARIA attributes
	 */</span>
	Y_Node.re_aria = <span class="hljs-regexp">/^(?:role$|aria-)/</span>;

	Y_Node.SHOW_TRANSITION = <span class="hljs-string">'fadeIn'</span>;
	Y_Node.HIDE_TRANSITION = <span class="hljs-string">'fadeOut'</span>;

	<span class="hljs-comment">/**
	 * A list of Node instances that have been created
	 * @private
	 * @type Object
	 * @property _instances
	 * @static
	 *
	 */</span>
	Y_Node._instances = {};

	<span class="hljs-comment">/**
	 * Retrieves the DOM node bound to a Node instance
	 * @method getDOMNode
	 * @static
	 *
	 * @param {Node | HTMLNode} node The Node instance or an HTMLNode
	 * @return {HTMLNode} The DOM node bound to the Node instance.  If a DOM node is passed
	 * as the node argument, it is simply returned.
	 */</span>
	Y_Node.getDOMNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
		<span class="hljs-keyword">if</span> (node) {
			<span class="hljs-keyword">return</span> (node.nodeType) ? node : node._node || <span class="hljs-literal">null</span>;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	};

	<span class="hljs-comment">/**
	 * Checks Node return values and wraps DOM Nodes as Y.Node instances
	 * and DOM Collections / Arrays as Y.NodeList instances.
	 * Other return values just pass thru.  If undefined is returned (e.g. no return)
	 * then the Node instance is returned for chainability.
	 * @method scrubVal
	 * @static
	 *
	 * @param {any} node The Node instance or an HTMLNode
	 * @return {Node | NodeList | Any} Depends on what is returned from the DOM node.
	 */</span>
	Y_Node.scrubVal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, node</span>) </span>{
		<span class="hljs-keyword">if</span> (val) { <span class="hljs-comment">// only truthy values are risky</span>
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val == <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> val == <span class="hljs-string">'function'</span>) { <span class="hljs-comment">// safari nodeList === function</span>
				<span class="hljs-keyword">if</span> (NODE_TYPE <span class="hljs-keyword">in</span> val || Y_DOM.isWindow(val)) {<span class="hljs-comment">// node || window</span>
					val = Y.one(val);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((val.item &amp;&amp; !val._nodes) || <span class="hljs-comment">// dom collection or Node instance</span>
					(val[<span class="hljs-number">0</span>] &amp;&amp; val[<span class="hljs-number">0</span>][NODE_TYPE])) { <span class="hljs-comment">// array of DOM Nodes</span>
					val = Y.all(val);
				}
			}
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'undefined'</span>) {
			val = node; <span class="hljs-comment">// for chaining</span>
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val === <span class="hljs-literal">null</span>) {
			val = <span class="hljs-literal">null</span>; <span class="hljs-comment">// IE: DOM null not the same as null</span>
		}

		<span class="hljs-keyword">return</span> val;
	};

	<span class="hljs-comment">/**
	 * Adds methods to the Y.Node prototype, routing through scrubVal.
	 * @method addMethod
	 * @static
	 *
	 * @param {String} name The name of the method to add
	 * @param {Function} fn The function that becomes the method
	 * @param {Object} context An optional context to call the method with
	 * (defaults to the Node instance)
	 * @return {any} Depends on what is returned from the DOM node.
	 */</span>
	Y_Node.addMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, fn, context</span>) </span>{
		<span class="hljs-keyword">if</span> (name &amp;&amp; fn &amp;&amp; <span class="hljs-keyword">typeof</span> fn == <span class="hljs-string">'function'</span>) {
			Y_Node.prototype[name] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">var</span> args = _slice.call(<span class="hljs-built_in">arguments</span>),
					node = <span class="hljs-keyword">this</span>,
					ret;

				<span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] &amp;&amp; args[<span class="hljs-number">0</span>]._node) {
					args[<span class="hljs-number">0</span>] = args[<span class="hljs-number">0</span>]._node;
				}

				<span class="hljs-keyword">if</span> (args[<span class="hljs-number">1</span>] &amp;&amp; args[<span class="hljs-number">1</span>]._node) {
					args[<span class="hljs-number">1</span>] = args[<span class="hljs-number">1</span>]._node;
				}
				args.unshift(node._node);

				ret = fn.apply(node, args);

				<span class="hljs-keyword">if</span> (ret) { <span class="hljs-comment">// scrub truthy</span>
					ret = Y_Node.scrubVal(ret, node);
				}

				(<span class="hljs-keyword">typeof</span> ret != <span class="hljs-string">'undefined'</span>) || (ret = node);
				<span class="hljs-keyword">return</span> ret;
			};
		} <span class="hljs-keyword">else</span> {
		}
	};

	<span class="hljs-comment">/**
	 * Imports utility methods to be added as Y.Node methods.
	 * @method importMethod
	 * @static
	 *
	 * @param {Object} host The object that contains the method to import.
	 * @param {String} name The name of the method to import
	 * @param {String} altName An optional name to use in place of the host name
	 * @param {Object} context An optional context to call the method with
	 */</span>
	Y_Node.importMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">host, name, altName</span>) </span>{
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name == <span class="hljs-string">'string'</span>) {
			altName = altName || name;
			Y_Node.addMethod(altName, host[name], host);
		} <span class="hljs-keyword">else</span> {
			Y.Array.each(name, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
				Y_Node.importMethod(host, n);
			});
		}
	};

	<span class="hljs-comment">/**
	 * Retrieves a NodeList based on the given CSS selector.
	 * @method all
	 *
	 * @param {string} selector The CSS selector to test against.
	 * @return {NodeList} A NodeList instance for the matching HTMLCollection/Array.
	 * @for YUI
	 */</span>

	<span class="hljs-comment">/**
	 * Returns a single Node instance bound to the node or the
	 * first element matching the given selector. Returns null if no match found.
	 * &lt;strong&gt;Note:&lt;/strong&gt; For chaining purposes you may want to
	 * use &lt;code&gt;Y.all&lt;/code&gt;, which returns a NodeList when no match is found.
	 * @method one
	 * @param {String | HTMLElement} node a node or Selector
	 * @return {Node | null} a Node instance or null if no match found.
	 * @for YUI
	 */</span>

	<span class="hljs-comment">/**
	 * Returns a single Node instance bound to the node or the
	 * first element matching the given selector. Returns null if no match found.
	 * &lt;strong&gt;Note:&lt;/strong&gt; For chaining purposes you may want to
	 * use &lt;code&gt;Y.all&lt;/code&gt;, which returns a NodeList when no match is found.
	 * @method one
	 * @static
	 * @param {String | HTMLElement} node a node or Selector
	 * @return {Node | null} a Node instance or null if no match found.
	 * @for Node
	 */</span>
	Y_Node.one = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
		<span class="hljs-keyword">var</span> instance = <span class="hljs-literal">null</span>,
			cachedNode,
			uid;

		<span class="hljs-keyword">if</span> (node) {
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node == <span class="hljs-string">'string'</span>) {
				node = Y_Node._fromString(node);
				<span class="hljs-keyword">if</span> (!node) {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> return</span>
				}
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.getDOMNode) {
				<span class="hljs-keyword">return</span> node; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> return</span>
			}

			<span class="hljs-keyword">if</span> (node.nodeType || Y.DOM.isWindow(node)) { <span class="hljs-comment">// avoid bad input (numbers, boolean, etc)</span>
				uid = (node.uniqueID &amp;&amp; node.nodeType !== <span class="hljs-number">9</span>) ? node.uniqueID : node._yuid;
				instance = Y_Node._instances[uid]; <span class="hljs-comment">// reuse exising instances</span>
				cachedNode = instance ? instance._node : <span class="hljs-literal">null</span>;
				<span class="hljs-keyword">if</span> (!instance || (cachedNode &amp;&amp; node !== cachedNode)) { <span class="hljs-comment">// new Node when nodes don't match</span>
					instance = <span class="hljs-keyword">new</span> Y_Node(node);
					<span class="hljs-keyword">if</span> (node.nodeType != <span class="hljs-number">11</span>) { <span class="hljs-comment">// dont cache document fragment</span>
						Y_Node._instances[instance[UID]] = instance; <span class="hljs-comment">// cache node</span>
					}
				}
			}
		}

		<span class="hljs-keyword">return</span> instance;
	};

	<span class="hljs-comment">/**
	 * The default setter for DOM properties
	 * Called with instance context (this === the Node instance)
	 * @method DEFAULT_SETTER
	 * @static
	 * @param {String} name The attribute/property being set
	 * @param {any} val The value to be set
	 * @return {any} The value
	 */</span>
	Y_Node.DEFAULT_SETTER = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, val</span>) </span>{
		<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._stateProxy,
			strPath;

		<span class="hljs-keyword">if</span> (name.indexOf(DOT) &gt; <span class="hljs-number">-1</span>) {
			strPath = name;
			name = name.split(DOT);</pre></div></div>
            
        </li>
        
        
        <li id="section-316">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-316">&#182;</a>
              </div>
              <p>only allow when defined on node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			Y.Object.setValue(node, name, val);
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node[name] != <span class="hljs-string">'undefined'</span>) { <span class="hljs-comment">// pass thru DOM properties</span>
			node[name] = val;
		}

		<span class="hljs-keyword">return</span> val;
	};

	<span class="hljs-comment">/**
	 * The default getter for DOM properties
	 * Called with instance context (this === the Node instance)
	 * @method DEFAULT_GETTER
	 * @static
	 * @param {String} name The attribute/property to look up
	 * @return {any} The current value
	 */</span>
	Y_Node.DEFAULT_GETTER = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
		<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._stateProxy,
			val;

		<span class="hljs-keyword">if</span> (name.indexOf &amp;&amp; name.indexOf(DOT) &gt; <span class="hljs-number">-1</span>) {
			val = Y.Object.getValue(node, name.split(DOT));
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node[name] != <span class="hljs-string">'undefined'</span>) { <span class="hljs-comment">// pass thru from DOM</span>
			val = node[name];
		}

		<span class="hljs-keyword">return</span> val;
	};

	Y.mix(Y_Node.prototype, {
		<span class="hljs-attr">DATA_PREFIX</span>: <span class="hljs-string">'data-'</span>,

		<span class="hljs-comment">/**
		 * The method called when outputting Node instances as strings
		 * @method toString
		 * @return {String} A string representation of the Node instance
		 */</span>
		toString: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> str = <span class="hljs-keyword">this</span>[UID] + <span class="hljs-string">': not bound to a node'</span>,
				node = <span class="hljs-keyword">this</span>._node,
				attrs, id, className;

			<span class="hljs-keyword">if</span> (node) {
				attrs = node.attributes;
				id = (attrs &amp;&amp; attrs.id) ? node.getAttribute(<span class="hljs-string">'id'</span>) : <span class="hljs-literal">null</span>;
				className = (attrs &amp;&amp; attrs.className) ? node.getAttribute(<span class="hljs-string">'className'</span>) : <span class="hljs-literal">null</span>;
				str = node[NODE_NAME];

				<span class="hljs-keyword">if</span> (id) {
					str += <span class="hljs-string">'#'</span> + id;
				}

				<span class="hljs-keyword">if</span> (className) {
					str += <span class="hljs-string">'.'</span> + className.replace(<span class="hljs-string">' '</span>, <span class="hljs-string">'.'</span>);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-317">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-317">&#182;</a>
              </div>
              <p>TODO: add yuid?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				str += <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>[UID];
			}
			<span class="hljs-keyword">return</span> str;
		},

		<span class="hljs-comment">/**
		 * Returns an attribute value on the Node instance.
		 * Unless pre-configured (via `Node.ATTRS`), get hands
		 * off to the underlying DOM node.  Only valid
		 * attributes/properties for the node will be queried.
		 * @method get
		 * @param {String} attr The attribute
		 * @return {any} The current value of the attribute
		 */</span>
		get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
			<span class="hljs-keyword">var</span> val;

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._getAttr) { <span class="hljs-comment">// use Attribute imple</span>
				val = <span class="hljs-keyword">this</span>._getAttr(attr);
			} <span class="hljs-keyword">else</span> {
				val = <span class="hljs-keyword">this</span>._get(attr);
			}

			<span class="hljs-keyword">if</span> (val) {
				val = Y_Node.scrubVal(val, <span class="hljs-keyword">this</span>);
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val === <span class="hljs-literal">null</span>) {
				val = <span class="hljs-literal">null</span>; <span class="hljs-comment">// IE: DOM null is not true null (even though they ===)</span>
			}
			<span class="hljs-keyword">return</span> val;
		},

		<span class="hljs-comment">/**
		 * Helper method for get.
		 * @method _get
		 * @private
		 * @param {String} attr The attribute
		 * @return {any} The current value of the attribute
		 */</span>
		_get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
			<span class="hljs-keyword">var</span> attrConfig = Y_Node.ATTRS[attr],
				val;

			<span class="hljs-keyword">if</span> (attrConfig &amp;&amp; attrConfig.getter) {
				val = attrConfig.getter.call(<span class="hljs-keyword">this</span>);
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Y_Node.re_aria.test(attr)) {
				val = <span class="hljs-keyword">this</span>._node.getAttribute(attr, <span class="hljs-number">2</span>);
			} <span class="hljs-keyword">else</span> {
				val = Y_Node.DEFAULT_GETTER.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			}

			<span class="hljs-keyword">return</span> val;
		},

		<span class="hljs-comment">/**
		 * Sets an attribute on the Node instance.
		 * Unless pre-configured (via Node.ATTRS), set hands
		 * off to the underlying DOM node.  Only valid
		 * attributes/properties for the node will be set.
		 * To set custom attributes use setAttribute.
		 * @method set
		 * @param {String} attr The attribute to be set.
		 * @param {any} val The value to set the attribute to.
		 * @chainable
		 */</span>
		set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr, val</span>) </span>{
			<span class="hljs-keyword">var</span> attrConfig = Y_Node.ATTRS[attr];

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._setAttr) { <span class="hljs-comment">// use Attribute imple</span>
				<span class="hljs-keyword">this</span>._setAttr.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// use setters inline</span>
				<span class="hljs-keyword">if</span> (attrConfig &amp;&amp; attrConfig.setter) {
					attrConfig.setter.call(<span class="hljs-keyword">this</span>, val, attr);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Y_Node.re_aria.test(attr)) { <span class="hljs-comment">// special case Aria</span>
					<span class="hljs-keyword">this</span>._node.setAttribute(attr, val);
				} <span class="hljs-keyword">else</span> {
					Y_Node.DEFAULT_SETTER.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Sets multiple attributes.
		 * @method setAttrs
		 * @param {Object} attrMap an object of name/value pairs to set
		 * @chainable
		 */</span>
		setAttrs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrMap</span>) </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._setAttrs) { <span class="hljs-comment">// use Attribute imple</span>
				<span class="hljs-keyword">this</span>._setAttrs(attrMap);
			} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// use setters inline</span>
				Y.Object.each(attrMap, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, n</span>) </span>{
					<span class="hljs-keyword">this</span>.set(n, v);
				}, <span class="hljs-keyword">this</span>);
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Returns an object containing the values for the requested attributes.
		 * @method getAttrs
		 * @param {Array} attrs an array of attributes to get values
		 * @return {Object} An object with attribute name/value pairs.
		 */</span>
		getAttrs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrs</span>) </span>{
			<span class="hljs-keyword">var</span> ret = {};
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._getAttrs) { <span class="hljs-comment">// use Attribute imple</span>
				<span class="hljs-keyword">this</span>._getAttrs(attrs);
			} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// use setters inline</span>
				Y.Array.each(attrs, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, n</span>) </span>{
					ret[v] = <span class="hljs-keyword">this</span>.get(v);
				}, <span class="hljs-keyword">this</span>);
			}

			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-comment">/**
		 * Compares nodes to determine if they match.
		 * Node instances can be compared to each other and/or HTMLElements.
		 * @method compareTo
		 * @param {HTMLElement | Node} refNode The reference node to compare to the node.
		 * @return {Boolean} True if the nodes match, false if they do not.
		 */</span>
		compareTo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">refNode</span>) </span>{
			<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node;

			<span class="hljs-keyword">if</span> (refNode &amp;&amp; refNode._node) {
				refNode = refNode._node;
			}
			<span class="hljs-keyword">return</span> node === refNode;
		},

		<span class="hljs-comment">/**
		 * Determines whether the node is appended to the document.
		 * @method inDoc
		 * @param {Node|HTMLElement} doc optional An optional document to check against.
		 * Defaults to current document.
		 * @return {Boolean} Whether or not this node is appended to the document.
		 */</span>
		inDoc: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
			<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node;
			doc = (doc) ? doc._node || doc : node[OWNER_DOCUMENT];
			<span class="hljs-keyword">if</span> (doc.documentElement) {
				<span class="hljs-keyword">return</span> Y_DOM.contains(doc.documentElement, node);
			}
		},

		<span class="hljs-attr">getById</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>{
			<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node,
				ret = Y_DOM.byId(id, node[OWNER_DOCUMENT]);
			<span class="hljs-keyword">if</span> (ret &amp;&amp; Y_DOM.contains(node, ret)) {
				ret = Y.one(ret);
			} <span class="hljs-keyword">else</span> {
				ret = <span class="hljs-literal">null</span>;
			}
			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-comment">/**
		 * Returns the nearest ancestor that passes the test applied by supplied boolean method.
		 * @method ancestor
		 * @param {String | Function} fn A selector string or boolean method for testing elements.
		 * If a function is used, it receives the current node being tested as the only argument.
		 * If fn is not passed as an argument, the parent node will be returned.
		 * @param {Boolean} testSelf optional Whether or not to include the element in the scan
		 * @param {String | Function} stopFn optional A selector string or boolean
		 * method to indicate when the search should stop. The search bails when the function
		 * returns true or the selector matches.
		 * If a function is used, it receives the current node being tested as the only argument.
		 * @return {Node} The matching Node instance or null if not found
		 */</span>
		ancestor: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, testSelf, stopFn</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-318">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-318">&#182;</a>
              </div>
              <p>testSelf is optional, check for stopFn as 2nd arg</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span> &amp;&amp;
				(<span class="hljs-keyword">typeof</span> testSelf == <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> testSelf == <span class="hljs-string">'function'</span>)) {
				stopFn = testSelf;
			}

			<span class="hljs-keyword">return</span> Y.one(Y_DOM.ancestor(<span class="hljs-keyword">this</span>._node, _wrapFn(fn), testSelf, _wrapFn(stopFn)));
		},

		<span class="hljs-comment">/**
		 * Returns the ancestors that pass the test applied by supplied boolean method.
		 * @method ancestors
		 * @param {String | Function} fn A selector string or boolean method for testing elements.
		 * @param {Boolean} testSelf optional Whether or not to include the element in the scan
		 * If a function is used, it receives the current node being tested as the only argument.
		 * @return {NodeList} A NodeList instance containing the matching elements
		 */</span>
		ancestors: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, testSelf, stopFn</span>) </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span> &amp;&amp;
				(<span class="hljs-keyword">typeof</span> testSelf == <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> testSelf == <span class="hljs-string">'function'</span>)) {
				stopFn = testSelf;
			}
			<span class="hljs-keyword">return</span> Y.all(Y_DOM.ancestors(<span class="hljs-keyword">this</span>._node, _wrapFn(fn), testSelf, _wrapFn(stopFn)));
		},

		<span class="hljs-comment">/**
		 * Returns the previous matching sibling.
		 * Returns the nearest element node sibling if no method provided.
		 * @method previous
		 * @param {String | Function} fn A selector or boolean method for testing elements.
		 * If a function is used, it receives the current node being tested as the only argument.
		 * @return {Node} Node instance or null if not found
		 */</span>
		previous: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, all</span>) </span>{
			<span class="hljs-keyword">return</span> Y.one(Y_DOM.elementByAxis(<span class="hljs-keyword">this</span>._node, <span class="hljs-string">'previousSibling'</span>, _wrapFn(fn), all));
		},

		<span class="hljs-comment">/**
		 * Returns the next matching sibling.
		 * Returns the nearest element node sibling if no method provided.
		 * @method next
		 * @param {String | Function} fn A selector or boolean method for testing elements.
		 * If a function is used, it receives the current node being tested as the only argument.
		 * @return {Node} Node instance or null if not found
		 */</span>
		next: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, all</span>) </span>{
			<span class="hljs-keyword">return</span> Y.one(Y_DOM.elementByAxis(<span class="hljs-keyword">this</span>._node, <span class="hljs-string">'nextSibling'</span>, _wrapFn(fn), all));
		},

		<span class="hljs-comment">/**
		 * Returns all matching siblings.
		 * Returns all siblings if no method provided.
		 * @method siblings
		 * @param {String | Function} fn A selector or boolean method for testing elements.
		 * If a function is used, it receives the current node being tested as the only argument.
		 * @return {NodeList} NodeList instance bound to found siblings
		 */</span>
		siblings: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
			<span class="hljs-keyword">return</span> Y.all(Y_DOM.siblings(<span class="hljs-keyword">this</span>._node, _wrapFn(fn)));
		},

		<span class="hljs-comment">/**
		 * Retrieves a Node instance of nodes based on the given CSS selector.
		 * @method one
		 *
		 * @param {string} selector The CSS selector to test against.
		 * @return {Node} A Node instance for the matching HTMLElement.
		 */</span>
		one: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
			<span class="hljs-keyword">return</span> Y.one(Y.Selector.query(selector, <span class="hljs-keyword">this</span>._node, <span class="hljs-literal">true</span>));
		},

		<span class="hljs-comment">/**
		 * Retrieves a NodeList based on the given CSS selector.
		 * @method all
		 *
		 * @param {string} selector The CSS selector to test against.
		 * @return {NodeList} A NodeList instance for the matching HTMLCollection/Array.
		 */</span>
		all: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
			<span class="hljs-keyword">var</span> nodelist = Y.all(Y.Selector.query(selector, <span class="hljs-keyword">this</span>._node));
			nodelist._query = selector;
			nodelist._queryRoot = <span class="hljs-keyword">this</span>._node;
			<span class="hljs-keyword">return</span> nodelist;
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-319">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-319">&#182;</a>
              </div>
              <p>TODO: allow fn test</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * Test if the supplied node matches the supplied selector.
		 * @method test
		 *
		 * @param {string} selector The CSS selector to test against.
		 * @return {boolean} Whether or not the node matches the selector.
		 */</span>
		test: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
			<span class="hljs-keyword">return</span> Y.Selector.test(<span class="hljs-keyword">this</span>._node, selector);
		},

		<span class="hljs-comment">/**
		 * Removes the node from its parent.
		 * Shortcut for myNode.get('parentNode').removeChild(myNode);
		 * @method remove
		 * @param {Boolean} destroy whether or not to call destroy() on the node
		 * after removal.
		 * @chainable
		 *
		 */</span>
		remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">destroy</span>) </span>{
			<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node;

			<span class="hljs-keyword">if</span> (node &amp;&amp; node.parentNode) {
				node.parentNode.removeChild(node);
			}

			<span class="hljs-keyword">if</span> (destroy) {
				<span class="hljs-keyword">this</span>.destroy();
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Replace the node with the other node. This is a DOM update only
		 * and does not change the node bound to the Node instance.
		 * Shortcut for myNode.get('parentNode').replaceChild(newNode, myNode);
		 * @method replace
		 * @param {Node | HTMLNode} newNode Node to be inserted
		 * @chainable
		 *
		 */</span>
		replace: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newNode</span>) </span>{
			<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node;
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newNode == <span class="hljs-string">'string'</span>) {
				newNode = Y_Node.create(newNode);
			}
			node.parentNode.replaceChild(Y_Node.getDOMNode(newNode), node);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * @method replaceChild
		 * @for Node
		 * @param {String | HTMLElement | Node} node Node to be inserted
		 * @param {HTMLElement | Node} refNode Node to be replaced
		 * @return {Node} The replaced node
		 */</span>
		replaceChild: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, refNode</span>) </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node == <span class="hljs-string">'string'</span>) {
				node = Y_DOM.create(node);
			}

			<span class="hljs-keyword">return</span> Y.one(<span class="hljs-keyword">this</span>._node.replaceChild(Y_Node.getDOMNode(node), Y_Node.getDOMNode(refNode)));
		},

		<span class="hljs-comment">/**
		 * Nulls internal node references, removes any plugins and event listeners.
		 * Note that destroy() will not remove the node from its parent or from the DOM. For that
		 * functionality, call remove(true).
		 * @method destroy
		 * @param {Boolean} [recursivePurge] Whether or not to remove listeners from the
		 * node's subtree (default is false)
		 *
		 */</span>
		destroy: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">recursive</span>) </span>{
			<span class="hljs-keyword">var</span> UID = Y.config.doc.uniqueID ? <span class="hljs-string">'uniqueID'</span> : <span class="hljs-string">'_yuid'</span>,
				instance;

			<span class="hljs-keyword">this</span>.purge(); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> only remove events add via this Node</span>

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.unplug) { <span class="hljs-comment">// may not be a PluginHost</span>
				<span class="hljs-keyword">this</span>.unplug();
			}

			<span class="hljs-keyword">this</span>.clearData();

			<span class="hljs-keyword">if</span> (recursive) {
				Y.NodeList.each(<span class="hljs-keyword">this</span>.all(<span class="hljs-string">'*'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
					instance = Y_Node._instances[node[UID]];
					<span class="hljs-keyword">if</span> (instance) {
						instance.destroy();
					} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// purge in case added by other means</span>
						Y.Event.purgeElement(node);
					}
				});
			}

			<span class="hljs-keyword">this</span>._node = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">this</span>._stateProxy = <span class="hljs-literal">null</span>;

			<span class="hljs-keyword">delete</span> Y_Node._instances[<span class="hljs-keyword">this</span>._yuid];
		},

		<span class="hljs-comment">/**
		 * Invokes a method on the Node instance
		 * @method invoke
		 * @param {String} method The name of the method to invoke
		 * @param {Any}  a, b, c, etc. Arguments to invoke the method with.
		 * @return Whatever the underly method returns.
		 * DOM Nodes and Collections return values
		 * are converted to Node/NodeList instances.
		 *
		 */</span>
		invoke: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">method, a, b, c, d, e</span>) </span>{
			<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node,
				ret;

			<span class="hljs-keyword">if</span> (a &amp;&amp; a._node) {
				a = a._node;
			}

			<span class="hljs-keyword">if</span> (b &amp;&amp; b._node) {
				b = b._node;
			}

			ret = node[method](a, b, c, d, e);
			<span class="hljs-keyword">return</span> Y_Node.scrubVal(ret, <span class="hljs-keyword">this</span>);
		},

		<span class="hljs-comment">/**
		 * @method swap
		 * @description Swap DOM locations with the given node.
		 * This does not change which DOM node each Node instance refers to.
		 * @param {Node} otherNode The node to swap with
		 * @chainable
		 */</span>
		swap: Y.config.doc.documentElement.swapNode ?
			<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherNode</span>) </span>{
				<span class="hljs-keyword">this</span>._node.swapNode(Y_Node.getDOMNode(otherNode));
			} :
			<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherNode</span>) </span>{
				otherNode = Y_Node.getDOMNode(otherNode);
				<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node,
					parent = otherNode.parentNode,
					nextSibling = otherNode.nextSibling;

				<span class="hljs-keyword">if</span> (nextSibling === node) {
					parent.insertBefore(node, otherNode);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (otherNode === node.nextSibling) {
					parent.insertBefore(otherNode, node);
				} <span class="hljs-keyword">else</span> {
					node.parentNode.replaceChild(otherNode, node);
					Y_DOM.addHTML(parent, node, nextSibling);
				}
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
			},


		<span class="hljs-attr">hasMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">method</span>) </span>{
			<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node;
			<span class="hljs-keyword">return</span> !!(node &amp;&amp; method <span class="hljs-keyword">in</span> node &amp;&amp;
				<span class="hljs-keyword">typeof</span> node[method] != <span class="hljs-string">'unknown'</span> &amp;&amp;
				(<span class="hljs-keyword">typeof</span> node[method] == <span class="hljs-string">'function'</span> ||
					<span class="hljs-built_in">String</span>(node[method]).indexOf(<span class="hljs-string">'function'</span>) === <span class="hljs-number">1</span>)); <span class="hljs-comment">// IE reports as object, prepends space</span>
		},

		<span class="hljs-attr">isFragment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'nodeType'</span>) === <span class="hljs-number">11</span>);
		},

		<span class="hljs-comment">/**
		 * Removes and destroys all of the nodes within the node.
		 * @method empty
		 * @chainable
		 */</span>
		empty: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'childNodes'</span>).remove().destroy(<span class="hljs-literal">true</span>);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Returns the DOM node bound to the Node instance
		 * @method getDOMNode
		 * @return {DOMNode}
		 */</span>
		getDOMNode: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._node;
		}
	}, <span class="hljs-literal">true</span>);

	Y.Node = Y_Node;
	Y.one = Y_Node.one;
	<span class="hljs-comment">/**
	 * The NodeList module provides support for managing collections of Nodes.
	 * @module node
	 * @submodule node-core
	 */</span>

	<span class="hljs-comment">/**
	 * The NodeList class provides a wrapper for manipulating DOM NodeLists.
	 * NodeList properties can be accessed via the set/get methods.
	 * Use Y.all() to retrieve NodeList instances.
	 *
	 * @class NodeList
	 * @constructor
	 * @param nodes {String|element|Node|Array} A selector, DOM element, Node, list of DOM elements, or list of Nodes with which to populate this NodeList.
	 */</span>

	<span class="hljs-keyword">var</span> NodeList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodes</span>) </span>{
		<span class="hljs-keyword">var</span> tmp = [];

		<span class="hljs-keyword">if</span> (nodes) {
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nodes === <span class="hljs-string">'string'</span>) { <span class="hljs-comment">// selector query</span>
				<span class="hljs-keyword">this</span>._query = nodes;
				nodes = Y.Selector.query(nodes);
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes.nodeType || Y_DOM.isWindow(nodes)) { <span class="hljs-comment">// domNode || window</span>
				nodes = [nodes];
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes._node) { <span class="hljs-comment">// Y.Node</span>
				nodes = [nodes._node];
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes[<span class="hljs-number">0</span>] &amp;&amp; nodes[<span class="hljs-number">0</span>]._node) { <span class="hljs-comment">// allow array of Y.Nodes</span>
				Y.Array.each(nodes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
					<span class="hljs-keyword">if</span> (node._node) {
						tmp.push(node._node);
					}
				});
				nodes = tmp;
			} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// array of domNodes or domNodeList (no mixed array of Y.Node/domNodes)</span>
				nodes = Y.Array(nodes, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);
			}
		}

		<span class="hljs-comment">/**
		 * The underlying array of DOM nodes bound to the Y.NodeList instance
		 * @property _nodes
		 * @private
		 */</span>
		<span class="hljs-keyword">this</span>._nodes = nodes || [];
	};

	NodeList.NAME = <span class="hljs-string">'NodeList'</span>;

	<span class="hljs-comment">/**
	 * Retrieves the DOM nodes bound to a NodeList instance
	 * @method getDOMNodes
	 * @static
	 *
	 * @param {NodeList} nodelist The NodeList instance
	 * @return {Array} The array of DOM nodes bound to the NodeList
	 */</span>
	NodeList.getDOMNodes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodelist</span>) </span>{
		<span class="hljs-keyword">return</span> (nodelist &amp;&amp; nodelist._nodes) ? nodelist._nodes : nodelist;
	};

	NodeList.each = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">instance, fn, context</span>) </span>{
		<span class="hljs-keyword">var</span> nodes = instance._nodes;
		<span class="hljs-keyword">if</span> (nodes &amp;&amp; nodes.length) {
			Y.Array.each(nodes, fn, context || instance);
		} <span class="hljs-keyword">else</span> {
		}
	};

	NodeList.addMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, fn, context</span>) </span>{
		<span class="hljs-keyword">if</span> (name &amp;&amp; fn) {
			NodeList.prototype[name] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">var</span> ret = [],
					args = <span class="hljs-built_in">arguments</span>;

				Y.Array.each(<span class="hljs-keyword">this</span>._nodes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
					<span class="hljs-keyword">var</span> UID = (node.uniqueID &amp;&amp; node.nodeType !== <span class="hljs-number">9</span> ) ? <span class="hljs-string">'uniqueID'</span> : <span class="hljs-string">'_yuid'</span>,
						instance = Y.Node._instances[node[UID]],
						ctx,
						result;

					<span class="hljs-keyword">if</span> (!instance) {
						instance = NodeList._getTempNode(node);
					}
					ctx = context || instance;
					result = fn.apply(ctx, args);
					<span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span> &amp;&amp; result !== instance) {
						ret[ret.length] = result;
					}
				});</pre></div></div>
            
        </li>
        
        
        <li id="section-320">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-320">&#182;</a>
              </div>
              <p>TODO: remove tmp pointer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> ret.length ? ret : <span class="hljs-keyword">this</span>;
			};
		} <span class="hljs-keyword">else</span> {
		}
	};

	NodeList.importMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">host, name, altName</span>) </span>{
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'string'</span>) {
			altName = altName || name;
			NodeList.addMethod(name, host[name]);
		} <span class="hljs-keyword">else</span> {
			Y.Array.each(name, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
				NodeList.importMethod(host, n);
			});
		}
	};

	NodeList._getTempNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
		<span class="hljs-keyword">var</span> tmp = NodeList._tempNode;
		<span class="hljs-keyword">if</span> (!tmp) {
			tmp = Y.Node.create(<span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>);
			NodeList._tempNode = tmp;
		}

		tmp._node = node;
		tmp._stateProxy = node;
		<span class="hljs-keyword">return</span> tmp;
	};

	Y.mix(NodeList.prototype, {
		<span class="hljs-attr">_invoke</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">method, args, getter</span>) </span>{
			<span class="hljs-keyword">var</span> ret = (getter) ? [] : <span class="hljs-keyword">this</span>;

			<span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">var</span> val = node[method].apply(node, args);
				<span class="hljs-keyword">if</span> (getter) {
					ret.push(val);
				}
			});

			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-comment">/**
		 * Retrieves the Node instance at the given index.
		 * @method item
		 *
		 * @param {Number} index The index of the target Node.
		 * @return {Node} The Node instance at the given index.
		 */</span>
		item: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>{
			<span class="hljs-keyword">return</span> Y.one((<span class="hljs-keyword">this</span>._nodes || [])[index]);
		},

		<span class="hljs-comment">/**
		 * Applies the given function to each Node in the NodeList.
		 * @method each
		 * @param {Function} fn The function to apply. It receives 3 arguments:
		 * the current node instance, the node's index, and the NodeList instance
		 * @param {Object} context optional An optional context to apply the function with
		 * Default context is the current Node instance
		 * @chainable
		 */</span>
		each: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context</span>) </span>{
			<span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">this</span>;
			Y.Array.each(<span class="hljs-keyword">this</span>._nodes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, index</span>) </span>{
				node = Y.one(node);
				<span class="hljs-keyword">return</span> fn.call(context || node, node, index, instance);
			});
			<span class="hljs-keyword">return</span> instance;
		},

		<span class="hljs-attr">batch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context</span>) </span>{
			<span class="hljs-keyword">var</span> nodelist = <span class="hljs-keyword">this</span>;

			Y.Array.each(<span class="hljs-keyword">this</span>._nodes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, index</span>) </span>{
				<span class="hljs-keyword">var</span> instance = Y.Node._instances[node[UID]];
				<span class="hljs-keyword">if</span> (!instance) {
					instance = NodeList._getTempNode(node);
				}

				<span class="hljs-keyword">return</span> fn.call(context || instance, instance, index, nodelist);
			});
			<span class="hljs-keyword">return</span> nodelist;
		},

		<span class="hljs-comment">/**
		 * Executes the function once for each node until a true value is returned.
		 * @method some
		 * @param {Function} fn The function to apply. It receives 3 arguments:
		 * the current node instance, the node's index, and the NodeList instance
		 * @param {Object} context optional An optional context to execute the function from.
		 * Default context is the current Node instance
		 * @return {Boolean} Whether or not the function returned true for any node.
		 */</span>
		some: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context</span>) </span>{
			<span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">this</span>;
			<span class="hljs-keyword">return</span> Y.Array.some(<span class="hljs-keyword">this</span>._nodes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, index</span>) </span>{
				node = Y.one(node);
				context = context || node;
				<span class="hljs-keyword">return</span> fn.call(context, node, index, instance);
			});
		},

		<span class="hljs-comment">/**
		 * Creates a documenFragment from the nodes bound to the NodeList instance
		 * @method toFrag
		 * @return {Node} a Node instance bound to the documentFragment
		 */</span>
		toFrag: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> Y.one(Y.DOM._nl2frag(<span class="hljs-keyword">this</span>._nodes));
		},

		<span class="hljs-comment">/**
		 * Returns the index of the node in the NodeList instance
		 * or -1 if the node isn't found.
		 * @method indexOf
		 * @param {Node | DOMNode} node the node to search for
		 * @return {Int} the index of the node value or -1 if not found
		 */</span>
		indexOf: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			<span class="hljs-keyword">return</span> Y.Array.indexOf(<span class="hljs-keyword">this</span>._nodes, Y.Node.getDOMNode(node));
		},

		<span class="hljs-comment">/**
		 * Filters the NodeList instance down to only nodes matching the given selector.
		 * @method filter
		 * @param {String} selector The selector to filter against
		 * @return {NodeList} NodeList containing the updated collection
		 * @see Selector
		 */</span>
		filter: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
			<span class="hljs-keyword">return</span> Y.all(Y.Selector.filter(<span class="hljs-keyword">this</span>._nodes, selector));
		},


		<span class="hljs-comment">/**
		 * Creates a new NodeList containing all nodes at every n indices, where
		 * remainder n % index equals r.
		 * (zero-based index).
		 * @method modulus
		 * @param {Int} n The offset to use (return every nth node)
		 * @param {Int} r An optional remainder to use with the modulus operation (defaults to zero)
		 * @return {NodeList} NodeList containing the updated collection
		 */</span>
		modulus: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, r</span>) </span>{
			r = r || <span class="hljs-number">0</span>;
			<span class="hljs-keyword">var</span> nodes = [];
			NodeList.each(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, i</span>) </span>{
				<span class="hljs-keyword">if</span> (i % n === r) {
					nodes.push(node);
				}
			});

			<span class="hljs-keyword">return</span> Y.all(nodes);
		},

		<span class="hljs-comment">/**
		 * Creates a new NodeList containing all nodes at odd indices
		 * (zero-based index).
		 * @method odd
		 * @return {NodeList} NodeList containing the updated collection
		 */</span>
		odd: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.modulus(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);
		},

		<span class="hljs-comment">/**
		 * Creates a new NodeList containing all nodes at even indices
		 * (zero-based index), including zero.
		 * @method even
		 * @return {NodeList} NodeList containing the updated collection
		 */</span>
		even: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.modulus(<span class="hljs-number">2</span>);
		},

		<span class="hljs-attr">destructor</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		},

		<span class="hljs-comment">/**
		 * Reruns the initial query, when created using a selector query
		 * @method refresh
		 * @chainable
		 */</span>
		refresh: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> doc,
				nodes = <span class="hljs-keyword">this</span>._nodes,
				query = <span class="hljs-keyword">this</span>._query,
				root = <span class="hljs-keyword">this</span>._queryRoot;

			<span class="hljs-keyword">if</span> (query) {
				<span class="hljs-keyword">if</span> (!root) {
					<span class="hljs-keyword">if</span> (nodes &amp;&amp; nodes[<span class="hljs-number">0</span>] &amp;&amp; nodes[<span class="hljs-number">0</span>].ownerDocument) {
						root = nodes[<span class="hljs-number">0</span>].ownerDocument;
					}
				}

				<span class="hljs-keyword">this</span>._nodes = Y.Selector.query(query, root);
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Returns the current number of items in the NodeList.
		 * @method size
		 * @return {Int} The number of items in the NodeList.
		 */</span>
		size: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._nodes.length;
		},

		<span class="hljs-comment">/**
		 * Determines if the instance is bound to any nodes
		 * @method isEmpty
		 * @return {Boolean} Whether or not the NodeList is bound to any nodes
		 */</span>
		isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._nodes.length &lt; <span class="hljs-number">1</span>;
		},

		<span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> str = <span class="hljs-string">''</span>,
				errorMsg = <span class="hljs-keyword">this</span>[UID] + <span class="hljs-string">': not bound to any nodes'</span>,
				nodes = <span class="hljs-keyword">this</span>._nodes,
				node;

			<span class="hljs-keyword">if</span> (nodes &amp;&amp; nodes[<span class="hljs-number">0</span>]) {
				node = nodes[<span class="hljs-number">0</span>];
				str += node[NODE_NAME];
				<span class="hljs-keyword">if</span> (node.id) {
					str += <span class="hljs-string">'#'</span> + node.id;
				}

				<span class="hljs-keyword">if</span> (node.className) {
					str += <span class="hljs-string">'.'</span> + node.className.replace(<span class="hljs-string">' '</span>, <span class="hljs-string">'.'</span>);
				}

				<span class="hljs-keyword">if</span> (nodes.length &gt; <span class="hljs-number">1</span>) {
					str += <span class="hljs-string">'...['</span> + nodes.length + <span class="hljs-string">' items]'</span>;
				}
			}
			<span class="hljs-keyword">return</span> str || errorMsg;
		},

		<span class="hljs-comment">/**
		 * Returns the DOM node bound to the Node instance
		 * @method getDOMNodes
		 * @return {Array}
		 */</span>
		getDOMNodes: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._nodes;
		}
	}, <span class="hljs-literal">true</span>);

	NodeList.importMethod(Y.Node.prototype, [
	<span class="hljs-comment">/**
	 * Called on each Node instance. Nulls internal node references,
	 * removes any plugins and event listeners
	 * @method destroy
	 * @param {Boolean} [recursivePurge] Whether or not to
	 * remove listeners from the node's subtree (default is false)
	 * @see Node.destroy
	 */</span>
		<span class="hljs-string">'destroy'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance. Removes and destroys all of the nodes
	 * within the node
	 * @method empty
	 * @chainable
	 * @see Node.empty
	 */</span>
		<span class="hljs-string">'empty'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance. Removes the node from its parent.
	 * Shortcut for myNode.get('parentNode').removeChild(myNode);
	 * @method remove
	 * @param {Boolean} destroy whether or not to call destroy() on the node
	 * after removal.
	 * @chainable
	 * @see Node.remove
	 */</span>
		<span class="hljs-string">'remove'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance. Sets an attribute on the Node instance.
	 * Unless pre-configured (via Node.ATTRS), set hands
	 * off to the underlying DOM node.  Only valid
	 * attributes/properties for the node will be set.
	 * To set custom attributes use setAttribute.
	 * @method set
	 * @param {String} attr The attribute to be set.
	 * @param {any} val The value to set the attribute to.
	 * @chainable
	 * @see Node.set
	 */</span>
		<span class="hljs-string">'set'</span>
	]);</pre></div></div>
            
        </li>
        
        
        <li id="section-321">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-321">&#182;</a>
              </div>
              <p>one-off implementation to convert array of Nodes to NodeList
e.g. Y.all(‘input’).get(‘parentNode’);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-comment">/** Called on each Node instance
	 * @method get
	 * @see Node
	 */</span>
	NodeList.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
		<span class="hljs-keyword">var</span> ret = [],
			nodes = <span class="hljs-keyword">this</span>._nodes,
			isNodeList = <span class="hljs-literal">false</span>,
			getTemp = NodeList._getTempNode,
			instance,
			val;

		<span class="hljs-keyword">if</span> (nodes[<span class="hljs-number">0</span>]) {
			instance = Y.Node._instances[nodes[<span class="hljs-number">0</span>]._yuid] || getTemp(nodes[<span class="hljs-number">0</span>]);
			val = instance._get(attr);
			<span class="hljs-keyword">if</span> (val &amp;&amp; val.nodeType) {
				isNodeList = <span class="hljs-literal">true</span>;
			}
		}

		Y.Array.each(nodes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			instance = Y.Node._instances[node._yuid];

			<span class="hljs-keyword">if</span> (!instance) {
				instance = getTemp(node);
			}

			val = instance._get(attr);
			<span class="hljs-keyword">if</span> (!isNodeList) { <span class="hljs-comment">// convert array of Nodes to NodeList</span>
				val = Y.Node.scrubVal(val, instance);
			}

			ret.push(val);
		});

		<span class="hljs-keyword">return</span> (isNodeList) ? Y.all(ret) : ret;
	};

	Y.NodeList = NodeList;

	Y.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodes</span>) </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NodeList(nodes);
	};

	Y.Node.all = Y.all;
	<span class="hljs-comment">/**
	 * @module node
	 * @submodule node-core
	 */</span>

	<span class="hljs-keyword">var</span> Y_NodeList = Y.NodeList,
		ArrayProto = <span class="hljs-built_in">Array</span>.prototype,
		ArrayMethods = {
			<span class="hljs-comment">/** Returns a new NodeList combining the given NodeList(s)
			 * @for NodeList
			 * @method concat
			 * @param {NodeList | Array} valueN Arrays/NodeLists and/or values to
			 * concatenate to the resulting NodeList
			 * @return {NodeList} A new NodeList comprised of this NodeList joined with the input.
			 */</span>
			<span class="hljs-string">'concat'</span>: <span class="hljs-number">1</span>,
			<span class="hljs-comment">/** Removes the last from the NodeList and returns it.
			 * @for NodeList
			 * @method pop
			 * @return {Node} The last item in the NodeList.
			 */</span>
			<span class="hljs-string">'pop'</span>: <span class="hljs-number">0</span>,
			<span class="hljs-comment">/** Adds the given Node(s) to the end of the NodeList.
			 * @for NodeList
			 * @method push
			 * @param {Node | DOMNode} nodes One or more nodes to add to the end of the NodeList.
			 */</span>
			<span class="hljs-string">'push'</span>: <span class="hljs-number">0</span>,
			<span class="hljs-comment">/** Removes the first item from the NodeList and returns it.
			 * @for NodeList
			 * @method shift
			 * @return {Node} The first item in the NodeList.
			 */</span>
			<span class="hljs-string">'shift'</span>: <span class="hljs-number">0</span>,
			<span class="hljs-comment">/** Returns a new NodeList comprising the Nodes in the given range.
			 * @for NodeList
			 * @method slice
			 * @param {Number} begin Zero-based index at which to begin extraction.
			 As a negative index, start indicates an offset from the end of the sequence. slice(-2) extracts the second-to-last element and the last element in the sequence.
			 * @param {Number} end Zero-based index at which to end extraction. slice extracts up to but not including end.
			 slice(1,4) extracts the second element through the fourth element (elements indexed 1, 2, and 3).
			 As a negative index, end indicates an offset from the end of the sequence. slice(2,-1) extracts the third element through the second-to-last element in the sequence.
			 If end is omitted, slice extracts to the end of the sequence.
			 * @return {NodeList} A new NodeList comprised of this NodeList joined with the input.
			 */</span>
			<span class="hljs-string">'slice'</span>: <span class="hljs-number">1</span>,
			<span class="hljs-comment">/** Changes the content of the NodeList, adding new elements while removing old elements.
			 * @for NodeList
			 * @method splice
			 * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
			 * @param {Number} howMany An integer indicating the number of old array elements to remove. If howMany is 0, no elements are removed. In this case, you should specify at least one new element. If no howMany parameter is specified (second syntax above, which is a SpiderMonkey extension), all elements after index are removed.
			 * {Node | DOMNode| element1, ..., elementN
			 The elements to add to the array. If you don't specify any elements, splice simply removes elements from the array.
			 * @return {NodeList} The element(s) removed.
			 */</span>
			<span class="hljs-string">'splice'</span>: <span class="hljs-number">1</span>,
			<span class="hljs-comment">/** Adds the given Node(s) to the beginning of the NodeList.
			 * @for NodeList
			 * @method unshift
			 * @param {Node | DOMNode} nodes One or more nodes to add to the NodeList.
			 */</span>
			<span class="hljs-string">'unshift'</span>: <span class="hljs-number">0</span>
		};


	Y.Object.each(ArrayMethods, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">returnNodeList, name</span>) </span>{
		Y_NodeList.prototype[name] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> args = [],
				i = <span class="hljs-number">0</span>,
				arg,
				ret;

			<span class="hljs-keyword">while</span> (<span class="hljs-keyword">typeof</span> (arg = <span class="hljs-built_in">arguments</span>[i++]) != <span class="hljs-string">'undefined'</span>) { <span class="hljs-comment">// use DOM nodes/nodeLists</span>
				args.push(arg._node || arg._nodes || arg);
			}

			ret = ArrayProto[name].apply(<span class="hljs-keyword">this</span>._nodes, args);

			<span class="hljs-keyword">if</span> (returnNodeList) {
				ret = Y.all(ret);
			} <span class="hljs-keyword">else</span> {
				ret = Y.Node.scrubVal(ret);
			}

			<span class="hljs-keyword">return</span> ret;
		};
	});
	<span class="hljs-comment">/**
	 * @module node
	 * @submodule node-core
	 */</span>

	Y.Array.each([
	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @for Node
	 * @method removeChild
	 * @param {HTMLElement | Node} node Node to be removed
	 * @return {Node} The removed node
	 */</span>
		<span class="hljs-string">'removeChild'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @method hasChildNodes
	 * @return {Boolean} Whether or not the node has any childNodes
	 */</span>
		<span class="hljs-string">'hasChildNodes'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @method cloneNode
	 * @param {Boolean} deep Whether or not to perform a deep clone, which includes
	 * subtree and attributes
	 * @return {Node} The clone
	 */</span>
		<span class="hljs-string">'cloneNode'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @method hasAttribute
	 * @param {String} attribute The attribute to test for
	 * @return {Boolean} Whether or not the attribute is present
	 */</span>
		<span class="hljs-string">'hasAttribute'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @method scrollIntoView
	 * @chainable
	 */</span>
		<span class="hljs-string">'scrollIntoView'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @method getElementsByTagName
	 * @param {String} tagName The tagName to collect
	 * @return {NodeList} A NodeList representing the HTMLCollection
	 */</span>
		<span class="hljs-string">'getElementsByTagName'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @method focus
	 * @chainable
	 */</span>
		<span class="hljs-string">'focus'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @method blur
	 * @chainable
	 */</span>
		<span class="hljs-string">'blur'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * Only valid on FORM elements
	 * @method submit
	 * @chainable
	 */</span>
		<span class="hljs-string">'submit'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * Only valid on FORM elements
	 * @method reset
	 * @chainable
	 */</span>
		<span class="hljs-string">'reset'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @method select
	 * @chainable
	 */</span>
		<span class="hljs-string">'select'</span>,

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * Only valid on TABLE elements
	 * @method createCaption
	 * @chainable
	 */</span>
		<span class="hljs-string">'createCaption'</span>

	], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">method</span>) </span>{
		Y.Node.prototype[method] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2, arg3</span>) </span>{
			<span class="hljs-keyword">var</span> ret = <span class="hljs-keyword">this</span>.invoke(method, arg1, arg2, arg3);
			<span class="hljs-keyword">return</span> ret;
		};
	});

	<span class="hljs-comment">/**
	 * Passes through to DOM method.
	 * @method removeAttribute
	 * @param {String} attribute The attribute to be removed
	 * @chainable
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-322">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-322">&#182;</a>
              </div>
              <p>one-off implementation due to IE returning boolean, breaking chaining</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	Y.Node.prototype.removeAttribute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
		<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node;
		<span class="hljs-keyword">if</span> (node) {
			node.removeAttribute(attr, <span class="hljs-number">0</span>); <span class="hljs-comment">// comma zero for IE &lt; 8 to force case-insensitive</span>
		}

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	};

	Y.Node.importMethod(Y.DOM, [
	<span class="hljs-comment">/**
	 * Determines whether the node is an ancestor of another HTML element in the DOM hierarchy.
	 * @method contains
	 * @param {Node | HTMLElement} needle The possible node or descendent
	 * @return {Boolean} Whether or not this node is the needle its ancestor
	 */</span>
		<span class="hljs-string">'contains'</span>,
	<span class="hljs-comment">/**
	 * Allows setting attributes on DOM nodes, normalizing in some cases.
	 * This passes through to the DOM node, allowing for custom attributes.
	 * @method setAttribute
	 * @for Node
	 * @chainable
	 * @param {string} name The attribute name
	 * @param {string} value The value to set
	 */</span>
		<span class="hljs-string">'setAttribute'</span>,
	<span class="hljs-comment">/**
	 * Allows getting attributes on DOM nodes, normalizing in some cases.
	 * This passes through to the DOM node, allowing for custom attributes.
	 * @method getAttribute
	 * @for Node
	 * @param {string} name The attribute name
	 * @return {string} The attribute value
	 */</span>
		<span class="hljs-string">'getAttribute'</span>,

	<span class="hljs-comment">/**
	 * Wraps the given HTML around the node.
	 * @method wrap
	 * @param {String} html The markup to wrap around the node.
	 * @chainable
	 * @for Node
	 */</span>
		<span class="hljs-string">'wrap'</span>,

	<span class="hljs-comment">/**
	 * Removes the node's parent node.
	 * @method unwrap
	 * @chainable
	 */</span>
		<span class="hljs-string">'unwrap'</span>,

	<span class="hljs-comment">/**
	 * Applies a unique ID to the node if none exists
	 * @method generateID
	 * @return {String} The existing or generated ID
	 */</span>
		<span class="hljs-string">'generateID'</span>
	]);

	Y.NodeList.importMethod(Y.Node.prototype, [
	<span class="hljs-comment">/**
	 * Allows getting attributes on DOM nodes, normalizing in some cases.
	 * This passes through to the DOM node, allowing for custom attributes.
	 * @method getAttribute
	 * @see Node
	 * @for NodeList
	 * @param {string} name The attribute name
	 * @return {string} The attribute value
	 */</span>

		<span class="hljs-string">'getAttribute'</span>,
	<span class="hljs-comment">/**
	 * Allows setting attributes on DOM nodes, normalizing in some cases.
	 * This passes through to the DOM node, allowing for custom attributes.
	 * @method setAttribute
	 * @see Node
	 * @for NodeList
	 * @chainable
	 * @param {string} name The attribute name
	 * @param {string} value The value to set
	 */</span>
		<span class="hljs-string">'setAttribute'</span>,

	<span class="hljs-comment">/**
	 * Allows for removing attributes on DOM nodes.
	 * This passes through to the DOM node, allowing for custom attributes.
	 * @method removeAttribute
	 * @see Node
	 * @for NodeList
	 * @param {string} name The attribute to remove
	 */</span>
		<span class="hljs-string">'removeAttribute'</span>,
	<span class="hljs-comment">/**
	 * Removes the parent node from node in the list.
	 * @method unwrap
	 * @chainable
	 */</span>
		<span class="hljs-string">'unwrap'</span>,
	<span class="hljs-comment">/**
	 * Wraps the given HTML around each node.
	 * @method wrap
	 * @param {String} html The markup to wrap around the node.
	 * @chainable
	 */</span>
		<span class="hljs-string">'wrap'</span>,

	<span class="hljs-comment">/**
	 * Applies a unique ID to each node if none exists
	 * @method generateID
	 * @return {String} The existing or generated ID
	 */</span>
		<span class="hljs-string">'generateID'</span>
	]);


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"dom-core"</span>, <span class="hljs-string">"selector"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'node-base'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * @module node
	 * @submodule node-base
	 */</span>

	<span class="hljs-keyword">var</span> methods = [
	<span class="hljs-comment">/**
	 * Determines whether each node has the given className.
	 * @method hasClass
	 * @for Node
	 * @param {String} className the class name to search for
	 * @return {Boolean} Whether or not the element has the specified class
	 */</span>
		<span class="hljs-string">'hasClass'</span>,

	<span class="hljs-comment">/**
	 * Adds a class name to each node.
	 * @method addClass
	 * @param {String} className the class name to add to the node's class attribute
	 * @chainable
	 */</span>
		<span class="hljs-string">'addClass'</span>,

	<span class="hljs-comment">/**
	 * Removes a class name from each node.
	 * @method removeClass
	 * @param {String} className the class name to remove from the node's class attribute
	 * @chainable
	 */</span>
		<span class="hljs-string">'removeClass'</span>,

	<span class="hljs-comment">/**
	 * Replace a class with another class for each node.
	 * If no oldClassName is present, the newClassName is simply added.
	 * @method replaceClass
	 * @param {String} oldClassName the class name to be replaced
	 * @param {String} newClassName the class name that will be replacing the old class name
	 * @chainable
	 */</span>
		<span class="hljs-string">'replaceClass'</span>,

	<span class="hljs-comment">/**
	 * If the className exists on the node it is removed, if it doesn't exist it is added.
	 * @method toggleClass
	 * @param {String} className the class name to be toggled
	 * @param {Boolean} force Option to force adding or removing the class.
	 * @chainable
	 */</span>
		<span class="hljs-string">'toggleClass'</span>
	];

	Y.Node.importMethod(Y.DOM, methods);
	<span class="hljs-comment">/**
	 * Determines whether each node has the given className.
	 * @method hasClass
	 * @see Node.hasClass
	 * @for NodeList
	 * @param {String} className the class name to search for
	 * @return {Array} An array of booleans for each node bound to the NodeList.
	 */</span>

	<span class="hljs-comment">/**
	 * Adds a class name to each node.
	 * @method addClass
	 * @see Node.addClass
	 * @param {String} className the class name to add to the node's class attribute
	 * @chainable
	 */</span>

	<span class="hljs-comment">/**
	 * Removes a class name from each node.
	 * @method removeClass
	 * @see Node.removeClass
	 * @param {String} className the class name to remove from the node's class attribute
	 * @chainable
	 */</span>

	<span class="hljs-comment">/**
	 * Replace a class with another class for each node.
	 * If no oldClassName is present, the newClassName is simply added.
	 * @method replaceClass
	 * @see Node.replaceClass
	 * @param {String} oldClassName the class name to be replaced
	 * @param {String} newClassName the class name that will be replacing the old class name
	 * @chainable
	 */</span>

	<span class="hljs-comment">/**
	 * If the className exists on the node it is removed, if it doesn't exist it is added.
	 * @method toggleClass
	 * @see Node.toggleClass
	 * @param {String} className the class name to be toggled
	 * @chainable
	 */</span>
	Y.NodeList.importMethod(Y.Node.prototype, methods);
	<span class="hljs-comment">/**
	 * @module node
	 * @submodule node-base
	 */</span>

	<span class="hljs-keyword">var</span> Y_Node = Y.Node,
		Y_DOM = Y.DOM;

	<span class="hljs-comment">/**
	 * Returns a new dom node using the provided markup string.
	 * @method create
	 * @static
	 * @param {String} html The markup used to create the element
	 * Use &lt;a href="../classes/Escape.html#method_html"&gt;`Y.Escape.html()`&lt;/a&gt;
	 * to escape html content.
	 * @param {HTMLDocument} doc An optional document context
	 * @return {Node} A Node instance bound to a DOM node or fragment
	 * @for Node
	 */</span>
	Y_Node.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html, doc</span>) </span>{
		<span class="hljs-keyword">if</span> (doc &amp;&amp; doc._node) {
			doc = doc._node;
		}
		<span class="hljs-keyword">return</span> Y.one(Y_DOM.create(html, doc));
	};

	Y.mix(Y_Node.prototype, {
		<span class="hljs-comment">/**
		 * Creates a new Node using the provided markup string.
		 * @method create
		 * @param {String} html The markup used to create the element.
		 * Use &lt;a href="../classes/Escape.html#method_html"&gt;`Y.Escape.html()`&lt;/a&gt;
		 * to escape html content.
		 * @param {HTMLDocument} doc An optional document context
		 * @return {Node} A Node instance bound to a DOM node or fragment
		 */</span>
		create: Y_Node.create,

		<span class="hljs-comment">/**
		 * Inserts the content before the reference node.
		 * @method insert
		 * @param {String | Node | HTMLElement | NodeList | HTMLCollection} content The content to insert
		 * Use &lt;a href="../classes/Escape.html#method_html"&gt;`Y.Escape.html()`&lt;/a&gt;
		 * to escape html content.
		 * @param {Int | Node | HTMLElement | String} where The position to insert at.
		 * Possible "where" arguments
		 * &lt;dl&gt;
		 * &lt;dt&gt;Y.Node&lt;/dt&gt;
		 * &lt;dd&gt;The Node to insert before&lt;/dd&gt;
		 * &lt;dt&gt;HTMLElement&lt;/dt&gt;
		 * &lt;dd&gt;The element to insert before&lt;/dd&gt;
		 * &lt;dt&gt;Int&lt;/dt&gt;
		 * &lt;dd&gt;The index of the child element to insert before&lt;/dd&gt;
		 * &lt;dt&gt;"replace"&lt;/dt&gt;
		 * &lt;dd&gt;Replaces the existing HTML&lt;/dd&gt;
		 * &lt;dt&gt;"before"&lt;/dt&gt;
		 * &lt;dd&gt;Inserts before the existing HTML&lt;/dd&gt;
		 * &lt;dt&gt;"before"&lt;/dt&gt;
		 * &lt;dd&gt;Inserts content before the node&lt;/dd&gt;
		 * &lt;dt&gt;"after"&lt;/dt&gt;
		 * &lt;dd&gt;Inserts content after the node&lt;/dd&gt;
		 * &lt;/dl&gt;
		 * @chainable
		 */</span>
		insert: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content, where</span>) </span>{
			<span class="hljs-keyword">this</span>._insert(content, where);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-attr">_insert</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content, where</span>) </span>{
			<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node,
				ret = <span class="hljs-literal">null</span>;

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> where == <span class="hljs-string">'number'</span>) { <span class="hljs-comment">// allow index</span>
				where = <span class="hljs-keyword">this</span>._node.childNodes[where];
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (where &amp;&amp; where._node) { <span class="hljs-comment">// Node</span>
				where = where._node;
			}

			<span class="hljs-keyword">if</span> (content &amp;&amp; <span class="hljs-keyword">typeof</span> content != <span class="hljs-string">'string'</span>) { <span class="hljs-comment">// allow Node or NodeList/Array instances</span>
				content = content._node || content._nodes || content;
			}
			ret = Y_DOM.addHTML(node, content, where);

			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-comment">/**
		 * Inserts the content as the firstChild of the node.
		 * @method prepend
		 * @param {String | Node | HTMLElement} content The content to insert
		 * Use &lt;a href="../classes/Escape.html#method_html"&gt;`Y.Escape.html()`&lt;/a&gt;
		 * to escape html content.
		 * @chainable
		 */</span>
		prepend: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.insert(content, <span class="hljs-number">0</span>);
		},

		<span class="hljs-comment">/**
		 * Inserts the content as the lastChild of the node.
		 * @method append
		 * @param {String | Node | HTMLElement} content The content to insert
		 * Use &lt;a href="../classes/Escape.html#method_html"&gt;`Y.Escape.html()`&lt;/a&gt;
		 * to escape html content.
		 * @chainable
		 */</span>
		append: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.insert(content, <span class="hljs-literal">null</span>);
		},

		<span class="hljs-comment">/**
		 * @method appendChild
		 * @param {String | HTMLElement | Node} node Node to be appended
		 * Use &lt;a href="../classes/Escape.html#method_html"&gt;`Y.Escape.html()`&lt;/a&gt;
		 * to escape html content.
		 * @return {Node} The appended node
		 */</span>
		appendChild: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			<span class="hljs-keyword">return</span> Y_Node.scrubVal(<span class="hljs-keyword">this</span>._insert(node));
		},

		<span class="hljs-comment">/**
		 * @method insertBefore
		 * @param {String | HTMLElement | Node} newNode Node to be appended
		 * @param {HTMLElement | Node} refNode Node to be inserted before
		 * Use &lt;a href="../classes/Escape.html#method_html"&gt;`Y.Escape.html()`&lt;/a&gt;
		 * to escape html content.
		 * @return {Node} The inserted node
		 */</span>
		insertBefore: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newNode, refNode</span>) </span>{
			<span class="hljs-keyword">return</span> Y.Node.scrubVal(<span class="hljs-keyword">this</span>._insert(newNode, refNode));
		},

		<span class="hljs-comment">/**
		 * Appends the node to the given node.
		 * @method appendTo
		 * @param {Node | HTMLElement} node The node to append to
		 * @chainable
		 */</span>
		appendTo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			Y.one(node).append(<span class="hljs-keyword">this</span>);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Replaces the node's current content with the content.
		 * Note that this passes to innerHTML and is not escaped.
		 * Use &lt;a href="../classes/Escape.html#method_html"&gt;`Y.Escape.html()`&lt;/a&gt;
		 * to escape html content or `set('text')` to add as text.
		 * @method setContent
		 * @deprecated Use setHTML
		 * @param {String | Node | HTMLElement | NodeList | HTMLCollection} content The content to insert
		 * @chainable
		 */</span>
		setContent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>) </span>{
			<span class="hljs-keyword">this</span>._insert(content, <span class="hljs-string">'replace'</span>);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Returns the node's current content (e.g. innerHTML)
		 * @method getContent
		 * @deprecated Use getHTML
		 * @return {String} The current content
		 */</span>
		getContent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'innerHTML'</span>);
		}
	});

	<span class="hljs-comment">/**
	 * Replaces the node's current html content with the content provided.
	 * Note that this passes to innerHTML and is not escaped.
	 * Use `Y.Escape.html()` to escape HTML, or `set('text')` to add as text.
	 * @method setHTML
	 * @param {String | HTML | Node | HTMLElement | NodeList | HTMLCollection} content The content to insert
	 * @chainable
	 */</span>
	Y.Node.prototype.setHTML = Y.Node.prototype.setContent;

	<span class="hljs-comment">/**
	 * Returns the node's current html content (e.g. innerHTML)
	 * @method getHTML
	 * @return {String} The html content
	 */</span>
	Y.Node.prototype.getHTML = Y.Node.prototype.getContent;

	Y.NodeList.importMethod(Y.Node.prototype, [
	<span class="hljs-comment">/**
	 * Called on each Node instance
	 * @for NodeList
	 * @method append
	 * @see Node.append
	 */</span>
		<span class="hljs-string">'append'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance
	 * @for NodeList
	 * @method insert
	 * @see Node.insert
	 */</span>
		<span class="hljs-string">'insert'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance
	 * @for NodeList
	 * @method appendChild
	 * @see Node.appendChild
	 */</span>
		<span class="hljs-string">'appendChild'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance
	 * @for NodeList
	 * @method insertBefore
	 * @see Node.insertBefore
	 */</span>
		<span class="hljs-string">'insertBefore'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance
	 * @for NodeList
	 * @method prepend
	 * @see Node.prepend
	 */</span>
		<span class="hljs-string">'prepend'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance
	 * Note that this passes to innerHTML and is not escaped.
	 * Use `Y.Escape.html()` to escape HTML, or `set('text')` to add as text.
	 * @for NodeList
	 * @method setContent
	 * @deprecated Use setHTML
	 */</span>
		<span class="hljs-string">'setContent'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance
	 * @for NodeList
	 * @method getContent
	 * @deprecated Use getHTML
	 */</span>
		<span class="hljs-string">'getContent'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance
	 * Note that this passes to innerHTML and is not escaped.
	 * Use `Y.Escape.html()` to escape HTML, or `set('text')` to add as text.
	 * @for NodeList
	 * @method setHTML
	 * @see Node.setHTML
	 */</span>
		<span class="hljs-string">'setHTML'</span>,

	<span class="hljs-comment">/**
	 * Called on each Node instance
	 * @for NodeList
	 * @method getHTML
	 * @see Node.getHTML
	 */</span>
		<span class="hljs-string">'getHTML'</span>
	]);
	<span class="hljs-comment">/**
	 * @module node
	 * @submodule node-base
	 */</span>

	<span class="hljs-keyword">var</span> Y_Node = Y.Node,
		Y_DOM = Y.DOM;

	<span class="hljs-comment">/**
	 * Static collection of configuration attributes for special handling
	 * @property ATTRS
	 * @static
	 * @type object
	 */</span>
	Y_Node.ATTRS = {
		<span class="hljs-comment">/**
		 * Allows for getting and setting the text of an element.
		 * Formatting is preserved and special characters are treated literally.
		 * @config text
		 * @type String
		 */</span>
		text: {
			<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.getText(<span class="hljs-keyword">this</span>._node);
			},

			<span class="hljs-attr">setter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>) </span>{
				Y_DOM.setText(<span class="hljs-keyword">this</span>._node, content);
				<span class="hljs-keyword">return</span> content;
			}
		},

		<span class="hljs-comment">/**
		 * Allows for getting and setting the text of an element.
		 * Formatting is preserved and special characters are treated literally.
		 * @config for
		 * @type String
		 */</span>
		<span class="hljs-string">'for'</span>: {
			<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.getAttribute(<span class="hljs-keyword">this</span>._node, <span class="hljs-string">'for'</span>);
			},

			<span class="hljs-attr">setter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
				Y_DOM.setAttribute(<span class="hljs-keyword">this</span>._node, <span class="hljs-string">'for'</span>, val);
				<span class="hljs-keyword">return</span> val;
			}
		},

		<span class="hljs-string">'options'</span>: {
			<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._node.getElementsByTagName(<span class="hljs-string">'option'</span>);
			}
		},

		<span class="hljs-comment">/**
		 * Returns a NodeList instance of all HTMLElement children.
		 * @readOnly
		 * @config children
		 * @type NodeList
		 */</span>
		<span class="hljs-string">'children'</span>: {
			<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._node,
					children = node.children,
					childNodes, i, len;

				<span class="hljs-keyword">if</span> (!children) {
					childNodes = node.childNodes;
					children = [];

					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = childNodes.length; i &lt; len; ++i) {
						<span class="hljs-keyword">if</span> (childNodes[i].tagName) {
							children[children.length] = childNodes[i];
						}
					}
				}
				<span class="hljs-keyword">return</span> Y.all(children);
			}
		},

		<span class="hljs-attr">value</span>: {
			<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.getValue(<span class="hljs-keyword">this</span>._node);
			},

			<span class="hljs-attr">setter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
				Y_DOM.setValue(<span class="hljs-keyword">this</span>._node, val);
				<span class="hljs-keyword">return</span> val;
			}
		}
	};

	Y.Node.importMethod(Y.DOM, [
	<span class="hljs-comment">/**
	 * Allows setting attributes on DOM nodes, normalizing in some cases.
	 * This passes through to the DOM node, allowing for custom attributes.
	 * @method setAttribute
	 * @for Node
	 * @for NodeList
	 * @chainable
	 * @param {string} name The attribute name
	 * @param {string} value The value to set
	 */</span>
		<span class="hljs-string">'setAttribute'</span>,
	<span class="hljs-comment">/**
	 * Allows getting attributes on DOM nodes, normalizing in some cases.
	 * This passes through to the DOM node, allowing for custom attributes.
	 * @method getAttribute
	 * @for Node
	 * @for NodeList
	 * @param {string} name The attribute name
	 * @return {string} The attribute value
	 */</span>
		<span class="hljs-string">'getAttribute'</span>

	]);
	<span class="hljs-comment">/**
	 * @module node
	 * @submodule node-base
	 */</span>

	<span class="hljs-keyword">var</span> Y_Node = Y.Node;
	<span class="hljs-keyword">var</span> Y_NodeList = Y.NodeList;
	<span class="hljs-comment">/**
	 * List of events that route to DOM events
	 * @static
	 * @property DOM_EVENTS
	 * @for Node
	 */</span>

	Y_Node.DOM_EVENTS = {
		<span class="hljs-attr">abort</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">beforeunload</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">blur</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">change</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">click</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">close</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">command</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">contextmenu</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">dblclick</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">DOMMouseScroll</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">drag</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">dragstart</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">dragenter</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">dragover</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">dragleave</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">dragend</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">drop</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">error</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">focus</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">key</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">keydown</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">keypress</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">keyup</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">load</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">message</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">mousedown</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">mouseenter</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">mouseleave</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">mousemove</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">mousemultiwheel</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">mouseout</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">mouseover</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">mouseup</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">mousewheel</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">orientationchange</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">reset</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">resize</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">select</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">selectstart</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">submit</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">scroll</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">textInput</span>: <span class="hljs-number">1</span>,
		<span class="hljs-attr">unload</span>: <span class="hljs-number">1</span>
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-323">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-323">&#182;</a>
              </div>
              <p>Add custom event adaptors to this list.  This will make it so
that delegate, key, available, contentready, etc all will
be available through Node.on</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	Y.mix(Y_Node.DOM_EVENTS, Y.Env.evt.plugins);

	Y.augment(Y_Node, Y.EventTarget);

	Y.mix(Y_Node.prototype, {
		<span class="hljs-comment">/**
		 * Removes event listeners from the node and (optionally) its subtree
		 * @method purge
		 * @param {Boolean} [recurse] Whether or not to remove listeners from the
		 * node's subtree
		 * @param {String} [type] Only remove listeners of the specified type
		 * @chainable
		 *
		 */</span>
		purge: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">recurse, type</span>) </span>{
			Y.Event.purgeElement(<span class="hljs-keyword">this</span>._node, recurse, type);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		}

	});

	Y.mix(Y.NodeList.prototype, {
		<span class="hljs-attr">_prepEvtArgs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, fn, context</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-324">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-324">&#182;</a>
              </div>
              <p>map to Y.on/after signature (type, fn, nodes, context, arg1, arg2, etc)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> args = Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);

			<span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">2</span>) { <span class="hljs-comment">// type only (event hash) just add nodes</span>
				args[<span class="hljs-number">2</span>] = <span class="hljs-keyword">this</span>._nodes;
			} <span class="hljs-keyword">else</span> {
				args.splice(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>._nodes);
			}

			args[<span class="hljs-number">3</span>] = context || <span class="hljs-keyword">this</span>; <span class="hljs-comment">// default to NodeList instance as context</span>

			<span class="hljs-keyword">return</span> args;
		},

		<span class="hljs-comment">/**
		 Subscribe a callback function for each `Node` in the collection to execute
		 in response to a DOM event.

		 <span class="hljs-doctag">NOTE:</span> Generally, the `on()` method should be avoided on `NodeLists`, in
		 favor of using event delegation from a parent Node.  See the Event user
		 guide for details.

		 Most DOM events are associated with a preventable default behavior, such as
		 link clicks navigating to a new page.  Callbacks are passed a
		 `DOMEventFacade` object as their first argument (usually called `e`) that
		 can be used to prevent this default behavior with `e.preventDefault()`. See
		 the `DOMEventFacade` API for all available properties and methods on the
		 object.

		 By default, the `this` object will be the `NodeList` that the subscription
		 came from, &lt;em&gt;not the `Node` that received the event&lt;/em&gt;.  Use
		 `e.currentTarget` to refer to the `Node`.

		 Returning `false` from a callback is supported as an alternative to calling
		 `e.preventDefault(); e.stopPropagation();`.  However, it is recommended to
		 use the event methods.

		 @example

		 Y.all(".sku").on("keydown", function (e) {
		 if (e.keyCode === 13) {
		 e.preventDefault();

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-325">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-325">&#182;</a>
              </div>
              <p>Use e.currentTarget to refer to the individual Node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 <span class="hljs-keyword">var</span> item = Y.MyApp.searchInventory( e.currentTarget.get(<span class="hljs-string">'value'</span>) );</pre></div></div>
            
        </li>
        
        
        <li id="section-326">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-326">&#182;</a>
              </div>
              <p>etc …</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		 }
		 });

		 @method on
		 @param {String} type The name of the event
		 @param {Function} fn The callback to execute in response to the event
		 @param {Object} [context] Override `this` object in callback
		 @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
		 @return {EventHandle} A subscription handle capable of detaching that
		 subscription
		 @for NodeList
		 **/
		on: function(type, fn, context) {
			return Y.on.apply(Y, this._prepEvtArgs.apply(this, arguments));
		},

		/**
		 * Applies an one-time event listener to each Node bound to the NodeList.
		 * @method once
		 * @param {String} type The event being listened for
		 * @param {Function} fn The handler to call when the event fires
		 * @param {Object} context The context to call the handler with.
		 * Default is the NodeList instance.
		 * @return {EventHandle} A subscription handle capable of detaching that
		 *                    subscription
		 * @for NodeList
		 */
		once: function(type, fn, context) {
			return Y.once.apply(Y, this._prepEvtArgs.apply(this, arguments));
		},

		/**
		 * Applies an event listener to each Node bound to the NodeList.
		 * The handler is called only after all on() handlers are called
		 * and the event is not prevented.
		 * @method after
		 * @param {String} type The event being listened for
		 * @param {Function} fn The handler to call when the event fires
		 * @param {Object} context The context to call the handler with.
		 * Default is the NodeList instance.
		 * @return {EventHandle} A subscription handle capable of detaching that
		 *                    subscription
		 * @for NodeList
		 */
		after: function(type, fn, context) {
			return Y.after.apply(Y, this._prepEvtArgs.apply(this, arguments));
		},

		/**
		 * Applies an one-time event listener to each Node bound to the NodeList
		 * that will be called only after all on() handlers are called and the
		 * event is not prevented.
		 *
		 * @method onceAfter
		 * @param {String} type The event being listened for
		 * @param {Function} fn The handler to call when the event fires
		 * @param {Object} context The context to call the handler with.
		 * Default is the NodeList instance.
		 * @return {EventHandle} A subscription handle capable of detaching that
		 *                    subscription
		 * @for NodeList
		 */
		onceAfter: function(type, fn, context) {
			return Y.onceAfter.apply(Y, this._prepEvtArgs.apply(this, arguments));
		}
	});

	Y_NodeList.importMethod(Y.Node.prototype, [
	/**
	 * Called on each Node instance
	 * @method detach
	 * @see Node.detach
	 * @for NodeList
	 */
		'detach',

	/** Called on each Node instance
	 * @method detachAll
	 * @see Node.detachAll
	 * @for NodeList
	 */
		'detachAll'
	]);

	/**
	 Subscribe a callback function to execute in response to a DOM event or custom
	 event.

	 Most DOM events are associated with a preventable default behavior such as
	 link clicks navigating to a new page.  Callbacks are passed a `DOMEventFacade`
	 object as their first argument (usually called `e`) that can be used to
	 prevent this default behavior with `e.preventDefault()`. See the
	 `DOMEventFacade` API for all available properties and methods on the object.

	 If the event name passed as the first parameter is not a whitelisted DOM event,
	 it will be treated as a custom event subscriptions, allowing
	 `node.fire('customEventName')` later in the code.  Refer to the Event user guide
	 for the full DOM event whitelist.

	 By default, the `this` object in the callback will refer to the subscribed
	 `Node`.

	 Returning `false` from a callback is supported as an alternative to calling
	 `e.preventDefault(); e.stopPropagation();`.  However, it is recommended to use
	 the event methods.

	 @example

	 Y.one("#my-form").on("submit", function (e) {
	 e.preventDefault();</pre></div></div>
            
        </li>
        
        
        <li id="section-327">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-327">&#182;</a>
              </div>
              <p>proceed with ajax form submission instead…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	 });

	 @method on
	 @param {String} type The name of the event
	 @param {Function} fn The callback to execute in response to the event
	 @param {Object} [context] Override `this` object in callback
	 @param {Any} [arg*] 0..n additional arguments to supply to the subscriber
	 @return {EventHandle} A subscription handle capable of detaching that
	 subscription
	 @for Node
	 **/

	Y.mix(Y.Node.ATTRS, {
		offsetHeight: {
			setter: function(h) {
				Y.DOM.setHeight(this._node, h);
				return h;
			},

			getter: function() {
				return this._node.offsetHeight;
			}
		},

		offsetWidth: {
			setter: function(w) {
				Y.DOM.setWidth(this._node, w);
				return w;
			},

			getter: function() {
				return this._node.offsetWidth;
			}
		}
	});

	Y.mix(Y.Node.prototype, {
		sizeTo: function(w, h) {
			var node;
			if (arguments.length &lt; 2) {
				node = Y.one(w);
				w = node.get('offsetWidth');
				h = node.get('offsetHeight');
			}

			this.setAttrs({
				offsetWidth: w,
				offsetHeight: h
			});
		}
	});
	/**
	 * @module node
	 * @submodule node-base
	 */

	var Y_Node = Y.Node;

	Y.mix(Y_Node.prototype, {
		/**
		 * Makes the node visible.
		 * If the "transition" module is loaded, show optionally
		 * animates the showing of the node using either the default
		 * transition effect ('fadeIn'), or the given named effect.
		 * @method show
		 * @for Node
		 * @param {String} name A named Transition effect to use as the show effect.
		 * @param {Object} config Options to use with the transition.
		 * @param {Function} callback An optional function to run after the transition completes.
		 * @chainable
		 */
		show: function(callback) {
			callback = arguments[arguments.length - 1];
			this.toggleView(true, callback);
			return this;
		},

		/**
		 * The implementation for showing nodes.
		 * Default is to toggle the style.display property.
		 * @method _show
		 * @protected
		 * @chainable
		 */
		_show: function() {
			this.setStyle('display', '');

		},

		_isHidden: function() {
			return Y.DOM.getStyle(this._node, 'display') === 'none';
		},

		/**
		 * Displays or hides the node.
		 * If the "transition" module is loaded, toggleView optionally
		 * animates the toggling of the node using either the default
		 * transition effect ('fadeIn'), or the given named effect.
		 * @method toggleView
		 * @for Node
		 * @param {Boolean} [on] An optional boolean value to force the node to be shown or hidden
		 * @param {Function} [callback] An optional function to run after the transition completes.
		 * @chainable
		 */
		toggleView: function(on, callback) {
			this._toggleView.apply(this, arguments);
			return this;
		},

		_toggleView: function(on, callback) {
			callback = arguments[arguments.length - 1];</pre></div></div>
            
        </li>
        
        
        <li id="section-328">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-328">&#182;</a>
              </div>
              <p>base on current state if not forcing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> on != <span class="hljs-string">'boolean'</span>) {
				on = (<span class="hljs-keyword">this</span>._isHidden()) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
			}

			<span class="hljs-keyword">if</span> (on) {
				<span class="hljs-keyword">this</span>._show();
			}  <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">this</span>._hide();
			}

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback == <span class="hljs-string">'function'</span>) {
				callback.call(<span class="hljs-keyword">this</span>);
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Hides the node.
		 * If the "transition" module is loaded, hide optionally
		 * animates the hiding of the node using either the default
		 * transition effect ('fadeOut'), or the given named effect.
		 * @method hide
		 * @param {String} name A named Transition effect to use as the show effect.
		 * @param {Object} config Options to use with the transition.
		 * @param {Function} callback An optional function to run after the transition completes.
		 * @chainable
		 */</span>
		hide: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
			callback = <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>];
			<span class="hljs-keyword">this</span>.toggleView(<span class="hljs-literal">false</span>, callback);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * The implementation for hiding nodes.
		 * Default is to toggle the style.display property.
		 * @method _hide
		 * @protected
		 * @chainable
		 */</span>
		_hide: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">this</span>.setStyle(<span class="hljs-string">'display'</span>, <span class="hljs-string">'none'</span>);
		}
	});

	Y.NodeList.importMethod(Y.Node.prototype, [
	<span class="hljs-comment">/**
	 * Makes each node visible.
	 * If the "transition" module is loaded, show optionally
	 * animates the showing of the node using either the default
	 * transition effect ('fadeIn'), or the given named effect.
	 * @method show
	 * @param {String} name A named Transition effect to use as the show effect.
	 * @param {Object} config Options to use with the transition.
	 * @param {Function} callback An optional function to run after the transition completes.
	 * @for NodeList
	 * @chainable
	 */</span>
		<span class="hljs-string">'show'</span>,

	<span class="hljs-comment">/**
	 * Hides each node.
	 * If the "transition" module is loaded, hide optionally
	 * animates the hiding of the node using either the default
	 * transition effect ('fadeOut'), or the given named effect.
	 * @method hide
	 * @param {String} name A named Transition effect to use as the show effect.
	 * @param {Object} config Options to use with the transition.
	 * @param {Function} callback An optional function to run after the transition completes.
	 * @chainable
	 */</span>
		<span class="hljs-string">'hide'</span>,

	<span class="hljs-comment">/**
	 * Displays or hides each node.
	 * If the "transition" module is loaded, toggleView optionally
	 * animates the toggling of the nodes using either the default
	 * transition effect ('fadeIn'), or the given named effect.
	 * @method toggleView
	 * @param {Boolean} [on] An optional boolean value to force the nodes to be shown or hidden
	 * @param {Function} [callback] An optional function to run after the transition completes.
	 * @chainable
	 */</span>
		<span class="hljs-string">'toggleView'</span>
	]);

	<span class="hljs-keyword">if</span> (!Y.config.doc.documentElement.hasAttribute) { <span class="hljs-comment">// IE &lt; 8</span>
		Y.Node.prototype.hasAttribute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
			<span class="hljs-keyword">if</span> (attr === <span class="hljs-string">'value'</span>) {
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'value'</span>) !== <span class="hljs-string">""</span>) { <span class="hljs-comment">// IE &lt; 8 fails to populate specified when set in HTML</span>
					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
				}
			}
			<span class="hljs-keyword">return</span> !!(<span class="hljs-keyword">this</span>._node.attributes[attr] &amp;&amp;
				<span class="hljs-keyword">this</span>._node.attributes[attr].specified);
		};
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-329">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-329">&#182;</a>
              </div>
              <p>IE throws an error when calling focus() on an element that’s invisible, not
displayed, or disabled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	Y.Node.prototype.focus = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">this</span>._node.focus();
		} <span class="hljs-keyword">catch</span> (e) {
		}

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-330">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-330">&#182;</a>
              </div>
              <p>IE throws error when setting input.type = ‘hidden’,
input.setAttribute(‘type’, ‘hidden’) and input.attributes.type.value = ‘hidden’</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	Y.Node.ATTRS.type = {
		<span class="hljs-attr">setter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
			<span class="hljs-keyword">if</span> (val === <span class="hljs-string">'hidden'</span>) {
				<span class="hljs-keyword">try</span> {
					<span class="hljs-keyword">this</span>._node.type = <span class="hljs-string">'hidden'</span>;
				} <span class="hljs-keyword">catch</span>(e) {
					<span class="hljs-keyword">this</span>.setStyle(<span class="hljs-string">'display'</span>, <span class="hljs-string">'none'</span>);
					<span class="hljs-keyword">this</span>._inputType = <span class="hljs-string">'hidden'</span>;
				}
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">try</span> { <span class="hljs-comment">// IE errors when changing the type from "hidden'</span>
					<span class="hljs-keyword">this</span>._node.type = val;
				} <span class="hljs-keyword">catch</span> (e) {
				}
			}
			<span class="hljs-keyword">return</span> val;
		},

		<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._inputType || <span class="hljs-keyword">this</span>._node.type;
		},

		<span class="hljs-attr">_bypassProxy</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// don't update DOM when using with Attribute</span>
	};

	<span class="hljs-keyword">if</span> (Y.config.doc.createElement(<span class="hljs-string">'form'</span>).elements.nodeType) {</pre></div></div>
            
        </li>
        
        
        <li id="section-331">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-331">&#182;</a>
              </div>
              <p>IE: elements collection is also FORM node which trips up scrubVal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		Y.Node.ATTRS.elements = {
			<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.all(<span class="hljs-string">'input, textarea, button, select'</span>);
			}
		};
	}

	<span class="hljs-comment">/**
	 * Provides methods for managing custom Node data.
	 *
	 * @module node
	 * @main node
	 * @submodule node-data
	 */</span>

	Y.mix(Y.Node.prototype, {
		<span class="hljs-attr">_initData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">if</span> (! (<span class="hljs-string">'_data'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>)) {
				<span class="hljs-keyword">this</span>._data = {};
			}
		},

		<span class="hljs-comment">/**
		 * @method getData
		 * @for Node
		 * @description Retrieves arbitrary data stored on a Node instance.
		 * If no data is associated with the Node, it will attempt to retrieve
		 * a value from the corresponding HTML data attribute. (e.g. node.getData('foo')
		 * will check node.getAttribute('data-foo')).
		 * @param {string} name Optional name of the data field to retrieve.
		 * If no name is given, all data is returned.
		 * @return {any | Object} Whatever is stored at the given field,
		 * or an object hash of all fields.
		 */</span>
		getData: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
			<span class="hljs-keyword">this</span>._initData();
			<span class="hljs-keyword">var</span> data = <span class="hljs-keyword">this</span>._data,
				ret = data;

			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length) { <span class="hljs-comment">// single field</span>
				<span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> data) {
					ret = data[name];
				} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// initialize from HTML attribute</span>
					ret = <span class="hljs-keyword">this</span>._getDataAttribute(name);
				}
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data == <span class="hljs-string">'object'</span> &amp;&amp; data !== <span class="hljs-literal">null</span>) { <span class="hljs-comment">// all fields</span>
				ret = {};
				Y.Object.each(data, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, n</span>) </span>{
					ret[n] = v;
				});

				ret = <span class="hljs-keyword">this</span>._getDataAttributes(ret);
			}

			<span class="hljs-keyword">return</span> ret;

		},

		<span class="hljs-attr">_getDataAttributes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>) </span>{
			ret = ret || {};
			<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
				attrs = <span class="hljs-keyword">this</span>._node.attributes,
				len = attrs.length,
				prefix = <span class="hljs-keyword">this</span>.DATA_PREFIX,
				prefixLength = prefix.length,
				name;

			<span class="hljs-keyword">while</span> (i &lt; len) {
				name = attrs[i].name;
				<span class="hljs-keyword">if</span> (name.indexOf(prefix) === <span class="hljs-number">0</span>) {
					name = name.substr(prefixLength);
					<span class="hljs-keyword">if</span> (!(name <span class="hljs-keyword">in</span> ret)) { <span class="hljs-comment">// only merge if not already stored</span>
						ret[name] = <span class="hljs-keyword">this</span>._getDataAttribute(name);
					}
				}

				i += <span class="hljs-number">1</span>;
			}

			<span class="hljs-keyword">return</span> ret;
		},

		<span class="hljs-attr">_getDataAttribute</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
			<span class="hljs-keyword">var</span> name = <span class="hljs-keyword">this</span>.DATA_PREFIX + name,
				node = <span class="hljs-keyword">this</span>._node,
				attrs = node.attributes,
				data = attrs &amp;&amp; attrs[name] &amp;&amp; attrs[name].value;

			<span class="hljs-keyword">return</span> data;
		},

		<span class="hljs-comment">/**
		 * @method setData
		 * @for Node
		 * @description Stores arbitrary data on a Node instance.
		 * This is not stored with the DOM node.
		 * @param {string} name The name of the field to set. If no val
		 * is given, name is treated as the data and overrides any existing data.
		 * @param {any} val The value to be assigned to the field.
		 * @chainable
		 */</span>
		setData: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, val</span>) </span>{
			<span class="hljs-keyword">this</span>._initData();
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>) {
				<span class="hljs-keyword">this</span>._data[name] = val;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">this</span>._data = name;
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * @method clearData
		 * @for Node
		 * @description Clears internally stored data.
		 * @param {string} name The name of the field to clear. If no name
		 * is given, all data is cleared.
		 * @chainable
		 */</span>
		clearData: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
			<span class="hljs-keyword">if</span> (<span class="hljs-string">'_data'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) {
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name != <span class="hljs-string">'undefined'</span>) {
					<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._data[name];
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._data;
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		}
	});

	Y.mix(Y.NodeList.prototype, {
		<span class="hljs-comment">/**
		 * @method getData
		 * @for NodeList
		 * @description Retrieves arbitrary data stored on each Node instance
		 * bound to the NodeList.
		 * @see Node
		 * @param {string} name Optional name of the data field to retrieve.
		 * If no name is given, all data is returned.
		 * @return {Array} An array containing all of the data for each Node instance.
		 * or an object hash of all fields.
		 */</span>
		getData: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
			<span class="hljs-keyword">var</span> args = (<span class="hljs-built_in">arguments</span>.length) ? [name] : [];
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._invoke(<span class="hljs-string">'getData'</span>, args, <span class="hljs-literal">true</span>);
		},

		<span class="hljs-comment">/**
		 * @method setData
		 * @for NodeList
		 * @description Stores arbitrary data on each Node instance bound to the
		 *  NodeList. This is not stored with the DOM node.
		 * @param {string} name The name of the field to set. If no name
		 * is given, name is treated as the data and overrides any existing data.
		 * @param {any} val The value to be assigned to the field.
		 * @chainable
		 */</span>
		setData: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, val</span>) </span>{
			<span class="hljs-keyword">var</span> args = (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>) ? [name, val] : [name];
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._invoke(<span class="hljs-string">'setData'</span>, args);
		},

		<span class="hljs-comment">/**
		 * @method clearData
		 * @for NodeList
		 * @description Clears data on all Node instances bound to the NodeList.
		 * @param {string} name The name of the field to clear. If no name
		 * is given, all data is cleared.
		 * @chainable
		 */</span>
		clearData: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
			<span class="hljs-keyword">var</span> args = (<span class="hljs-built_in">arguments</span>.length) ? [name] : [];
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._invoke(<span class="hljs-string">'clearData'</span>, [name]);
		}
	});


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"event-base"</span>, <span class="hljs-string">"node-core"</span>, <span class="hljs-string">"dom-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">var</span> GLOBAL_ENV = YUI.Env;

	<span class="hljs-keyword">if</span> (!GLOBAL_ENV._ready) {
		GLOBAL_ENV._ready = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			GLOBAL_ENV.DOMReady = <span class="hljs-literal">true</span>;
			GLOBAL_ENV.remove(YUI.config.doc, <span class="hljs-string">'DOMContentLoaded'</span>, GLOBAL_ENV._ready);
		};

		GLOBAL_ENV.add(YUI.config.doc, <span class="hljs-string">'DOMContentLoaded'</span>, GLOBAL_ENV._ready);
	}
})();
YUI.add(<span class="hljs-string">'event-base'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/*
	 * DOM event listener abstraction layer
	 * @module event
	 * @submodule event-base
	 */</span>

	<span class="hljs-comment">/**
	 * The domready event fires at the moment the browser's DOM is
	 * usable. In most cases, this is before images are fully
	 * downloaded, allowing you to provide a more responsive user
	 * interface.
	 *
	 * In YUI 3, domready subscribers will be notified immediately if
	 * that moment has already passed when the subscription is created.
	 *
	 * One exception is if the yui.js file is dynamically injected into
	 * the page.  If this is done, you must tell the YUI instance that
	 * you did this in order for DOMReady (and window load events) to
	 * fire normally.  That configuration option is 'injected' -- set
	 * it to true if the yui.js script is not included inline.
	 *
	 * This method is part of the 'event-ready' module, which is a
	 * submodule of 'event'.
	 *
	 * @event domready
	 * @for YUI
	 */</span>
	Y.publish(<span class="hljs-string">'domready'</span>, {
		<span class="hljs-attr">fireOnce</span>: <span class="hljs-literal">true</span>,
		<span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>
	});

	<span class="hljs-keyword">if</span> (YUI.Env.DOMReady) {
		Y.fire(<span class="hljs-string">'domready'</span>);
	} <span class="hljs-keyword">else</span> {
		Y.Do.before(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ Y.fire(<span class="hljs-string">'domready'</span>); }, YUI.Env, <span class="hljs-string">'_ready'</span>);
	}

	<span class="hljs-comment">/**
	 * Custom event engine, DOM event listener abstraction layer, synthetic DOM
	 * events.
	 * @module event
	 * @submodule event-base
	 */</span>

	<span class="hljs-comment">/**
	 * Wraps a DOM event, properties requiring browser abstraction are
	 * fixed here.  Provids a security layer when required.
	 * @class DOMEventFacade
	 * @param ev {Event} the DOM event
	 * @param currentTarget {HTMLElement} the element the listener was attached to
	 * @param wrapper {Event.Custom} the custom event wrapper for this DOM event
	 */</span>

	<span class="hljs-keyword">var</span> ua = Y.UA,

		EMPTY = {},

		<span class="hljs-comment">/**
		 * webkit key remapping required for Safari &lt; 3.1
		 * @property webkitKeymap
		 * @private
		 */</span>
			webkitKeymap = {
			<span class="hljs-number">63232</span>: <span class="hljs-number">38</span>, <span class="hljs-comment">// up</span>
			<span class="hljs-number">63233</span>: <span class="hljs-number">40</span>, <span class="hljs-comment">// down</span>
			<span class="hljs-number">63234</span>: <span class="hljs-number">37</span>, <span class="hljs-comment">// left</span>
			<span class="hljs-number">63235</span>: <span class="hljs-number">39</span>, <span class="hljs-comment">// right</span>
			<span class="hljs-number">63276</span>: <span class="hljs-number">33</span>, <span class="hljs-comment">// page up</span>
			<span class="hljs-number">63277</span>: <span class="hljs-number">34</span>, <span class="hljs-comment">// page down</span>
			<span class="hljs-number">25</span>:     <span class="hljs-number">9</span>, <span class="hljs-comment">// SHIFT-TAB (Safari provides a different key code in</span></pre></div></div>
            
        </li>
        
        
        <li id="section-332">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-332">&#182;</a>
              </div>
              <p>this case, even though the shiftKey modifier is set)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-number">63272</span>: <span class="hljs-number">46</span>, <span class="hljs-comment">// delete</span>
			<span class="hljs-number">63273</span>: <span class="hljs-number">36</span>, <span class="hljs-comment">// home</span>
			<span class="hljs-number">63275</span>: <span class="hljs-number">35</span>  <span class="hljs-comment">// end</span>
		},

		<span class="hljs-comment">/**
		 * Returns a wrapped node.  Intended to be used on event targets,
		 * so it will return the node's parent if the target is a text
		 * node.
		 *
		 * If accessing a property of the node throws an error, this is
		 * probably the anonymous div wrapper Gecko adds inside text
		 * nodes.  This likely will only occur when attempting to access
		 * the relatedTarget.  In this case, we now return null because
		 * the anonymous div is completely useless and we do not know
		 * what the related target was because we can't even get to
		 * the element's parent node.
		 *
		 * @method resolve
		 * @private
		 */</span>
			resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
			<span class="hljs-keyword">if</span> (!n) {
				<span class="hljs-keyword">return</span> n;
			}
			<span class="hljs-keyword">try</span> {
				<span class="hljs-keyword">if</span> (n &amp;&amp; <span class="hljs-number">3</span> == n.nodeType) {
					n = n.parentNode;
				}
			} <span class="hljs-keyword">catch</span>(e) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
			}

			<span class="hljs-keyword">return</span> Y.one(n);
		},

		DOMEventFacade = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev, currentTarget, wrapper</span>) </span>{
			<span class="hljs-keyword">this</span>._event = ev;
			<span class="hljs-keyword">this</span>._currentTarget = currentTarget;
			<span class="hljs-keyword">this</span>._wrapper = wrapper || EMPTY;</pre></div></div>
            
        </li>
        
        
        <li id="section-333">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-333">&#182;</a>
              </div>
              <p>if not lazy init</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>.init();
		};

	Y.extend(DOMEventFacade, <span class="hljs-built_in">Object</span>, {

		<span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

			<span class="hljs-keyword">var</span> e = <span class="hljs-keyword">this</span>._event,
				overrides = <span class="hljs-keyword">this</span>._wrapper.overrides,
				x = e.pageX,
				y = e.pageY,
				c,
				currentTarget = <span class="hljs-keyword">this</span>._currentTarget;

			<span class="hljs-keyword">this</span>.altKey   = e.altKey;
			<span class="hljs-keyword">this</span>.ctrlKey  = e.ctrlKey;
			<span class="hljs-keyword">this</span>.metaKey  = e.metaKey;
			<span class="hljs-keyword">this</span>.shiftKey = e.shiftKey;
			<span class="hljs-keyword">this</span>.type     = (overrides &amp;&amp; overrides.type) || e.type;
			<span class="hljs-keyword">this</span>.clientX  = e.clientX;
			<span class="hljs-keyword">this</span>.clientY  = e.clientY;

			<span class="hljs-keyword">this</span>.pageX = x;
			<span class="hljs-keyword">this</span>.pageY = y;</pre></div></div>
            
        </li>
        
        
        <li id="section-334">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-334">&#182;</a>
              </div>
              <p>charCode is unknown in keyup, keydown. keyCode is unknown in keypress.
FF 3.6 - 8+? pass 0 for keyCode in keypress events.
Webkit, FF 3.6-8+?, and IE9+? pass 0 for charCode in keydown, keyup.
Webkit and IE9+? duplicate charCode in keyCode.
Opera never sets charCode, always keyCode (though with the charCode).
IE6-8 don’t set charCode or which.
All browsers other than IE6-8 set which=keyCode in keydown, keyup, and 
which=charCode in keypress.</p>
<p>Moral of the story: (e.which || e.keyCode) will always return the
known code for that key event phase. e.keyCode is often different in
keypress from keydown and keyup.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			c = e.keyCode || e.charCode;

			<span class="hljs-keyword">if</span> (ua.webkit &amp;&amp; (c <span class="hljs-keyword">in</span> webkitKeymap)) {
				c = webkitKeymap[c];
			}

			<span class="hljs-keyword">this</span>.keyCode = c;
			<span class="hljs-keyword">this</span>.charCode = c;</pre></div></div>
            
        </li>
        
        
        <li id="section-335">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-335">&#182;</a>
              </div>
              <p>Fill in e.which for IE - implementers should always use this over
e.keyCode or e.charCode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>.which = e.which || e.charCode || c;</pre></div></div>
            
        </li>
        
        
        <li id="section-336">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-336">&#182;</a>
              </div>
              <p>this.button = e.button;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>.button = <span class="hljs-keyword">this</span>.which;

			<span class="hljs-keyword">this</span>.target = resolve(e.target);
			<span class="hljs-keyword">this</span>.currentTarget = resolve(currentTarget);
			<span class="hljs-keyword">this</span>.relatedTarget = resolve(e.relatedTarget);

			<span class="hljs-keyword">if</span> (e.type == <span class="hljs-string">"mousewheel"</span> || e.type == <span class="hljs-string">"DOMMouseScroll"</span>) {
				<span class="hljs-keyword">this</span>.wheelDelta = (e.detail) ? (e.detail * <span class="hljs-number">-1</span>) : <span class="hljs-built_in">Math</span>.round(e.wheelDelta / <span class="hljs-number">80</span>) || ((e.wheelDelta &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);
			}

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._touch) {
				<span class="hljs-keyword">this</span>._touch(e, currentTarget, <span class="hljs-keyword">this</span>._wrapper);
			}
		},

		<span class="hljs-attr">stopPropagation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">this</span>._event.stopPropagation();
			<span class="hljs-keyword">this</span>._wrapper.stopped = <span class="hljs-number">1</span>;
			<span class="hljs-keyword">this</span>.stopped = <span class="hljs-number">1</span>;
		},

		<span class="hljs-attr">stopImmediatePropagation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> e = <span class="hljs-keyword">this</span>._event;
			<span class="hljs-keyword">if</span> (e.stopImmediatePropagation) {
				e.stopImmediatePropagation();
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">this</span>.stopPropagation();
			}
			<span class="hljs-keyword">this</span>._wrapper.stopped = <span class="hljs-number">2</span>;
			<span class="hljs-keyword">this</span>.stopped = <span class="hljs-number">2</span>;
		},

		<span class="hljs-attr">preventDefault</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">returnValue</span>) </span>{
			<span class="hljs-keyword">var</span> e = <span class="hljs-keyword">this</span>._event;
			e.preventDefault();
			e.returnValue = returnValue || <span class="hljs-literal">false</span>;
			<span class="hljs-keyword">this</span>._wrapper.prevented = <span class="hljs-number">1</span>;
			<span class="hljs-keyword">this</span>.prevented = <span class="hljs-number">1</span>;
		},

		<span class="hljs-attr">halt</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">immediate</span>) </span>{
			<span class="hljs-keyword">if</span> (immediate) {
				<span class="hljs-keyword">this</span>.stopImmediatePropagation();
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">this</span>.stopPropagation();
			}

			<span class="hljs-keyword">this</span>.preventDefault();
		}

	});

	DOMEventFacade.resolve = resolve;
	Y.DOM2EventFacade = DOMEventFacade;
	Y.DOMEventFacade = DOMEventFacade;

	<span class="hljs-comment">/**
	 * The native event
	 * @property _event
	 * @type {Native DOM Event}
	 * @private
	 */</span>

	<span class="hljs-comment">/**
	 The name of the event (e.g. "click")

	 @property type
	 @type {String}
	 **/</span>

	<span class="hljs-comment">/**
	 `true` if the "alt" or "option" key is pressed.

	 @property altKey
	 @type {Boolean}
	 **/</span>

	<span class="hljs-comment">/**
	 `true` if the shift key is pressed.

	 @property shiftKey
	 @type {Boolean}
	 **/</span>

	<span class="hljs-comment">/**
	 `true` if the "Windows" key on a Windows keyboard, "command" key on an
	 Apple keyboard, or "meta" key on other keyboards is pressed.

	 @property metaKey
	 @type {Boolean}
	 **/</span>

	<span class="hljs-comment">/**
	 `true` if the "Ctrl" or "control" key is pressed.

	 @property ctrlKey
	 @type {Boolean}
	 **/</span>

	<span class="hljs-comment">/**
	 * The X location of the event on the page (including scroll)
	 * @property pageX
	 * @type {Number}
	 */</span>

	<span class="hljs-comment">/**
	 * The Y location of the event on the page (including scroll)
	 * @property pageY
	 * @type {Number}
	 */</span>

	<span class="hljs-comment">/**
	 * The X location of the event in the viewport
	 * @property clientX
	 * @type {Number}
	 */</span>

	<span class="hljs-comment">/**
	 * The Y location of the event in the viewport
	 * @property clientY
	 * @type {Number}
	 */</span>

	<span class="hljs-comment">/**
	 * The keyCode for key events.  Uses charCode if keyCode is not available
	 * @property keyCode
	 * @type {Number}
	 */</span>

	<span class="hljs-comment">/**
	 * The charCode for key events.  Same as keyCode
	 * @property charCode
	 * @type {Number}
	 */</span>

	<span class="hljs-comment">/**
	 * The button that was pushed. 1 for left click, 2 for middle click, 3 for
	 * right click.  This is only reliably populated on `mouseup` events.
	 * @property button
	 * @type {Number}
	 */</span>

	<span class="hljs-comment">/**
	 * The button that was pushed.  Same as button.
	 * @property which
	 * @type {Number}
	 */</span>

	<span class="hljs-comment">/**
	 * Node reference for the targeted element
	 * @property target
	 * @type {Node}
	 */</span>

	<span class="hljs-comment">/**
	 * Node reference for the element that the listener was attached to.
	 * @property currentTarget
	 * @type {Node}
	 */</span>

	<span class="hljs-comment">/**
	 * Node reference to the relatedTarget
	 * @property relatedTarget
	 * @type {Node}
	 */</span>

	<span class="hljs-comment">/**
	 * Number representing the direction and velocity of the movement of the mousewheel.
	 * Negative is down, the higher the number, the faster.  Applies to the mousewheel event.
	 * @property wheelDelta
	 * @type {Number}
	 */</span>

	<span class="hljs-comment">/**
	 * Stops the propagation to the next bubble target
	 * @method stopPropagation
	 */</span>

	<span class="hljs-comment">/**
	 * Stops the propagation to the next bubble target and
	 * prevents any additional listeners from being exectued
	 * on the current target.
	 * @method stopImmediatePropagation
	 */</span>

	<span class="hljs-comment">/**
	 * Prevents the event's default behavior
	 * @method preventDefault
	 * @param returnValue {string} sets the returnValue of the event to this value
	 * (rather than the default false value).  This can be used to add a customized
	 * confirmation query to the beforeunload event).
	 */</span>

	<span class="hljs-comment">/**
	 * Stops the event propagation and prevents the default
	 * event behavior.
	 * @method halt
	 * @param immediate {boolean} if true additional listeners
	 * on the current target will not be executed
	 */</span>
	(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-comment">/**
		 * The event utility provides functions to add and remove event listeners,
		 * event cleansing.  It also tries to automatically remove listeners it
		 * registers during the unload event.
		 * @module event
		 * @main event
		 * @submodule event-base
		 */</span>

		<span class="hljs-comment">/**
		 * The event utility provides functions to add and remove event listeners,
		 * event cleansing.  It also tries to automatically remove listeners it
		 * registers during the unload event.
		 *
		 * @class Event
		 * @static
		 */</span>

		Y.Env.evt.dom_wrappers = {};
		Y.Env.evt.dom_map = {};

		<span class="hljs-keyword">var</span> YDOM = Y.DOM,
			_eventenv = Y.Env.evt,
			config = Y.config,
			win = config.win,
			add = YUI.Env.add,
			remove = YUI.Env.remove,

			onLoad = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				YUI.Env.windowLoaded = <span class="hljs-literal">true</span>;
				Y.Event._load();
				remove(win, <span class="hljs-string">"load"</span>, onLoad);
			},

			onUnload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				Y.Event._unload();
			},

			EVENT_READY = <span class="hljs-string">'domready'</span>,

			COMPAT_ARG = <span class="hljs-string">'~yui|2|compat~'</span>,

			shouldIterate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
				<span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-337">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-337">&#182;</a>
              </div>
              <p>TODO: See if there’s a more performant way to return true early on this, for the common case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> (o &amp;&amp; <span class="hljs-keyword">typeof</span> o !== <span class="hljs-string">"string"</span> &amp;&amp; Y.Lang.isNumber(o.length) &amp;&amp; !o.tagName &amp;&amp; !YDOM.isWindow(o));
				} <span class="hljs-keyword">catch</span>(ex) {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				}
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-338">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-338">&#182;</a>
              </div>
              <p>aliases to support DOM event subscription clean up when the last
subscriber is detached. deleteAndClean overrides the DOM event’s wrapper
CustomEvent _delete method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			_ceProtoDelete = Y.CustomEvent.prototype._delete,
			_deleteAndClean = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
				<span class="hljs-keyword">var</span> ret = _ceProtoDelete.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

				<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hasSubs()) {
					Y.Event._clean(<span class="hljs-keyword">this</span>);
				}

				<span class="hljs-keyword">return</span> ret;
			},

			Event = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

				<span class="hljs-comment">/**
				 * True after the onload event has fired
				 * @property _loadComplete
				 * @type boolean
				 * @static
				 * @private
				 */</span>
				<span class="hljs-keyword">var</span> _loadComplete =  <span class="hljs-literal">false</span>,

					<span class="hljs-comment">/**
					 * The number of times to poll after window.onload.  This number is
					 * increased if additional late-bound handlers are requested after
					 * the page load.
					 * @property _retryCount
					 * @static
					 * @private
					 */</span>
						_retryCount = <span class="hljs-number">0</span>,

					<span class="hljs-comment">/**
					 * onAvailable listeners
					 * @property _avail
					 * @static
					 * @private
					 */</span>
						_avail = [],

					<span class="hljs-comment">/**
					 * Custom event wrappers for DOM events.  Key is
					 * 'event:' + Element uid stamp + event type
					 * @property _wrappers
					 * @type Y.Event.Custom
					 * @static
					 * @private
					 */</span>
						_wrappers = _eventenv.dom_wrappers,

					_windowLoadKey = <span class="hljs-literal">null</span>,

					<span class="hljs-comment">/**
					 * Custom event wrapper map DOM events.  Key is
					 * Element uid stamp.  Each item is a hash of custom event
					 * wrappers as provided in the _wrappers collection.  This
					 * provides the infrastructure for getListeners.
					 * @property _el_events
					 * @static
					 * @private
					 */</span>
						_el_events = _eventenv.dom_map;

				<span class="hljs-keyword">return</span> {

					<span class="hljs-comment">/**
					 * The number of times we should look for elements that are not
					 * in the DOM at the time the event is requested after the document
					 * has been loaded.  The default is 1000@amp;40 ms, so it will poll
					 * for 40 seconds or until all outstanding handlers are bound
					 * (whichever comes first).
					 * @property POLL_RETRYS
					 * @type int
					 * @static
					 * @final
					 */</span>
					POLL_RETRYS: <span class="hljs-number">1000</span>,

					<span class="hljs-comment">/**
					 * The poll interval in milliseconds
					 * @property POLL_INTERVAL
					 * @type int
					 * @static
					 * @final
					 */</span>
					POLL_INTERVAL: <span class="hljs-number">40</span>,

					<span class="hljs-comment">/**
					 * addListener/removeListener can throw errors in unexpected scenarios.
					 * These errors are suppressed, the method returns false, and this property
					 * is set
					 * @property lastError
					 * @static
					 * @type Error
					 */</span>
					lastError: <span class="hljs-literal">null</span>,


					<span class="hljs-comment">/**
					 * poll handle
					 * @property _interval
					 * @static
					 * @private
					 */</span>
					_interval: <span class="hljs-literal">null</span>,

					<span class="hljs-comment">/**
					 * document readystate poll handle
					 * @property _dri
					 * @static
					 * @private
					 */</span>
					_dri: <span class="hljs-literal">null</span>,

					<span class="hljs-comment">/**
					 * True when the document is initially usable
					 * @property DOMReady
					 * @type boolean
					 * @static
					 */</span>
					DOMReady: <span class="hljs-literal">false</span>,

					<span class="hljs-comment">/**
					 * @method startInterval
					 * @static
					 * @private
					 */</span>
					startInterval: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
						<span class="hljs-keyword">if</span> (!Event._interval) {
							Event._interval = setInterval(Event._poll, Event.POLL_INTERVAL);
						}
					},

					<span class="hljs-comment">/**
					 * Executes the supplied callback when the item with the supplied
					 * id is found.  This is meant to be used to execute behavior as
					 * soon as possible as the page loads.  If you use this after the
					 * initial page load it will poll for a fixed time for the element.
					 * The number of times it will poll and the frequency are
					 * configurable.  By default it will poll for 10 seconds.
					 *
					 * &lt;p&gt;The callback is executed with a single parameter:
					 * the custom object parameter, if provided.&lt;/p&gt;
					 *
					 * @method onAvailable
					 *
					 * @param {string||string[]}   id the id of the element, or an array
					 * of ids to look for.
					 * @param {function} fn what to execute when the element is found.
					 * @param {object}   p_obj an optional object to be passed back as
					 *                   a parameter to fn.
					 * @param {boolean|object}  p_override If set to true, fn will execute
					 *                   in the context of p_obj, if set to an object it
					 *                   will execute in the context of that object
					 * @param checkContent {boolean} check child node readiness (onContentReady)
					 * @static
					 * @deprecated Use Y.on("available")
					 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-339">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-339">&#182;</a>
              </div>
              <p>@TODO fix arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					onAvailable: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id, fn, p_obj, p_override, checkContent, compat</span>) </span>{

						<span class="hljs-keyword">var</span> a = Y.Array(id), i, availHandle;


						<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;a.length; i=i+<span class="hljs-number">1</span>) {
							_avail.push({
								<span class="hljs-attr">id</span>:         a[i],
								<span class="hljs-attr">fn</span>:         fn,
								<span class="hljs-attr">obj</span>:        p_obj,
								<span class="hljs-attr">override</span>:   p_override,
								<span class="hljs-attr">checkReady</span>: checkContent,
								<span class="hljs-attr">compat</span>:     compat
							});
						}
						_retryCount = <span class="hljs-keyword">this</span>.POLL_RETRYS;</pre></div></div>
            
        </li>
        
        
        <li id="section-340">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-340">&#182;</a>
              </div>
              <p>We want the first test to be immediate, but async</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						setTimeout(Event._poll, <span class="hljs-number">0</span>);

						availHandle = <span class="hljs-keyword">new</span> Y.EventHandle({

							<span class="hljs-attr">_delete</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-341">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-341">&#182;</a>
              </div>
              <p>set by the event system for lazy DOM listeners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (availHandle.handle) {
									availHandle.handle.detach();
									<span class="hljs-keyword">return</span>;
								}

								<span class="hljs-keyword">var</span> i, j;</pre></div></div>
            
        </li>
        
        
        <li id="section-342">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-342">&#182;</a>
              </div>
              <p>otherwise try to remove the onAvailable listener(s)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; a.length; i++) {
									<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; _avail.length; j++) {
										<span class="hljs-keyword">if</span> (a[i] === _avail[j].id) {
											_avail.splice(j, <span class="hljs-number">1</span>);
										}
									}
								}
							}

						});

						<span class="hljs-keyword">return</span> availHandle;
					},

					<span class="hljs-comment">/**
					 * Works the same way as onAvailable, but additionally checks the
					 * state of sibling elements to determine if the content of the
					 * available element is safe to modify.
					 *
					 * &lt;p&gt;The callback is executed with a single parameter:
					 * the custom object parameter, if provided.&lt;/p&gt;
					 *
					 * @method onContentReady
					 *
					 * @param {string}   id the id of the element to look for.
					 * @param {function} fn what to execute when the element is ready.
					 * @param {object}   obj an optional object to be passed back as
					 *                   a parameter to fn.
					 * @param {boolean|object}  override If set to true, fn will execute
					 *                   in the context of p_obj.  If an object, fn will
					 *                   exectute in the context of that object
					 *
					 * @static
					 * @deprecated Use Y.on("contentready")
					 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-343">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-343">&#182;</a>
              </div>
              <p>@TODO fix arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					onContentReady: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id, fn, obj, override, compat</span>) </span>{
						<span class="hljs-keyword">return</span> Event.onAvailable(id, fn, obj, override, <span class="hljs-literal">true</span>, compat);
					},

					<span class="hljs-comment">/**
					 * Adds an event listener
					 *
					 * @method attach
					 *
					 * @param {String}   type     The type of event to append
					 * @param {Function} fn        The method the event invokes
					 * @param {String|HTMLElement|Array|NodeList} el An id, an element
					 *  reference, or a collection of ids and/or elements to assign the
					 *  listener to.
					 * @param {Object}   context optional context object
					 * @param {Boolean|object}  args 0..n arguments to pass to the callback
					 * @return {EventHandle} an object to that can be used to detach the listener
					 *
					 * @static
					 */</span>

					attach: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, fn, el, context</span>) </span>{
						<span class="hljs-keyword">return</span> Event._attach(Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>));
					},

					<span class="hljs-attr">_createWrapper</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, type, capture, compat, facade</span>) </span>{

						<span class="hljs-keyword">var</span> cewrapper,
							ek  = Y.stamp(el),
							key = <span class="hljs-string">'event:'</span> + ek + type;

						<span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> === facade) {
							key += <span class="hljs-string">'native'</span>;
						}
						<span class="hljs-keyword">if</span> (capture) {
							key += <span class="hljs-string">'capture'</span>;
						}


						cewrapper = _wrappers[key];


						<span class="hljs-keyword">if</span> (!cewrapper) {</pre></div></div>
            
        </li>
        
        
        <li id="section-344">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-344">&#182;</a>
              </div>
              <p>create CE wrapper</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							cewrapper = Y.publish(key, {
								<span class="hljs-attr">silent</span>: <span class="hljs-literal">true</span>,
								<span class="hljs-attr">bubbles</span>: <span class="hljs-literal">false</span>,
								<span class="hljs-attr">contextFn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
									<span class="hljs-keyword">if</span> (compat) {
										<span class="hljs-keyword">return</span> cewrapper.el;
									} <span class="hljs-keyword">else</span> {
										cewrapper.nodeRef = cewrapper.nodeRef || Y.one(cewrapper.el);
										<span class="hljs-keyword">return</span> cewrapper.nodeRef;
									}
								}
							});

							cewrapper.overrides = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-345">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-345">&#182;</a>
              </div>
              <p>for later removeListener calls</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							cewrapper.el = el;
							cewrapper.key = key;
							cewrapper.domkey = ek;
							cewrapper.type = type;
							cewrapper.fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
								cewrapper.fire(Event.getEvent(e, el, (compat || (<span class="hljs-literal">false</span> === facade))));
							};
							cewrapper.capture = capture;

							<span class="hljs-keyword">if</span> (el == win &amp;&amp; type == <span class="hljs-string">"load"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-346">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-346">&#182;</a>
              </div>
              <p>window load happens once</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								cewrapper.fireOnce = <span class="hljs-literal">true</span>;
								_windowLoadKey = key;
							}
							cewrapper._delete = _deleteAndClean;

							_wrappers[key] = cewrapper;
							_el_events[ek] = _el_events[ek] || {};
							_el_events[ek][key] = cewrapper;

							add(el, type, cewrapper.fn, capture);
						}

						<span class="hljs-keyword">return</span> cewrapper;

					},

					<span class="hljs-attr">_attach</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args, conf</span>) </span>{

						<span class="hljs-keyword">var</span> compat,
							handles, oEl, cewrapper, context,
							fireNow = <span class="hljs-literal">false</span>, ret,
							type = args[<span class="hljs-number">0</span>],
							fn = args[<span class="hljs-number">1</span>],
							el = args[<span class="hljs-number">2</span>] || win,
							facade = conf &amp;&amp; conf.facade,
							capture = conf &amp;&amp; conf.capture,
							overrides = conf &amp;&amp; conf.overrides;

						<span class="hljs-keyword">if</span> (args[args.length<span class="hljs-number">-1</span>] === COMPAT_ARG) {
							compat = <span class="hljs-literal">true</span>;
						}

						<span class="hljs-keyword">if</span> (!fn || !fn.call) {</pre></div></div>
            
        </li>
        
        
        <li id="section-347">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-347">&#182;</a>
              </div>
              <p>throw new TypeError(type + “ attach call failed, callback undefined”);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-348">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-348">&#182;</a>
              </div>
              <p>The el argument can be an array of elements or element ids.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (shouldIterate(el)) {

							handles=[];

							Y.each(el, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, k</span>) </span>{
								args[<span class="hljs-number">2</span>] = v;
								handles.push(Event._attach(args.slice(), conf));
							});</pre></div></div>
            
        </li>
        
        
        <li id="section-349">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-349">&#182;</a>
              </div>
              <p>return (handles.length === 1) ? handles[0] : handles;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Y.EventHandle(handles);</pre></div></div>
            
        </li>
        
        
        <li id="section-350">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-350">&#182;</a>
              </div>
              <p>If the el argument is a string, we assume it is
actually the id of the element.  If the page is loaded
we convert el to the actual element, otherwise we
defer attaching the event until the element is
ready</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Y.Lang.isString(el)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-351">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-351">&#182;</a>
              </div>
              <p>oEl = (compat) ? Y.DOM.byId(el) : Y.Selector.query(el);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
							<span class="hljs-keyword">if</span> (compat) {
								oEl = YDOM.byId(el);
							} <span class="hljs-keyword">else</span> {

								oEl = Y.Selector.query(el);

								<span class="hljs-keyword">switch</span> (oEl.length) {
									<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
										oEl = <span class="hljs-literal">null</span>;
										<span class="hljs-keyword">break</span>;
									<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
										oEl = oEl[<span class="hljs-number">0</span>];
										<span class="hljs-keyword">break</span>;
									<span class="hljs-keyword">default</span>:
										args[<span class="hljs-number">2</span>] = oEl;
										<span class="hljs-keyword">return</span> Event._attach(args, conf);
								}
							}

							<span class="hljs-keyword">if</span> (oEl) {

								el = oEl;</pre></div></div>
            
        </li>
        
        
        <li id="section-352">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-352">&#182;</a>
              </div>
              <p>Not found = defer adding the event until the element is available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							} <span class="hljs-keyword">else</span> {

								ret = Event.onAvailable(el, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

									ret.handle = Event._attach(args, conf);

								}, Event, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, compat);

								<span class="hljs-keyword">return</span> ret;

							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-353">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-353">&#182;</a>
              </div>
              <p>Element should be an html element or node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (!el) {
							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						}

						<span class="hljs-keyword">if</span> (Y.Node &amp;&amp; Y.instanceOf(el, Y.Node)) {
							el = Y.Node.getDOMNode(el);
						}

						cewrapper = Event._createWrapper(el, type, capture, compat, facade);
						<span class="hljs-keyword">if</span> (overrides) {
							Y.mix(cewrapper.overrides, overrides);
						}

						<span class="hljs-keyword">if</span> (el == win &amp;&amp; type == <span class="hljs-string">"load"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-354">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-354">&#182;</a>
              </div>
              <p>if the load is complete, fire immediately.
all subscribers, including the current one
will be notified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (YUI.Env.windowLoaded) {
								fireNow = <span class="hljs-literal">true</span>;
							}
						}

						<span class="hljs-keyword">if</span> (compat) {
							args.pop();
						}

						context = args[<span class="hljs-number">3</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-355">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-355">&#182;</a>
              </div>
              <p>set context to the Node if not specified
ret = cewrapper.on.apply(cewrapper, trimmedArgs);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						ret = cewrapper._on(fn, context, (args.length &gt; <span class="hljs-number">4</span>) ? args.slice(<span class="hljs-number">4</span>) : <span class="hljs-literal">null</span>);

						<span class="hljs-keyword">if</span> (fireNow) {
							cewrapper.fire();
						}

						<span class="hljs-keyword">return</span> ret;

					},

					<span class="hljs-comment">/**
					 * Removes an event listener.  Supports the signature the event was bound
					 * with, but the preferred way to remove listeners is using the handle
					 * that is returned when using Y.on
					 *
					 * @method detach
					 *
					 * @param {String} type the type of event to remove.
					 * @param {Function} fn the method the event invokes.  If fn is
					 * undefined, then all event handlers for the type of event are
					 * removed.
					 * @param {String|HTMLElement|Array|NodeList|EventHandle} el An
					 * event handle, an id, an element reference, or a collection
					 * of ids and/or elements to remove the listener from.
					 * @return {boolean} true if the unbind was successful, false otherwise.
					 * @static
					 */</span>
					detach: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, fn, el, obj</span>) </span>{

						<span class="hljs-keyword">var</span> args=Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>), compat, l, ok, i,
							id, ce;

						<span class="hljs-keyword">if</span> (args[args.length<span class="hljs-number">-1</span>] === COMPAT_ARG) {
							compat = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-356">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-356">&#182;</a>
              </div>
              <p>args.pop();</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						}

						<span class="hljs-keyword">if</span> (type &amp;&amp; type.detach) {
							<span class="hljs-keyword">return</span> type.detach();
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-357">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-357">&#182;</a>
              </div>
              <p>The el argument can be a string</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el == <span class="hljs-string">"string"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-358">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-358">&#182;</a>
              </div>
              <p>el = (compat) ? Y.DOM.byId(el) : Y.all(el);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (compat) {
								el = YDOM.byId(el);
							} <span class="hljs-keyword">else</span> {
								el = Y.Selector.query(el);
								l = el.length;
								<span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">1</span>) {
									el = <span class="hljs-literal">null</span>;
								} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l == <span class="hljs-number">1</span>) {
									el = el[<span class="hljs-number">0</span>];
								}
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-359">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-359">&#182;</a>
              </div>
              <p>return Event.detach.apply(Event, args);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						}

						<span class="hljs-keyword">if</span> (!el) {
							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						}

						<span class="hljs-keyword">if</span> (el.detach) {
							args.splice(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);
							<span class="hljs-keyword">return</span> el.detach.apply(el, args);</pre></div></div>
            
        </li>
        
        
        <li id="section-360">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-360">&#182;</a>
              </div>
              <p>The el argument can be an array of elements or element ids.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shouldIterate(el)) {
							ok = <span class="hljs-literal">true</span>;
							<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>, l=el.length; i&lt;l; ++i) {
								args[<span class="hljs-number">2</span>] = el[i];
								ok = ( Y.Event.detach.apply(Y.Event, args) &amp;&amp; ok );
							}

							<span class="hljs-keyword">return</span> ok;
						}

						<span class="hljs-keyword">if</span> (!type || !fn || !fn.call) {
							<span class="hljs-keyword">return</span> Event.purgeElement(el, <span class="hljs-literal">false</span>, type);
						}

						id = <span class="hljs-string">'event:'</span> + Y.stamp(el) + type;
						ce = _wrappers[id];

						<span class="hljs-keyword">if</span> (ce) {
							<span class="hljs-keyword">return</span> ce.detach(fn);
						} <span class="hljs-keyword">else</span> {
							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						}

					},

					<span class="hljs-comment">/**
					 * Finds the event in the window object, the caller's arguments, or
					 * in the arguments of another method in the callstack.  This is
					 * executed automatically for events registered through the event
					 * manager, so the implementer should not normally need to execute
					 * this function at all.
					 * @method getEvent
					 * @param {Event} e the event parameter from the handler
					 * @param {HTMLElement} el the element the listener was attached to
					 * @return {Event} the event
					 * @static
					 */</span>
					getEvent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, el, noFacade</span>) </span>{
						<span class="hljs-keyword">var</span> ev = e || win.event;

						<span class="hljs-keyword">return</span> (noFacade) ? ev :
							<span class="hljs-keyword">new</span> Y.DOMEventFacade(ev, el, _wrappers[<span class="hljs-string">'event:'</span> + Y.stamp(el) + e.type]);
					},

					<span class="hljs-comment">/**
					 * Generates an unique ID for the element if it does not already
					 * have one.
					 * @method generateId
					 * @param el the element to create the id for
					 * @return {string} the resulting id of the element
					 * @static
					 */</span>
					generateId: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>) </span>{
						<span class="hljs-keyword">return</span> YDOM.generateID(el);
					},

					<span class="hljs-comment">/**
					 * We want to be able to use getElementsByTagName as a collection
					 * to attach a group of events to.  Unfortunately, different
					 * browsers return different types of collections.  This function
					 * tests to determine if the object is array-like.  It will also
					 * fail if the object is an array, but is empty.
					 * @method _isValidCollection
					 * @param o the object to test
					 * @return {boolean} true if the object is array-like and populated
					 * @deprecated was not meant to be used directly
					 * @static
					 * @private
					 */</span>
					_isValidCollection: shouldIterate,

					<span class="hljs-comment">/**
					 * hook up any deferred listeners
					 * @method _load
					 * @static
					 * @private
					 */</span>
					_load: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
						<span class="hljs-keyword">if</span> (!_loadComplete) {
							_loadComplete = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-361">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-361">&#182;</a>
              </div>
              <p>Just in case DOMReady did not go off for some reason
E._ready();</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (Y.fire) {
								Y.fire(EVENT_READY);
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-362">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-362">&#182;</a>
              </div>
              <p>Available elements may not have been detected before the
window load event fires. Try to find them now so that the
the user is more likely to get the onAvailable notifications
before the window load notification</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							Event._poll();
						}
					},

					<span class="hljs-comment">/**
					 * Polling function that runs before the onload event fires,
					 * attempting to attach to DOM Nodes as soon as they are
					 * available
					 * @method _poll
					 * @static
					 * @private
					 */</span>
					_poll: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
						<span class="hljs-keyword">if</span> (Event.locked) {
							<span class="hljs-keyword">return</span>;
						}

						<span class="hljs-keyword">if</span> (Y.UA.ie &amp;&amp; !YUI.Env.DOMReady) {</pre></div></div>
            
        </li>
        
        
        <li id="section-363">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-363">&#182;</a>
              </div>
              <p>Hold off if DOMReady has not fired and check current
readyState to protect against the IE operation aborted
issue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							Event.startInterval();
							<span class="hljs-keyword">return</span>;
						}

						Event.locked = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-364">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-364">&#182;</a>
              </div>
              <p>keep trying until after the page is loaded.  We need to
check the page load state prior to trying to bind the
elements so that we can be certain all elements have been
tested appropriately</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> i, len, item, el, notAvail, executeItem,
							tryAgain = !_loadComplete;

						<span class="hljs-keyword">if</span> (!tryAgain) {
							tryAgain = (_retryCount &gt; <span class="hljs-number">0</span>);
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-365">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-365">&#182;</a>
              </div>
              <p>onAvailable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						notAvail = [];

						executeItem = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, item</span>) </span>{
							<span class="hljs-keyword">var</span> context, ov = item.override;
							<span class="hljs-keyword">try</span> {
								<span class="hljs-keyword">if</span> (item.compat) {
									<span class="hljs-keyword">if</span> (item.override) {
										<span class="hljs-keyword">if</span> (ov === <span class="hljs-literal">true</span>) {
											context = item.obj;
										} <span class="hljs-keyword">else</span> {
											context = ov;
										}
									} <span class="hljs-keyword">else</span> {
										context = el;
									}
									item.fn.call(context, item.obj);
								} <span class="hljs-keyword">else</span> {
									context = item.obj || Y.one(el);
									item.fn.apply(context, (Y.Lang.isArray(ov)) ? ov : []);
								}
							} <span class="hljs-keyword">catch</span> (e) {
							}
						};</pre></div></div>
            
        </li>
        
        
        <li id="section-366">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-366">&#182;</a>
              </div>
              <p>onAvailable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>,len=_avail.length; i&lt;len; ++i) {
							item = _avail[i];
							<span class="hljs-keyword">if</span> (item &amp;&amp; !item.checkReady) {</pre></div></div>
            
        </li>
        
        
        <li id="section-367">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-367">&#182;</a>
              </div>
              <p>el = (item.compat) ? Y.DOM.byId(item.id) : Y.one(item.id);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								el = (item.compat) ? YDOM.byId(item.id) : Y.Selector.query(item.id, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);

								<span class="hljs-keyword">if</span> (el) {
									executeItem(el, item);
									_avail[i] = <span class="hljs-literal">null</span>;
								} <span class="hljs-keyword">else</span> {
									notAvail.push(item);
								}
							}
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-368">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-368">&#182;</a>
              </div>
              <p>onContentReady</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>,len=_avail.length; i&lt;len; ++i) {
							item = _avail[i];
							<span class="hljs-keyword">if</span> (item &amp;&amp; item.checkReady) {</pre></div></div>
            
        </li>
        
        
        <li id="section-369">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-369">&#182;</a>
              </div>
              <p>el = (item.compat) ? Y.DOM.byId(item.id) : Y.one(item.id);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								el = (item.compat) ? YDOM.byId(item.id) : Y.Selector.query(item.id, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);

								<span class="hljs-keyword">if</span> (el) {</pre></div></div>
            
        </li>
        
        
        <li id="section-370">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-370">&#182;</a>
              </div>
              <p>The element is available, but not necessarily ready
@todo should we test parentNode.nextSibling?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									<span class="hljs-keyword">if</span> (_loadComplete || (el.get &amp;&amp; el.get(<span class="hljs-string">'nextSibling'</span>)) || el.nextSibling) {
										executeItem(el, item);
										_avail[i] = <span class="hljs-literal">null</span>;
									}
								} <span class="hljs-keyword">else</span> {
									notAvail.push(item);
								}
							}
						}

						_retryCount = (notAvail.length === <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : _retryCount - <span class="hljs-number">1</span>;

						<span class="hljs-keyword">if</span> (tryAgain) {</pre></div></div>
            
        </li>
        
        
        <li id="section-371">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-371">&#182;</a>
              </div>
              <p>we may need to strip the nulled out items here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							Event.startInterval();
						} <span class="hljs-keyword">else</span> {
							clearInterval(Event._interval);
							Event._interval = <span class="hljs-literal">null</span>;
						}

						Event.locked = <span class="hljs-literal">false</span>;

						<span class="hljs-keyword">return</span>;

					},

					<span class="hljs-comment">/**
					 * Removes all listeners attached to the given element via addListener.
					 * Optionally, the node's children can also be purged.
					 * Optionally, you can specify a specific type of event to remove.
					 * @method purgeElement
					 * @param {HTMLElement} el the element to purge
					 * @param {boolean} recurse recursively purge this element's children
					 * as well.  Use with caution.
					 * @param {string} type optional type of listener to purge. If
					 * left out, all listeners will be removed
					 * @static
					 */</span>
					purgeElement: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, recurse, type</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-372">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-372">&#182;</a>
              </div>
              <p>var oEl = (Y.Lang.isString(el)) ? Y.one(el) : el,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> oEl = (Y.Lang.isString(el)) ?  Y.Selector.query(el, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>) : el,
							lis = Event.getListeners(oEl, type), i, len, children, child;

						<span class="hljs-keyword">if</span> (recurse &amp;&amp; oEl) {
							lis = lis || [];
							children = Y.Selector.query(<span class="hljs-string">'*'</span>, oEl);
							len = children.length;
							<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; ++i) {
								child = Event.getListeners(children[i], type);
								<span class="hljs-keyword">if</span> (child) {
									lis = lis.concat(child);
								}
							}
						}

						<span class="hljs-keyword">if</span> (lis) {
							<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = lis.length; i &lt; len; ++i) {
								lis[i].detachAll();
							}
						}

					},

					<span class="hljs-comment">/**
					 * Removes all object references and the DOM proxy subscription for
					 * a given event for a DOM node.
					 *
					 * @method _clean
					 * @param wrapper {CustomEvent} Custom event proxy for the DOM
					 *                  subscription
					 * @private
					 * @static
					 * @since 3.4.0
					 */</span>
					_clean: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">wrapper</span>) </span>{
						<span class="hljs-keyword">var</span> key    = wrapper.key,
							domkey = wrapper.domkey;

						remove(wrapper.el, wrapper.type, wrapper.fn, wrapper.capture);
						<span class="hljs-keyword">delete</span> _wrappers[key];
						<span class="hljs-keyword">delete</span> Y._yuievt.events[key];
						<span class="hljs-keyword">if</span> (_el_events[domkey]) {
							<span class="hljs-keyword">delete</span> _el_events[domkey][key];
							<span class="hljs-keyword">if</span> (!Y.Object.size(_el_events[domkey])) {
								<span class="hljs-keyword">delete</span> _el_events[domkey];
							}
						}
					},

					<span class="hljs-comment">/**
					 * Returns all listeners attached to the given element via addListener.
					 * Optionally, you can specify a specific type of event to return.
					 * @method getListeners
					 * @param el {HTMLElement|string} the element or element id to inspect
					 * @param type {string} optional type of listener to return. If
					 * left out, all listeners will be returned
					 * @return {CustomEvent} the custom event wrapper for the DOM event(s)
					 * @static
					 */</span>
					getListeners: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, type</span>) </span>{
						<span class="hljs-keyword">var</span> ek = Y.stamp(el, <span class="hljs-literal">true</span>), evts = _el_events[ek],
							results=[] , key = (type) ? <span class="hljs-string">'event:'</span> + ek + type : <span class="hljs-literal">null</span>,
							adapters = _eventenv.plugins;

						<span class="hljs-keyword">if</span> (!evts) {
							<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
						}

						<span class="hljs-keyword">if</span> (key) {</pre></div></div>
            
        </li>
        
        
        <li id="section-373">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-373">&#182;</a>
              </div>
              <p>look for synthetic events</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (adapters[type] &amp;&amp; adapters[type].eventDef) {
								key += <span class="hljs-string">'_synth'</span>;
							}

							<span class="hljs-keyword">if</span> (evts[key]) {
								results.push(evts[key]);
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-374">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-374">&#182;</a>
              </div>
              <p>get native events as well</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							key += <span class="hljs-string">'native'</span>;
							<span class="hljs-keyword">if</span> (evts[key]) {
								results.push(evts[key]);
							}

						} <span class="hljs-keyword">else</span> {
							Y.each(evts, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, k</span>) </span>{
								results.push(v);
							});
						}

						<span class="hljs-keyword">return</span> (results.length) ? results : <span class="hljs-literal">null</span>;
					},

					<span class="hljs-comment">/**
					 * Removes all listeners registered by pe.event.  Called
					 * automatically during the unload event.
					 * @method _unload
					 * @static
					 * @private
					 */</span>
					_unload: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
						Y.each(_wrappers, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, k</span>) </span>{
							<span class="hljs-keyword">if</span> (v.type == <span class="hljs-string">'unload'</span>) {
								v.fire(e);
							}
							v.detachAll();
						});
						remove(win, <span class="hljs-string">"unload"</span>, onUnload);
					},

					<span class="hljs-comment">/**
					 * Adds a DOM event directly without the caching, cleanup, context adj, etc
					 *
					 * @method nativeAdd
					 * @param {HTMLElement} el      the element to bind the handler to
					 * @param {string}      type   the type of event handler
					 * @param {function}    fn      the callback to invoke
					 * @param {boolen}      capture capture or bubble phase
					 * @static
					 * @private
					 */</span>
					nativeAdd: add,

					<span class="hljs-comment">/**
					 * Basic remove listener
					 *
					 * @method nativeRemove
					 * @param {HTMLElement} el      the element to bind the handler to
					 * @param {string}      type   the type of event handler
					 * @param {function}    fn      the callback to invoke
					 * @param {boolen}      capture capture or bubble phase
					 * @static
					 * @private
					 */</span>
					nativeRemove: remove
				};

			}();

		Y.Event = Event;

		<span class="hljs-keyword">if</span> (config.injected || YUI.Env.windowLoaded) {
			onLoad();
		} <span class="hljs-keyword">else</span> {
			add(win, <span class="hljs-string">"load"</span>, onLoad);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-375">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-375">&#182;</a>
              </div>
              <p>Process onAvailable/onContentReady items when when the DOM is ready in IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (Y.UA.ie) {
			Y.on(EVENT_READY, Event._poll);
		}

		<span class="hljs-keyword">try</span> {
			add(win, <span class="hljs-string">"unload"</span>, onUnload);
		} <span class="hljs-keyword">catch</span>(e) {
		}

		Event.Custom = Y.CustomEvent;
		Event.Subscriber = Y.Subscriber;
		Event.Target = Y.EventTarget;
		Event.Handle = Y.EventHandle;
		Event.Facade = Y.EventFacade;

		Event._poll();

	}());

	<span class="hljs-comment">/**
	 * DOM event listener abstraction layer
	 * @module event
	 * @submodule event-base
	 */</span>

	<span class="hljs-comment">/**
	 * Executes the callback as soon as the specified element
	 * is detected in the DOM.  This function expects a selector
	 * string for the element(s) to detect.  If you already have
	 * an element reference, you don't need this event.
	 * @event available
	 * @param type {string} 'available'
	 * @param fn {function} the callback function to execute.
	 * @param el {string} an selector for the element(s) to attach
	 * @param context optional argument that specifies what 'this' refers to.
	 * @param args* 0..n additional arguments to pass on to the callback function.
	 * These arguments will be added after the event object.
	 * @return {EventHandle} the detach handle
	 * @for YUI
	 */</span>
	Y.Env.evt.plugins.available = {
		<span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, fn, id, o</span>) </span>{
			<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">4</span> ?  Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>) : <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">return</span> Y.Event.onAvailable.call(Y.Event, id, fn, o, a);
		}
	};

	<span class="hljs-comment">/**
	 * Executes the callback as soon as the specified element
	 * is detected in the DOM with a nextSibling property
	 * (indicating that the element's children are available).
	 * This function expects a selector
	 * string for the element(s) to detect.  If you already have
	 * an element reference, you don't need this event.
	 * @event contentready
	 * @param type {string} 'contentready'
	 * @param fn {function} the callback function to execute.
	 * @param el {string} an selector for the element(s) to attach.
	 * @param context optional argument that specifies what 'this' refers to.
	 * @param args* 0..n additional arguments to pass on to the callback function.
	 * These arguments will be added after the event object.
	 * @return {EventHandle} the detach handle
	 * @for YUI
	 */</span>
	Y.Env.evt.plugins.contentready = {
		<span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, fn, id, o</span>) </span>{
			<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">4</span> ? Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>) : <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">return</span> Y.Event.onContentReady.call(Y.Event, id, fn, o, a);
		}
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"event-custom-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'event-delegate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Adds event delegation support to the library.
	 *
	 * @module event
	 * @submodule event-delegate
	 */</span>

	<span class="hljs-keyword">var</span> toArray          = Y.Array,
		YLang            = Y.Lang,
		isString         = YLang.isString,
		isObject         = YLang.isObject,
		isArray          = YLang.isArray,
		selectorTest     = Y.Selector.test,
		detachCategories = Y.Env.evt.handles;

	<span class="hljs-comment">/**
	 * &lt;p&gt;Sets up event delegation on a container element.  The delegated event
	 * will use a supplied selector or filtering function to test if the event
	 * references at least one node that should trigger the subscription
	 * callback.&lt;/p&gt;
	 *
	 * &lt;p&gt;Selector string filters will trigger the callback if the event originated
	 * from a node that matches it or is contained in a node that matches it.
	 * Function filters are called for each Node up the parent axis to the
	 * subscribing container node, and receive at each level the Node and the event
	 * object.  The function should return true (or a truthy value) if that Node
	 * should trigger the subscription callback.  Note, it is possible for filters
	 * to match multiple Nodes for a single event.  In this case, the delegate
	 * callback will be executed for each matching Node.&lt;/p&gt;
	 *
	 * &lt;p&gt;For each matching Node, the callback will be executed with its 'this'
	 * object set to the Node matched by the filter (unless a specific context was
	 * provided during subscription), and the provided event's
	 * &lt;code&gt;currentTarget&lt;/code&gt; will also be set to the matching Node.  The
	 * containing Node from which the subscription was originally made can be
	 * referenced as &lt;code&gt;e.container&lt;/code&gt;.
	 *
	 * @method delegate
	 * @param type {String} the event type to delegate
	 * @param fn {Function} the callback function to execute.  This function
	 *              will be provided the event object for the delegated event.
	 * @param el {String|node} the element that is the delegation container
	 * @param filter {string|Function} a selector that must match the target of the
	 *              event or a function to test target and its parents for a match
	 * @param context optional argument that specifies what 'this' refers to.
	 * @param args* 0..n additional arguments to pass on to the callback function.
	 *              These arguments will be added after the event object.
	 * @return {EventHandle} the detach handle
	 * @static
	 * @for Event
	 */</span>
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delegate</span>(<span class="hljs-params">type, fn, el, filter</span>) </span>{
		<span class="hljs-keyword">var</span> args     = toArray(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>),
			query    = isString(el) ? el : <span class="hljs-literal">null</span>,
			typeBits, synth, container, categories, cat, i, len, handles, handle;</pre></div></div>
            
        </li>
        
        
        <li id="section-376">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-376">&#182;</a>
              </div>
              <p>Support Y.delegate({ click: fnA, key: fnB }, el, filter, …);
and Y.delegate([‘click’, ‘key’], fn, el, filter, …);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (isObject(type)) {
			handles = [];

			<span class="hljs-keyword">if</span> (isArray(type)) {
				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = type.length; i &lt; len; ++i) {
					args[<span class="hljs-number">0</span>] = type[i];
					handles.push(Y.delegate.apply(Y, args));
				}
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-377">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-377">&#182;</a>
              </div>
              <p>Y.delegate({‘click’, fn}, el, filter) =&gt;
Y.delegate(‘click’, fn, el, filter)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				args.unshift(<span class="hljs-literal">null</span>); <span class="hljs-comment">// one arg becomes two; need to make space</span>

				<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> type) {
					<span class="hljs-keyword">if</span> (type.hasOwnProperty(i)) {
						args[<span class="hljs-number">0</span>] = i;
						args[<span class="hljs-number">1</span>] = type[i];
						handles.push(Y.delegate.apply(Y, args));
					}
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Y.EventHandle(handles);
		}

		typeBits = type.split(<span class="hljs-regexp">/\|/</span>);

		<span class="hljs-keyword">if</span> (typeBits.length &gt; <span class="hljs-number">1</span>) {
			cat  = typeBits.shift();
			args[<span class="hljs-number">0</span>] = type = typeBits.shift();
		}

		synth = Y.Node.DOM_EVENTS[type];

		<span class="hljs-keyword">if</span> (isObject(synth) &amp;&amp; synth.delegate) {
			handle = synth.delegate.apply(synth, <span class="hljs-built_in">arguments</span>);
		}

		<span class="hljs-keyword">if</span> (!handle) {
			<span class="hljs-keyword">if</span> (!type || !fn || !el || !filter) {
				<span class="hljs-keyword">return</span>;
			}

			container = (query) ? Y.Selector.query(query, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>) : el;

			<span class="hljs-keyword">if</span> (!container &amp;&amp; isString(el)) {
				handle = Y.on(<span class="hljs-string">'available'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
					Y.mix(handle, Y.delegate.apply(Y, args), <span class="hljs-literal">true</span>);
				}, el);
			}

			<span class="hljs-keyword">if</span> (!handle &amp;&amp; container) {
				args.splice(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, container); <span class="hljs-comment">// remove the filter</span>

				handle = Y.Event._attach(args, { <span class="hljs-attr">facade</span>: <span class="hljs-literal">false</span> });
				handle.sub.filter  = filter;
				handle.sub._notify = delegate.notifySub;
			}
		}

		<span class="hljs-keyword">if</span> (handle &amp;&amp; cat) {
			categories = detachCategories[cat]  || (detachCategories[cat] = {});
			categories = categories[type] || (categories[type] = []);
			categories.push(handle);
		}

		<span class="hljs-keyword">return</span> handle;
	}

	<span class="hljs-comment">/**
	 Overrides the &lt;code&gt;_notify&lt;/code&gt; method on the normal DOM subscription to
	 inject the filtering logic and only proceed in the case of a match.

	 This method is hosted as a private property of the `delegate` method
	 (e.g. `Y.delegate.notifySub`)

	 @method notifySub
	 @param thisObj {Object} default 'this' object for the callback
	 @param args {Array} arguments passed to the event's &lt;code&gt;fire()&lt;/code&gt;
	 @param ce {CustomEvent} the custom event managing the DOM subscriptions for
	 the subscribed event on the subscribing node.
	 @return {Boolean} false if the event was stopped
	 @private
	 @static
	 @since 3.2.0
	 **/</span>
	delegate.notifySub = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">thisObj, args, ce</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-378">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-378">&#182;</a>
              </div>
              <p>Preserve args for other subscribers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		args = args.slice();
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.args) {
			args.push.apply(args, <span class="hljs-keyword">this</span>.args);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-379">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-379">&#182;</a>
              </div>
              <p>Only notify subs if the event occurred on a targeted element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> currentTarget = delegate._applyFilter(<span class="hljs-keyword">this</span>.filter, args, ce),</pre></div></div>
            
        </li>
        
        
        <li id="section-380">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-380">&#182;</a>
              </div>
              <p>container     = e.currentTarget,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			e, i, len, ret;

		<span class="hljs-keyword">if</span> (currentTarget) {</pre></div></div>
            
        </li>
        
        
        <li id="section-381">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-381">&#182;</a>
              </div>
              <p>Support multiple matches up the the container subtree</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			currentTarget = toArray(currentTarget);</pre></div></div>
            
        </li>
        
        
        <li id="section-382">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-382">&#182;</a>
              </div>
              <p>The second arg is the currentTarget, but we’ll be reusing this
facade, replacing the currentTarget for each use, so it doesn’t
matter what element we seed it with.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			e = args[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Y.DOMEventFacade(args[<span class="hljs-number">0</span>], ce.el, ce);

			e.container = Y.one(ce.el);

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = currentTarget.length; i &lt; len &amp;&amp; !e.stopped; ++i) {
				e.currentTarget = Y.one(currentTarget[i]);

				ret = <span class="hljs-keyword">this</span>.fn.apply(<span class="hljs-keyword">this</span>.context || e.currentTarget, args);

				<span class="hljs-keyword">if</span> (ret === <span class="hljs-literal">false</span>) { <span class="hljs-comment">// stop further notifications</span>
					<span class="hljs-keyword">break</span>;
				}
			}

			<span class="hljs-keyword">return</span> ret;
		}
	};

	<span class="hljs-comment">/**
	 Compiles a selector string into a filter function to identify whether
	 Nodes along the parent axis of an event's target should trigger event
	 notification.

	 This function is memoized, so previously compiled filter functions are
	 returned if the same selector string is provided.

	 This function may be useful when defining synthetic events for delegate
	 handling.

	 Hosted as a property of the `delegate` method (e.g. `Y.delegate.compileFilter`).

	 @method compileFilter
	 @param selector {String} the selector string to base the filtration on
	 @return {Function}
	 @since 3.2.0
	 @static
	 **/</span>
	delegate.compileFilter = Y.cached(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector</span>) </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, e</span>) </span>{
			<span class="hljs-keyword">return</span> selectorTest(target._node, selector,
				(e.currentTarget === e.target) ? <span class="hljs-literal">null</span> : e.currentTarget._node);
		};
	});

	<span class="hljs-comment">/**
	 Walks up the parent axis of an event's target, and tests each element
	 against a supplied filter function.  If any Nodes, including the container,
	 satisfy the filter, the delegated callback will be triggered for each.

	 Hosted as a protected property of the `delegate` method (e.g.
	 `Y.delegate._applyFilter`).

	 @method _applyFilter
	 @param filter {Function} boolean function to test for inclusion in event
	 notification
	 @param args {Array} the arguments that would be passed to subscribers
	 @param ce   {CustomEvent} the DOM event wrapper
	 @return {Node|Node[]|undefined} The Node or Nodes that satisfy the filter
	 @protected
	 **/</span>
	delegate._applyFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filter, args, ce</span>) </span>{
		<span class="hljs-keyword">var</span> e         = args[<span class="hljs-number">0</span>],
			container = ce.el, <span class="hljs-comment">// facadeless events in IE, have no e.currentTarget</span>
			target    = e.target || e.srcElement,
			match     = [],
			isContainer = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-383">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-383">&#182;</a>
              </div>
              <p>Resolve text nodes to their containing element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (target.nodeType === <span class="hljs-number">3</span>) {
			target = target.parentNode;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-384">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-384">&#182;</a>
              </div>
              <p>passing target as the first arg rather than leaving well enough alone
making ‘this’ in the filter function refer to the target.  This is to
support bound filter functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		args.unshift(target);

		<span class="hljs-keyword">if</span> (isString(filter)) {
			<span class="hljs-keyword">while</span> (target) {
				isContainer = (target === container);
				<span class="hljs-keyword">if</span> (selectorTest(target, filter, (isContainer ? <span class="hljs-literal">null</span>: container))) {
					match.push(target);
				}

				<span class="hljs-keyword">if</span> (isContainer) {
					<span class="hljs-keyword">break</span>;
				}

				target = target.parentNode;
			}
		} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-385">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-385">&#182;</a>
              </div>
              <p>filter functions are implementer code and should receive wrappers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			args[<span class="hljs-number">0</span>] = Y.one(target);
			args[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Y.DOMEventFacade(e, container, ce);

			<span class="hljs-keyword">while</span> (target) {</pre></div></div>
            
        </li>
        
        
        <li id="section-386">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-386">&#182;</a>
              </div>
              <p>filter(target, e, extra args…) - this === target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (filter.apply(args[<span class="hljs-number">0</span>], args)) {
					match.push(target);
				}

				<span class="hljs-keyword">if</span> (target === container) {
					<span class="hljs-keyword">break</span>;
				}

				target = target.parentNode;
				args[<span class="hljs-number">0</span>] = Y.one(target);
			}
			args[<span class="hljs-number">1</span>] = e; <span class="hljs-comment">// restore the raw DOM event</span>
		}

		<span class="hljs-keyword">if</span> (match.length &lt;= <span class="hljs-number">1</span>) {
			match = match[<span class="hljs-number">0</span>]; <span class="hljs-comment">// single match or undefined</span>
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-387">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-387">&#182;</a>
              </div>
              <p>remove the target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		args.shift();

		<span class="hljs-keyword">return</span> match;
	};

	<span class="hljs-comment">/**
	 * Sets up event delegation on a container element.  The delegated event
	 * will use a supplied filter to test if the callback should be executed.
	 * This filter can be either a selector string or a function that returns
	 * a Node to use as the currentTarget for the event.
	 *
	 * The event object for the delegated event is supplied to the callback
	 * function.  It is modified slightly in order to support all properties
	 * that may be needed for event delegation.  'currentTarget' is set to
	 * the element that matched the selector string filter or the Node returned
	 * from the filter function.  'container' is set to the element that the
	 * listener is delegated from (this normally would be the 'currentTarget').
	 *
	 * Filter functions will be called with the arguments that would be passed to
	 * the callback function, including the event object as the first parameter.
	 * The function should return false (or a falsey value) if the success criteria
	 * aren't met, and the Node to use as the event's currentTarget and 'this'
	 * object if they are.
	 *
	 * @method delegate
	 * @param type {string} the event type to delegate
	 * @param fn {function} the callback function to execute.  This function
	 * will be provided the event object for the delegated event.
	 * @param el {string|node} the element that is the delegation container
	 * @param filter {string|function} a selector that must match the target of the
	 * event or a function that returns a Node or false.
	 * @param context optional argument that specifies what 'this' refers to.
	 * @param args* 0..n additional arguments to pass on to the callback function.
	 * These arguments will be added after the event object.
	 * @return {EventHandle} the detach handle
	 * @for YUI
	 */</span>
	Y.delegate = Y.Event.delegate = delegate;


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"node-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'node-event-delegate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Functionality to make the node a delegated event container
	 * @module node
	 * @submodule node-event-delegate
	 */</span>

	<span class="hljs-comment">/**
	 * &lt;p&gt;Sets up a delegation listener for an event occurring inside the Node.
	 * The delegated event will be verified against a supplied selector or
	 * filtering function to test if the event references at least one node that
	 * should trigger the subscription callback.&lt;/p&gt;
	 *
	 * &lt;p&gt;Selector string filters will trigger the callback if the event originated
	 * from a node that matches it or is contained in a node that matches it.
	 * Function filters are called for each Node up the parent axis to the
	 * subscribing container node, and receive at each level the Node and the event
	 * object.  The function should return true (or a truthy value) if that Node
	 * should trigger the subscription callback.  Note, it is possible for filters
	 * to match multiple Nodes for a single event.  In this case, the delegate
	 * callback will be executed for each matching Node.&lt;/p&gt;
	 *
	 * &lt;p&gt;For each matching Node, the callback will be executed with its 'this'
	 * object set to the Node matched by the filter (unless a specific context was
	 * provided during subscription), and the provided event's
	 * &lt;code&gt;currentTarget&lt;/code&gt; will also be set to the matching Node.  The
	 * containing Node from which the subscription was originally made can be
	 * referenced as &lt;code&gt;e.container&lt;/code&gt;.
	 *
	 * @method delegate
	 * @param type {String} the event type to delegate
	 * @param fn {Function} the callback function to execute.  This function
	 *              will be provided the event object for the delegated event.
	 * @param spec {String|Function} a selector that must match the target of the
	 *              event or a function to test target and its parents for a match
	 * @param context {Object} optional argument that specifies what 'this' refers to.
	 * @param args* {any} 0..n additional arguments to pass on to the callback function.
	 *              These arguments will be added after the event object.
	 * @return {EventHandle} the detach handle
	 * @for Node
	 */</span>
	Y.Node.prototype.delegate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) </span>{

		<span class="hljs-keyword">var</span> args = Y.Array(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>),
			index = (Y.Lang.isObject(type) &amp;&amp; !Y.Lang.isArray(type)) ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>;

		args.splice(index, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>._node);

		<span class="hljs-keyword">return</span> Y.delegate.apply(Y, args);
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"node-base"</span>, <span class="hljs-string">"event-delegate"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'pluginhost-base'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Provides the augmentable PluginHost interface, which can be added to any class.
	 * @module pluginhost
	 */</span>

	<span class="hljs-comment">/**
	 * Provides the augmentable PluginHost interface, which can be added to any class.
	 * @module pluginhost-base
	 */</span>

	<span class="hljs-comment">/**
	 * &lt;p&gt;
	 * An augmentable class, which provides the augmented class with the ability to host plugins.
	 * It adds &lt;a href="#method_plug"&gt;plug&lt;/a&gt; and &lt;a href="#method_unplug"&gt;unplug&lt;/a&gt; methods to the augmented class, which can
	 * be used to add or remove plugins from instances of the class.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;Plugins can also be added through the constructor configuration object passed to the host class' constructor using
	 * the "plugins" property. Supported values for the "plugins" property are those defined by the &lt;a href="#method_plug"&gt;plug&lt;/a&gt; method.
	 *
	 * For example the following code would add the AnimPlugin and IOPlugin to Overlay (the plugin host):
	 * &lt;xmp&gt;
	 * var o = new Overlay({plugins: [ AnimPlugin, {fn:IOPlugin, cfg:{section:"header"}}]});
	 * &lt;/xmp&gt;
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * Plug.Host's protected &lt;a href="#method_initPlugins"&gt;_initPlugins&lt;/a&gt; and &lt;a href="#method_destroyPlugins"&gt;_destroyPlugins&lt;/a&gt;
	 * methods should be invoked by the host class at the appropriate point in the host's lifecyle.
	 * &lt;/p&gt;
	 *
	 * @class Plugin.Host
	 */</span>

	<span class="hljs-keyword">var</span> L = Y.Lang;

	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PluginHost</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">this</span>._plugins = {};
	}

	PluginHost.prototype = {

		<span class="hljs-comment">/**
		 * Adds a plugin to the host object. This will instantiate the
		 * plugin and attach it to the configured namespace on the host object.
		 *
		 * @method plug
		 * @chainable
		 * @param P {Function | Object |Array} Accepts the plugin class, or an
		 * object with a "fn" property specifying the plugin class and
		 * a "cfg" property specifying the configuration for the Plugin.
		 * &lt;p&gt;
		 * Additionally an Array can also be passed in, with the above function or
		 * object values, allowing the user to add multiple plugins in a single call.
		 * &lt;/p&gt;
		 * @param [config] If the first argument is the plugin class, the second argument
		 * can be the configuration for the plugin.
		 * @return {Base} A reference to the host object
		 */</span>
		plug: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Plugin, config</span>) </span>{
			<span class="hljs-keyword">var</span> i, ln, ns;

			<span class="hljs-keyword">if</span> (L.isArray(Plugin)) {
				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, ln = Plugin.length; i &lt; ln; i++) {
					<span class="hljs-keyword">this</span>.plug(Plugin[i]);
				}
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">if</span> (Plugin &amp;&amp; !L.isFunction(Plugin)) {
					config = Plugin.cfg;
					Plugin = Plugin.fn;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-388">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-388">&#182;</a>
              </div>
              <p>Plugin should be fn by now</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (Plugin &amp;&amp; Plugin.NS) {
					ns = Plugin.NS;

					config = config || {};
					config.host = <span class="hljs-keyword">this</span>;

					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasPlugin(ns)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-389">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-389">&#182;</a>
              </div>
              <p>Update config</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[ns].setAttrs) {
							<span class="hljs-keyword">this</span>[ns].setAttrs(config);
						}
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-390">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-390">&#182;</a>
              </div>
              <p>Create new instance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">this</span>[ns] = <span class="hljs-keyword">new</span> Plugin(config);
						<span class="hljs-keyword">this</span>._plugins[ns] = Plugin;
					}
				}
			}
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Removes a plugin from the host object. This will destroy the
		 * plugin instance and delete the namespace from the host object.
		 *
		 * @method unplug
		 * @param {String | Function} plugin The namespace of the plugin, or the plugin class with the static NS namespace property defined. If not provided,
		 * all registered plugins are unplugged.
		 * @return {Base} A reference to the host object
		 * @chainable
		 */</span>
		unplug: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">plugin</span>) </span>{
			<span class="hljs-keyword">var</span> ns = plugin,
				plugins = <span class="hljs-keyword">this</span>._plugins;

			<span class="hljs-keyword">if</span> (plugin) {
				<span class="hljs-keyword">if</span> (L.isFunction(plugin)) {
					ns = plugin.NS;
					<span class="hljs-keyword">if</span> (ns &amp;&amp; (!plugins[ns] || plugins[ns] !== plugin)) {
						ns = <span class="hljs-literal">null</span>;
					}
				}

				<span class="hljs-keyword">if</span> (ns) {
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[ns]) {
						<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[ns].destroy) {
							<span class="hljs-keyword">this</span>[ns].destroy();
						}
						<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>[ns];
					}
					<span class="hljs-keyword">if</span> (plugins[ns]) {
						<span class="hljs-keyword">delete</span> plugins[ns];
					}
				}
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">for</span> (ns <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._plugins) {
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._plugins.hasOwnProperty(ns)) {
						<span class="hljs-keyword">this</span>.unplug(ns);
					}
				}
			}
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},

		<span class="hljs-comment">/**
		 * Determines if a plugin has plugged into this host.
		 *
		 * @method hasPlugin
		 * @param {String} ns The plugin's namespace
		 * @return {Plugin} Returns a truthy value (the plugin instance) if present, or undefined if not.
		 */</span>
		hasPlugin : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ns</span>) </span>{
			<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>._plugins[ns] &amp;&amp; <span class="hljs-keyword">this</span>[ns]);
		},

		<span class="hljs-comment">/**
		 * Initializes static plugins registered on the host (using the
		 * Base.plug static method) and any plugins passed to the
		 * instance through the "plugins" configuration property.
		 *
		 * @method _initPlugins
		 * @param {Config} config The configuration object with property name/value pairs.
		 * @private
		 */</span>

		_initPlugins: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) </span>{
			<span class="hljs-keyword">this</span>._plugins = <span class="hljs-keyword">this</span>._plugins || {};

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._initConfigPlugins) {
				<span class="hljs-keyword">this</span>._initConfigPlugins(config);
			}
		},

		<span class="hljs-comment">/**
		 * Unplugs and destroys all plugins on the host
		 * @method _destroyPlugins
		 * @private
		 */</span>
		_destroyPlugins: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">this</span>.unplug();
		}
	};

	Y.namespace(<span class="hljs-string">"Plugin"</span>).Host = PluginHost;


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'pluginhost-config'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Adds pluginhost constructor configuration and static configuration support
	 * @submodule pluginhost-config
	 */</span>

	<span class="hljs-keyword">var</span> PluginHost = Y.Plugin.Host,
		L = Y.Lang;

	<span class="hljs-comment">/**
	 * A protected initialization method, used by the host class to initialize
	 * plugin configurations passed the constructor, through the config object.
	 *
	 * Host objects should invoke this method at the appropriate time in their
	 * construction lifecycle.
	 *
	 * @method _initConfigPlugins
	 * @param {Object} config The configuration object passed to the constructor
	 * @protected
	 * @for Plugin.Host
	 */</span>
	PluginHost.prototype._initConfigPlugins = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-391">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-391">&#182;</a>
              </div>
              <p>Class Configuration</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> classes = (<span class="hljs-keyword">this</span>._getClasses) ? <span class="hljs-keyword">this</span>._getClasses() : [<span class="hljs-keyword">this</span>.constructor],
			plug = [],
			unplug = {},
			<span class="hljs-keyword">constructor</span>, i, classPlug, classUnplug, pluginClassName;</pre></div></div>
            
        </li>
        
        
        <li id="section-392">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-392">&#182;</a>
              </div>
              <p>TODO: Room for optimization. Can we apply statically/unplug in same pass?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i = classes.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
			<span class="hljs-keyword">constructor</span> = classes[i];

			classUnplug = <span class="hljs-keyword">constructor</span>._UNPLUG;
			if (classUnplug) {</pre></div></div>
            
        </li>
        
        
        <li id="section-393">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-393">&#182;</a>
              </div>
              <p>subclasses over-write</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				Y.mix(unplug, classUnplug, <span class="hljs-literal">true</span>);
			}

			classPlug = <span class="hljs-keyword">constructor</span>._PLUG;
			if (classPlug) {</pre></div></div>
            
        </li>
        
        
        <li id="section-394">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-394">&#182;</a>
              </div>
              <p>subclasses over-write</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				Y.mix(plug, classPlug, <span class="hljs-literal">true</span>);
			}
		}

		<span class="hljs-keyword">for</span> (pluginClassName <span class="hljs-keyword">in</span> plug) {
			<span class="hljs-keyword">if</span> (plug.hasOwnProperty(pluginClassName)) {
				<span class="hljs-keyword">if</span> (!unplug[pluginClassName]) {
					<span class="hljs-keyword">this</span>.plug(plug[pluginClassName]);
				}
			}
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-395">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-395">&#182;</a>
              </div>
              <p>User Configuration</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (config &amp;&amp; config.plugins) {
			<span class="hljs-keyword">this</span>.plug(config.plugins);
		}
	};

	<span class="hljs-comment">/**
	 * Registers plugins to be instantiated at the class level (plugins
	 * which should be plugged into every instance of the class by default).
	 *
	 * @method plug
	 * @static
	 *
	 * @param {Function} hostClass The host class on which to register the plugins
	 * @param {Function | Array} plugin Either the plugin class, an array of plugin classes or an array of objects (with fn and cfg properties defined)
	 * @param {Object} [config] If plugin is the plugin class, the configuration for the plugin
	 * @for Plugin.Host
	 */</span>
	PluginHost.plug = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hostClass, plugin, config</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-396">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-396">&#182;</a>
              </div>
              <p>Cannot plug into Base, since Plugins derive from Base [ will cause infinite recurrsion ]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> p, i, l, name;

		<span class="hljs-keyword">if</span> (hostClass !== Y.Base) {
			hostClass._PLUG = hostClass._PLUG || {};

			<span class="hljs-keyword">if</span> (!L.isArray(plugin)) {
				<span class="hljs-keyword">if</span> (config) {
					plugin = {<span class="hljs-attr">fn</span>:plugin, <span class="hljs-attr">cfg</span>:config};
				}
				plugin = [plugin];
			}

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = plugin.length; i &lt; l;i++) {
				p = plugin[i];
				name = p.NAME || p.fn.NAME;
				hostClass._PLUG[name] = p;
			}
		}
	};

	<span class="hljs-comment">/**
	 * Unregisters any class level plugins which have been registered by the host class, or any
	 * other class in the hierarchy.
	 *
	 * @method unplug
	 * @static
	 *
	 * @param {Function} hostClass The host class from which to unregister the plugins
	 * @param {Function | Array} plugin The plugin class, or an array of plugin classes
	 * @for Plugin.Host
	 */</span>
	PluginHost.unplug = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hostClass, plugin</span>) </span>{
		<span class="hljs-keyword">var</span> p, i, l, name;

		<span class="hljs-keyword">if</span> (hostClass !== Y.Base) {
			hostClass._UNPLUG = hostClass._UNPLUG || {};

			<span class="hljs-keyword">if</span> (!L.isArray(plugin)) {
				plugin = [plugin];
			}

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = plugin.length; i &lt; l; i++) {
				p = plugin[i];
				name = p.NAME;
				<span class="hljs-keyword">if</span> (!hostClass._PLUG[name]) {
					hostClass._UNPLUG[name] = p;
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">delete</span> hostClass._PLUG[name];
				}
			}
		}
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"pluginhost-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'node-pluginhost'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * @module node
	 * @submodule node-pluginhost
	 */</span>

	<span class="hljs-comment">/**
	 * Registers plugins to be instantiated at the class level (plugins
	 * which should be plugged into every instance of Node by default).
	 *
	 * @method plug
	 * @static
	 * @for Node
	 * @param {Function | Array} plugin Either the plugin class, an array of plugin classes or an array of objects (with fn and cfg properties defined)
	 * @param {Object} [config] If plugin is the plugin class, the configuration for the plugin
	 */</span>
	Y.Node.plug = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">var</span> args = Y.Array(<span class="hljs-built_in">arguments</span>);
		args.unshift(Y.Node);
		Y.Plugin.Host.plug.apply(Y.Base, args);
		<span class="hljs-keyword">return</span> Y.Node;
	};

	<span class="hljs-comment">/**
	 * Unregisters any class level plugins which have been registered by the Node
	 *
	 * @method unplug
	 * @static
	 *
	 * @param {Function | Array} plugin The plugin class, or an array of plugin classes
	 */</span>
	Y.Node.unplug = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">var</span> args = Y.Array(<span class="hljs-built_in">arguments</span>);
		args.unshift(Y.Node);
		Y.Plugin.Host.unplug.apply(Y.Base, args);
		<span class="hljs-keyword">return</span> Y.Node;
	};

	Y.mix(Y.Node, Y.Plugin.Host, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-397">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-397">&#182;</a>
              </div>
              <p>allow batching of plug/unplug via NodeList
doesn’t use NodeList.importMethod because we need real Nodes (not tmpNode)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * Adds a plugin to each node in the NodeList.
	 * This will instantiate the plugin and attach it to the configured namespace on each node
	 * @method plug
	 * @for NodeList
	 * @param P {Function | Object |Array} Accepts the plugin class, or an
	 * object with a "fn" property specifying the plugin class and
	 * a "cfg" property specifying the configuration for the Plugin.
	 * &lt;p&gt;
	 * Additionally an Array can also be passed in, with the above function or
	 * object values, allowing the user to add multiple plugins in a single call.
	 * &lt;/p&gt;
	 * @param [config] If the first argument is the plugin class, the second argument
	 * can be the configuration for the plugin.
	 * @chainable
	 */</span>
	Y.NodeList.prototype.plug = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
		Y.NodeList.each(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			Y.Node.prototype.plug.apply(Y.one(node), args);
		});
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	};

	<span class="hljs-comment">/**
	 * Removes a plugin from all nodes in the NodeList. This will destroy the
	 * plugin instance and delete the namespace each node.
	 * @method unplug
	 * @for NodeList
	 * @param {String | Function} plugin The namespace of the plugin, or the plugin class with the static NS namespace property defined. If not provided,
	 * all registered plugins are unplugged.
	 * @chainable
	 */</span>
	Y.NodeList.prototype.unplug = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
		Y.NodeList.each(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			Y.Node.prototype.unplug.apply(Y.one(node), args);
		});
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"node-base"</span>, <span class="hljs-string">"pluginhost"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'dom-style'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
		<span class="hljs-comment">/**
		 * Add style management functionality to DOM.
		 * @module dom
		 * @submodule dom-style
		 * @for DOM
		 */</span>

		<span class="hljs-keyword">var</span> DOCUMENT_ELEMENT = <span class="hljs-string">'documentElement'</span>,
			DEFAULT_VIEW = <span class="hljs-string">'defaultView'</span>,
			OWNER_DOCUMENT = <span class="hljs-string">'ownerDocument'</span>,
			STYLE = <span class="hljs-string">'style'</span>,
			FLOAT = <span class="hljs-string">'float'</span>,
			CSS_FLOAT = <span class="hljs-string">'cssFloat'</span>,
			STYLE_FLOAT = <span class="hljs-string">'styleFloat'</span>,
			TRANSPARENT = <span class="hljs-string">'transparent'</span>,
			GET_COMPUTED_STYLE = <span class="hljs-string">'getComputedStyle'</span>,
			GET_BOUNDING_CLIENT_RECT = <span class="hljs-string">'getBoundingClientRect'</span>,

			WINDOW = Y.config.win,
			DOCUMENT = Y.config.doc,
			UNDEFINED = <span class="hljs-literal">undefined</span>,

			Y_DOM = Y.DOM,

			TRANSFORM = <span class="hljs-string">'transform'</span>,
			TRANSFORMORIGIN = <span class="hljs-string">'transformOrigin'</span>,
			VENDOR_TRANSFORM = [
				<span class="hljs-string">'WebkitTransform'</span>,
				<span class="hljs-string">'MozTransform'</span>,
				<span class="hljs-string">'OTransform'</span>,
				<span class="hljs-string">'msTransform'</span>
			],

			re_color = <span class="hljs-regexp">/color$/i</span>,
			re_unit = <span class="hljs-regexp">/width|height|top|left|right|bottom|margin|padding/i</span>;

		Y.Array.each(VENDOR_TRANSFORM, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
			<span class="hljs-keyword">if</span> (val <span class="hljs-keyword">in</span> DOCUMENT[DOCUMENT_ELEMENT].style) {
				TRANSFORM = val;
				TRANSFORMORIGIN = val + <span class="hljs-string">"Origin"</span>;
			}
		});

		Y.mix(Y_DOM, {
			<span class="hljs-attr">DEFAULT_UNIT</span>: <span class="hljs-string">'px'</span>,

			<span class="hljs-attr">CUSTOM_STYLES</span>: {
			},


			<span class="hljs-comment">/**
			 * Sets a style property for a given element.
			 * @method setStyle
			 * @param {HTMLElement} An HTMLElement to apply the style to.
			 * @param {String} att The style property to set.
			 * @param {String|Number} val The value.
			 */</span>
			setStyle: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, att, val, style</span>) </span>{
				style = style || node.style;
				<span class="hljs-keyword">var</span> CUSTOM_STYLES = Y_DOM.CUSTOM_STYLES;

				<span class="hljs-keyword">if</span> (style) {
					<span class="hljs-keyword">if</span> (val === <span class="hljs-literal">null</span> || val === <span class="hljs-string">''</span>) { <span class="hljs-comment">// normalize unsetting</span>
						val = <span class="hljs-string">''</span>;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(val)) &amp;&amp; re_unit.test(att)) { <span class="hljs-comment">// number values may need a unit</span>
						val += Y_DOM.DEFAULT_UNIT;
					}

					<span class="hljs-keyword">if</span> (att <span class="hljs-keyword">in</span> CUSTOM_STYLES) {
						<span class="hljs-keyword">if</span> (CUSTOM_STYLES[att].set) {
							CUSTOM_STYLES[att].set(node, val, style);
							<span class="hljs-keyword">return</span>; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> return</span>
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> CUSTOM_STYLES[att] === <span class="hljs-string">'string'</span>) {
							att = CUSTOM_STYLES[att];
						}
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (att === <span class="hljs-string">''</span>) { <span class="hljs-comment">// unset inline styles</span>
						att = <span class="hljs-string">'cssText'</span>;
						val = <span class="hljs-string">''</span>;
					}
					style[att] = val;
				}
			},

			<span class="hljs-comment">/**
			 * Returns the current style value for the given property.
			 * @method getStyle
			 * @param {HTMLElement} An HTMLElement to get the style from.
			 * @param {String} att The style property to get.
			 */</span>
			getStyle: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, att, style</span>) </span>{
				style = style || node.style;
				<span class="hljs-keyword">var</span> CUSTOM_STYLES = Y_DOM.CUSTOM_STYLES,
					val = <span class="hljs-string">''</span>;

				<span class="hljs-keyword">if</span> (style) {
					<span class="hljs-keyword">if</span> (att <span class="hljs-keyword">in</span> CUSTOM_STYLES) {
						<span class="hljs-keyword">if</span> (CUSTOM_STYLES[att].get) {
							<span class="hljs-keyword">return</span> CUSTOM_STYLES[att].get(node, att, style); <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> return</span>
						} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> CUSTOM_STYLES[att] === <span class="hljs-string">'string'</span>) {
							att = CUSTOM_STYLES[att];
						}
					}
					val = style[att];
					<span class="hljs-keyword">if</span> (val === <span class="hljs-string">''</span>) { <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> is empty string sufficient?</span>
						val = Y_DOM[GET_COMPUTED_STYLE](node, att);
					}
				}

				<span class="hljs-keyword">return</span> val;
			},

			<span class="hljs-comment">/**
			 * Sets multiple style properties.
			 * @method setStyles
			 * @param {HTMLElement} node An HTMLElement to apply the styles to.
			 * @param {Object} hash An object literal of property:value pairs.
			 */</span>
			setStyles: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, hash</span>) </span>{
				<span class="hljs-keyword">var</span> style = node.style;
				Y.each(hash, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, n</span>) </span>{
					Y_DOM.setStyle(node, n, v, style);
				}, Y_DOM);
			},

			<span class="hljs-comment">/**
			 * Returns the computed style for the given node.
			 * @method getComputedStyle
			 * @param {HTMLElement} An HTMLElement to get the style from.
			 * @param {String} att The style property to get.
			 * @return {String} The computed value of the style property.
			 */</span>
			getComputedStyle: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, att</span>) </span>{
				<span class="hljs-keyword">var</span> val = <span class="hljs-string">''</span>,
					doc = node[OWNER_DOCUMENT],
					computed;

				<span class="hljs-keyword">if</span> (node[STYLE] &amp;&amp; doc[DEFAULT_VIEW] &amp;&amp; doc[DEFAULT_VIEW][GET_COMPUTED_STYLE]) {
					computed = doc[DEFAULT_VIEW][GET_COMPUTED_STYLE](node, <span class="hljs-literal">null</span>);
					<span class="hljs-keyword">if</span> (computed) { <span class="hljs-comment">// FF may be null in some cases (ticket #2530548)</span>
						val = computed[att];
					}
				}
				<span class="hljs-keyword">return</span> val;
			}
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-398">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-398">&#182;</a>
              </div>
              <p>normalize reserved word float alternatives (“cssFloat” or “styleFloat”)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (DOCUMENT[DOCUMENT_ELEMENT][STYLE][CSS_FLOAT] !== UNDEFINED) {
			Y_DOM.CUSTOM_STYLES[FLOAT] = CSS_FLOAT;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DOCUMENT[DOCUMENT_ELEMENT][STYLE][STYLE_FLOAT] !== UNDEFINED) {
			Y_DOM.CUSTOM_STYLES[FLOAT] = STYLE_FLOAT;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-399">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-399">&#182;</a>
              </div>
              <p>fix opera computedStyle default color unit (convert to rgb)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (Y.UA.opera) {
			Y_DOM[GET_COMPUTED_STYLE] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, att</span>) </span>{
				<span class="hljs-keyword">var</span> view = node[OWNER_DOCUMENT][DEFAULT_VIEW],
					val = view[GET_COMPUTED_STYLE](node, <span class="hljs-string">''</span>)[att];

				<span class="hljs-keyword">if</span> (re_color.test(att)) {
					val = Y.Color.toRGB(val);
				}

				<span class="hljs-keyword">return</span> val;
			};

		}</pre></div></div>
            
        </li>
        
        
        <li id="section-400">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-400">&#182;</a>
              </div>
              <p>safari converts transparent to rgba(), others use “transparent”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (Y.UA.webkit) {
			Y_DOM[GET_COMPUTED_STYLE] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, att</span>) </span>{
				<span class="hljs-keyword">var</span> view = node[OWNER_DOCUMENT][DEFAULT_VIEW],
					val = view[GET_COMPUTED_STYLE](node, <span class="hljs-string">''</span>)[att];

				<span class="hljs-keyword">if</span> (val === <span class="hljs-string">'rgba(0, 0, 0, 0)'</span>) {
					val = TRANSPARENT;
				}

				<span class="hljs-keyword">return</span> val;
			};

		}

		Y.DOM._getAttrOffset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, attr</span>) </span>{
			<span class="hljs-keyword">var</span> val = Y.DOM[GET_COMPUTED_STYLE](node, attr),
				offsetParent = node.offsetParent,
				position,
				parentOffset,
				offset;

			<span class="hljs-keyword">if</span> (val === <span class="hljs-string">'auto'</span>) {
				position = Y.DOM.getStyle(node, <span class="hljs-string">'position'</span>);
				<span class="hljs-keyword">if</span> (position === <span class="hljs-string">'static'</span> || position === <span class="hljs-string">'relative'</span>) {
					val = <span class="hljs-number">0</span>;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offsetParent &amp;&amp; offsetParent[GET_BOUNDING_CLIENT_RECT]) {
					parentOffset = offsetParent[GET_BOUNDING_CLIENT_RECT]()[attr];
					offset = node[GET_BOUNDING_CLIENT_RECT]()[attr];
					<span class="hljs-keyword">if</span> (attr === <span class="hljs-string">'left'</span> || attr === <span class="hljs-string">'top'</span>) {
						val = offset - parentOffset;
					} <span class="hljs-keyword">else</span> {
						val = parentOffset - node[GET_BOUNDING_CLIENT_RECT]()[attr];
					}
				}
			}

			<span class="hljs-keyword">return</span> val;
		};

		Y.DOM._getOffset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
			<span class="hljs-keyword">var</span> pos,
				xy = <span class="hljs-literal">null</span>;

			<span class="hljs-keyword">if</span> (node) {
				pos = Y_DOM.getStyle(node, <span class="hljs-string">'position'</span>);
				xy = [
					<span class="hljs-built_in">parseInt</span>(Y_DOM[GET_COMPUTED_STYLE](node, <span class="hljs-string">'left'</span>), <span class="hljs-number">10</span>),
					<span class="hljs-built_in">parseInt</span>(Y_DOM[GET_COMPUTED_STYLE](node, <span class="hljs-string">'top'</span>), <span class="hljs-number">10</span>)
				];

				<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">isNaN</span>(xy[<span class="hljs-number">0</span>]) ) { <span class="hljs-comment">// in case of 'auto'</span>
					xy[<span class="hljs-number">0</span>] = <span class="hljs-built_in">parseInt</span>(Y_DOM.getStyle(node, <span class="hljs-string">'left'</span>), <span class="hljs-number">10</span>); <span class="hljs-comment">// try inline</span>
					<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">isNaN</span>(xy[<span class="hljs-number">0</span>]) ) { <span class="hljs-comment">// default to offset value</span>
						xy[<span class="hljs-number">0</span>] = (pos === <span class="hljs-string">'relative'</span>) ? <span class="hljs-number">0</span> : node.offsetLeft || <span class="hljs-number">0</span>;
					}
				}

				<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">isNaN</span>(xy[<span class="hljs-number">1</span>]) ) { <span class="hljs-comment">// in case of 'auto'</span>
					xy[<span class="hljs-number">1</span>] = <span class="hljs-built_in">parseInt</span>(Y_DOM.getStyle(node, <span class="hljs-string">'top'</span>), <span class="hljs-number">10</span>); <span class="hljs-comment">// try inline</span>
					<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">isNaN</span>(xy[<span class="hljs-number">1</span>]) ) { <span class="hljs-comment">// default to offset value</span>
						xy[<span class="hljs-number">1</span>] = (pos === <span class="hljs-string">'relative'</span>) ? <span class="hljs-number">0</span> : node.offsetTop || <span class="hljs-number">0</span>;
					}
				}
			}

			<span class="hljs-keyword">return</span> xy;

		};

		Y_DOM.CUSTOM_STYLES.transform = {
			<span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, val, style</span>) </span>{
				style[TRANSFORM] = val;
			},

			<span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, style</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM[GET_COMPUTED_STYLE](node, TRANSFORM);
			}
		};

		Y_DOM.CUSTOM_STYLES.transformOrigin = {
			<span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, val, style</span>) </span>{
				style[TRANSFORMORIGIN] = val;
			},

			<span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, style</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM[GET_COMPUTED_STYLE](node, TRANSFORMORIGIN);
			}
		};


	})(Y);
	(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
		<span class="hljs-keyword">var</span> PARSE_INT = <span class="hljs-built_in">parseInt</span>,
			RE = <span class="hljs-built_in">RegExp</span>;

		Y.Color = {
			<span class="hljs-attr">KEYWORDS</span>: {
				<span class="hljs-attr">black</span>: <span class="hljs-string">'000'</span>,
				<span class="hljs-attr">silver</span>: <span class="hljs-string">'c0c0c0'</span>,
				<span class="hljs-attr">gray</span>: <span class="hljs-string">'808080'</span>,
				<span class="hljs-attr">white</span>: <span class="hljs-string">'fff'</span>,
				<span class="hljs-attr">maroon</span>: <span class="hljs-string">'800000'</span>,
				<span class="hljs-attr">red</span>: <span class="hljs-string">'f00'</span>,
				<span class="hljs-attr">purple</span>: <span class="hljs-string">'800080'</span>,
				<span class="hljs-attr">fuchsia</span>: <span class="hljs-string">'f0f'</span>,
				<span class="hljs-attr">green</span>: <span class="hljs-string">'008000'</span>,
				<span class="hljs-attr">lime</span>: <span class="hljs-string">'0f0'</span>,
				<span class="hljs-attr">olive</span>: <span class="hljs-string">'808000'</span>,
				<span class="hljs-attr">yellow</span>: <span class="hljs-string">'ff0'</span>,
				<span class="hljs-attr">navy</span>: <span class="hljs-string">'000080'</span>,
				<span class="hljs-attr">blue</span>: <span class="hljs-string">'00f'</span>,
				<span class="hljs-attr">teal</span>: <span class="hljs-string">'008080'</span>,
				<span class="hljs-attr">aqua</span>: <span class="hljs-string">'0ff'</span>
			},

			<span class="hljs-attr">re_RGB</span>: <span class="hljs-regexp">/^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i</span>,
			<span class="hljs-attr">re_hex</span>: <span class="hljs-regexp">/^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i</span>,
			<span class="hljs-attr">re_hex3</span>: <span class="hljs-regexp">/([0-9A-F])/gi</span>,

			<span class="hljs-attr">toRGB</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
				<span class="hljs-keyword">if</span> (!Y.Color.re_RGB.test(val)) {
					val = Y.Color.toHex(val);
				}

				<span class="hljs-keyword">if</span>(Y.Color.re_hex.exec(val)) {
					val = <span class="hljs-string">'rgb('</span> + [
						PARSE_INT(RE.$<span class="hljs-number">1</span>, <span class="hljs-number">16</span>),
						PARSE_INT(RE.$<span class="hljs-number">2</span>, <span class="hljs-number">16</span>),
						PARSE_INT(RE.$<span class="hljs-number">3</span>, <span class="hljs-number">16</span>)
					].join(<span class="hljs-string">', '</span>) + <span class="hljs-string">')'</span>;
				}
				<span class="hljs-keyword">return</span> val;
			},

			<span class="hljs-attr">toHex</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
				val = Y.Color.KEYWORDS[val] || val;
				<span class="hljs-keyword">if</span> (Y.Color.re_RGB.exec(val)) {
					val = [
						<span class="hljs-built_in">Number</span>(RE.$<span class="hljs-number">1</span>).toString(<span class="hljs-number">16</span>),
						<span class="hljs-built_in">Number</span>(RE.$<span class="hljs-number">2</span>).toString(<span class="hljs-number">16</span>),
						<span class="hljs-built_in">Number</span>(RE.$<span class="hljs-number">3</span>).toString(<span class="hljs-number">16</span>)
					];

					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; val.length; i++) {
						<span class="hljs-keyword">if</span> (val[i].length &lt; <span class="hljs-number">2</span>) {
							val[i] = <span class="hljs-string">'0'</span> + val[i];
						}
					}

					val = val.join(<span class="hljs-string">''</span>);
				}

				<span class="hljs-keyword">if</span> (val.length &lt; <span class="hljs-number">6</span>) {
					val = val.replace(Y.Color.re_hex3, <span class="hljs-string">'$1$1'</span>);
				}

				<span class="hljs-keyword">if</span> (val !== <span class="hljs-string">'transparent'</span> &amp;&amp; val.indexOf(<span class="hljs-string">'#'</span>) &lt; <span class="hljs-number">0</span>) {
					val = <span class="hljs-string">'#'</span> + val;
				}

				<span class="hljs-keyword">return</span> val.toUpperCase();
			}
		};
	})(Y);



}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"dom-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'dom-screen'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{

		<span class="hljs-comment">/**
		 * Adds position and region management functionality to DOM.
		 * @module dom
		 * @submodule dom-screen
		 * @for DOM
		 */</span>

		<span class="hljs-keyword">var</span> DOCUMENT_ELEMENT = <span class="hljs-string">'documentElement'</span>,
			COMPAT_MODE = <span class="hljs-string">'compatMode'</span>,
			POSITION = <span class="hljs-string">'position'</span>,
			FIXED = <span class="hljs-string">'fixed'</span>,
			RELATIVE = <span class="hljs-string">'relative'</span>,
			LEFT = <span class="hljs-string">'left'</span>,
			TOP = <span class="hljs-string">'top'</span>,
			_BACK_COMPAT = <span class="hljs-string">'BackCompat'</span>,
			MEDIUM = <span class="hljs-string">'medium'</span>,
			BORDER_LEFT_WIDTH = <span class="hljs-string">'borderLeftWidth'</span>,
			BORDER_TOP_WIDTH = <span class="hljs-string">'borderTopWidth'</span>,
			GET_BOUNDING_CLIENT_RECT = <span class="hljs-string">'getBoundingClientRect'</span>,
			GET_COMPUTED_STYLE = <span class="hljs-string">'getComputedStyle'</span>,

			Y_DOM = Y.DOM,</pre></div></div>
            
        </li>
        
        
        <li id="section-401">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-401">&#182;</a>
              </div>
              <p>TODO: how about thead/tbody/tfoot/tr?
TODO: does caption matter?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			RE_TABLE = <span class="hljs-regexp">/^t(?:able|d|h)$/i</span>,

			SCROLL_NODE;

		<span class="hljs-keyword">if</span> (Y.UA.ie) {
			<span class="hljs-keyword">if</span> (Y.config.doc[COMPAT_MODE] !== <span class="hljs-string">'BackCompat'</span>) {
				SCROLL_NODE = DOCUMENT_ELEMENT;
			} <span class="hljs-keyword">else</span> {
				SCROLL_NODE = <span class="hljs-string">'body'</span>;
			}
		}

		Y.mix(Y_DOM, {
			<span class="hljs-comment">/**
			 * Returns the inner height of the viewport (exludes scrollbar).
			 * @method winHeight
			 * @return {Number} The current height of the viewport.
			 */</span>
			winHeight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">var</span> h = Y_DOM._getWinSize(node).height;
				<span class="hljs-keyword">return</span> h;
			},

			<span class="hljs-comment">/**
			 * Returns the inner width of the viewport (exludes scrollbar).
			 * @method winWidth
			 * @return {Number} The current width of the viewport.
			 */</span>
			winWidth: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">var</span> w = Y_DOM._getWinSize(node).width;
				<span class="hljs-keyword">return</span> w;
			},

			<span class="hljs-comment">/**
			 * Document height
			 * @method docHeight
			 * @return {Number} The current height of the document.
			 */</span>
			docHeight:  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">var</span> h = Y_DOM._getDocSize(node).height;
				<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(h, Y_DOM._getWinSize(node).height);
			},

			<span class="hljs-comment">/**
			 * Document width
			 * @method docWidth
			 * @return {Number} The current width of the document.
			 */</span>
			docWidth:  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">var</span> w = Y_DOM._getDocSize(node).width;
				<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(w, Y_DOM._getWinSize(node).width);
			},

			<span class="hljs-comment">/**
			 * Amount page has been scroll horizontally
			 * @method docScrollX
			 * @return {Number} The current amount the screen is scrolled horizontally.
			 */</span>
			docScrollX: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, doc</span>) </span>{
				doc = doc || (node) ? Y_DOM._getDoc(node) : Y.config.doc; <span class="hljs-comment">// perf optimization</span>
				<span class="hljs-keyword">var</span> dv = doc.defaultView,
					pageOffset = (dv) ? dv.pageXOffset : <span class="hljs-number">0</span>;
				<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(doc[DOCUMENT_ELEMENT].scrollLeft, doc.body.scrollLeft, pageOffset);
			},

			<span class="hljs-comment">/**
			 * Amount page has been scroll vertically
			 * @method docScrollY
			 * @return {Number} The current amount the screen is scrolled vertically.
			 */</span>
			docScrollY:  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, doc</span>) </span>{
				doc = doc || (node) ? Y_DOM._getDoc(node) : Y.config.doc; <span class="hljs-comment">// perf optimization</span>
				<span class="hljs-keyword">var</span> dv = doc.defaultView,
					pageOffset = (dv) ? dv.pageYOffset : <span class="hljs-number">0</span>;
				<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(doc[DOCUMENT_ELEMENT].scrollTop, doc.body.scrollTop, pageOffset);
			},

			<span class="hljs-comment">/**
			 * Gets the current position of an element based on page coordinates.
			 * Element must be part of the DOM tree to have page coordinates
			 * (display:none or elements not appended return false).
			 * @method getXY
			 * @param element The target element
			 * @return {Array} The XY position of the element

			 <span class="hljs-doctag">TODO:</span> test inDocument/display?
			 */</span>
			getXY: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">if</span> (Y.config.doc[DOCUMENT_ELEMENT][GET_BOUNDING_CLIENT_RECT]) {
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
						<span class="hljs-keyword">var</span> xy = <span class="hljs-literal">null</span>,
							scrollLeft,
							scrollTop,
							mode,
							box,
							offX,
							offY,
							doc,
							win,
							inDoc,
							rootNode;

						<span class="hljs-keyword">if</span> (node &amp;&amp; node.tagName) {
							doc = node.ownerDocument;
							mode = doc[COMPAT_MODE];

							<span class="hljs-keyword">if</span> (mode !== _BACK_COMPAT) {
								rootNode = doc[DOCUMENT_ELEMENT];
							} <span class="hljs-keyword">else</span> {
								rootNode = doc.body;
							}</pre></div></div>
            
        </li>
        
        
        <li id="section-402">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-402">&#182;</a>
              </div>
              <p>inline inDoc check for perf</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">if</span> (rootNode.contains) {
								inDoc = rootNode.contains(node);
							} <span class="hljs-keyword">else</span> {
								inDoc = Y.DOM.contains(rootNode, node);
							}

							<span class="hljs-keyword">if</span> (inDoc) {
								win = doc.defaultView;</pre></div></div>
            
        </li>
        
        
        <li id="section-403">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-403">&#182;</a>
              </div>
              <p>inline scroll calc for perf</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (win &amp;&amp; <span class="hljs-string">'pageXOffset'</span> <span class="hljs-keyword">in</span> win) {
									scrollLeft = win.pageXOffset;
									scrollTop = win.pageYOffset;
								} <span class="hljs-keyword">else</span> {
									scrollLeft = (SCROLL_NODE) ? doc[SCROLL_NODE].scrollLeft : Y_DOM.docScrollX(node, doc);
									scrollTop = (SCROLL_NODE) ? doc[SCROLL_NODE].scrollTop : Y_DOM.docScrollY(node, doc);
								}

								<span class="hljs-keyword">if</span> (Y.UA.ie) { <span class="hljs-comment">// IE &lt; 8, quirks, or compatMode</span>
									<span class="hljs-keyword">if</span> (!doc.documentMode || doc.documentMode &lt; <span class="hljs-number">8</span> || mode === _BACK_COMPAT) {
										offX = rootNode.clientLeft;
										offY = rootNode.clientTop;
									}
								}
								box = node[GET_BOUNDING_CLIENT_RECT]();
								xy = [box.left, box.top];

								<span class="hljs-keyword">if</span> (offX || offY) {
									xy[<span class="hljs-number">0</span>] -= offX;
									xy[<span class="hljs-number">1</span>] -= offY;

								}
								<span class="hljs-keyword">if</span> ((scrollTop || scrollLeft)) {
									<span class="hljs-keyword">if</span> (!Y.UA.ios || (Y.UA.ios &gt;= <span class="hljs-number">4.2</span>)) {
										xy[<span class="hljs-number">0</span>] += scrollLeft;
										xy[<span class="hljs-number">1</span>] += scrollTop;
									}

								}
							} <span class="hljs-keyword">else</span> {
								xy = Y_DOM._getOffset(node);
							}
						}
						<span class="hljs-keyword">return</span> xy;
					};
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{ <span class="hljs-comment">// manually calculate by crawling up offsetParents</span></pre></div></div>
            
        </li>
        
        
        <li id="section-404">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-404">&#182;</a>
              </div>
              <p>Calculate the Top and Left border sizes (assumes pixels)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> xy = <span class="hljs-literal">null</span>,
							doc,
							parentNode,
							bCheck,
							scrollTop,
							scrollLeft;

						<span class="hljs-keyword">if</span> (node) {
							<span class="hljs-keyword">if</span> (Y_DOM.inDoc(node)) {
								xy = [node.offsetLeft, node.offsetTop];
								doc = node.ownerDocument;
								parentNode = node;</pre></div></div>
            
        </li>
        
        
        <li id="section-405">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-405">&#182;</a>
              </div>
              <p>TODO: refactor with !! or just falsey</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								bCheck = ((Y.UA.gecko || Y.UA.webkit &gt; <span class="hljs-number">519</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-406">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-406">&#182;</a>
              </div>
              <p>TODO: worth refactoring for TOP/LEFT only?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">while</span> ((parentNode = parentNode.offsetParent)) {
									xy[<span class="hljs-number">0</span>] += parentNode.offsetLeft;
									xy[<span class="hljs-number">1</span>] += parentNode.offsetTop;
									<span class="hljs-keyword">if</span> (bCheck) {
										xy = Y_DOM._calcBorders(parentNode, xy);
									}
								}</pre></div></div>
            
        </li>
        
        
        <li id="section-407">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-407">&#182;</a>
              </div>
              <p>account for any scrolled ancestors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								<span class="hljs-keyword">if</span> (Y_DOM.getStyle(node, POSITION) != FIXED) {
									parentNode = node;

									<span class="hljs-keyword">while</span> ((parentNode = parentNode.parentNode)) {
										scrollTop = parentNode.scrollTop;
										scrollLeft = parentNode.scrollLeft;</pre></div></div>
            
        </li>
        
        
        <li id="section-408">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-408">&#182;</a>
              </div>
              <p>Firefox does something funky with borders when overflow is not visible.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>										<span class="hljs-keyword">if</span> (Y.UA.gecko &amp;&amp; (Y_DOM.getStyle(parentNode, <span class="hljs-string">'overflow'</span>) !== <span class="hljs-string">'visible'</span>)) {
											xy = Y_DOM._calcBorders(parentNode, xy);
										}


										<span class="hljs-keyword">if</span> (scrollTop || scrollLeft) {
											xy[<span class="hljs-number">0</span>] -= scrollLeft;
											xy[<span class="hljs-number">1</span>] -= scrollTop;
										}
									}
									xy[<span class="hljs-number">0</span>] += Y_DOM.docScrollX(node, doc);
									xy[<span class="hljs-number">1</span>] += Y_DOM.docScrollY(node, doc);

								} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-409">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-409">&#182;</a>
              </div>
              <p>Fix FIXED position – add scrollbars</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>									xy[<span class="hljs-number">0</span>] += Y_DOM.docScrollX(node, doc);
									xy[<span class="hljs-number">1</span>] += Y_DOM.docScrollY(node, doc);
								}
							} <span class="hljs-keyword">else</span> {
								xy = Y_DOM._getOffset(node);
							}
						}

						<span class="hljs-keyword">return</span> xy;
					};
				}
			}(),<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Executing for loadtime branching</span>

			<span class="hljs-comment">/**
			 Gets the width of vertical scrollbars on overflowed containers in the body
			 content.

			 @method getScrollbarWidth
			 @return {Number} Pixel width of a scrollbar in the current browser
			 **/</span>
			getScrollbarWidth: Y.cached(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">var</span> doc      = Y.config.doc,
					testNode = doc.createElement(<span class="hljs-string">'div'</span>),
					body     = doc.getElementsByTagName(<span class="hljs-string">'body'</span>)[<span class="hljs-number">0</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-410">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-410">&#182;</a>
              </div>
              <p>0.1 because cached doesn’t support falsy refetch values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					width    = <span class="hljs-number">0.1</span>;

				<span class="hljs-keyword">if</span> (body) {
					testNode.style.cssText = <span class="hljs-string">"position:absolute;visibility:hidden;overflow:scroll;width:20px;"</span>;
					testNode.appendChild(doc.createElement(<span class="hljs-string">'p'</span>)).style.height = <span class="hljs-string">'1px'</span>;
					body.insertBefore(testNode, body.firstChild);
					width = testNode.offsetWidth - testNode.clientWidth;

					body.removeChild(testNode);
				}

				<span class="hljs-keyword">return</span> width;
			}, <span class="hljs-literal">null</span>, <span class="hljs-number">0.1</span>),

			<span class="hljs-comment">/**
			 * Gets the current X position of an element based on page coordinates.
			 * Element must be part of the DOM tree to have page coordinates
			 * (display:none or elements not appended return false).
			 * @method getX
			 * @param element The target element
			 * @return {Number} The X position of the element
			 */</span>

			getX: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.getXY(node)[<span class="hljs-number">0</span>];
			},

			<span class="hljs-comment">/**
			 * Gets the current Y position of an element based on page coordinates.
			 * Element must be part of the DOM tree to have page coordinates
			 * (display:none or elements not appended return false).
			 * @method getY
			 * @param element The target element
			 * @return {Number} The Y position of the element
			 */</span>

			getY: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.getXY(node)[<span class="hljs-number">1</span>];
			},

			<span class="hljs-comment">/**
			 * Set the position of an html element in page coordinates.
			 * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
			 * @method setXY
			 * @param element The target element
			 * @param {Array} xy Contains X &amp; Y values for new position (coordinates are page-based)
			 * @param {Boolean} noRetry By default we try and set the position a second time if the first fails
			 */</span>
			setXY: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, xy, noRetry</span>) </span>{
				<span class="hljs-keyword">var</span> setStyle = Y_DOM.setStyle,
					pos,
					delta,
					newXY,
					currentXY;

				<span class="hljs-keyword">if</span> (node &amp;&amp; xy) {
					pos = Y_DOM.getStyle(node, POSITION);

					delta = Y_DOM._getOffset(node);
					<span class="hljs-keyword">if</span> (pos == <span class="hljs-string">'static'</span>) { <span class="hljs-comment">// default to relative</span>
						pos = RELATIVE;
						setStyle(node, POSITION, pos);
					}
					currentXY = Y_DOM.getXY(node);

					<span class="hljs-keyword">if</span> (xy[<span class="hljs-number">0</span>] !== <span class="hljs-literal">null</span>) {
						setStyle(node, LEFT, xy[<span class="hljs-number">0</span>] - currentXY[<span class="hljs-number">0</span>] + delta[<span class="hljs-number">0</span>] + <span class="hljs-string">'px'</span>);
					}

					<span class="hljs-keyword">if</span> (xy[<span class="hljs-number">1</span>] !== <span class="hljs-literal">null</span>) {
						setStyle(node, TOP, xy[<span class="hljs-number">1</span>] - currentXY[<span class="hljs-number">1</span>] + delta[<span class="hljs-number">1</span>] + <span class="hljs-string">'px'</span>);
					}

					<span class="hljs-keyword">if</span> (!noRetry) {
						newXY = Y_DOM.getXY(node);
						<span class="hljs-keyword">if</span> (newXY[<span class="hljs-number">0</span>] !== xy[<span class="hljs-number">0</span>] || newXY[<span class="hljs-number">1</span>] !== xy[<span class="hljs-number">1</span>]) {
							Y_DOM.setXY(node, xy, <span class="hljs-literal">true</span>);
						}
					}

				} <span class="hljs-keyword">else</span> {
				}
			},

			<span class="hljs-comment">/**
			 * Set the X position of an html element in page coordinates, regardless of how the element is positioned.
			 * The element(s) must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
			 * @method setX
			 * @param element The target element
			 * @param {Number} x The X values for new position (coordinates are page-based)
			 */</span>
			setX: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, x</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.setXY(node, [x, <span class="hljs-literal">null</span>]);
			},

			<span class="hljs-comment">/**
			 * Set the Y position of an html element in page coordinates, regardless of how the element is positioned.
			 * The element(s) must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
			 * @method setY
			 * @param element The target element
			 * @param {Number} y The Y values for new position (coordinates are page-based)
			 */</span>
			setY: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, y</span>) </span>{
				<span class="hljs-keyword">return</span> Y_DOM.setXY(node, [<span class="hljs-literal">null</span>, y]);
			},

			<span class="hljs-comment">/**
			 * @method swapXY
			 * @description Swap the xy position with another node
			 * @param {Node} node The node to swap with
			 * @param {Node} otherNode The other node to swap with
			 * @return {Node}
			 */</span>
			swapXY: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, otherNode</span>) </span>{
				<span class="hljs-keyword">var</span> xy = Y_DOM.getXY(node);
				Y_DOM.setXY(node, Y_DOM.getXY(otherNode));
				Y_DOM.setXY(otherNode, xy);
			},

			<span class="hljs-attr">_calcBorders</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, xy2</span>) </span>{
				<span class="hljs-keyword">var</span> t = <span class="hljs-built_in">parseInt</span>(Y_DOM[GET_COMPUTED_STYLE](node, BORDER_TOP_WIDTH), <span class="hljs-number">10</span>) || <span class="hljs-number">0</span>,
					l = <span class="hljs-built_in">parseInt</span>(Y_DOM[GET_COMPUTED_STYLE](node, BORDER_LEFT_WIDTH), <span class="hljs-number">10</span>) || <span class="hljs-number">0</span>;
				<span class="hljs-keyword">if</span> (Y.UA.gecko) {
					<span class="hljs-keyword">if</span> (RE_TABLE.test(node.tagName)) {
						t = <span class="hljs-number">0</span>;
						l = <span class="hljs-number">0</span>;
					}
				}
				xy2[<span class="hljs-number">0</span>] += l;
				xy2[<span class="hljs-number">1</span>] += t;
				<span class="hljs-keyword">return</span> xy2;
			},

			<span class="hljs-attr">_getWinSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, doc</span>) </span>{
				doc  = doc || (node) ? Y_DOM._getDoc(node) : Y.config.doc;
				<span class="hljs-keyword">var</span> win = doc.defaultView || doc.parentWindow,
					mode = doc[COMPAT_MODE],
					h = win.innerHeight,
					w = win.innerWidth,
					root = doc[DOCUMENT_ELEMENT];

				<span class="hljs-keyword">if</span> ( mode &amp;&amp; !Y.UA.opera ) { <span class="hljs-comment">// IE, Gecko</span>
					<span class="hljs-keyword">if</span> (mode != <span class="hljs-string">'CSS1Compat'</span>) { <span class="hljs-comment">// Quirks</span>
						root = doc.body;
					}
					h = root.clientHeight;
					w = root.clientWidth;
				}
				<span class="hljs-keyword">return</span> { <span class="hljs-attr">height</span>: h, <span class="hljs-attr">width</span>: w };
			},

			<span class="hljs-attr">_getDocSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">var</span> doc = (node) ? Y_DOM._getDoc(node) : Y.config.doc,
					root = doc[DOCUMENT_ELEMENT];

				<span class="hljs-keyword">if</span> (doc[COMPAT_MODE] != <span class="hljs-string">'CSS1Compat'</span>) {
					root = doc.body;
				}

				<span class="hljs-keyword">return</span> { <span class="hljs-attr">height</span>: root.scrollHeight, <span class="hljs-attr">width</span>: root.scrollWidth };
			}
		});

	})(Y);
	(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
		<span class="hljs-keyword">var</span> TOP = <span class="hljs-string">'top'</span>,
			RIGHT = <span class="hljs-string">'right'</span>,
			BOTTOM = <span class="hljs-string">'bottom'</span>,
			LEFT = <span class="hljs-string">'left'</span>,

			getOffsets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r1, r2</span>) </span>{
				<span class="hljs-keyword">var</span> t = <span class="hljs-built_in">Math</span>.max(r1[TOP], r2[TOP]),
					r = <span class="hljs-built_in">Math</span>.min(r1[RIGHT], r2[RIGHT]),
					b = <span class="hljs-built_in">Math</span>.min(r1[BOTTOM], r2[BOTTOM]),
					l = <span class="hljs-built_in">Math</span>.max(r1[LEFT], r2[LEFT]),
					ret = {};

				ret[TOP] = t;
				ret[RIGHT] = r;
				ret[BOTTOM] = b;
				ret[LEFT] = l;
				<span class="hljs-keyword">return</span> ret;
			},

			DOM = Y.DOM;

		Y.mix(DOM, {
			<span class="hljs-comment">/**
			 * Returns an Object literal containing the following about this element: (top, right, bottom, left)
			 * @for DOM
			 * @method region
			 * @param {HTMLElement} element The DOM element.
			 * @return {Object} Object literal containing the following about this element: (top, right, bottom, left)
			 */</span>
			region: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				<span class="hljs-keyword">var</span> xy = DOM.getXY(node),
					ret = <span class="hljs-literal">false</span>;

				<span class="hljs-keyword">if</span> (node &amp;&amp; xy) {
					ret = DOM._getRegion(
						xy[<span class="hljs-number">1</span>], <span class="hljs-comment">// top</span>
						xy[<span class="hljs-number">0</span>] + node.offsetWidth, <span class="hljs-comment">// right</span>
						xy[<span class="hljs-number">1</span>] + node.offsetHeight, <span class="hljs-comment">// bottom</span>
						xy[<span class="hljs-number">0</span>] <span class="hljs-comment">// left</span>
					);
				}

				<span class="hljs-keyword">return</span> ret;
			},

			<span class="hljs-comment">/**
			 * Find the intersect information for the passed nodes.
			 * @method intersect
			 * @for DOM
			 * @param {HTMLElement} element The first element
			 * @param {HTMLElement | Object} element2 The element or region to check the interect with
			 * @param {Object} altRegion An object literal containing the region for the first element if we already have the data (for performance e.g. DragDrop)
			 * @return {Object} Object literal containing the following intersection data: (top, right, bottom, left, area, yoff, xoff, inRegion)
			 */</span>
			intersect: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, node2, altRegion</span>) </span>{
				<span class="hljs-keyword">var</span> r = altRegion || DOM.region(node), region = {},
					n = node2,
					off;

				<span class="hljs-keyword">if</span> (n.tagName) {
					region = DOM.region(n);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Y.Lang.isObject(node2)) {
					region = node2;
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				}

				off = getOffsets(region, r);
				<span class="hljs-keyword">return</span> {
					<span class="hljs-attr">top</span>: off[TOP],
					<span class="hljs-attr">right</span>: off[RIGHT],
					<span class="hljs-attr">bottom</span>: off[BOTTOM],
					<span class="hljs-attr">left</span>: off[LEFT],
					<span class="hljs-attr">area</span>: ((off[BOTTOM] - off[TOP]) * (off[RIGHT] - off[LEFT])),
					<span class="hljs-attr">yoff</span>: ((off[BOTTOM] - off[TOP])),
					<span class="hljs-attr">xoff</span>: (off[RIGHT] - off[LEFT]),
					<span class="hljs-attr">inRegion</span>: DOM.inRegion(node, node2, <span class="hljs-literal">false</span>, altRegion)
				};

			},
			<span class="hljs-comment">/**
			 * Check if any part of this node is in the passed region
			 * @method inRegion
			 * @for DOM
			 * @param {Object} node The node to get the region from
			 * @param {Object} node2 The second node to get the region from or an Object literal of the region
			 * @param {Boolean} all Should all of the node be inside the region
			 * @param {Object} altRegion An object literal containing the region for this node if we already have the data (for performance e.g. DragDrop)
			 * @return {Boolean} True if in region, false if not.
			 */</span>
			inRegion: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, node2, all, altRegion</span>) </span>{
				<span class="hljs-keyword">var</span> region = {},
					r = altRegion || DOM.region(node),
					n = node2,
					off;

				<span class="hljs-keyword">if</span> (n.tagName) {
					region = DOM.region(n);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Y.Lang.isObject(node2)) {
					region = node2;
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				}

				<span class="hljs-keyword">if</span> (all) {
					<span class="hljs-keyword">return</span> (
						r[LEFT]   &gt;= region[LEFT]   &amp;&amp;
							r[RIGHT]  &lt;= region[RIGHT]  &amp;&amp;
							r[TOP]    &gt;= region[TOP]    &amp;&amp;
							r[BOTTOM] &lt;= region[BOTTOM]  );
				} <span class="hljs-keyword">else</span> {
					off = getOffsets(region, r);
					<span class="hljs-keyword">if</span> (off[BOTTOM] &gt;= off[TOP] &amp;&amp; off[RIGHT] &gt;= off[LEFT]) {
						<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
					}

				}
			},

			<span class="hljs-comment">/**
			 * Check if any part of this element is in the viewport
			 * @method inViewportRegion
			 * @for DOM
			 * @param {HTMLElement} element The DOM element.
			 * @param {Boolean} all Should all of the node be inside the region
			 * @param {Object} altRegion An object literal containing the region for this node if we already have the data (for performance e.g. DragDrop)
			 * @return {Boolean} True if in region, false if not.
			 */</span>
			inViewportRegion: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, all, altRegion</span>) </span>{
				<span class="hljs-keyword">return</span> DOM.inRegion(node, DOM.viewportRegion(node), all, altRegion);

			},

			<span class="hljs-attr">_getRegion</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t, r, b, l</span>) </span>{
				<span class="hljs-keyword">var</span> region = {};

				region[TOP] = region[<span class="hljs-number">1</span>] = t;
				region[LEFT] = region[<span class="hljs-number">0</span>] = l;
				region[BOTTOM] = b;
				region[RIGHT] = r;
				region.width = region[RIGHT] - region[LEFT];
				region.height = region[BOTTOM] - region[TOP];

				<span class="hljs-keyword">return</span> region;
			},

			<span class="hljs-comment">/**
			 * Returns an Object literal containing the following about the visible region of viewport: (top, right, bottom, left)
			 * @method viewportRegion
			 * @for DOM
			 * @return {Object} Object literal containing the following about the visible region of the viewport: (top, right, bottom, left)
			 */</span>
			viewportRegion: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
				node = node || Y.config.doc.documentElement;
				<span class="hljs-keyword">var</span> ret = <span class="hljs-literal">false</span>,
					scrollX,
					scrollY;

				<span class="hljs-keyword">if</span> (node) {
					scrollX = DOM.docScrollX(node);
					scrollY = DOM.docScrollY(node);

					ret = DOM._getRegion(scrollY, <span class="hljs-comment">// top</span>
						DOM.winWidth(node) + scrollX, <span class="hljs-comment">// right</span>
						scrollY + DOM.winHeight(node), <span class="hljs-comment">// bottom</span>
						scrollX); <span class="hljs-comment">// left</span>
				}

				<span class="hljs-keyword">return</span> ret;
			}
		});
	})(Y);


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"dom-base"</span>, <span class="hljs-string">"dom-style"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'node-screen'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Extended Node interface for managing regions and screen positioning.
	 * Adds support for positioning elements and normalizes window size and scroll detection.
	 * @module node
	 * @submodule node-screen
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-411">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-411">&#182;</a>
              </div>
              <p>these are all “safe” returns, no wrapping required</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	Y.each([
	<span class="hljs-comment">/**
	 * Returns the inner width of the viewport (exludes scrollbar).
	 * @config winWidth
	 * @for Node
	 * @type {Int}
	 */</span>
		<span class="hljs-string">'winWidth'</span>,

	<span class="hljs-comment">/**
	 * Returns the inner height of the viewport (exludes scrollbar).
	 * @config winHeight
	 * @type {Int}
	 */</span>
		<span class="hljs-string">'winHeight'</span>,

	<span class="hljs-comment">/**
	 * Document width
	 * @config docWidth
	 * @type {Int}
	 */</span>
		<span class="hljs-string">'docWidth'</span>,

	<span class="hljs-comment">/**
	 * Document height
	 * @config docHeight
	 * @type {Int}
	 */</span>
		<span class="hljs-string">'docHeight'</span>,

	<span class="hljs-comment">/**
	 * Pixel distance the page has been scrolled horizontally
	 * @config docScrollX
	 * @type {Int}
	 */</span>
		<span class="hljs-string">'docScrollX'</span>,

	<span class="hljs-comment">/**
	 * Pixel distance the page has been scrolled vertically
	 * @config docScrollY
	 * @type {Int}
	 */</span>
		<span class="hljs-string">'docScrollY'</span>
	],
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
			Y.Node.ATTRS[name] = {
				<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					<span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
					args.unshift(Y.Node.getDOMNode(<span class="hljs-keyword">this</span>));

					<span class="hljs-keyword">return</span> Y.DOM[name].apply(<span class="hljs-keyword">this</span>, args);
				}
			};
		}
	);

	Y.Node.ATTRS.scrollLeft = {
		<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> node = Y.Node.getDOMNode(<span class="hljs-keyword">this</span>);
			<span class="hljs-keyword">return</span> (<span class="hljs-string">'scrollLeft'</span> <span class="hljs-keyword">in</span> node) ? node.scrollLeft : Y.DOM.docScrollX(node);
		},

		<span class="hljs-attr">setter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
			<span class="hljs-keyword">var</span> node = Y.Node.getDOMNode(<span class="hljs-keyword">this</span>);
			<span class="hljs-keyword">if</span> (node) {
				<span class="hljs-keyword">if</span> (<span class="hljs-string">'scrollLeft'</span> <span class="hljs-keyword">in</span> node) {
					node.scrollLeft = val;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.document || node.nodeType === <span class="hljs-number">9</span>) {
					Y.DOM._getWin(node).scrollTo(val, Y.DOM.docScrollY(node)); <span class="hljs-comment">// scroll window if win or doc</span>
				}
			} <span class="hljs-keyword">else</span> {
			}
		}
	};

	Y.Node.ATTRS.scrollTop = {
		<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> node = Y.Node.getDOMNode(<span class="hljs-keyword">this</span>);
			<span class="hljs-keyword">return</span> (<span class="hljs-string">'scrollTop'</span> <span class="hljs-keyword">in</span> node) ? node.scrollTop : Y.DOM.docScrollY(node);
		},

		<span class="hljs-attr">setter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
			<span class="hljs-keyword">var</span> node = Y.Node.getDOMNode(<span class="hljs-keyword">this</span>);
			<span class="hljs-keyword">if</span> (node) {
				<span class="hljs-keyword">if</span> (<span class="hljs-string">'scrollTop'</span> <span class="hljs-keyword">in</span> node) {
					node.scrollTop = val;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.document || node.nodeType === <span class="hljs-number">9</span>) {
					Y.DOM._getWin(node).scrollTo(Y.DOM.docScrollX(node), val); <span class="hljs-comment">// scroll window if win or doc</span>
				}
			} <span class="hljs-keyword">else</span> {
			}
		}
	};

	Y.Node.importMethod(Y.DOM, [
	<span class="hljs-comment">/**
	 * Gets the current position of the node in page coordinates.
	 * @method getXY
	 * @for Node
	 * @return {Array} The XY position of the node
	 */</span>
		<span class="hljs-string">'getXY'</span>,

	<span class="hljs-comment">/**
	 * Set the position of the node in page coordinates, regardless of how the node is positioned.
	 * @method setXY
	 * @param {Array} xy Contains X &amp; Y values for new position (coordinates are page-based)
	 * @chainable
	 */</span>
		<span class="hljs-string">'setXY'</span>,

	<span class="hljs-comment">/**
	 * Gets the current position of the node in page coordinates.
	 * @method getX
	 * @return {Int} The X position of the node
	 */</span>
		<span class="hljs-string">'getX'</span>,

	<span class="hljs-comment">/**
	 * Set the position of the node in page coordinates, regardless of how the node is positioned.
	 * @method setX
	 * @param {Int} x X value for new position (coordinates are page-based)
	 * @chainable
	 */</span>
		<span class="hljs-string">'setX'</span>,

	<span class="hljs-comment">/**
	 * Gets the current position of the node in page coordinates.
	 * @method getY
	 * @return {Int} The Y position of the node
	 */</span>
		<span class="hljs-string">'getY'</span>,

	<span class="hljs-comment">/**
	 * Set the position of the node in page coordinates, regardless of how the node is positioned.
	 * @method setY
	 * @param {Int} y Y value for new position (coordinates are page-based)
	 * @chainable
	 */</span>
		<span class="hljs-string">'setY'</span>,

	<span class="hljs-comment">/**
	 * Swaps the XY position of this node with another node.
	 * @method swapXY
	 * @param {Node | HTMLElement} otherNode The node to swap with.
	 * @chainable
	 */</span>
		<span class="hljs-string">'swapXY'</span>
	]);

	<span class="hljs-comment">/**
	 * @module node
	 * @submodule node-screen
	 */</span>

	<span class="hljs-comment">/**
	 * Returns a region object for the node
	 * @config region
	 * @for Node
	 * @type Node
	 */</span>
	Y.Node.ATTRS.region = {
		<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.getDOMNode(),
				region;

			<span class="hljs-keyword">if</span> (node &amp;&amp; !node.tagName) {
				<span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">9</span>) { <span class="hljs-comment">// document</span>
					node = node.documentElement;
				}
			}
			<span class="hljs-keyword">if</span> (Y.DOM.isWindow(node)) {
				region = Y.DOM.viewportRegion(node);
			} <span class="hljs-keyword">else</span> {
				region = Y.DOM.region(node);
			}
			<span class="hljs-keyword">return</span> region;
		}
	};

	<span class="hljs-comment">/**
	 * Returns a region object for the node's viewport
	 * @config viewportRegion
	 * @type Node
	 */</span>
	Y.Node.ATTRS.viewportRegion = {
		<span class="hljs-attr">getter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">return</span> Y.DOM.viewportRegion(Y.Node.getDOMNode(<span class="hljs-keyword">this</span>));
		}
	};

	Y.Node.importMethod(Y.DOM, <span class="hljs-string">'inViewportRegion'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-412">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-412">&#182;</a>
              </div>
              <p>these need special treatment to extract 2nd node arg</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * Compares the intersection of the node with another node or region
	 * @method intersect
	 * @for Node
	 * @param {Node|Object} node2 The node or region to compare with.
	 * @param {Object} altRegion An alternate region to use (rather than this node's).
	 * @return {Object} An object representing the intersection of the regions.
	 */</span>
	Y.Node.prototype.intersect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node2, altRegion</span>) </span>{
		<span class="hljs-keyword">var</span> node1 = Y.Node.getDOMNode(<span class="hljs-keyword">this</span>);
		<span class="hljs-keyword">if</span> (Y.instanceOf(node2, Y.Node)) { <span class="hljs-comment">// might be a region object</span>
			node2 = Y.Node.getDOMNode(node2);
		}
		<span class="hljs-keyword">return</span> Y.DOM.intersect(node1, node2, altRegion);
	};

	<span class="hljs-comment">/**
	 * Determines whether or not the node is within the giving region.
	 * @method inRegion
	 * @param {Node|Object} node2 The node or region to compare with.
	 * @param {Boolean} all Whether or not all of the node must be in the region.
	 * @param {Object} altRegion An alternate region to use (rather than this node's).
	 * @return {Object} An object representing the intersection of the regions.
	 */</span>
	Y.Node.prototype.inRegion = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node2, all, altRegion</span>) </span>{
		<span class="hljs-keyword">var</span> node1 = Y.Node.getDOMNode(<span class="hljs-keyword">this</span>);
		<span class="hljs-keyword">if</span> (Y.instanceOf(node2, Y.Node)) { <span class="hljs-comment">// might be a region object</span>
			node2 = Y.Node.getDOMNode(node2);
		}
		<span class="hljs-keyword">return</span> Y.DOM.inRegion(node1, node2, all, altRegion);
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"dom-screen"</span>, <span class="hljs-string">"node-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'node-style'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Y</span>) </span>{
		<span class="hljs-comment">/**
		 * Extended Node interface for managing node styles.
		 * @module node
		 * @submodule node-style
		 */</span>

		Y.mix(Y.Node.prototype, {
			<span class="hljs-comment">/**
			 * Sets a style property of the node.
			 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
			 * @method setStyle
			 * @param {String} attr The style attribute to set.
			 * @param {String|Number} val The value.
			 * @chainable
			 */</span>
			setStyle: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr, val</span>) </span>{
				Y.DOM.setStyle(<span class="hljs-keyword">this</span>._node, attr, val);
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
			},

			<span class="hljs-comment">/**
			 * Sets multiple style properties on the node.
			 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
			 * @method setStyles
			 * @param {Object} hash An object literal of property:value pairs.
			 * @chainable
			 */</span>
			setStyles: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hash</span>) </span>{
				Y.DOM.setStyles(<span class="hljs-keyword">this</span>._node, hash);
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
			},

			<span class="hljs-comment">/**
			 * Returns the style's current value.
			 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
			 * @method getStyle
			 * @for Node
			 * @param {String} attr The style attribute to retrieve.
			 * @return {String} The current value of the style property for the element.
			 */</span>

			getStyle: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
				<span class="hljs-keyword">return</span> Y.DOM.getStyle(<span class="hljs-keyword">this</span>._node, attr);
			},

			<span class="hljs-comment">/**
			 * Returns the computed value for the given style property.
			 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
			 * @method getComputedStyle
			 * @param {String} attr The style attribute to retrieve.
			 * @return {String} The computed value of the style property for the element.
			 */</span>
			getComputedStyle: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
				<span class="hljs-keyword">return</span> Y.DOM.getComputedStyle(<span class="hljs-keyword">this</span>._node, attr);
			}
		});

		<span class="hljs-comment">/**
		 * Returns an array of values for each node.
		 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
		 * @method getStyle
		 * @for NodeList
		 * @see Node.getStyle
		 * @param {String} attr The style attribute to retrieve.
		 * @return {Array} The current values of the style property for the element.
		 */</span>

		<span class="hljs-comment">/**
		 * Returns an array of the computed value for each node.
		 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
		 * @method getComputedStyle
		 * @see Node.getComputedStyle
		 * @param {String} attr The style attribute to retrieve.
		 * @return {Array} The computed values for each node.
		 */</span>

		<span class="hljs-comment">/**
		 * Sets a style property on each node.
		 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
		 * @method setStyle
		 * @see Node.setStyle
		 * @param {String} attr The style attribute to set.
		 * @param {String|Number} val The value.
		 * @chainable
		 */</span>

		<span class="hljs-comment">/**
		 * Sets multiple style properties on each node.
		 * Use camelCase (e.g. 'backgroundColor') for multi-word properties.
		 * @method setStyles
		 * @see Node.setStyles
		 * @param {Object} hash An object literal of property:value pairs.
		 * @chainable
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-413">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-413">&#182;</a>
              </div>
              <p>These are broken out to handle undefined return (avoid false positive for
chainable)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		Y.NodeList.importMethod(Y.Node.prototype, [<span class="hljs-string">'getStyle'</span>, <span class="hljs-string">'getComputedStyle'</span>, <span class="hljs-string">'setStyle'</span>, <span class="hljs-string">'setStyles'</span>]);
	})(Y);


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"dom-style"</span>, <span class="hljs-string">"node-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'querystring-stringify-simple'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/*global Y */</span>
	<span class="hljs-comment">/**
	 * &lt;p&gt;Provides Y.QueryString.stringify method for converting objects to Query Strings.
	 * This is a subset implementation of the full querystring-stringify.&lt;/p&gt;
	 * &lt;p&gt;This module provides the bare minimum functionality (encoding a hash of simple values),
	 * without the additional support for nested data structures.  Every key-value pair is
	 * encoded by encodeURIComponent.&lt;/p&gt;
	 * &lt;p&gt;This module provides a minimalistic way for io to handle  single-level objects
	 * as transaction data.&lt;/p&gt;
	 *
	 * @module querystring
	 * @submodule querystring-stringify-simple
	 * @for QueryString
	 * @static
	 */</span>

	<span class="hljs-keyword">var</span> QueryString = Y.namespace(<span class="hljs-string">"QueryString"</span>),
		EUC = <span class="hljs-built_in">encodeURIComponent</span>;

	<span class="hljs-comment">/**
	 * &lt;p&gt;Converts a simple object to a Query String representation.&lt;/p&gt;
	 * &lt;p&gt;Nested objects, Arrays, and so on, are not supported.&lt;/p&gt;
	 *
	 * @method stringify
	 * @for QueryString
	 * @public
	 * @submodule querystring-stringify-simple
	 * @param obj {Object} A single-level object to convert to a querystring.
	 * @param cfg {Object} (optional) Configuration object.  In the simple
	 *                                module, only the arrayKey setting is
	 *                                supported.  When set to true, the key of an
	 *                                array will have the '[]' notation appended
	 *                                to the key;.
	 * @static
	 */</span>
	QueryString.stringify = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, c</span>) </span>{
		<span class="hljs-keyword">var</span> qs = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-414">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-414">&#182;</a>
              </div>
              <p>Default behavior is false; standard key notation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			s = c &amp;&amp; c.arrayKey ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>,
			key, i, l;

		<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) {
			<span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) {
				<span class="hljs-keyword">if</span> (Y.Lang.isArray(obj[key])) {
					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = obj[key].length; i &lt; l; i++) {
						qs.push(EUC(s ? key + <span class="hljs-string">'[]'</span> : key) + <span class="hljs-string">'='</span> + EUC(obj[key][i]));
					}
				}
				<span class="hljs-keyword">else</span> {
					qs.push(EUC(key) + <span class="hljs-string">'='</span> + EUC(obj[key]));
				}
			}
		}

		<span class="hljs-keyword">return</span> qs.join(<span class="hljs-string">'&amp;'</span>);
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'io-base'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 Base IO functionality. Provides basic XHR transport support.

	 @module io
	 @submodule io-base
	 @for IO
	 **/</span>

	<span class="hljs-keyword">var</span> <span class="hljs-comment">// List of events that comprise the IO event lifecycle.</span>
		EVENTS = [<span class="hljs-string">'start'</span>, <span class="hljs-string">'complete'</span>, <span class="hljs-string">'end'</span>, <span class="hljs-string">'success'</span>, <span class="hljs-string">'failure'</span>, <span class="hljs-string">'progress'</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-415">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-415">&#182;</a>
              </div>
              <p>Whitelist of used XHR response object properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		XHR_PROPS = [<span class="hljs-string">'status'</span>, <span class="hljs-string">'statusText'</span>, <span class="hljs-string">'responseText'</span>, <span class="hljs-string">'responseXML'</span>],

		win = Y.config.win,
		uid = <span class="hljs-number">0</span>;

	<span class="hljs-comment">/**
	 The IO class is a utility that brokers HTTP requests through a simplified
	 interface.  Specifically, it allows JavaScript to make HTTP requests to
	 a resource without a page reload.  The underlying transport for making
	 same-domain requests is the XMLHttpRequest object.  IO can also use
	 Flash, if specified as a transport, for cross-domain requests.

	 @class IO
	 @constructor
	 @param {Object} config Object of EventTarget's publish method configurations
	 used to configure IO's events.
	 **/</span>
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IO</span> (<span class="hljs-params">config</span>) </span>{
		<span class="hljs-keyword">var</span> io = <span class="hljs-keyword">this</span>;

		io._uid = <span class="hljs-string">'io:'</span> + uid++;
		io._init(config);
		Y.io._map[io._uid] = io;
	}

	IO.prototype = {</pre></div></div>
            
        </li>
        
        
        <li id="section-416">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-416">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-417">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-417">&#182;</a>
              </div>
              <h2 id="-properties"> Properties</h2>

            </div>
            
        </li>
        
        
        <li id="section-418">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-418">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * A counter that increments for each transaction.
		 *
		 * @property _id
		 * @private
		 * @type {Number}
		 */</span>
		_id: <span class="hljs-number">0</span>,

		<span class="hljs-comment">/**
		 * Object of IO HTTP headers sent with each transaction.
		 *
		 * @property _headers
		 * @private
		 * @type {Object}
		 */</span>
		_headers: {
			<span class="hljs-string">'X-Requested-With'</span> : <span class="hljs-string">'XMLHttpRequest'</span>
		},

		<span class="hljs-comment">/**
		 * Object that stores timeout values for any transaction with a defined
		 * "timeout" configuration property.
		 *
		 * @property _timeout
		 * @private
		 * @type {Object}
		 */</span>
		_timeout: {},</pre></div></div>
            
        </li>
        
        
        <li id="section-419">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-419">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-420">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-420">&#182;</a>
              </div>
              <h2 id="-methods"> Methods</h2>

            </div>
            
        </li>
        
        
        <li id="section-421">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-421">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
		_init: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config</span>) </span>{
			<span class="hljs-keyword">var</span> io = <span class="hljs-keyword">this</span>, i, len;

			io.cfg = config || {};

			Y.augment(io, Y.EventTarget);
			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = EVENTS.length; i &lt; len; ++i) {</pre></div></div>
            
        </li>
        
        
        <li id="section-422">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-422">&#182;</a>
              </div>
              <p>Publish IO global events with configurations, if any.
IO global events are set to broadcast by default.
These events use the “io:” namespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				io.publish(<span class="hljs-string">'io:'</span> + EVENTS[i], Y.merge({ <span class="hljs-attr">broadcast</span>: <span class="hljs-number">1</span> }, config));</pre></div></div>
            
        </li>
        
        
        <li id="section-423">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-423">&#182;</a>
              </div>
              <p>Publish IO transaction events with configurations, if
any.  These events use the “io-trn:” namespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				io.publish(<span class="hljs-string">'io-trn:'</span> + EVENTS[i], config);
			}
		},

		<span class="hljs-comment">/**
		 * Method that creates a unique transaction object for each request.
		 *
		 * @method _create
		 * @private
		 * @param {Object} cfg Configuration object subset to determine if
		 *                 the transaction is an XDR or file upload,
		 *                 requiring an alternate transport.
		 * @param {Number} id Transaction id
		 * @return {Object} The transaction object
		 */</span>
		_create: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config, id</span>) </span>{
			<span class="hljs-keyword">var</span> io = <span class="hljs-keyword">this</span>,
				transaction = {
					<span class="hljs-attr">id</span> : Y.Lang.isNumber(id) ? id : io._id++,
					<span class="hljs-attr">uid</span>: io._uid
				},
				alt = config.xdr ? config.xdr.use : <span class="hljs-literal">null</span>,
				form = config.form &amp;&amp; config.form.upload ? <span class="hljs-string">'iframe'</span> : <span class="hljs-literal">null</span>,
				use;

			<span class="hljs-keyword">if</span> (alt === <span class="hljs-string">'native'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-424">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-424">&#182;</a>
              </div>
              <p>Non-IE and IE &gt;= 10  can use XHR level 2 and not rely on an
external transport.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				alt = Y.UA.ie &amp;&amp; !SUPPORTS_CORS ? <span class="hljs-string">'xdr'</span> : <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-425">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-425">&#182;</a>
              </div>
              <p>Prevent “pre-flight” OPTIONS request by removing the
<code>X-Requested-With</code> HTTP header from CORS requests. This header
can be added back on a per-request basis, if desired.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				io.setHeader(<span class="hljs-string">'X-Requested-With'</span>);
			}

			use = alt || form;
			transaction = use ? Y.merge(Y.IO.customTransport(use), transaction) :
				Y.merge(Y.IO.defaultTransport(), transaction);

			<span class="hljs-keyword">if</span> (transaction.notify) {
				config.notify = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, t, c</span>) </span>{ io.notify(e, t, c); };
			}

			<span class="hljs-keyword">if</span> (!use) {
				<span class="hljs-keyword">if</span> (win &amp;&amp; win.FormData &amp;&amp; config.data <span class="hljs-keyword">instanceof</span> win.FormData) {
					transaction.c.upload.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
						io.progress(transaction, e, config);
					};
					transaction.c.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
						io.load(transaction, e, config);
					};
					transaction.c.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
						io.error(transaction, e, config);
					};
					transaction.upload = <span class="hljs-literal">true</span>;
				}
			}

			<span class="hljs-keyword">return</span> transaction;
		},

		<span class="hljs-attr">_destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction</span>) </span>{
			<span class="hljs-keyword">if</span> (win &amp;&amp; !transaction.notify &amp;&amp; !transaction.xdr) {
				<span class="hljs-keyword">if</span> (XHR &amp;&amp; !transaction.upload) {
					transaction.c.onreadystatechange = <span class="hljs-literal">null</span>;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (transaction.upload) {
					transaction.c.upload.onprogress = <span class="hljs-literal">null</span>;
					transaction.c.onload = <span class="hljs-literal">null</span>;
					transaction.c.onerror = <span class="hljs-literal">null</span>;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Y.UA.ie &amp;&amp; !transaction.e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-426">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-426">&#182;</a>
              </div>
              <p>IE, when using XMLHttpRequest as an ActiveX Object, will throw
a “Type Mismatch” error if the event handler is set to “null”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					transaction.c.abort();
				}
			}

			transaction = transaction.c = <span class="hljs-literal">null</span>;
		},

		<span class="hljs-comment">/**
		 * Method for creating and firing events.
		 *
		 * @method _evt
		 * @private
		 * @param {String} eventName Event to be published.
		 * @param {Object} transaction Transaction object.
		 * @param {Object} config Configuration data subset for event subscription.
		 */</span>
		_evt: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, transaction, config</span>) </span>{
			<span class="hljs-keyword">var</span> io          = <span class="hljs-keyword">this</span>, params,
				args        = config[<span class="hljs-string">'arguments'</span>],
				emitFacade  = io.cfg.emitFacade,
				globalEvent = <span class="hljs-string">"io:"</span> + eventName,
				trnEvent    = <span class="hljs-string">"io-trn:"</span> + eventName;</pre></div></div>
            
        </li>
        
        
        <li id="section-427">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-427">&#182;</a>
              </div>
              <p>Workaround for #2532107</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>.detach(trnEvent);

			<span class="hljs-keyword">if</span> (transaction.e) {
				transaction.c = { <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">statusText</span>: transaction.e };
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-428">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-428">&#182;</a>
              </div>
              <p>Fire event with parameters or an Event Facade.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			params = [ emitFacade ?
			{
				<span class="hljs-attr">id</span>: transaction.id,
				<span class="hljs-attr">data</span>: transaction.c,
				<span class="hljs-attr">cfg</span>: config,
				<span class="hljs-string">'arguments'</span>: args
			} :
				transaction.id
			];

			<span class="hljs-keyword">if</span> (!emitFacade) {
				<span class="hljs-keyword">if</span> (eventName === EVENTS[<span class="hljs-number">0</span>] || eventName === EVENTS[<span class="hljs-number">2</span>]) {
					<span class="hljs-keyword">if</span> (args) {
						params.push(args);
					}
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">if</span> (transaction.evt) {
						params.push(transaction.evt);
					} <span class="hljs-keyword">else</span> {
						params.push(transaction.c);
					}
					<span class="hljs-keyword">if</span> (args) {
						params.push(args);
					}
				}
			}

			params.unshift(globalEvent);</pre></div></div>
            
        </li>
        
        
        <li id="section-429">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-429">&#182;</a>
              </div>
              <p>Fire global events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			io.fire.apply(io, params);</pre></div></div>
            
        </li>
        
        
        <li id="section-430">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-430">&#182;</a>
              </div>
              <p>Fire transaction events, if receivers are defined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (config.on) {
				params[<span class="hljs-number">0</span>] = trnEvent;
				io.once(trnEvent, config.on[eventName], config.context || Y);
				io.fire.apply(io, params);
			}
		},

		<span class="hljs-comment">/**
		 * Fires event "io:start" and creates, fires a transaction-specific
		 * start event, if `config.on.start` is defined.
		 *
		 * @method start
		 * @param {Object} transaction Transaction object.
		 * @param {Object} config Configuration object for the transaction.
		 */</span>
		start: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, config</span>) </span>{
			<span class="hljs-comment">/**
			 * Signals the start of an IO request.
			 * @event io:start
			 */</span>
			<span class="hljs-keyword">this</span>._evt(EVENTS[<span class="hljs-number">0</span>], transaction, config);
		},

		<span class="hljs-comment">/**
		 * Fires event "io:complete" and creates, fires a
		 * transaction-specific "complete" event, if config.on.complete is
		 * defined.
		 *
		 * @method complete
		 * @param {Object} transaction Transaction object.
		 * @param {Object} config Configuration object for the transaction.
		 */</span>
		complete: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, config</span>) </span>{
			<span class="hljs-comment">/**
			 * Signals the completion of the request-response phase of a
			 * transaction. Response status and data are accessible, if
			 * available, in this event.
			 * @event io:complete
			 */</span>
			<span class="hljs-keyword">this</span>._evt(EVENTS[<span class="hljs-number">1</span>], transaction, config);
		},

		<span class="hljs-comment">/**
		 * Fires event "io:end" and creates, fires a transaction-specific "end"
		 * event, if config.on.end is defined.
		 *
		 * @method end
		 * @param {Object} transaction Transaction object.
		 * @param {Object} config Configuration object for the transaction.
		 */</span>
		end: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, config</span>) </span>{
			<span class="hljs-comment">/**
			 * Signals the end of the transaction lifecycle.
			 * @event io:end
			 */</span>
			<span class="hljs-keyword">this</span>._evt(EVENTS[<span class="hljs-number">2</span>], transaction, config);
			<span class="hljs-keyword">this</span>._destroy(transaction);
		},

		<span class="hljs-comment">/**
		 * Fires event "io:success" and creates, fires a transaction-specific
		 * "success" event, if config.on.success is defined.
		 *
		 * @method success
		 * @param {Object} transaction Transaction object.
		 * @param {Object} config Configuration object for the transaction.
		 */</span>
		success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, config</span>) </span>{
			<span class="hljs-comment">/**
			 * Signals an HTTP response with status in the 2xx range.
			 * Fires after io:complete.
			 * @event io:success
			 */</span>
			<span class="hljs-keyword">this</span>._evt(EVENTS[<span class="hljs-number">3</span>], transaction, config);
			<span class="hljs-keyword">this</span>.end(transaction, config);
		},

		<span class="hljs-comment">/**
		 * Fires event "io:failure" and creates, fires a transaction-specific
		 * "failure" event, if config.on.failure is defined.
		 *
		 * @method failure
		 * @param {Object} transaction Transaction object.
		 * @param {Object} config Configuration object for the transaction.
		 */</span>
		failure: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, config</span>) </span>{
			<span class="hljs-comment">/**
			 * Signals an HTTP response with status outside of the 2xx range.
			 * Fires after io:complete.
			 * @event io:failure
			 */</span>
			<span class="hljs-keyword">this</span>._evt(EVENTS[<span class="hljs-number">4</span>], transaction, config);
			<span class="hljs-keyword">this</span>.end(transaction, config);
		},

		<span class="hljs-comment">/**
		 * Fires event "io:progress" and creates, fires a transaction-specific
		 * "progress" event -- for XMLHttpRequest file upload -- if
		 * config.on.progress is defined.
		 *
		 * @method progress
		 * @param {Object} transaction Transaction object.
		 * @param {Object} progress event.
		 * @param {Object} config Configuration object for the transaction.
		 */</span>
		progress: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, e, config</span>) </span>{
			<span class="hljs-comment">/**
			 * Signals the interactive state during a file upload transaction.
			 * This event fires after io:start and before io:complete.
			 * @event io:progress
			 */</span>
			transaction.evt = e;
			<span class="hljs-keyword">this</span>._evt(EVENTS[<span class="hljs-number">5</span>], transaction, config);
		},

		<span class="hljs-comment">/**
		 * Fires event "io:complete" and creates, fires a transaction-specific
		 * "complete" event -- for XMLHttpRequest file upload -- if
		 * config.on.complete is defined.
		 *
		 * @method load
		 * @param {Object} transaction Transaction object.
		 * @param {Object} load event.
		 * @param {Object} config Configuration object for the transaction.
		 */</span>
		load: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">transaction, e, config</span>) </span>{
			transaction.evt = e.target;
			<span class="hljs-keyword">this</span>._evt(EVENTS[<span class="hljs-number">1</span>], transaction, config);
		},

		<span class="hljs-comment">/**
		 * Fires event "io:failure" and creates, fires a transaction-specific
		 * "failure" event -- for XMLHttpRequest file upload -- if
		 * config.on.failure is defined.
		 *
		 * @method error
		 * @param {Object} transaction Transaction object.
		 * @param {Object} error event.
		 * @param {Object} config Configuration object for the transaction.
		 */</span>
		error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">transaction, e, config</span>) </span>{
			transaction.evt = e;
			<span class="hljs-keyword">this</span>._evt(EVENTS[<span class="hljs-number">4</span>], transaction, config);
		},

		<span class="hljs-comment">/**
		 * Retry an XDR transaction, using the Flash tranport, if the native
		 * transport fails.
		 *
		 * @method _retry
		 * @private
		 * @param {Object} transaction Transaction object.
		 * @param {String} uri Qualified path to transaction resource.
		 * @param {Object} config Configuration object for the transaction.
		 */</span>
		_retry: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, uri, config</span>) </span>{
			<span class="hljs-keyword">this</span>._destroy(transaction);
			config.xdr.use = <span class="hljs-string">'flash'</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.send(uri, config, transaction.id);
		},

		<span class="hljs-comment">/**
		 * Method that concatenates string data for HTTP GET transactions.
		 *
		 * @method _concat
		 * @private
		 * @param {String} uri URI or root data.
		 * @param {String} data Data to be concatenated onto URI.
		 * @return {String}
		 */</span>
		_concat: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">uri, data</span>) </span>{
			uri += (uri.indexOf(<span class="hljs-string">'?'</span>) === <span class="hljs-number">-1</span> ? <span class="hljs-string">'?'</span> : <span class="hljs-string">'&amp;'</span>) + data;
			<span class="hljs-keyword">return</span> uri;
		},

		<span class="hljs-comment">/**
		 * Stores default client headers for all transactions. If a label is
		 * passed with no value argument, the header will be deleted.
		 *
		 * @method setHeader
		 * @param {String} name HTTP header
		 * @param {String} value HTTP header value
		 */</span>
		setHeader: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, value</span>) </span>{
			<span class="hljs-keyword">if</span> (value) {
				<span class="hljs-keyword">this</span>._headers[name] = value;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._headers[name];
			}
		},

		<span class="hljs-comment">/**
		 * Method that sets all HTTP headers to be sent in a transaction.
		 *
		 * @method _setHeaders
		 * @private
		 * @param {Object} transaction - XHR instance for the specific transaction.
		 * @param {Object} headers - HTTP headers for the specific transaction, as
		 *                    defined in the configuration object passed to YUI.io().
		 */</span>
		_setHeaders: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, headers</span>) </span>{
			headers = Y.merge(<span class="hljs-keyword">this</span>._headers, headers);
			Y.Object.each(headers, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, name</span>) </span>{
				<span class="hljs-keyword">if</span> (value !== <span class="hljs-string">'disable'</span>) {
					transaction.setRequestHeader(name, headers[name]);
				}
			});
		},

		<span class="hljs-comment">/**
		 * Starts timeout count if the configuration object has a defined
		 * timeout property.
		 *
		 * @method _startTimeout
		 * @private
		 * @param {Object} transaction Transaction object generated by _create().
		 * @param {Object} timeout Timeout in milliseconds.
		 */</span>
		_startTimeout: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, timeout</span>) </span>{
			<span class="hljs-keyword">var</span> io = <span class="hljs-keyword">this</span>;

			io._timeout[transaction.id] = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
				io._abort(transaction, <span class="hljs-string">'timeout'</span>);
			}, timeout);
		},

		<span class="hljs-comment">/**
		 * Clears the timeout interval started by _startTimeout().
		 *
		 * @method _clearTimeout
		 * @private
		 * @param {Number} id - Transaction id.
		 */</span>
		_clearTimeout: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>{
			clearTimeout(<span class="hljs-keyword">this</span>._timeout[id]);
			<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._timeout[id];
		},

		<span class="hljs-comment">/**
		 * Method that determines if a transaction response qualifies as success
		 * or failure, based on the response HTTP status code, and fires the
		 * appropriate success or failure events.
		 *
		 * @method _result
		 * @private
		 * @static
		 * @param {Object} transaction Transaction object generated by _create().
		 * @param {Object} config Configuration object passed to io().
		 */</span>
		_result: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, config</span>) </span>{
			<span class="hljs-keyword">var</span> status;</pre></div></div>
            
        </li>
        
        
        <li id="section-431">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-431">&#182;</a>
              </div>
              <p>Firefox will throw an exception if attempting to access
an XHR object’s status property, after a request is aborted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">try</span> {
				status = transaction.c.status;
			} <span class="hljs-keyword">catch</span>(e) {
				status = <span class="hljs-number">0</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-432">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-432">&#182;</a>
              </div>
              <p>IE reports HTTP 204 as HTTP 1223.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span> || status === <span class="hljs-number">304</span> || status === <span class="hljs-number">1223</span>) {
				<span class="hljs-keyword">this</span>.success(transaction, config);
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">this</span>.failure(transaction, config);
			}
		},

		<span class="hljs-comment">/**
		 * Event handler bound to onreadystatechange.
		 *
		 * @method _rS
		 * @private
		 * @param {Object} transaction Transaction object generated by _create().
		 * @param {Object} config Configuration object passed to YUI.io().
		 */</span>
		_rS: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, config</span>) </span>{
			<span class="hljs-keyword">var</span> io = <span class="hljs-keyword">this</span>;

			<span class="hljs-keyword">if</span> (transaction.c.readyState === <span class="hljs-number">4</span>) {
				<span class="hljs-keyword">if</span> (config.timeout) {
					io._clearTimeout(transaction.id);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-433">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-433">&#182;</a>
              </div>
              <p>Yield in the event of request timeout or abort.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					io.complete(transaction, config);
					io._result(transaction, config);
				}, <span class="hljs-number">0</span>);
			}
		},

		<span class="hljs-comment">/**
		 * Terminates a transaction due to an explicit abort or timeout.
		 *
		 * @method _abort
		 * @private
		 * @param {Object} transaction Transaction object generated by _create().
		 * @param {String} type Identifies timed out or aborted transaction.
		 */</span>
		_abort: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">transaction, type</span>) </span>{
			<span class="hljs-keyword">if</span> (transaction &amp;&amp; transaction.c) {
				transaction.e = type;
				transaction.c.abort();
			}
		},

		<span class="hljs-comment">/**
		 * Requests a transaction. `send()` is implemented as `Y.io()`.  Each
		 * transaction may include a configuration object.  Its properties are:
		 *
		 * &lt;dl&gt;
		 *   &lt;dt&gt;method&lt;/dt&gt;
		 *     &lt;dd&gt;HTTP method verb (e.g., GET or POST). If this property is not
		 *         not defined, the default value will be GET.&lt;/dd&gt;
		 *
		 *   &lt;dt&gt;data&lt;/dt&gt;
		 *     &lt;dd&gt;This is the name-value string that will be sent as the
		 *     transaction data. If the request is HTTP GET, the data become
		 *     part of querystring. If HTTP POST, the data are sent in the
		 *     message body.&lt;/dd&gt;
		 *
		 *   &lt;dt&gt;xdr&lt;/dt&gt;
		 *     &lt;dd&gt;Defines the transport to be used for cross-domain requests.
		 *     By setting this property, the transaction will use the specified
		 *     transport instead of XMLHttpRequest. The properties of the
		 *     transport object are:
		 *     &lt;dl&gt;
		 *       &lt;dt&gt;use&lt;/dt&gt;
		 *         &lt;dd&gt;The transport to be used: 'flash' or 'native'&lt;/dd&gt;
		 *       &lt;dt&gt;dataType&lt;/dt&gt;
		 *         &lt;dd&gt;Set the value to 'XML' if that is the expected response
		 *         content type.&lt;/dd&gt;
		 *     &lt;/dl&gt;&lt;/dd&gt;
		 *
		 *   &lt;dt&gt;form&lt;/dt&gt;
		 *     &lt;dd&gt;Form serialization configuration object.  Its properties are:
		 *     &lt;dl&gt;
		 *       &lt;dt&gt;id&lt;/dt&gt;
		 *         &lt;dd&gt;Node object or id of HTML form&lt;/dd&gt;
		 *       &lt;dt&gt;useDisabled&lt;/dt&gt;
		 *         &lt;dd&gt;`true` to also serialize disabled form field values
		 *         (defaults to `false`)&lt;/dd&gt;
		 *     &lt;/dl&gt;&lt;/dd&gt;
		 *
		 *   &lt;dt&gt;on&lt;/dt&gt;
		 *     &lt;dd&gt;Assigns transaction event subscriptions. Available events are:
		 *     &lt;dl&gt;
		 *       &lt;dt&gt;start&lt;/dt&gt;
		 *         &lt;dd&gt;Fires when a request is sent to a resource.&lt;/dd&gt;
		 *       &lt;dt&gt;complete&lt;/dt&gt;
		 *         &lt;dd&gt;Fires when the transaction is complete.&lt;/dd&gt;
		 *       &lt;dt&gt;success&lt;/dt&gt;
		 *         &lt;dd&gt;Fires when the HTTP response status is within the 2xx
		 *         range.&lt;/dd&gt;
		 *       &lt;dt&gt;failure&lt;/dt&gt;
		 *         &lt;dd&gt;Fires when the HTTP response status is outside the 2xx
		 *         range, if an exception occurs, if the transation is aborted,
		 *         or if the transaction exceeds a configured `timeout`.&lt;/dd&gt;
		 *       &lt;dt&gt;end&lt;/dt&gt;
		 *         &lt;dd&gt;Fires at the conclusion of the transaction
		 *            lifecycle, after `success` or `failure`.&lt;/dd&gt;
		 *     &lt;/dl&gt;
		 *
		 *     &lt;p&gt;Callback functions for `start` and `end` receive the id of the
		 *     transaction as a first argument. For `complete`, `success`, and
		 *     `failure`, callbacks receive the id and the response object
		 *     (usually the XMLHttpRequest instance).  If the `arguments`
		 *     property was included in the configuration object passed to
		 *     `Y.io()`, the configured data will be passed to all callbacks as
		 *     the last argument.&lt;/p&gt;
		 *     &lt;/dd&gt;
		 *
		 *   &lt;dt&gt;sync&lt;/dt&gt;
		 *     &lt;dd&gt;Pass `true` to make a same-domain transaction synchronous.
		 *     &lt;strong&gt;CAVEAT&lt;/strong&gt;: This will negatively impact the user
		 *     experience. Have a &lt;em&gt;very&lt;/em&gt; good reason if you intend to use
		 *     this.&lt;/dd&gt;
		 *
		 *   &lt;dt&gt;context&lt;/dt&gt;
		 *     &lt;dd&gt;The "`this'" object for all configured event handlers. If a
		 *     specific context is needed for individual callbacks, bind the
		 *     callback to a context using `Y.bind()`.&lt;/dd&gt;
		 *
		 *   &lt;dt&gt;headers&lt;/dt&gt;
		 *     &lt;dd&gt;Object map of transaction headers to send to the server. The
		 *     object keys are the header names and the values are the header
		 *     values.&lt;/dd&gt;
		 *
		 *   &lt;dt&gt;timeout&lt;/dt&gt;
		 *     &lt;dd&gt;Millisecond threshold for the transaction before being
		 *     automatically aborted.&lt;/dd&gt;
		 *
		 *   &lt;dt&gt;arguments&lt;/dt&gt;
		 *     &lt;dd&gt;User-defined data passed to all registered event handlers.
		 *     This value is available as the second argument in the "start" and
		 *     "end" event handlers. It is the third argument in the "complete",
		 *     "success", and "failure" event handlers. &lt;strong&gt;Be sure to quote
		 *     this property name in the transaction configuration as
		 *     "arguments" is a reserved word in JavaScript&lt;/strong&gt; (e.g.
		 *     `Y.io({ ..., "arguments": stuff })`).&lt;/dd&gt;
		 * &lt;/dl&gt;
		 *
		 * @method send
		 * @public
		 * @param {String} uri Qualified path to transaction resource.
		 * @param {Object} config Configuration object for the transaction.
		 * @param {Number} id Transaction id, if already set.
		 * @return {Object}
		 */</span>
		send: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">uri, config, id</span>) </span>{
			<span class="hljs-keyword">var</span> transaction, method, i, len, sync, data,
				io = <span class="hljs-keyword">this</span>,
				u = uri,
				response = {};

			config = config ? Y.Object(config) : {};
			transaction = io._create(config, id);
			method = config.method ? config.method.toUpperCase() : <span class="hljs-string">'GET'</span>;
			sync = config.sync;
			data = config.data;</pre></div></div>
            
        </li>
        
        
        <li id="section-434">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-434">&#182;</a>
              </div>
              <p>Serialize an map object into a key-value string using
querystring-stringify-simple.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ((Y.Lang.isObject(data) &amp;&amp; !data.nodeType) &amp;&amp; !transaction.upload) {
				data = Y.QueryString.stringify(data);
			}

			<span class="hljs-keyword">if</span> (config.form) {
				<span class="hljs-keyword">if</span> (config.form.upload) {</pre></div></div>
            
        </li>
        
        
        <li id="section-435">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-435">&#182;</a>
              </div>
              <p>This is a file upload transaction, calling
upload() in io-upload-iframe.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> io.upload(transaction, uri, config);
				} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-436">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-436">&#182;</a>
              </div>
              <p>Serialize HTML form data into a key-value string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					data = io._serialize(config.form, data);
				}
			}

			<span class="hljs-keyword">if</span> (data) {
				<span class="hljs-keyword">switch</span> (method) {
					<span class="hljs-keyword">case</span> <span class="hljs-string">'GET'</span>:
					<span class="hljs-keyword">case</span> <span class="hljs-string">'HEAD'</span>:
					<span class="hljs-keyword">case</span> <span class="hljs-string">'DELETE'</span>:
						u = io._concat(u, data);
						data = <span class="hljs-string">''</span>;
						<span class="hljs-keyword">break</span>;
					<span class="hljs-keyword">case</span> <span class="hljs-string">'POST'</span>:
					<span class="hljs-keyword">case</span> <span class="hljs-string">'PUT'</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-437">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-437">&#182;</a>
              </div>
              <p>If Content-Type is defined in the configuration object, or
or as a default header, it will be used instead of
‘application/x-www-form-urlencoded; charset=UTF-8’</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						config.headers = Y.merge({
							<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>
						}, config.headers);
						<span class="hljs-keyword">break</span>;
				}
			}

			<span class="hljs-keyword">if</span> (transaction.xdr) {</pre></div></div>
            
        </li>
        
        
        <li id="section-438">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-438">&#182;</a>
              </div>
              <p>Route data to io-xdr module for flash and XDomainRequest.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> io.xdr(u, transaction, config);
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (transaction.notify) {</pre></div></div>
            
        </li>
        
        
        <li id="section-439">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-439">&#182;</a>
              </div>
              <p>Route data to custom transport</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> transaction.c.send(transaction, uri, config);
			}

			<span class="hljs-keyword">if</span> (!sync &amp;&amp; !transaction.upload) {
				transaction.c.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					io._rS(transaction, config);
				};
			}

			<span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-440">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-440">&#182;</a>
              </div>
              <p>Determine if request is to be set as
synchronous or asynchronous.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				transaction.c.open(method, u, !sync, config.username || <span class="hljs-literal">null</span>, config.password || <span class="hljs-literal">null</span>);
				io._setHeaders(transaction.c, config.headers || {});
				io.start(transaction, config);</pre></div></div>
            
        </li>
        
        
        <li id="section-441">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-441">&#182;</a>
              </div>
              <p>Will work only in browsers that implement the
Cross-Origin Resource Sharing draft.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (config.xdr &amp;&amp; config.xdr.credentials &amp;&amp; SUPPORTS_CORS) {
					transaction.c.withCredentials = <span class="hljs-literal">true</span>;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-442">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-442">&#182;</a>
              </div>
              <p>Using “null” with HTTP POST will result in a request
with no Content-Length header defined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				transaction.c.send(data);

				<span class="hljs-keyword">if</span> (sync) {</pre></div></div>
            
        </li>
        
        
        <li id="section-443">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-443">&#182;</a>
              </div>
              <p>Create a response object for synchronous transactions,
mixing id and arguments properties with the xhr
properties whitelist.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = XHR_PROPS.length; i &lt; len; ++i) {
						response[XHR_PROPS[i]] = transaction.c[XHR_PROPS[i]];
					}

					response.getAllResponseHeaders = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
						<span class="hljs-keyword">return</span> transaction.c.getAllResponseHeaders();
					};

					response.getResponseHeader = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
						<span class="hljs-keyword">return</span> transaction.c.getResponseHeader(name);
					};

					io.complete(transaction, config);
					io._result(transaction, config);

					<span class="hljs-keyword">return</span> response;
				}
			} <span class="hljs-keyword">catch</span>(e) {
				<span class="hljs-keyword">if</span> (transaction.xdr) {</pre></div></div>
            
        </li>
        
        
        <li id="section-444">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-444">&#182;</a>
              </div>
              <p>This exception is usually thrown by browsers
that do not support XMLHttpRequest Level 2.
Retry the request with the XDR transport set
to ‘flash’.  If the Flash transport is not
initialized or available, the transaction
will resolve to a transport error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span> io._retry(transaction, uri, config);
				} <span class="hljs-keyword">else</span> {
					io.complete(transaction, config);
					io._result(transaction, config);
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-445">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-445">&#182;</a>
              </div>
              <p>If config.timeout is defined, and the request is standard XHR,
initialize timeout polling.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (config.timeout) {
				io._startTimeout(transaction, config.timeout);
			}

			<span class="hljs-keyword">return</span> {
				<span class="hljs-attr">id</span>: transaction.id,
				<span class="hljs-attr">abort</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					<span class="hljs-keyword">return</span> transaction.c ? io._abort(transaction, <span class="hljs-string">'abort'</span>) : <span class="hljs-literal">false</span>;
				},
				<span class="hljs-attr">isInProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					<span class="hljs-keyword">return</span> transaction.c ? (transaction.c.readyState % <span class="hljs-number">4</span>) : <span class="hljs-literal">false</span>;
				},
				<span class="hljs-attr">io</span>: io
			};
		}
	};

	<span class="hljs-comment">/**
	 Method for initiating an ajax call.  The first argument is the url end
	 point for the call.  The second argument is an object to configure the
	 transaction and attach event subscriptions.  The configuration object
	 supports the following properties:

	 &lt;dl&gt;
	 &lt;dt&gt;method&lt;/dt&gt;
	 &lt;dd&gt;HTTP method verb (e.g., GET or POST). If this property is not
	 not defined, the default value will be GET.&lt;/dd&gt;

	 &lt;dt&gt;data&lt;/dt&gt;
	 &lt;dd&gt;This is the name-value string that will be sent as the
	 transaction data. If the request is HTTP GET, the data become
	 part of querystring. If HTTP POST, the data are sent in the
	 message body.&lt;/dd&gt;

	 &lt;dt&gt;xdr&lt;/dt&gt;
	 &lt;dd&gt;Defines the transport to be used for cross-domain requests.
	 By setting this property, the transaction will use the specified
	 transport instead of XMLHttpRequest. The properties of the
	 transport object are:
	 &lt;dl&gt;
	 &lt;dt&gt;use&lt;/dt&gt;
	 &lt;dd&gt;The transport to be used: 'flash' or 'native'&lt;/dd&gt;
	 &lt;dt&gt;dataType&lt;/dt&gt;
	 &lt;dd&gt;Set the value to 'XML' if that is the expected response
	 content type.&lt;/dd&gt;
	 &lt;/dl&gt;&lt;/dd&gt;

	 &lt;dt&gt;form&lt;/dt&gt;
	 &lt;dd&gt;Form serialization configuration object.  Its properties are:
	 &lt;dl&gt;
	 &lt;dt&gt;id&lt;/dt&gt;
	 &lt;dd&gt;Node object or id of HTML form&lt;/dd&gt;
	 &lt;dt&gt;useDisabled&lt;/dt&gt;
	 &lt;dd&gt;`true` to also serialize disabled form field values
	 (defaults to `false`)&lt;/dd&gt;
	 &lt;/dl&gt;&lt;/dd&gt;

	 &lt;dt&gt;on&lt;/dt&gt;
	 &lt;dd&gt;Assigns transaction event subscriptions. Available events are:
	 &lt;dl&gt;
	 &lt;dt&gt;start&lt;/dt&gt;
	 &lt;dd&gt;Fires when a request is sent to a resource.&lt;/dd&gt;
	 &lt;dt&gt;complete&lt;/dt&gt;
	 &lt;dd&gt;Fires when the transaction is complete.&lt;/dd&gt;
	 &lt;dt&gt;success&lt;/dt&gt;
	 &lt;dd&gt;Fires when the HTTP response status is within the 2xx
	 range.&lt;/dd&gt;
	 &lt;dt&gt;failure&lt;/dt&gt;
	 &lt;dd&gt;Fires when the HTTP response status is outside the 2xx
	 range, if an exception occurs, if the transation is aborted,
	 or if the transaction exceeds a configured `timeout`.&lt;/dd&gt;
	 &lt;dt&gt;end&lt;/dt&gt;
	 &lt;dd&gt;Fires at the conclusion of the transaction
	 lifecycle, after `success` or `failure`.&lt;/dd&gt;
	 &lt;/dl&gt;

	 &lt;p&gt;Callback functions for `start` and `end` receive the id of the
	 transaction as a first argument. For `complete`, `success`, and
	 `failure`, callbacks receive the id and the response object
	 (usually the XMLHttpRequest instance).  If the `arguments`
	 property was included in the configuration object passed to
	 `Y.io()`, the configured data will be passed to all callbacks as
	 the last argument.&lt;/p&gt;
	 &lt;/dd&gt;

	 &lt;dt&gt;sync&lt;/dt&gt;
	 &lt;dd&gt;Pass `true` to make a same-domain transaction synchronous.
	 &lt;strong&gt;CAVEAT&lt;/strong&gt;: This will negatively impact the user
	 experience. Have a &lt;em&gt;very&lt;/em&gt; good reason if you intend to use
	 this.&lt;/dd&gt;

	 &lt;dt&gt;context&lt;/dt&gt;
	 &lt;dd&gt;The "`this'" object for all configured event handlers. If a
	 specific context is needed for individual callbacks, bind the
	 callback to a context using `Y.bind()`.&lt;/dd&gt;

	 &lt;dt&gt;headers&lt;/dt&gt;
	 &lt;dd&gt;Object map of transaction headers to send to the server. The
	 object keys are the header names and the values are the header
	 values.&lt;/dd&gt;

	 &lt;dt&gt;timeout&lt;/dt&gt;
	 &lt;dd&gt;Millisecond threshold for the transaction before being
	 automatically aborted.&lt;/dd&gt;

	 &lt;dt&gt;arguments&lt;/dt&gt;
	 &lt;dd&gt;User-defined data passed to all registered event handlers.
	 This value is available as the second argument in the "start" and
	 "end" event handlers. It is the third argument in the "complete",
	 "success", and "failure" event handlers. &lt;strong&gt;Be sure to quote
	 this property name in the transaction configuration as
	 "arguments" is a reserved word in JavaScript&lt;/strong&gt; (e.g.
	 `Y.io({ ..., "arguments": stuff })`).&lt;/dd&gt;
	 &lt;/dl&gt;

	 @method io
	 @static
	 @param {String} url qualified path to transaction resource.
	 @param {Object} config configuration object for the transaction.
	 @return {Object}
	 @for YUI
	 **/</span>
	Y.io = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url, config</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-446">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-446">&#182;</a>
              </div>
              <p>Calling IO through the static interface will use and reuse
an instance of IO.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> transaction = Y.io._map[<span class="hljs-string">'io:0'</span>] || <span class="hljs-keyword">new</span> IO();
		<span class="hljs-keyword">return</span> transaction.send.apply(transaction, [url, config]);
	};

	<span class="hljs-comment">/**
	 Method for setting and deleting IO HTTP headers to be sent with every
	 request.

	 Hosted as a property on the `io` function (e.g. `Y.io.header`).

	 @method header
	 @param {String} name HTTP header
	 @param {String} value HTTP header value
	 @static
	 **/</span>
	Y.io.header = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, value</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-447">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-447">&#182;</a>
              </div>
              <p>Calling IO through the static interface will use and reuse
an instance of IO.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> transaction = Y.io._map[<span class="hljs-string">'io:0'</span>] || <span class="hljs-keyword">new</span> IO();
		transaction.setHeader(name, value);
	};

	Y.IO = IO;</pre></div></div>
            
        </li>
        
        
        <li id="section-448">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-448">&#182;</a>
              </div>
              <p>Map of all IO instances created.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	Y.io._map = {};
	<span class="hljs-keyword">var</span> XHR = win &amp;&amp; win.XMLHttpRequest,
		XDR = win &amp;&amp; win.XDomainRequest,
		AX = win &amp;&amp; win.ActiveXObject,</pre></div></div>
            
        </li>
        
        
        <li id="section-449">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-449">&#182;</a>
              </div>
              <p>Checks for the presence of the <code>withCredentials</code> in an XHR instance
object, which will be present if the environment supports CORS.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		SUPPORTS_CORS = XHR &amp;&amp; <span class="hljs-string">'withCredentials'</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">new</span> XMLHttpRequest());


	Y.mix(Y.IO, {
		<span class="hljs-comment">/**
		 * The ID of the default IO transport, defaults to `xhr`
		 * @property _default
		 * @type {String}
		 * @static
		 */</span>
		_default: <span class="hljs-string">'xhr'</span>,
		<span class="hljs-comment">/**
		 *
		 * @method defaultTransport
		 * @static
		 * @param {String} [id] The transport to set as the default, if empty a new transport is created.
		 * @return {Object} The transport object with a `send` method
		 */</span>
		defaultTransport: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>{
			<span class="hljs-keyword">if</span> (id) {
				Y.IO._default = id;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">var</span> o = {
					<span class="hljs-attr">c</span>: Y.IO.transports[Y.IO._default](),
					<span class="hljs-attr">notify</span>: Y.IO._default === <span class="hljs-string">'xhr'</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>
				};
				<span class="hljs-keyword">return</span> o;
			}
		},
		<span class="hljs-comment">/**
		 * An object hash of custom transports available to IO
		 * @property transports
		 * @type {Object}
		 * @static
		 */</span>
		transports: {
			<span class="hljs-attr">xhr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">return</span> XHR ? <span class="hljs-keyword">new</span> XMLHttpRequest() :
					AX ? <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">'Microsoft.XMLHTTP'</span>) : <span class="hljs-literal">null</span>;
			},
			<span class="hljs-attr">xdr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">return</span> XDR ? <span class="hljs-keyword">new</span> XDomainRequest() : <span class="hljs-literal">null</span>;
			},
			<span class="hljs-attr">iframe</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> {}; },
			<span class="hljs-attr">flash</span>: <span class="hljs-literal">null</span>,
			<span class="hljs-attr">nodejs</span>: <span class="hljs-literal">null</span>
		},
		<span class="hljs-comment">/**
		 * Create a custom transport of type and return it's object
		 * @method customTransport
		 * @param {String} id The id of the transport to create.
		 * @static
		 */</span>
		customTransport: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>{
			<span class="hljs-keyword">var</span> o = { <span class="hljs-attr">c</span>: Y.IO.transports[id]() };

			o[(id === <span class="hljs-string">'xdr'</span> || id === <span class="hljs-string">'flash'</span>) ? <span class="hljs-string">'xdr'</span> : <span class="hljs-string">'notify'</span>] = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">return</span> o;
		}
	});

	Y.mix(Y.IO.prototype, {
		<span class="hljs-comment">/**
		 * Fired from the notify method of the transport which in turn fires
		 * the event on the IO object.
		 * @method notify
		 * @param {String} event The name of the event
		 * @param {Object} transaction The transaction object
		 * @param {Object} config The configuration object for this transaction
		 */</span>
		notify: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, transaction, config</span>) </span>{
			<span class="hljs-keyword">var</span> io = <span class="hljs-keyword">this</span>;

			<span class="hljs-keyword">switch</span> (event) {
				<span class="hljs-keyword">case</span> <span class="hljs-string">'timeout'</span>:
				<span class="hljs-keyword">case</span> <span class="hljs-string">'abort'</span>:
				<span class="hljs-keyword">case</span> <span class="hljs-string">'transport error'</span>:
					transaction.c = { <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">statusText</span>: event };
					event = <span class="hljs-string">'failure'</span>;
				<span class="hljs-keyword">default</span>:
					io[event].apply(io, [transaction, config]);
			}
		}
	});




}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"event-custom-base"</span>, <span class="hljs-string">"querystring-stringify-simple"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'array-extras'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 Adds additional utility methods to the `Y.Array` class.

	 @module collection
	 @submodule array-extras
	 **/</span>

	<span class="hljs-keyword">var</span> A          = Y.Array,
		L          = Y.Lang,
		ArrayProto = <span class="hljs-built_in">Array</span>.prototype;

	<span class="hljs-comment">/**
	 Returns the index of the last item in the array that contains the specified
	 value, or `-1` if the value isn't found.

	 @method lastIndexOf
	 @param {Array} a Array to search in.
	 @param {Any} val Value to search for.
	 @param {Number} [fromIndex] Index at which to start searching backwards.
	 Defaults to the array's length - 1. If negative, it will be taken as an offset
	 from the end of the array. If the calculated index is less than 0, the array
	 will not be searched and `-1` will be returned.
	 @return {Number} Index of the item that contains the value, or `-1` if not
	 found.
	 @static
	 @for Array
	 **/</span>
	A.lastIndexOf = L._isNative(ArrayProto.lastIndexOf) ?
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, val, fromIndex</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-450">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-450">&#182;</a>
              </div>
              <p>An undefined fromIndex is still considered a value by some (all?)
native implementations, so we can’t pass it unless it’s actually
specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> fromIndex || fromIndex === <span class="hljs-number">0</span> ? a.lastIndexOf(val, fromIndex) :
				a.lastIndexOf(val);
		} :
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, val, fromIndex</span>) </span>{
			<span class="hljs-keyword">var</span> len = a.length,
				i   = len - <span class="hljs-number">1</span>;

			<span class="hljs-keyword">if</span> (fromIndex || fromIndex === <span class="hljs-number">0</span>) {
				i = <span class="hljs-built_in">Math</span>.min(fromIndex &lt; <span class="hljs-number">0</span> ? len + fromIndex : fromIndex, len);
			}

			<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">-1</span> &amp;&amp; len &gt; <span class="hljs-number">0</span>) {
				<span class="hljs-keyword">for</span> (; i &gt; <span class="hljs-number">-1</span>; --i) {
					<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> a &amp;&amp; a[i] === val) {
						<span class="hljs-keyword">return</span> i;
					}
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
		};

	<span class="hljs-comment">/**
	 Returns a copy of the input array with duplicate items removed.

	 Note: If the input array only contains strings, the `Y.Array.dedupe()` method is
	 a much faster alternative.

	 @method unique
	 @param {Array} array Array to dedupe.
	 @param {Function} [testFn] Custom function to use to test the equality of two
	 values. A truthy return value indicates that the values are equal. A falsy
	 return value indicates that the values are not equal.

	 @param {Any} testFn.a First value to compare.
	 @param {Any} testFn.b Second value to compare.
	 @param {Number} testFn.index Index of the current item in the original
	 array.
	 @param {Array} testFn.array The original array.
	 @return {Boolean} _true_ if the items are equal, _false_ otherwise.

	 @return {Array} Copy of the input array with duplicate items removed.
	 @static
	 **/</span>
	A.unique = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">array, testFn</span>) </span>{
		<span class="hljs-keyword">var</span> i       = <span class="hljs-number">0</span>,
			len     = array.length,
			results = [],
			j, result, resultLen, value;</pre></div></div>
            
        </li>
        
        
        <li id="section-451">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-451">&#182;</a>
              </div>
              <p>Note the label here. It’s used to jump out of the inner loop when a value
is not unique.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		outerLoop: <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
			value = array[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-452">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-452">&#182;</a>
              </div>
              <p>For each value in the input array, iterate through the result array
and check for uniqueness against each result value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, resultLen = results.length; j &lt; resultLen; j++) {
				result = results[j];</pre></div></div>
            
        </li>
        
        
        <li id="section-453">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-453">&#182;</a>
              </div>
              <p>If the test function returns true or there’s no test function and
the value equals the current result item, stop iterating over the
results and continue to the next value in the input array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (testFn) {
					<span class="hljs-keyword">if</span> (testFn.call(array, value, result, i, array)) {
						<span class="hljs-keyword">continue</span> outerLoop;
					}
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value === result) {
					<span class="hljs-keyword">continue</span> outerLoop;
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-454">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-454">&#182;</a>
              </div>
              <p>If we get this far, that means the current value is not already in
the result array, so add it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			results.push(value);
		}

		<span class="hljs-keyword">return</span> results;
	};

	<span class="hljs-comment">/**
	 Executes the supplied function on each item in the array. Returns a new array
	 containing the items for which the supplied function returned a truthy value.

	 @method filter
	 @param {Array} a Array to filter.
	 @param {Function} f Function to execute on each item.
	 @param {Object} [o] Optional context object.
	 @return {Array} Array of items for which the supplied function returned a
	 truthy value (empty if it never returned a truthy value).
	 @static
	 */</span>
	A.filter = L._isNative(ArrayProto.filter) ?
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, f, o</span>) </span>{
			<span class="hljs-keyword">return</span> ArrayProto.filter.call(a, f, o);
		} :
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, f, o</span>) </span>{
			<span class="hljs-keyword">var</span> i       = <span class="hljs-number">0</span>,
				len     = a.length,
				results = [],
				item;

			<span class="hljs-keyword">for</span> (; i &lt; len; ++i) {
				<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> a) {
					item = a[i];

					<span class="hljs-keyword">if</span> (f.call(o, item, i, a)) {
						results.push(item);
					}
				}
			}

			<span class="hljs-keyword">return</span> results;
		};

	<span class="hljs-comment">/**
	 The inverse of `Array.filter()`. Executes the supplied function on each item.
	 Returns a new array containing the items for which the supplied function
	 returned `false`.

	 @method reject
	 @param {Array} a the array to iterate.
	 @param {Function} f the function to execute on each item.
	 @param {object} [o] Optional context object.
	 @return {Array} The items for which the supplied function returned `false`.
	 @static
	 */</span>
	A.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, f, o</span>) </span>{
		<span class="hljs-keyword">return</span> A.filter(a, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, i, a</span>) </span>{
			<span class="hljs-keyword">return</span> !f.call(o, item, i, a);
		});
	};

	<span class="hljs-comment">/**
	 Executes the supplied function on each item in the array. Iteration stops if the
	 supplied function does not return a truthy value.

	 @method every
	 @param {Array} a the array to iterate.
	 @param {Function} f the function to execute on each item.
	 @param {Object} [o] Optional context object.
	 @return {Boolean} `true` if every item in the array returns `true` from the
	 supplied function, `false` otherwise.
	 @static
	 */</span>
	A.every = L._isNative(ArrayProto.every) ?
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, f, o</span>) </span>{
			<span class="hljs-keyword">return</span> ArrayProto.every.call(a, f, o);
		} :
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, f, o</span>) </span>{
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = a.length; i &lt; l; ++i) {
				<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> a &amp;&amp; !f.call(o, a[i], i, a)) {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				}
			}

			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		};

	<span class="hljs-comment">/**
	 Executes the supplied function on each item in the array and returns a new array
	 containing all the values returned by the supplied function.

	 @example

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-455">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-455">&#182;</a>
              </div>
              <p>Convert an array of numbers into an array of strings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	 Y.Array.map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
	 <span class="hljs-keyword">return</span> <span class="hljs-string">''</span> + item;
	 });</pre></div></div>
            
        </li>
        
        
        <li id="section-456">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-456">&#182;</a>
              </div>
              <p>=&gt; [‘1’, ‘2’, ‘3’, ‘4’]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	 @method map
	 @param {<span class="hljs-built_in">Array</span>} a the array to iterate.
	 @param {<span class="hljs-built_in">Function</span>} f the <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to</span> <span class="hljs-title">execute</span> <span class="hljs-title">on</span> <span class="hljs-title">each</span> <span class="hljs-title">item</span>.
	 @<span class="hljs-title">param</span> </span>{object} [o] Optional context object.
	 @<span class="hljs-keyword">return</span> {<span class="hljs-built_in">Array</span>} A <span class="hljs-keyword">new</span> array containing the <span class="hljs-keyword">return</span> value <span class="hljs-keyword">of</span> the supplied <span class="hljs-function"><span class="hljs-keyword">function</span>
	 <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">item</span> <span class="hljs-title">in</span> <span class="hljs-title">the</span> <span class="hljs-title">original</span> <span class="hljs-title">array</span>.
	 @<span class="hljs-title">static</span>
	 */
	<span class="hljs-title">A</span>.<span class="hljs-title">map</span> = <span class="hljs-title">L</span>.<span class="hljs-title">_isNative</span>(<span class="hljs-params">ArrayProto.map</span>) ?
		<span class="hljs-title">function</span>(<span class="hljs-params">a, f, o</span>) </span>{
			<span class="hljs-keyword">return</span> ArrayProto.map.call(a, f, o);
		} :
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, f, o</span>) </span>{
			<span class="hljs-keyword">var</span> i       = <span class="hljs-number">0</span>,
				len     = a.length,
				results = ArrayProto.concat.call(a);

			<span class="hljs-keyword">for</span> (; i &lt; len; ++i) {
				<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> a) {
					results[i] = f.call(o, a[i], i, a);
				}
			}

			<span class="hljs-keyword">return</span> results;
		};


	<span class="hljs-comment">/**
	 Executes the supplied function on each item in the array, "folding" the array
	 into a single value.

	 @method reduce
	 @param {Array} a Array to iterate.
	 @param {Any} init Initial value to start with.
	 @param {Function} f Function to execute on each item. This function should
	 update and return the value of the computation. It will receive the following
	 arguments:
	 @param {Any} f.previousValue Value returned from the previous iteration,
	 or the initial value if this is the first iteration.
	 @param {Any} f.currentValue Value of the current item being iterated.
	 @param {Number} f.index Index of the current item.
	 @param {Array} f.array Array being iterated.
	 @param {Object} [o] Optional context object.
	 @return {Any} Final result from iteratively applying the given function to each
	 element in the array.
	 @static
	 */</span>
	A.reduce = L._isNative(ArrayProto.reduce) ?
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, init, f, o</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-457">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-457">&#182;</a>
              </div>
              <p>ES5 Array.reduce doesn’t support a thisObject, so we need to
implement it manually.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> ArrayProto.reduce.call(a, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">init, item, i, a</span>) </span>{
				<span class="hljs-keyword">return</span> f.call(o, init, item, i, a);
			}, init);
		} :
		<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, init, f, o</span>) </span>{
			<span class="hljs-keyword">var</span> i      = <span class="hljs-number">0</span>,
				len    = a.length,
				result = init;

			<span class="hljs-keyword">for</span> (; i &lt; len; ++i) {
				<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> a) {
					result = f.call(o, result, a[i], i, a);
				}
			}

			<span class="hljs-keyword">return</span> result;
		};

	<span class="hljs-comment">/**
	 Executes the supplied function on each item in the array, searching for the
	 first item that matches the supplied function.

	 @method find
	 @param {Array} a the array to search.
	 @param {Function} f the function to execute on each item. Iteration is stopped
	 as soon as this function returns `true`.
	 @param {Object} [o] Optional context object.
	 @return {Object} the first item that the supplied function returns `true` for,
	 or `null` if it never returns `true`.
	 @static
	 */</span>
	A.find = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, f, o</span>) </span>{
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = a.length; i &lt; l; i++) {
			<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> a &amp;&amp; f.call(o, a[i], i, a)) {
				<span class="hljs-keyword">return</span> a[i];
			}
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	};

	<span class="hljs-comment">/**
	 Iterates over an array, returning a new array of all the elements that match the
	 supplied regular expression.

	 @method grep
	 @param {Array} a Array to iterate over.
	 @param {RegExp} pattern Regular expression to test against each item.
	 @return {Array} All the items in the array that produce a match against the
	 supplied regular expression. If no items match, an empty array is returned.
	 @static
	 */</span>
	A.grep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, pattern</span>) </span>{
		<span class="hljs-keyword">return</span> A.filter(a, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>{
			<span class="hljs-keyword">return</span> pattern.test(item);
		});
	};

	<span class="hljs-comment">/**
	 Partitions an array into two new arrays, one with the items for which the
	 supplied function returns `true`, and one with the items for which the function
	 returns `false`.

	 @method partition
	 @param {Array} a Array to iterate over.
	 @param {Function} f Function to execute for each item in the array. It will
	 receive the following arguments:
	 @param {Any} f.item Current item.
	 @param {Number} f.index Index of the current item.
	 @param {Array} f.array The array being iterated.
	 @param {Object} [o] Optional execution context.
	 @return {Object} An object with two properties: `matches` and `rejects`. Each is
	 an array containing the items that were selected or rejected by the test
	 function (or an empty array if none).
	 @static
	 */</span>
	A.partition = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, f, o</span>) </span>{
		<span class="hljs-keyword">var</span> results = {
			<span class="hljs-attr">matches</span>: [],
			<span class="hljs-attr">rejects</span>: []
		};

		A.each(a, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>{
			<span class="hljs-keyword">var</span> set = f.call(o, item, index, a) ? results.matches : results.rejects;
			set.push(item);
		});

		<span class="hljs-keyword">return</span> results;
	};

	<span class="hljs-comment">/**
	 Creates an array of arrays by pairing the corresponding elements of two arrays
	 together into a new array.

	 @method zip
	 @param {Array} a Array to iterate over.
	 @param {Array} a2 Another array whose values will be paired with values of the
	 first array.
	 @return {Array} An array of arrays formed by pairing each element of the first
	 array with an item in the second array having the corresponding index.
	 @static
	 */</span>
	A.zip = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, a2</span>) </span>{
		<span class="hljs-keyword">var</span> results = [];
		A.each(a, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>{
			results.push([item, a2[index]]);
		});
		<span class="hljs-keyword">return</span> results;
	};

	<span class="hljs-comment">/**
	 Flattens an array of nested arrays at any abitrary depth into a single, flat
	 array.

	 @method flatten
	 @param {Array} a Array with nested arrays to flatten.
	 @return {Array} An array whose nested arrays have been flattened.
	 @static
	 @since 3.7.0
	 **/</span>
	A.flatten = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>{
		<span class="hljs-keyword">var</span> result = [],
			i, len, val;</pre></div></div>
            
        </li>
        
        
        <li id="section-458">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-458">&#182;</a>
              </div>
              <p>Always return an array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!a) {
			<span class="hljs-keyword">return</span> result;
		}

		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = a.length; i &lt; len; ++i) {
			val = a[i];

			<span class="hljs-keyword">if</span> (L.isArray(val)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-459">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-459">&#182;</a>
              </div>
              <p>Recusively flattens any nested arrays.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				result.push.apply(result, A.flatten(val));
			} <span class="hljs-keyword">else</span> {
				result.push(val);
			}
		}

		<span class="hljs-keyword">return</span> result;
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'querystring-parse'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * The QueryString module adds support for serializing JavaScript objects into
	 * query strings and parsing JavaScript objects from query strings format.
	 *
	 * The QueryString namespace is added to your YUI instance including static methods
	 * `Y.QueryString.parse(..)` and `Y.QueryString.stringify(..)`.
	 *
	 * The `querystring` module is a alias for `querystring-parse` and
	 * `querystring-stringify`.
	 *
	 * As their names suggest, `querystring-parse` adds support for parsing
	 * Query String data (`Y.QueryString.parse`) and `querystring-stringify` for serializing
	 * JavaScript data into Query Strings (`Y.QueryString.stringify`).  You may choose to
	 * include either of the submodules individually if you don't need the
	 * complementary functionality, or include the rollup for both.
	 *
	 * @module querystring
	 * @main querystring
	 */</span>
	<span class="hljs-comment">/**
	 * The QueryString module adds support for serializing JavaScript objects into
	 * query strings and parsing JavaScript objects from query strings format.
	 * @class QueryString
	 * @static
	 */</span>
	<span class="hljs-keyword">var</span> QueryString = Y.namespace(<span class="hljs-string">"QueryString"</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-460">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-460">&#182;</a>
              </div>
              <p>Parse a key=val string.
These can get pretty hairy
example flow:
parse(foo[bar][][bla]=baz)
return parse(foo[bar][][bla],”baz”)
return parse(foo[bar][], {bla : “baz”})
return parse(foo[bar], [{bla:”baz”}])
return parse(foo, {bar:[{bla:”baz”}]})
return {foo:{bar:[{bla:”baz”}]}}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		pieceParser = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">eq</span>) </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePiece</span> (<span class="hljs-params">key, val</span>) </span>{

				<span class="hljs-keyword">var</span> sliced, numVal, head, tail, ret;

				<span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">2</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-461">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-461">&#182;</a>
              </div>
              <p>key=val, called from the map/reduce</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					key = key.split(eq);
					<span class="hljs-keyword">return</span> parsePiece(
						QueryString.unescape(key.shift()),
						QueryString.unescape(key.join(eq))
					);
				}
				key = key.replace(<span class="hljs-regexp">/^\s+|\s+$/g</span>, <span class="hljs-string">''</span>);
				<span class="hljs-keyword">if</span> (Y.Lang.isString(val)) {
					val = val.replace(<span class="hljs-regexp">/^\s+|\s+$/g</span>, <span class="hljs-string">''</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-462">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-462">&#182;</a>
              </div>
              <p>convert numerals to numbers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(val)) {
						numVal = +val;
						<span class="hljs-keyword">if</span> (val === numVal.toString(<span class="hljs-number">10</span>)) {
							val = numVal;
						}
					}
				}
				sliced = <span class="hljs-regexp">/(.*)\[([^\]]*)\]$/</span>.exec(key);
				<span class="hljs-keyword">if</span> (!sliced) {
					ret = {};
					<span class="hljs-keyword">if</span> (key) {
						ret[key] = val;
					}
					<span class="hljs-keyword">return</span> ret;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-463">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-463">&#182;</a>
              </div>
              <p>[“foo[][bar][][baz]”, “foo[][bar][]”, “baz”]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				tail = sliced[<span class="hljs-number">2</span>];
				head = sliced[<span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-464">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-464">&#182;</a>
              </div>
              <p>array: key[]=val</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!tail) {
					<span class="hljs-keyword">return</span> parsePiece(head, [val]);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-465">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-465">&#182;</a>
              </div>
              <p>obj: key[subkey]=val</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				ret = {};
				ret[tail] = val;
				<span class="hljs-keyword">return</span> parsePiece(head, ret);
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-466">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-466">&#182;</a>
              </div>
              <p>the reducer function that merges each query piece together into one set of params</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		mergeParams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params, addition</span>) </span>{
			<span class="hljs-keyword">return</span> (</pre></div></div>
            
        </li>
        
        
        <li id="section-467">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-467">&#182;</a>
              </div>
              <p>if it’s uncontested, then just return the addition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				(!params) ? addition</pre></div></div>
            
        </li>
        
        
        <li id="section-468">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-468">&#182;</a>
              </div>
              <p>if the existing value is an array, then concat it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					: (Y.Lang.isArray(params)) ? params.concat(addition)</pre></div></div>
            
        </li>
        
        
        <li id="section-469">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-469">&#182;</a>
              </div>
              <p>if the existing value is not an array, and either are not objects, arrayify it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					: (!Y.Lang.isObject(params) || !Y.Lang.isObject(addition)) ? [params].concat(addition)</pre></div></div>
            
        </li>
        
        
        <li id="section-470">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-470">&#182;</a>
              </div>
              <p>else merge them as objects, which is a little more complex</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					: mergeObjects(params, addition)
				);
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-471">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-471">&#182;</a>
              </div>
              <p>Merge two <em>objects</em> together. If this is called, we’ve already ruled
out the simple cases, and need to do the for-in business.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		mergeObjects = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params, addition</span>) </span>{
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> addition) {
				<span class="hljs-keyword">if</span> (i &amp;&amp; addition.hasOwnProperty(i)) {
					params[i] = mergeParams(params[i], addition[i]);
				}
			}
			<span class="hljs-keyword">return</span> params;
		};

	<span class="hljs-comment">/**
	 * Provides Y.QueryString.parse method to accept Query Strings and return native
	 * JavaScript objects.
	 *
	 * @module querystring
	 * @submodule querystring-parse
	 * @for QueryString
	 * @method parse
	 * @param qs {String} Querystring to be parsed into an object.
	 * @param sep {String} (optional) Character that should join param k=v pairs together. Default: "&amp;"
	 * @param eq  {String} (optional) Character that should join keys to their values. Default: "="
	 * @public
	 * @static
	 */</span>
	QueryString.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">qs, sep, eq</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-472">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-472">&#182;</a>
              </div>
              <p>wouldn’t Y.Array(qs.split()).map(pieceParser(eq)).reduce(mergeParams) be prettier?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span> Y.Array.reduce(
			Y.Array.map(
				qs.split(sep || <span class="hljs-string">"&amp;"</span>),
				pieceParser(eq || <span class="hljs-string">"="</span>)
			),
			{},
			mergeParams
		);
	};

	<span class="hljs-comment">/**
	 * Provides Y.QueryString.unescape method to be able to override default decoding
	 * method.  This is important in cases where non-standard delimiters are used, if
	 * the delimiters would not normally be handled properly by the builtin
	 * (en|de)codeURIComponent functions.
	 * Default: replace "+" with " ", and then decodeURIComponent behavior.
	 * @module querystring
	 * @submodule querystring-parse
	 * @for QueryString
	 * @method unescape
	 * @param s {String} String to be decoded.
	 * @public
	 * @static
	 **/</span>
	QueryString.unescape = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">decodeURIComponent</span>(s.replace(<span class="hljs-regexp">/\+/g</span>, <span class="hljs-string">' '</span>));
	};




}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>, <span class="hljs-string">"array-extras"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'querystring-stringify'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Provides Y.QueryString.stringify method for converting objects to Query Strings.
	 *
	 * @module querystring
	 * @submodule querystring-stringify
	 * @for QueryString
	 * @static
	 */</span>

	<span class="hljs-keyword">var</span> QueryString = Y.namespace(<span class="hljs-string">"QueryString"</span>),
		stack = [],
		L = Y.Lang;

	<span class="hljs-comment">/**
	 * Provides Y.QueryString.escape method to be able to override default encoding
	 * method.  This is important in cases where non-standard delimiters are used, if
	 * the delimiters would not normally be handled properly by the builtin
	 * (en|de)codeURIComponent functions.
	 * Default: encodeURIComponent
	 * @module querystring
	 * @submodule querystring-stringify
	 * @for QueryString
	 * @static
	 **/</span>
	QueryString.escape = <span class="hljs-built_in">encodeURIComponent</span>;

	<span class="hljs-comment">/**
	 * &lt;p&gt;Converts an arbitrary value to a Query String representation.&lt;/p&gt;
	 *
	 * &lt;p&gt;Objects with cyclical references will trigger an exception.&lt;/p&gt;
	 *
	 * @method stringify
	 * @public
	 * @param obj {Variant} any arbitrary value to convert to query string
	 * @param cfg {Object} (optional) Configuration object.  The three
	 * supported configurations are:
	 * &lt;ul&gt;&lt;li&gt;sep: When defined, the value will be used as the key-value
	 * separator.  The default value is "&amp;".&lt;/li&gt;
	 * &lt;li&gt;eq: When defined, the value will be used to join the key to
	 * the value.  The default value is "=".&lt;/li&gt;
	 * &lt;li&gt;arrayKey: When set to true, the key of an array will have the
	 * '[]' notation appended to the key.  The default value is false.
	 * &lt;/li&gt;&lt;/ul&gt;
	 * @param name {String} (optional) Name of the current key, for handling children recursively.
	 * @static
	 */</span>
	QueryString.stringify = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, c, name</span>) </span>{
		<span class="hljs-keyword">var</span> begin, end, i, l, n, s,
			sep = c &amp;&amp; c.sep ? c.sep : <span class="hljs-string">"&amp;"</span>,
			eq = c &amp;&amp; c.eq ? c.eq : <span class="hljs-string">"="</span>,
			aK = c &amp;&amp; c.arrayKey ? c.arrayKey : <span class="hljs-literal">false</span>;

		<span class="hljs-keyword">if</span> (L.isNull(obj) || L.isUndefined(obj) || L.isFunction(obj)) {
			<span class="hljs-keyword">return</span> name ? QueryString.escape(name) + eq : <span class="hljs-string">''</span>;
		}

		<span class="hljs-keyword">if</span> (L.isBoolean(obj) || <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">'[object Boolean]'</span>) {
			obj =+ obj;
		}

		<span class="hljs-keyword">if</span> (L.isNumber(obj) || L.isString(obj)) {
			<span class="hljs-keyword">return</span> QueryString.escape(name) + eq + QueryString.escape(obj);
		}

		<span class="hljs-keyword">if</span> (L.isArray(obj)) {
			s = [];
			name = aK ? name + <span class="hljs-string">'[]'</span> : name;
			l = obj.length;
			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; l; i++) {
				s.push( QueryString.stringify(obj[i], c, name) );
			}

			<span class="hljs-keyword">return</span> s.join(sep);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-473">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-473">&#182;</a>
              </div>
              <p>now we know it’s an object.</p>

            </div>
            
        </li>
        
        
        <li id="section-474">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-474">&#182;</a>
              </div>
              <p>Check for cyclical references in nested objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i = stack.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
			<span class="hljs-keyword">if</span> (stack[i] === obj) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"QueryString.stringify. Cyclical reference"</span>);
			}
		}

		stack.push(obj);
		s = [];
		begin = name ? name + <span class="hljs-string">'['</span> : <span class="hljs-string">''</span>;
		end = name ? <span class="hljs-string">']'</span> : <span class="hljs-string">''</span>;
		<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> obj) {
			<span class="hljs-keyword">if</span> (obj.hasOwnProperty(i)) {
				n = begin + i + end;
				s.push(QueryString.stringify(obj[i], c, n));
			}
		}

		stack.pop();
		s = s.join(sep);
		<span class="hljs-keyword">if</span> (!s &amp;&amp; name) {
			<span class="hljs-keyword">return</span> name + <span class="hljs-string">"="</span>;
		}

		<span class="hljs-keyword">return</span> s;
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"yui-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'event-custom-complex'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{


	<span class="hljs-comment">/**
	 * Adds event facades, preventable default behavior, and bubbling.
	 * events.
	 * @module event-custom
	 * @submodule event-custom-complex
	 */</span>

	<span class="hljs-keyword">var</span> FACADE,
		FACADE_KEYS,
		key,
		EMPTY = {},
		CEProto = Y.CustomEvent.prototype,
		ETProto = Y.EventTarget.prototype,

		mixFacadeProps = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">facade, payload</span>) </span>{
			<span class="hljs-keyword">var</span> p;

			<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> payload) {
				<span class="hljs-keyword">if</span> (!(FACADE_KEYS.hasOwnProperty(p))) {
					facade[p] = payload[p];
				}
			}
		};

	<span class="hljs-comment">/**
	 * Wraps and protects a custom event for use when emitFacade is set to true.
	 * Requires the event-custom-complex module
	 * @class EventFacade
	 * @param e {Event} the custom event
	 * @param currentTarget {HTMLElement} the element the listener was attached to
	 */</span>

	Y.EventFacade = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, currentTarget</span>) </span>{

		e = e || EMPTY;

		<span class="hljs-keyword">this</span>._event = e;

		<span class="hljs-comment">/**
		 * The arguments passed to fire
		 * @property details
		 * @type Array
		 */</span>
		<span class="hljs-keyword">this</span>.details = e.details;

		<span class="hljs-comment">/**
		 * The event type, this can be overridden by the fire() payload
		 * @property type
		 * @type string
		 */</span>
		<span class="hljs-keyword">this</span>.type = e.type;

		<span class="hljs-comment">/**
		 * The real event type
		 * @property _type
		 * @type string
		 * @private
		 */</span>
		<span class="hljs-keyword">this</span>._type = e.type;</pre></div></div>
            
        </li>
        
        
        <li id="section-475">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-475">&#182;</a>
              </div>
              <p>////////////////////////////////////////////////////</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-comment">/**
		 * Node reference for the targeted eventtarget
		 * @property target
		 * @type Node
		 */</span>
		<span class="hljs-keyword">this</span>.target = e.target;

		<span class="hljs-comment">/**
		 * Node reference for the element that the listener was attached to.
		 * @property currentTarget
		 * @type Node
		 */</span>
		<span class="hljs-keyword">this</span>.currentTarget = currentTarget;

		<span class="hljs-comment">/**
		 * Node reference to the relatedTarget
		 * @property relatedTarget
		 * @type Node
		 */</span>
		<span class="hljs-keyword">this</span>.relatedTarget = e.relatedTarget;

	};

	Y.mix(Y.EventFacade.prototype, {

		<span class="hljs-comment">/**
		 * Stops the propagation to the next bubble target
		 * @method stopPropagation
		 */</span>
		stopPropagation: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">this</span>._event.stopPropagation();
			<span class="hljs-keyword">this</span>.stopped = <span class="hljs-number">1</span>;
		},

		<span class="hljs-comment">/**
		 * Stops the propagation to the next bubble target and
		 * prevents any additional listeners from being exectued
		 * on the current target.
		 * @method stopImmediatePropagation
		 */</span>
		stopImmediatePropagation: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">this</span>._event.stopImmediatePropagation();
			<span class="hljs-keyword">this</span>.stopped = <span class="hljs-number">2</span>;
		},

		<span class="hljs-comment">/**
		 * Prevents the event's default behavior
		 * @method preventDefault
		 */</span>
		preventDefault: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">this</span>._event.preventDefault();
			<span class="hljs-keyword">this</span>.prevented = <span class="hljs-number">1</span>;
		},

		<span class="hljs-comment">/**
		 * Stops the event propagation and prevents the default
		 * event behavior.
		 * @method halt
		 * @param immediate {boolean} if true additional listeners
		 * on the current target will not be executed
		 */</span>
		halt: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">immediate</span>) </span>{
			<span class="hljs-keyword">this</span>._event.halt(immediate);
			<span class="hljs-keyword">this</span>.prevented = <span class="hljs-number">1</span>;
			<span class="hljs-keyword">this</span>.stopped = (immediate) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;
		}

	});

	CEProto.fireComplex = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{

		<span class="hljs-keyword">var</span> es, ef, q, queue, ce, ret, events, subs, postponed,
			self = <span class="hljs-keyword">this</span>, host = self.host || self, next, oldbubble;

		<span class="hljs-keyword">if</span> (self.stack) {</pre></div></div>
            
        </li>
        
        
        <li id="section-476">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-476">&#182;</a>
              </div>
              <p>queue this event if the current item in the queue bubbles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (self.queuable &amp;&amp; self.type != self.stack.next.type) {
				self.stack.queue.push([self, args]);
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
			}
		}

		es = self.stack || {</pre></div></div>
            
        </li>
        
        
        <li id="section-477">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-477">&#182;</a>
              </div>
              <p>id of the first event in the stack</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			id: self.id,
			<span class="hljs-attr">next</span>: self,
			<span class="hljs-attr">silent</span>: self.silent,
			<span class="hljs-attr">stopped</span>: <span class="hljs-number">0</span>,
			<span class="hljs-attr">prevented</span>: <span class="hljs-number">0</span>,
			<span class="hljs-attr">bubbling</span>: <span class="hljs-literal">null</span>,
			<span class="hljs-attr">type</span>: self.type,</pre></div></div>
            
        </li>
        
        
        <li id="section-478">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-478">&#182;</a>
              </div>
              <p>defaultFnQueue: new Y.Queue(),</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			afterQueue: <span class="hljs-keyword">new</span> Y.Queue(),
			<span class="hljs-attr">defaultTargetOnly</span>: self.defaultTargetOnly,
			<span class="hljs-attr">queue</span>: []
		};

		subs = self.getSubs();

		self.stopped = (self.type !== es.type) ? <span class="hljs-number">0</span> : es.stopped;
		self.prevented = (self.type !== es.type) ? <span class="hljs-number">0</span> : es.prevented;

		self.target = self.target || host;

		<span class="hljs-keyword">if</span> (self.stoppedFn) {
			events = <span class="hljs-keyword">new</span> Y.EventTarget({
				<span class="hljs-attr">fireOnce</span>: <span class="hljs-literal">true</span>,
				<span class="hljs-attr">context</span>: host
			});

			self.events = events;

			events.on(<span class="hljs-string">'stopped'</span>, self.stoppedFn);
		}

		self.currentTarget = host;

		self.details = args.slice(); <span class="hljs-comment">// original arguments in the details</span>


		self._facade = <span class="hljs-literal">null</span>; <span class="hljs-comment">// kill facade to eliminate stale properties</span>

		ef = self._getFacade(args);

		<span class="hljs-keyword">if</span> (Y.Lang.isObject(args[<span class="hljs-number">0</span>])) {
			args[<span class="hljs-number">0</span>] = ef;
		} <span class="hljs-keyword">else</span> {
			args.unshift(ef);
		}

		<span class="hljs-keyword">if</span> (subs[<span class="hljs-number">0</span>]) {
			self._procSubs(subs[<span class="hljs-number">0</span>], args, ef);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-479">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-479">&#182;</a>
              </div>
              <p>bubble if this is hosted in an event target and propagation has not been stopped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (self.bubbles &amp;&amp; host.bubble &amp;&amp; !self.stopped) {

			oldbubble = es.bubbling;

			es.bubbling = self.type;

			<span class="hljs-keyword">if</span> (es.type != self.type) {
				es.stopped = <span class="hljs-number">0</span>;
				es.prevented = <span class="hljs-number">0</span>;
			}

			ret = host.bubble(self, args, <span class="hljs-literal">null</span>, es);

			self.stopped = <span class="hljs-built_in">Math</span>.max(self.stopped, es.stopped);
			self.prevented = <span class="hljs-built_in">Math</span>.max(self.prevented, es.prevented);

			es.bubbling = oldbubble;
		}

		<span class="hljs-keyword">if</span> (self.prevented) {
			<span class="hljs-keyword">if</span> (self.preventedFn) {
				self.preventedFn.apply(host, args);
			}
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.defaultFn &amp;&amp;
			((!self.defaultTargetOnly &amp;&amp; !es.defaultTargetOnly) ||
				host === ef.target)) {
			self.defaultFn.apply(host, args);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-480">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-480">&#182;</a>
              </div>
              <p>broadcast listeners are fired as discreet events on the
YUI instance and potentially the YUI global.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		self._broadcast(args);</pre></div></div>
            
        </li>
        
        
        <li id="section-481">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-481">&#182;</a>
              </div>
              <p>Queue the after</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (subs[<span class="hljs-number">1</span>] &amp;&amp; !self.prevented &amp;&amp; self.stopped &lt; <span class="hljs-number">2</span>) {
			<span class="hljs-keyword">if</span> (es.id === self.id || self.type != host._yuievt.bubbling) {
				self._procSubs(subs[<span class="hljs-number">1</span>], args, ef);
				<span class="hljs-keyword">while</span> ((next = es.afterQueue.last())) {
					next();
				}
			} <span class="hljs-keyword">else</span> {
				postponed = subs[<span class="hljs-number">1</span>];
				<span class="hljs-keyword">if</span> (es.execDefaultCnt) {
					postponed = Y.merge(postponed);
					Y.each(postponed, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
						s.postponed = <span class="hljs-literal">true</span>;
					});
				}

				es.afterQueue.add(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
					self._procSubs(postponed, args, ef);
				});
			}
		}

		self.target = <span class="hljs-literal">null</span>;

		<span class="hljs-keyword">if</span> (es.id === self.id) {
			queue = es.queue;

			<span class="hljs-keyword">while</span> (queue.length) {
				q = queue.pop();
				ce = q[<span class="hljs-number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-482">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-482">&#182;</a>
              </div>
              <p>set up stack to allow the next item to be processed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				es.next = ce;
				ce.fire.apply(ce, q[<span class="hljs-number">1</span>]);
			}

			self.stack = <span class="hljs-literal">null</span>;
		}

		ret = !(self.stopped);

		<span class="hljs-keyword">if</span> (self.type != host._yuievt.bubbling) {
			es.stopped = <span class="hljs-number">0</span>;
			es.prevented = <span class="hljs-number">0</span>;
			self.stopped = <span class="hljs-number">0</span>;
			self.prevented = <span class="hljs-number">0</span>;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-483">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-483">&#182;</a>
              </div>
              <p>Kill the cached facade to free up memory.
Otherwise we have the facade from the last fire, sitting around forever.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		self._facade = <span class="hljs-literal">null</span>;

		<span class="hljs-keyword">return</span> ret;
	};

	CEProto._getFacade = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

		<span class="hljs-keyword">var</span> ef = <span class="hljs-keyword">this</span>._facade, o,
			args = <span class="hljs-keyword">this</span>.details;

		<span class="hljs-keyword">if</span> (!ef) {
			ef = <span class="hljs-keyword">new</span> Y.EventFacade(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.currentTarget);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-484">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-484">&#182;</a>
              </div>
              <p>if the first argument is an object literal, apply the
properties to the event facade</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		o = args &amp;&amp; args[<span class="hljs-number">0</span>];

		<span class="hljs-keyword">if</span> (Y.Lang.isObject(o, <span class="hljs-literal">true</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-485">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-485">&#182;</a>
              </div>
              <p>protect the event facade properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			mixFacadeProps(ef, o);</pre></div></div>
            
        </li>
        
        
        <li id="section-486">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-486">&#182;</a>
              </div>
              <p>Allow the event type to be faked
<a href="http://yuilibrary.com/projects/yui3/ticket/2528376">http://yuilibrary.com/projects/yui3/ticket/2528376</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			ef.type = o.type || ef.type;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-487">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-487">&#182;</a>
              </div>
              <p>update the details field with the arguments
ef.type = this.type;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		ef.details = <span class="hljs-keyword">this</span>.details;</pre></div></div>
            
        </li>
        
        
        <li id="section-488">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-488">&#182;</a>
              </div>
              <p>use the original target when the event bubbled to this target</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		ef.target = <span class="hljs-keyword">this</span>.originalTarget || <span class="hljs-keyword">this</span>.target;

		ef.currentTarget = <span class="hljs-keyword">this</span>.currentTarget;
		ef.stopped = <span class="hljs-number">0</span>;
		ef.prevented = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">this</span>._facade = ef;

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._facade;
	};

	<span class="hljs-comment">/**
	 * Stop propagation to bubble targets
	 * @for CustomEvent
	 * @method stopPropagation
	 */</span>
	CEProto.stopPropagation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">this</span>.stopped = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stack) {
			<span class="hljs-keyword">this</span>.stack.stopped = <span class="hljs-number">1</span>;
		}
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.events) {
			<span class="hljs-keyword">this</span>.events.fire(<span class="hljs-string">'stopped'</span>, <span class="hljs-keyword">this</span>);
		}
	};

	<span class="hljs-comment">/**
	 * Stops propagation to bubble targets, and prevents any remaining
	 * subscribers on the current target from executing.
	 * @method stopImmediatePropagation
	 */</span>
	CEProto.stopImmediatePropagation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">this</span>.stopped = <span class="hljs-number">2</span>;
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stack) {
			<span class="hljs-keyword">this</span>.stack.stopped = <span class="hljs-number">2</span>;
		}
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.events) {
			<span class="hljs-keyword">this</span>.events.fire(<span class="hljs-string">'stopped'</span>, <span class="hljs-keyword">this</span>);
		}
	};

	<span class="hljs-comment">/**
	 * Prevents the execution of this event's defaultFn
	 * @method preventDefault
	 */</span>
	CEProto.preventDefault = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.preventable) {
			<span class="hljs-keyword">this</span>.prevented = <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stack) {
				<span class="hljs-keyword">this</span>.stack.prevented = <span class="hljs-number">1</span>;
			}
		}
	};

	<span class="hljs-comment">/**
	 * Stops the event propagation and prevents the default
	 * event behavior.
	 * @method halt
	 * @param immediate {boolean} if true additional listeners
	 * on the current target will not be executed
	 */</span>
	CEProto.halt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">immediate</span>) </span>{
		<span class="hljs-keyword">if</span> (immediate) {
			<span class="hljs-keyword">this</span>.stopImmediatePropagation();
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">this</span>.stopPropagation();
		}
		<span class="hljs-keyword">this</span>.preventDefault();
	};

	<span class="hljs-comment">/**
	 * Registers another EventTarget as a bubble target.  Bubble order
	 * is determined by the order registered.  Multiple targets can
	 * be specified.
	 *
	 * Events can only bubble if emitFacade is true.
	 *
	 * Included in the event-custom-complex submodule.
	 *
	 * @method addTarget
	 * @param o {EventTarget} the target to add
	 * @for EventTarget
	 */</span>
	ETProto.addTarget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">this</span>._yuievt.targets[Y.stamp(o)] = o;
		<span class="hljs-keyword">this</span>._yuievt.hasTargets = <span class="hljs-literal">true</span>;
	};

	<span class="hljs-comment">/**
	 * Returns an array of bubble targets for this object.
	 * @method getTargets
	 * @return EventTarget[]
	 */</span>
	ETProto.getTargets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">return</span> Y.Object.values(<span class="hljs-keyword">this</span>._yuievt.targets);
	};

	<span class="hljs-comment">/**
	 * Removes a bubble target
	 * @method removeTarget
	 * @param o {EventTarget} the target to remove
	 * @for EventTarget
	 */</span>
	ETProto.removeTarget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
		<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._yuievt.targets[Y.stamp(o)];
	};

	<span class="hljs-comment">/**
	 * Propagate an event.  Requires the event-custom-complex module.
	 * @method bubble
	 * @param evt {CustomEvent} the custom event to propagate
	 * @return {boolean} the aggregated return value from Event.Custom.fire
	 * @for EventTarget
	 */</span>
	ETProto.bubble = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt, args, target, es</span>) </span>{

		<span class="hljs-keyword">var</span> targs = <span class="hljs-keyword">this</span>._yuievt.targets, ret = <span class="hljs-literal">true</span>,
			t, type = evt &amp;&amp; evt.type, ce, i, bc, ce2,
			originalTarget = target || (evt &amp;&amp; evt.target) || <span class="hljs-keyword">this</span>,
			oldbubble;

		<span class="hljs-keyword">if</span> (!evt || ((!evt.stopped) &amp;&amp; targs)) {

			<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> targs) {
				<span class="hljs-keyword">if</span> (targs.hasOwnProperty(i)) {
					t = targs[i];
					ce = t.getEvent(type, <span class="hljs-literal">true</span>);
					ce2 = t.getSibling(type, ce);

					<span class="hljs-keyword">if</span> (ce2 &amp;&amp; !ce) {
						ce = t.publish(type);
					}

					oldbubble = t._yuievt.bubbling;
					t._yuievt.bubbling = type;</pre></div></div>
            
        </li>
        
        
        <li id="section-489">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-489">&#182;</a>
              </div>
              <p>if this event was not published on the bubble target,
continue propagating the event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!ce) {
						<span class="hljs-keyword">if</span> (t._yuievt.hasTargets) {
							t.bubble(evt, args, originalTarget, es);
						}
					} <span class="hljs-keyword">else</span> {

						ce.sibling = ce2;</pre></div></div>
            
        </li>
        
        
        <li id="section-490">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-490">&#182;</a>
              </div>
              <p>set the original target to that the target payload on the
facade is correct.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						ce.target = originalTarget;
						ce.originalTarget = originalTarget;
						ce.currentTarget = t;
						bc = ce.broadcast;
						ce.broadcast = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-491">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-491">&#182;</a>
              </div>
              <p>default publish may not have emitFacade true – that
shouldn’t be what the implementer meant to do</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						ce.emitFacade = <span class="hljs-literal">true</span>;

						ce.stack = es;

						ret = ret &amp;&amp; ce.fire.apply(ce, args || evt.details || []);
						ce.broadcast = bc;
						ce.originalTarget = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-492">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-492">&#182;</a>
              </div>
              <p>stopPropagation() was called</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (ce.stopped) {
							<span class="hljs-keyword">break</span>;
						}
					}

					t._yuievt.bubbling = oldbubble;
				}
			}
		}

		<span class="hljs-keyword">return</span> ret;
	};

	FACADE = <span class="hljs-keyword">new</span> Y.EventFacade();
	FACADE_KEYS = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-493">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-493">&#182;</a>
              </div>
              <p>Flatten whitelist</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> FACADE) {
		FACADE_KEYS[key] = <span class="hljs-literal">true</span>;
	}

}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"event-custom-base"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'event-synthetic'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Define new DOM events that can be subscribed to from Nodes.
	 *
	 * @module event
	 * @submodule event-synthetic
	 */</span>
	<span class="hljs-keyword">var</span> CustomEvent = Y.CustomEvent,
		DOMMap   = Y.Env.evt.dom_map,
		toArray  = Y.Array,
		YLang    = Y.Lang,
		isObject = YLang.isObject,
		isString = YLang.isString,
		isArray  = YLang.isArray,
		query    = Y.Selector.query,
		noop     = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

	<span class="hljs-comment">/**
	 * &lt;p&gt;The triggering mechanism used by SyntheticEvents.&lt;/p&gt;
	 *
	 * &lt;p&gt;Implementers should not instantiate these directly.  Use the Notifier
	 * provided to the event's implemented &lt;code&gt;on(node, sub, notifier)&lt;/code&gt; or
	 * &lt;code&gt;delegate(node, sub, notifier, filter)&lt;/code&gt; methods.&lt;/p&gt;
	 *
	 * @class SyntheticEvent.Notifier
	 * @constructor
	 * @param handle {EventHandle} the detach handle for the subscription to an
	 *              internal custom event used to execute the callback passed to
	 *              on(..) or delegate(..)
	 * @param emitFacade {Boolean} take steps to ensure the first arg received by
	 *              the subscription callback is an event facade
	 * @private
	 * @since 3.2.0
	 */</span>
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Notifier</span>(<span class="hljs-params">handle, emitFacade</span>) </span>{
		<span class="hljs-keyword">this</span>.handle     = handle;
		<span class="hljs-keyword">this</span>.emitFacade = emitFacade;
	}

	<span class="hljs-comment">/**
	 * &lt;p&gt;Executes the subscription callback, passing the firing arguments as the
	 * first parameters to that callback. For events that are configured with
	 * emitFacade=true, it is common practice to pass the triggering DOMEventFacade
	 * as the first parameter.  Barring a proper DOMEventFacade or EventFacade
	 * (from a CustomEvent), a new EventFacade will be generated.  In that case, if
	 * fire() is called with a simple object, it will be mixed into the facade.
	 * Otherwise, the facade will be prepended to the callback parameters.&lt;/p&gt;
	 *
	 * &lt;p&gt;For notifiers provided to delegate logic, the first argument should be an
	 * object with a &amp;quot;currentTarget&amp;quot; property to identify what object to
	 * default as 'this' in the callback.  Typically this is gleaned from the
	 * DOMEventFacade or EventFacade, but if configured with emitFacade=false, an
	 * object must be provided.  In that case, the object will be removed from the
	 * callback parameters.&lt;/p&gt;
	 *
	 * &lt;p&gt;Additional arguments passed during event subscription will be
	 * automatically added after those passed to fire().&lt;/p&gt;
	 *
	 * @method fire
	 * @param e {EventFacade|DOMEventFacade|Object|any} (see description)
	 * @param arg* {any} additional arguments received by all subscriptions
	 * @private
	 */</span>
	Notifier.prototype.fire = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-494">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-494">&#182;</a>
              </div>
              <p>first arg to delegate notifier should be an object with currentTarget</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> args     = toArray(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>),
			handle   = <span class="hljs-keyword">this</span>.handle,
			ce       = handle.evt,
			sub      = handle.sub,
			thisObj  = sub.context,
			delegate = sub.filter,
			event    = e || {},
			ret;

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.emitFacade) {
			<span class="hljs-keyword">if</span> (!e || !e.preventDefault) {
				event = ce._getFacade();

				<span class="hljs-keyword">if</span> (isObject(e) &amp;&amp; !e.preventDefault) {
					Y.mix(event, e, <span class="hljs-literal">true</span>);
					args[<span class="hljs-number">0</span>] = event;
				} <span class="hljs-keyword">else</span> {
					args.unshift(event);
				}
			}

			event.type    = ce.type;
			event.details = args.slice();

			<span class="hljs-keyword">if</span> (delegate) {
				event.container = ce.host;
			}
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate &amp;&amp; isObject(e) &amp;&amp; e.currentTarget) {
			args.shift();
		}

		sub.context = thisObj || event.currentTarget || ce.host;
		ret = ce.fire.apply(ce, args);
		sub.context = thisObj; <span class="hljs-comment">// reset for future firing</span></pre></div></div>
            
        </li>
        
        
        <li id="section-495">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-495">&#182;</a>
              </div>
              <p>to capture callbacks that return false to stopPropagation.
Useful for delegate implementations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span> ret;
	};

	<span class="hljs-comment">/**
	 * Manager object for synthetic event subscriptions to aggregate multiple synths on the same node without colliding with actual DOM subscription entries in the global map of DOM subscriptions.  Also facilitates proper cleanup on page unload.
	 *
	 * @class SynthRegistry
	 * @constructor
	 * @param el {HTMLElement} the DOM element
	 * @param yuid {String} the yuid stamp for the element
	 * @param key {String} the generated id token used to identify an event type +
	 *                     element in the global DOM subscription map.
	 * @private
	 */</span>
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SynthRegistry</span>(<span class="hljs-params">el, yuid, key</span>) </span>{
		<span class="hljs-keyword">this</span>.handles = [];
		<span class="hljs-keyword">this</span>.el      = el;
		<span class="hljs-keyword">this</span>.key     = key;
		<span class="hljs-keyword">this</span>.domkey  = yuid;
	}

	SynthRegistry.prototype = {
		<span class="hljs-attr">constructor</span>: SynthRegistry,</pre></div></div>
            
        </li>
        
        
        <li id="section-496">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-496">&#182;</a>
              </div>
              <p>A few object properties to fake the CustomEvent interface for page
unload cleanup.  DON’T TOUCH!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		type      : <span class="hljs-string">'_synth'</span>,
		<span class="hljs-attr">fn</span>        : noop,
		<span class="hljs-attr">capture</span>   : <span class="hljs-literal">false</span>,

		<span class="hljs-comment">/**
		 * Adds a subscription from the Notifier registry.
		 *
		 * @method register
		 * @param handle {EventHandle} the subscription
		 * @since 3.4.0
		 */</span>
		register: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">handle</span>) </span>{
			handle.evt.registry = <span class="hljs-keyword">this</span>;
			<span class="hljs-keyword">this</span>.handles.push(handle);
		},

		<span class="hljs-comment">/**
		 * Removes the subscription from the Notifier registry.
		 *
		 * @method _unregisterSub
		 * @param sub {Subscription} the subscription
		 * @since 3.4.0
		 */</span>
		unregister: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sub</span>) </span>{
			<span class="hljs-keyword">var</span> handles = <span class="hljs-keyword">this</span>.handles,
				events = DOMMap[<span class="hljs-keyword">this</span>.domkey],
				i;

			<span class="hljs-keyword">for</span> (i = handles.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
				<span class="hljs-keyword">if</span> (handles[i].sub === sub) {
					handles.splice(i, <span class="hljs-number">1</span>);
					<span class="hljs-keyword">break</span>;
				}
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-497">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-497">&#182;</a>
              </div>
              <p>Clean up left over objects when there are no more subscribers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!handles.length) {
				<span class="hljs-keyword">delete</span> events[<span class="hljs-keyword">this</span>.key];
				<span class="hljs-keyword">if</span> (!Y.Object.size(events)) {
					<span class="hljs-keyword">delete</span> DOMMap[<span class="hljs-keyword">this</span>.domkey];
				}
			}
		},

		<span class="hljs-comment">/**
		 * Used by the event system's unload cleanup process.  When navigating
		 * away from the page, the event system iterates the global map of element
		 * subscriptions and detaches everything using detachAll().  Normally,
		 * the map is populated with custom events, so this object needs to
		 * at least support the detachAll method to duck type its way to
		 * cleanliness.
		 *
		 * @method detachAll
		 * @private
		 * @since 3.4.0
		 */</span>
		detachAll : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">var</span> handles = <span class="hljs-keyword">this</span>.handles,
				i = handles.length;

			<span class="hljs-keyword">while</span> (--i &gt;= <span class="hljs-number">0</span>) {
				handles[i].detach();
			}
		}
	};

	<span class="hljs-comment">/**
	 * &lt;p&gt;Wrapper class for the integration of new events into the YUI event
	 * infrastructure.  Don't instantiate this object directly, use
	 * &lt;code&gt;Y.Event.define(type, config)&lt;/code&gt;.  See that method for details.&lt;/p&gt;
	 *
	 * &lt;p&gt;Properties that MAY or SHOULD be specified in the configuration are noted
	 * below and in the description of &lt;code&gt;Y.Event.define&lt;/code&gt;.&lt;/p&gt;
	 *
	 * @class SyntheticEvent
	 * @constructor
	 * @param cfg {Object} Implementation pieces and configuration
	 * @since 3.1.0
	 * @in event-synthetic
	 */</span>
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SyntheticEvent</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">this</span>._init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
	}

	Y.mix(SyntheticEvent, {
		<span class="hljs-attr">Notifier</span>: Notifier,
		<span class="hljs-attr">SynthRegistry</span>: SynthRegistry,

		<span class="hljs-comment">/**
		 * Returns the array of subscription handles for a node for the given event
		 * type.  Passing true as the third argument will create a registry entry
		 * in the event system's DOM map to host the array if one doesn't yet exist.
		 *
		 * @method getRegistry
		 * @param node {Node} the node
		 * @param type {String} the event
		 * @param create {Boolean} create a registration entry to host a new array
		 *                  if one doesn't exist.
		 * @return {Array}
		 * @static
		 * @protected
		 * @since 3.2.0
		 */</span>
		getRegistry: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, type, create</span>) </span>{
			<span class="hljs-keyword">var</span> el     = node._node,
				yuid   = Y.stamp(el),
				key    = <span class="hljs-string">'event:'</span> + yuid + type + <span class="hljs-string">'_synth'</span>,
				events = DOMMap[yuid];

			<span class="hljs-keyword">if</span> (create) {
				<span class="hljs-keyword">if</span> (!events) {
					events = DOMMap[yuid] = {};
				}
				<span class="hljs-keyword">if</span> (!events[key]) {
					events[key] = <span class="hljs-keyword">new</span> SynthRegistry(el, yuid, key);
				}
			}

			<span class="hljs-keyword">return</span> (events &amp;&amp; events[key]) || <span class="hljs-literal">null</span>;
		},

		<span class="hljs-comment">/**
		 * Alternate &lt;code&gt;_delete()&lt;/code&gt; method for the CustomEvent object
		 * created to manage SyntheticEvent subscriptions.
		 *
		 * @method _deleteSub
		 * @param sub {Subscription} the subscription to clean up
		 * @private
		 * @since 3.2.0
		 */</span>
		_deleteSub: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sub</span>) </span>{
			<span class="hljs-keyword">if</span> (sub &amp;&amp; sub.fn) {
				<span class="hljs-keyword">var</span> synth = <span class="hljs-keyword">this</span>.eventDef,
					method = (sub.filter) ? <span class="hljs-string">'detachDelegate'</span> : <span class="hljs-string">'detach'</span>;

				<span class="hljs-keyword">this</span>._subscribers = [];

				<span class="hljs-keyword">if</span> (CustomEvent.keepDeprecatedSubs) {
					<span class="hljs-keyword">this</span>.subscribers = {};
				}

				synth[method](sub.node, sub, <span class="hljs-keyword">this</span>.notifier, sub.filter);
				<span class="hljs-keyword">this</span>.registry.unregister(sub);

				<span class="hljs-keyword">delete</span> sub.fn;
				<span class="hljs-keyword">delete</span> sub.node;
				<span class="hljs-keyword">delete</span> sub.context;
			}
		},

		<span class="hljs-attr">prototype</span>: {
			<span class="hljs-attr">constructor</span>: SyntheticEvent,

			<span class="hljs-comment">/**
			 * Construction logic for the event.
			 *
			 * @method _init
			 * @protected
			 */</span>
			_init: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
				<span class="hljs-keyword">var</span> config = <span class="hljs-keyword">this</span>.publishConfig || (<span class="hljs-keyword">this</span>.publishConfig = {});</pre></div></div>
            
        </li>
        
        
        <li id="section-498">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-498">&#182;</a>
              </div>
              <p>The notification mechanism handles facade creation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>.emitFacade = (<span class="hljs-string">'emitFacade'</span> <span class="hljs-keyword">in</span> config) ?
					config.emitFacade :
					<span class="hljs-literal">true</span>;
				config.emitFacade  = <span class="hljs-literal">false</span>;
			},

			<span class="hljs-comment">/**
			 * &lt;p&gt;Implementers MAY provide this method definition.&lt;/p&gt;
			 *
			 * &lt;p&gt;Implement this function if the event supports a different
			 * subscription signature.  This function is used by both
			 * &lt;code&gt;on()&lt;/code&gt; and &lt;code&gt;delegate()&lt;/code&gt;.  The second parameter
			 * indicates that the event is being subscribed via
			 * &lt;code&gt;delegate()&lt;/code&gt;.&lt;/p&gt;
			 *
			 * &lt;p&gt;Implementations must remove extra arguments from the args list
			 * before returning.  The required args for &lt;code&gt;on()&lt;/code&gt;
			 * subscriptions are&lt;/p&gt;
			 * &lt;pre&gt;&lt;code&gt;[type, callback, target, context, argN...]&lt;/code&gt;&lt;/pre&gt;
			 *
			 * &lt;p&gt;The required args for &lt;code&gt;delegate()&lt;/code&gt;
			 * subscriptions are&lt;/p&gt;
			 *
			 * &lt;pre&gt;&lt;code&gt;[type, callback, target, filter, context, argN...]&lt;/code&gt;&lt;/pre&gt;
			 *
			 * &lt;p&gt;The return value from this function will be stored on the
			 * subscription in the '_extra' property for reference elsewhere.&lt;/p&gt;
			 *
			 * @method processArgs
			 * @param args {Array} parmeters passed to Y.on(..) or Y.delegate(..)
			 * @param delegate {Boolean} true if the subscription is from Y.delegate
			 * @return {any}
			 */</span>
			processArgs: noop,

			<span class="hljs-comment">/**
			 * &lt;p&gt;Implementers MAY override this property.&lt;/p&gt;
			 *
			 * &lt;p&gt;Whether to prevent multiple subscriptions to this event that are
			 * classified as being the same.  By default, this means the subscribed
			 * callback is the same function.  See the &lt;code&gt;subMatch&lt;/code&gt;
			 * method.  Setting this to true will impact performance for high volume
			 * events.&lt;/p&gt;
			 *
			 * @property preventDups
			 * @type {Boolean}
			 * @default false
			 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-499">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-499">&#182;</a>
              </div>
              <p>preventDups  : false,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
			<span class="hljs-comment">/**
			 * &lt;p&gt;Implementers SHOULD provide this method definition.&lt;/p&gt;
			 *
			 * Implementation logic for subscriptions done via &lt;code&gt;node.on(type,
			 * fn)&lt;/code&gt; or &lt;code&gt;Y.on(type, fn, target)&lt;/code&gt;.  This
			 * function should set up the monitor(s) that will eventually fire the
			 * event.  Typically this involves subscribing to at least one DOM
			 * event.  It is recommended to store detach handles from any DOM
			 * subscriptions to make for easy cleanup in the &lt;code&gt;detach&lt;/code&gt;
			 * method.  Typically these handles are added to the &lt;code&gt;sub&lt;/code&gt;
			 * object.  Also for SyntheticEvents that leverage a single DOM
			 * subscription under the hood, it is recommended to pass the DOM event
			 * object to &lt;code&gt;notifier.fire(e)&lt;/code&gt;.  (The event name on the
			 * object will be updated).
			 *
			 * @method on
			 * @param node {Node} the node the subscription is being applied to
			 * @param sub {Subscription} the object to track this subscription
			 * @param notifier {SyntheticEvent.Notifier} call notifier.fire(..) to
			 *              trigger the execution of the subscribers
			 */</span>
			on: noop,

			<span class="hljs-comment">/**
			 * &lt;p&gt;Implementers SHOULD provide this method definition.&lt;/p&gt;
			 *
			 * &lt;p&gt;Implementation logic for detaching subscriptions done via
			 * &lt;code&gt;node.on(type, fn)&lt;/code&gt;.  This function should clean up any
			 * subscriptions made in the &lt;code&gt;on()&lt;/code&gt; phase.&lt;/p&gt;
			 *
			 * @method detach
			 * @param node {Node} the node the subscription was applied to
			 * @param sub {Subscription} the object tracking this subscription
			 * @param notifier {SyntheticEvent.Notifier} the Notifier used to
			 *              trigger the execution of the subscribers
			 */</span>
			detach: noop,

			<span class="hljs-comment">/**
			 * &lt;p&gt;Implementers SHOULD provide this method definition.&lt;/p&gt;
			 *
			 * &lt;p&gt;Implementation logic for subscriptions done via
			 * &lt;code&gt;node.delegate(type, fn, filter)&lt;/code&gt; or
			 * &lt;code&gt;Y.delegate(type, fn, container, filter)&lt;/code&gt;.  Like with
			 * &lt;code&gt;on()&lt;/code&gt; above, this function should monitor the environment
			 * for the event being fired, and trigger subscription execution by
			 * calling &lt;code&gt;notifier.fire(e)&lt;/code&gt;.&lt;/p&gt;
			 *
			 * &lt;p&gt;This function receives a fourth argument, which is the filter
			 * used to identify which Node's are of interest to the subscription.
			 * The filter will be either a boolean function that accepts a target
			 * Node for each hierarchy level as the event bubbles, or a selector
			 * string.  To translate selector strings into filter functions, use
			 * &lt;code&gt;Y.delegate.compileFilter(filter)&lt;/code&gt;.&lt;/p&gt;
			 *
			 * @method delegate
			 * @param node {Node} the node the subscription is being applied to
			 * @param sub {Subscription} the object to track this subscription
			 * @param notifier {SyntheticEvent.Notifier} call notifier.fire(..) to
			 *              trigger the execution of the subscribers
			 * @param filter {String|Function} Selector string or function that
			 *              accepts an event object and returns null, a Node, or an
			 *              array of Nodes matching the criteria for processing.
			 * @since 3.2.0
			 */</span>
			delegate       : noop,

			<span class="hljs-comment">/**
			 * &lt;p&gt;Implementers SHOULD provide this method definition.&lt;/p&gt;
			 *
			 * &lt;p&gt;Implementation logic for detaching subscriptions done via
			 * &lt;code&gt;node.delegate(type, fn, filter)&lt;/code&gt; or
			 * &lt;code&gt;Y.delegate(type, fn, container, filter)&lt;/code&gt;.  This function
			 * should clean up any subscriptions made in the
			 * &lt;code&gt;delegate()&lt;/code&gt; phase.&lt;/p&gt;
			 *
			 * @method detachDelegate
			 * @param node {Node} the node the subscription was applied to
			 * @param sub {Subscription} the object tracking this subscription
			 * @param notifier {SyntheticEvent.Notifier} the Notifier used to
			 *              trigger the execution of the subscribers
			 * @param filter {String|Function} Selector string or function that
			 *              accepts an event object and returns null, a Node, or an
			 *              array of Nodes matching the criteria for processing.
			 * @since 3.2.0
			 */</span>
			detachDelegate : noop,

			<span class="hljs-comment">/**
			 * Sets up the boilerplate for detaching the event and facilitating the
			 * execution of subscriber callbacks.
			 *
			 * @method _on
			 * @param args {Array} array of arguments passed to
			 *              &lt;code&gt;Y.on(...)&lt;/code&gt; or &lt;code&gt;Y.delegate(...)&lt;/code&gt;
			 * @param delegate {Boolean} true if called from
			 * &lt;code&gt;Y.delegate(...)&lt;/code&gt;
			 * @return {EventHandle} the detach handle for this subscription
			 * @private
			 * since 3.2.0
			 */</span>
			_on: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, delegate</span>) </span>{
				<span class="hljs-keyword">var</span> handles  = [],
					originalArgs = args.slice(),
					extra    = <span class="hljs-keyword">this</span>.processArgs(args, delegate),
					selector = args[<span class="hljs-number">2</span>],
					method   = delegate ? <span class="hljs-string">'delegate'</span> : <span class="hljs-string">'on'</span>,
					nodes, handle;</pre></div></div>
            
        </li>
        
        
        <li id="section-500">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-500">&#182;</a>
              </div>
              <p>Can’t just use Y.all because it doesn’t support window (yet?)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				nodes = (isString(selector)) ?
					query(selector) :
					toArray(selector || Y.one(Y.config.win));

				<span class="hljs-keyword">if</span> (!nodes.length &amp;&amp; isString(selector)) {
					handle = Y.on(<span class="hljs-string">'available'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
						Y.mix(handle, Y[method].apply(Y, originalArgs), <span class="hljs-literal">true</span>);
					}, selector);

					<span class="hljs-keyword">return</span> handle;
				}

				Y.Array.each(nodes, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
					<span class="hljs-keyword">var</span> subArgs = args.slice(),
						filter;

					node = Y.one(node);

					<span class="hljs-keyword">if</span> (node) {
						<span class="hljs-keyword">if</span> (delegate) {
							filter = subArgs.splice(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];
						}</pre></div></div>
            
        </li>
        
        
        <li id="section-501">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-501">&#182;</a>
              </div>
              <p>(type, fn, el, thisObj, …) =&gt; (fn, thisObj, …)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						subArgs.splice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, subArgs[<span class="hljs-number">1</span>], subArgs[<span class="hljs-number">3</span>]);

						<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.preventDups ||
							!<span class="hljs-keyword">this</span>.getSubs(node, args, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))
						{
							handles.push(<span class="hljs-keyword">this</span>._subscribe(node, method, subArgs, extra, filter));
						}
					}
				}, <span class="hljs-keyword">this</span>);

				<span class="hljs-keyword">return</span> (handles.length === <span class="hljs-number">1</span>) ?
					handles[<span class="hljs-number">0</span>] :
					<span class="hljs-keyword">new</span> Y.EventHandle(handles);
			},

			<span class="hljs-comment">/**
			 * Creates a new Notifier object for use by this event's
			 * &lt;code&gt;on(...)&lt;/code&gt; or &lt;code&gt;delegate(...)&lt;/code&gt; implementation
			 * and register the custom event proxy in the DOM system for cleanup.
			 *
			 * @method _subscribe
			 * @param node {Node} the Node hosting the event
			 * @param method {String} "on" or "delegate"
			 * @param args {Array} the subscription arguments passed to either
			 *              &lt;code&gt;Y.on(...)&lt;/code&gt; or &lt;code&gt;Y.delegate(...)&lt;/code&gt;
			 *              after running through &lt;code&gt;processArgs(args)&lt;/code&gt; to
			 *              normalize the argument signature
			 * @param extra {any} Extra data parsed from
			 *              &lt;code&gt;processArgs(args)&lt;/code&gt;
			 * @param filter {String|Function} the selector string or function
			 *              filter passed to &lt;code&gt;Y.delegate(...)&lt;/code&gt; (not
			 *              present when called from &lt;code&gt;Y.on(...)&lt;/code&gt;)
			 * @return {EventHandle}
			 * @private
			 * @since 3.2.0
			 */</span>
			_subscribe: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, method, args, extra, filter</span>) </span>{
				<span class="hljs-keyword">var</span> dispatcher = <span class="hljs-keyword">new</span> Y.CustomEvent(<span class="hljs-keyword">this</span>.type, <span class="hljs-keyword">this</span>.publishConfig),
					handle     = dispatcher.on.apply(dispatcher, args),
					notifier   = <span class="hljs-keyword">new</span> Notifier(handle, <span class="hljs-keyword">this</span>.emitFacade),
					registry   = SyntheticEvent.getRegistry(node, <span class="hljs-keyword">this</span>.type, <span class="hljs-literal">true</span>),
					sub        = handle.sub;

				sub.node   = node;
				sub.filter = filter;
				<span class="hljs-keyword">if</span> (extra) {
					<span class="hljs-keyword">this</span>.applyArgExtras(extra, sub);
				}

				Y.mix(dispatcher, {
					<span class="hljs-attr">eventDef</span>     : <span class="hljs-keyword">this</span>,
					<span class="hljs-attr">notifier</span>     : notifier,
					<span class="hljs-attr">host</span>         : node,       <span class="hljs-comment">// I forget what this is for</span>
					currentTarget: node,       <span class="hljs-comment">// for generating facades</span>
					target       : node,       <span class="hljs-comment">// for generating facades</span>
					el           : node._node, <span class="hljs-comment">// For category detach</span>

					_delete      : SyntheticEvent._deleteSub
				}, <span class="hljs-literal">true</span>);

				handle.notifier = notifier;

				registry.register(handle);</pre></div></div>
            
        </li>
        
        
        <li id="section-502">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-502">&#182;</a>
              </div>
              <p>Call the implementation’s “on” or “delegate” method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>[method](node, sub, notifier, filter);

				<span class="hljs-keyword">return</span> handle;
			},

			<span class="hljs-comment">/**
			 * &lt;p&gt;Implementers MAY provide this method definition.&lt;/p&gt;
			 *
			 * &lt;p&gt;Implement this function if you want extra data extracted during
			 * processArgs to be propagated to subscriptions on a per-node basis.
			 * That is to say, if you call &lt;code&gt;Y.on('xyz', fn, xtra, 'div')&lt;/code&gt;
			 * the data returned from processArgs will be shared
			 * across the subscription objects for all the divs.  If you want each
			 * subscription to receive unique information, do that processing
			 * here.&lt;/p&gt;
			 *
			 * &lt;p&gt;The default implementation adds the data extracted by processArgs
			 * to the subscription object as &lt;code&gt;sub._extra&lt;/code&gt;.&lt;/p&gt;
			 *
			 * @method applyArgExtras
			 * @param extra {any} Any extra data extracted from processArgs
			 * @param sub {Subscription} the individual subscription
			 */</span>
			applyArgExtras: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">extra, sub</span>) </span>{
				sub._extra = extra;
			},

			<span class="hljs-comment">/**
			 * Removes the subscription(s) from the internal subscription dispatch
			 * mechanism.  See &lt;code&gt;SyntheticEvent._deleteSub&lt;/code&gt;.
			 *
			 * @method _detach
			 * @param args {Array} The arguments passed to
			 *                  &lt;code&gt;node.detach(...)&lt;/code&gt;
			 * @private
			 * @since 3.2.0
			 */</span>
			_detach: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-503">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-503">&#182;</a>
              </div>
              <p>Can’t use Y.all because it doesn’t support window (yet?)
TODO: Does Y.all support window now?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> target = args[<span class="hljs-number">2</span>],
					els    = (isString(target)) ?
						query(target) : toArray(target),
					node, i, len, handles, j;</pre></div></div>
            
        </li>
        
        
        <li id="section-504">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-504">&#182;</a>
              </div>
              <p>(type, fn, el, context, filter?) =&gt; (type, fn, context, filter?)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				args.splice(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);

				<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = els.length; i &lt; len; ++i) {
					node = Y.one(els[i]);

					<span class="hljs-keyword">if</span> (node) {
						handles = <span class="hljs-keyword">this</span>.getSubs(node, args);

						<span class="hljs-keyword">if</span> (handles) {
							<span class="hljs-keyword">for</span> (j = handles.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) {
								handles[j].detach();
							}
						}
					}
				}
			},

			<span class="hljs-comment">/**
			 * Returns the detach handles of subscriptions on a node that satisfy a
			 * search/filter function.  By default, the filter used is the
			 * &lt;code&gt;subMatch&lt;/code&gt; method.
			 *
			 * @method getSubs
			 * @param node {Node} the node hosting the event
			 * @param args {Array} the array of original subscription args passed
			 *              to &lt;code&gt;Y.on(...)&lt;/code&gt; (before
			 *              &lt;code&gt;processArgs&lt;/code&gt;
			 * @param filter {Function} function used to identify a subscription
			 *              for inclusion in the returned array
			 * @param first {Boolean} stop after the first match (used to check for
			 *              duplicate subscriptions)
			 * @return {EventHandle[]} detach handles for the matching subscriptions
			 */</span>
			getSubs: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, args, filter, first</span>) </span>{
				<span class="hljs-keyword">var</span> registry = SyntheticEvent.getRegistry(node, <span class="hljs-keyword">this</span>.type),
					handles  = [],
					allHandles, i, len, handle;

				<span class="hljs-keyword">if</span> (registry) {
					allHandles = registry.handles;

					<span class="hljs-keyword">if</span> (!filter) {
						filter = <span class="hljs-keyword">this</span>.subMatch;
					}

					<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = allHandles.length; i &lt; len; ++i) {
						handle = allHandles[i];
						<span class="hljs-keyword">if</span> (filter.call(<span class="hljs-keyword">this</span>, handle.sub, args)) {
							<span class="hljs-keyword">if</span> (first) {
								<span class="hljs-keyword">return</span> handle;
							} <span class="hljs-keyword">else</span> {
								handles.push(allHandles[i]);
							}
						}
					}
				}

				<span class="hljs-keyword">return</span> handles.length &amp;&amp; handles;
			},

			<span class="hljs-comment">/**
			 * &lt;p&gt;Implementers MAY override this to define what constitutes a
			 * &amp;quot;same&amp;quot; subscription.  Override implementations should
			 * consider the lack of a comparator as a match, so calling
			 * &lt;code&gt;getSubs()&lt;/code&gt; with no arguments will return all subs.&lt;/p&gt;
			 *
			 * &lt;p&gt;Compares a set of subscription arguments against a Subscription
			 * object to determine if they match.  The default implementation
			 * compares the callback function against the second argument passed to
			 * &lt;code&gt;Y.on(...)&lt;/code&gt; or &lt;code&gt;node.detach(...)&lt;/code&gt; etc.&lt;/p&gt;
			 *
			 * @method subMatch
			 * @param sub {Subscription} the existing subscription
			 * @param args {Array} the calling arguments passed to
			 *                  &lt;code&gt;Y.on(...)&lt;/code&gt; etc.
			 * @return {Boolean} true if the sub can be described by the args
			 *                  present
			 * @since 3.2.0
			 */</span>
			subMatch: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sub, args</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-505">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-505">&#182;</a>
              </div>
              <p>Default detach cares only about the callback matching</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> !args[<span class="hljs-number">1</span>] || sub.fn === args[<span class="hljs-number">1</span>];
			}
		}
	}, <span class="hljs-literal">true</span>);

	Y.SyntheticEvent = SyntheticEvent;

	<span class="hljs-comment">/**
	 * &lt;p&gt;Defines a new event in the DOM event system.  Implementers are
	 * responsible for monitoring for a scenario whereby the event is fired.  A
	 * notifier object is provided to the functions identified below.  When the
	 * criteria defining the event are met, call notifier.fire( [args] ); to
	 * execute event subscribers.&lt;/p&gt;
	 *
	 * &lt;p&gt;The first parameter is the name of the event.  The second parameter is a
	 * configuration object which define the behavior of the event system when the
	 * new event is subscribed to or detached from.  The methods that should be
	 * defined in this configuration object are &lt;code&gt;on&lt;/code&gt;,
	 * &lt;code&gt;detach&lt;/code&gt;, &lt;code&gt;delegate&lt;/code&gt;, and &lt;code&gt;detachDelegate&lt;/code&gt;.
	 * You are free to define any other methods or properties needed to define your
	 * event.  Be aware, however, that since the object is used to subclass
	 * SyntheticEvent, you should avoid method names used by SyntheticEvent unless
	 * your intention is to override the default behavior.&lt;/p&gt;
	 *
	 * &lt;p&gt;This is a list of properties and methods that you can or should specify
	 * in the configuration object:&lt;/p&gt;
	 *
	 * &lt;dl&gt;
	 *   &lt;dt&gt;&lt;code&gt;on&lt;/code&gt;&lt;/dt&gt;
	 *       &lt;dd&gt;&lt;code&gt;function (node, subscription, notifier)&lt;/code&gt; The
	 *       implementation logic for subscription.  Any special setup you need to
	 *       do to create the environment for the event being fired--E.g. native
	 *       DOM event subscriptions.  Store subscription related objects and
	 *       state on the &lt;code&gt;subscription&lt;/code&gt; object.  When the
	 *       criteria have been met to fire the synthetic event, call
	 *       &lt;code&gt;notifier.fire(e)&lt;/code&gt;.  See Notifier's &lt;code&gt;fire()&lt;/code&gt;
	 *       method for details about what to pass as parameters.&lt;/dd&gt;
	 *
	 *   &lt;dt&gt;&lt;code&gt;detach&lt;/code&gt;&lt;/dt&gt;
	 *       &lt;dd&gt;&lt;code&gt;function (node, subscription, notifier)&lt;/code&gt; The
	 *       implementation logic for cleaning up a detached subscription. E.g.
	 *       detach any DOM subscriptions added in &lt;code&gt;on&lt;/code&gt;.&lt;/dd&gt;
	 *
	 *   &lt;dt&gt;&lt;code&gt;delegate&lt;/code&gt;&lt;/dt&gt;
	 *       &lt;dd&gt;&lt;code&gt;function (node, subscription, notifier, filter)&lt;/code&gt; The
	 *       implementation logic for subscription via &lt;code&gt;Y.delegate&lt;/code&gt; or
	 *       &lt;code&gt;node.delegate&lt;/code&gt;.  The filter is typically either a selector
	 *       string or a function.  You can use
	 *       &lt;code&gt;Y.delegate.compileFilter(selectorString)&lt;/code&gt; to create a
	 *       filter function from a selector string if needed.  The filter function
	 *       expects an event object as input and should output either null, a
	 *       matching Node, or an array of matching Nodes.  Otherwise, this acts
	 *       like &lt;code&gt;on&lt;/code&gt; DOM event subscriptions.  Store subscription
	 *       related objects and information on the &lt;code&gt;subscription&lt;/code&gt;
	 *       object.  When the criteria have been met to fire the synthetic event,
	 *       call &lt;code&gt;notifier.fire(e)&lt;/code&gt; as noted above.&lt;/dd&gt;
	 *
	 *   &lt;dt&gt;&lt;code&gt;detachDelegate&lt;/code&gt;&lt;/dt&gt;
	 *       &lt;dd&gt;&lt;code&gt;function (node, subscription, notifier)&lt;/code&gt; The
	 *       implementation logic for cleaning up a detached delegate subscription.
	 *       E.g. detach any DOM delegate subscriptions added in
	 *       &lt;code&gt;delegate&lt;/code&gt;.&lt;/dd&gt;
	 *
	 *   &lt;dt&gt;&lt;code&gt;publishConfig&lt;/code&gt;&lt;/dt&gt;
	 *       &lt;dd&gt;(Object) The configuration object that will be used to instantiate
	 *       the underlying CustomEvent. See Notifier's &lt;code&gt;fire&lt;/code&gt; method
	 *       for details.&lt;/dd&gt;
	 *
	 *   &lt;dt&gt;&lt;code&gt;processArgs&lt;/code&gt;&lt;/dt
	 *       &lt;dd&gt;
	 *          &lt;p&gt;&lt;code&gt;function (argArray, fromDelegate)&lt;/code&gt; Optional method
	 *          to extract any additional arguments from the subscription
	 *          signature.  Using this allows &lt;code&gt;on&lt;/code&gt; or
	 *          &lt;code&gt;delegate&lt;/code&gt; signatures like
	 *          &lt;code&gt;node.on(&amp;quot;hover&amp;quot;, overCallback,
	 *          outCallback)&lt;/code&gt;.&lt;/p&gt;
	 *          &lt;p&gt;When processing an atypical argument signature, make sure the
	 *          args array is returned to the normal signature before returning
	 *          from the function.  For example, in the &amp;quot;hover&amp;quot; example
	 *          above, the &lt;code&gt;outCallback&lt;/code&gt; needs to be &lt;code&gt;splice&lt;/code&gt;d
	 *          out of the array.  The expected signature of the args array for
	 *          &lt;code&gt;on()&lt;/code&gt; subscriptions is:&lt;/p&gt;
	 *          &lt;pre&gt;
	 *              &lt;code&gt;[type, callback, target, contextOverride, argN...]&lt;/code&gt;
	 *          &lt;/pre&gt;
	 *          &lt;p&gt;And for &lt;code&gt;delegate()&lt;/code&gt;:&lt;/p&gt;
	 *          &lt;pre&gt;
	 *              &lt;code&gt;[type, callback, target, filter, contextOverride, argN...]&lt;/code&gt;
	 *          &lt;/pre&gt;
	 *          &lt;p&gt;where &lt;code&gt;target&lt;/code&gt; is the node the event is being
	 *          subscribed for.  You can see these signatures documented for
	 *          &lt;code&gt;Y.on()&lt;/code&gt; and &lt;code&gt;Y.delegate()&lt;/code&gt; respectively.&lt;/p&gt;
	 *          &lt;p&gt;Whatever gets returned from the function will be stored on the
	 *          &lt;code&gt;subscription&lt;/code&gt; object under
	 *          &lt;code&gt;subscription._extra&lt;/code&gt;.&lt;/p&gt;&lt;/dd&gt;
	 *   &lt;dt&gt;&lt;code&gt;subMatch&lt;/code&gt;&lt;/dt&gt;
	 *       &lt;dd&gt;
	 *           &lt;p&gt;&lt;code&gt;function (sub, args)&lt;/code&gt;  Compares a set of
	 *           subscription arguments against a Subscription object to determine
	 *           if they match.  The default implementation compares the callback
	 *           function against the second argument passed to
	 *           &lt;code&gt;Y.on(...)&lt;/code&gt; or &lt;code&gt;node.detach(...)&lt;/code&gt; etc.&lt;/p&gt;
	 *       &lt;/dd&gt;
	 * &lt;/dl&gt;
	 *
	 * @method define
	 * @param type {String} the name of the event
	 * @param config {Object} the prototype definition for the new event (see above)
	 * @param force {Boolean} override an existing event (use with caution)
	 * @return {SyntheticEvent} the subclass implementation instance created to
	 *              handle event subscriptions of this type
	 * @static
	 * @for Event
	 * @since 3.1.0
	 * @in event-synthetic
	 */</span>
	Y.Event.define = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, config, force</span>) </span>{
		<span class="hljs-keyword">var</span> eventDef, Impl, synth;

		<span class="hljs-keyword">if</span> (type &amp;&amp; type.type) {
			eventDef = type;
			force = config;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config) {
			eventDef = Y.merge({ <span class="hljs-attr">type</span>: type }, config);
		}

		<span class="hljs-keyword">if</span> (eventDef) {
			<span class="hljs-keyword">if</span> (force || !Y.Node.DOM_EVENTS[eventDef.type]) {
				Impl = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
					SyntheticEvent.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
				};
				Y.extend(Impl, SyntheticEvent, eventDef);
				synth = <span class="hljs-keyword">new</span> Impl();

				type = synth.type;

				Y.Node.DOM_EVENTS[type] = Y.Env.evt.plugins[type] = {
					<span class="hljs-attr">eventDef</span>: synth,

					<span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
						<span class="hljs-keyword">return</span> synth._on(toArray(<span class="hljs-built_in">arguments</span>));
					},

					<span class="hljs-attr">delegate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
						<span class="hljs-keyword">return</span> synth._on(toArray(<span class="hljs-built_in">arguments</span>), <span class="hljs-literal">true</span>);
					},

					<span class="hljs-attr">detach</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
						<span class="hljs-keyword">return</span> synth._detach(toArray(<span class="hljs-built_in">arguments</span>));
					}
				};

			}
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isString(type) || isArray(type)) {
			Y.Array.each(toArray(type), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>{
				Y.Node.DOM_EVENTS[t] = <span class="hljs-number">1</span>;
			});
		}

		<span class="hljs-keyword">return</span> synth;
	};


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"node-base"</span>, <span class="hljs-string">"event-custom-complex"</span>]});
<span class="hljs-comment">/*
 YUI 3.7.3 (build 5687)
 Copyright 2012 Yahoo! Inc. All rights reserved.
 Licensed under the BSD License.
 http://yuilibrary.com/license/
 */</span>
YUI.add(<span class="hljs-string">'event-focus'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Y, NAME</span>) </span>{

	<span class="hljs-comment">/**
	 * Adds bubbling and delegation support to DOM events focus and blur.
	 *
	 * @module event
	 * @submodule event-focus
	 */</span>
	<span class="hljs-keyword">var</span> Event    = Y.Event,

		YLang    = Y.Lang,

		isString = YLang.isString,

		arrayIndex = Y.Array.indexOf,

		useActivate = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-506">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-506">&#182;</a>
              </div>
              <p>Changing the structure of this test, so that it doesn’t use inline JS in HTML,
which throws an exception in Win8 packaged apps, due to additional security restrictions:
<a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh465380.aspx#differences">http://msdn.microsoft.com/en-us/library/windows/apps/hh465380.aspx#differences</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
			<span class="hljs-keyword">var</span> p = Y.config.doc.createElement(<span class="hljs-string">"p"</span>),
				listener;

			p.setAttribute(<span class="hljs-string">"onbeforeactivate"</span>, <span class="hljs-string">";"</span>);
			listener = p.onbeforeactivate;</pre></div></div>
            
        </li>
        
        
        <li id="section-507">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-507">&#182;</a>
              </div>
              <p>listener is a function in IE8+.
listener is a string in IE6,7 (unfortunate, but that’s not going to change. Otherwise we could have just checked for function).
listener is a function in IE10, in a Win8 App environment (no exception running the test).</p>

            </div>
            
        </li>
        
        
        <li id="section-508">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-508">&#182;</a>
              </div>
              <p>listener is undefined in Webkit/Gecko.
listener is a function in Webkit/Gecko if it’s a supported event (e.g. onclick).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
			<span class="hljs-keyword">return</span> (listener !== <span class="hljs-literal">undefined</span>);
		}());

	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">define</span>(<span class="hljs-params">type, proxy, directEvent</span>) </span>{
		<span class="hljs-keyword">var</span> nodeDataKey = <span class="hljs-string">'_'</span> + type + <span class="hljs-string">'Notifiers'</span>;

		Y.Event.define(type, {

			<span class="hljs-attr">_useActivate</span> : useActivate,

			<span class="hljs-attr">_attach</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, notifier, delegate</span>) </span>{
				<span class="hljs-keyword">if</span> (Y.DOM.isWindow(el)) {
					<span class="hljs-keyword">return</span> Event._attach([type, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
						notifier.fire(e);
					}, el]);
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> Event._attach(
						[proxy, <span class="hljs-keyword">this</span>._proxy, el, <span class="hljs-keyword">this</span>, notifier, delegate],
						{ <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> });
				}
			},

			<span class="hljs-attr">_proxy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, notifier, delegate</span>) </span>{
				<span class="hljs-keyword">var</span> target        = e.target,
					currentTarget = e.currentTarget,
					notifiers     = target.getData(nodeDataKey),
					yuid          = Y.stamp(currentTarget._node),
					defer         = (useActivate || target !== currentTarget),
					directSub;

				notifier.currentTarget = (delegate) ? target : currentTarget;
				notifier.container     = (delegate) ? currentTarget : <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-509">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-509">&#182;</a>
              </div>
              <p>Maintain a list to handle subscriptions from nested
containers div#a&gt;div#b&gt;input #a.on(focus..) #b.on(focus..),
use one focus or blur subscription that fires notifiers from</p>
<p>#b then #a to emulate bubble sequence.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!notifiers) {
					notifiers = {};
					target.setData(nodeDataKey, notifiers);</pre></div></div>
            
        </li>
        
        
        <li id="section-510">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-510">&#182;</a>
              </div>
              <p>only subscribe to the element’s focus if the target is
not the current target (</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (defer) {
						directSub = Event._attach(
							[directEvent, <span class="hljs-keyword">this</span>._notify, target._node]).sub;
						directSub.once = <span class="hljs-literal">true</span>;
					}
				} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-511">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-511">&#182;</a>
              </div>
              <p>In old IE, defer is always true.  In capture-phase browsers,
The delegate subscriptions will be encountered first, which
will establish the notifiers data and direct subscription
on the node.  If there is also a direct subscription to the
node’s focus/blur, it should not call _notify because the
direct subscription from the delegate sub(s) exists, which
will call _notify.  So this avoids _notify being called
twice, unnecessarily.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					defer = <span class="hljs-literal">true</span>;
				}

				<span class="hljs-keyword">if</span> (!notifiers[yuid]) {
					notifiers[yuid] = [];
				}

				notifiers[yuid].push(notifier);

				<span class="hljs-keyword">if</span> (!defer) {
					<span class="hljs-keyword">this</span>._notify(e);
				}
			},

			<span class="hljs-attr">_notify</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e, container</span>) </span>{
				<span class="hljs-keyword">var</span> currentTarget = e.currentTarget,
					notifierData  = currentTarget.getData(nodeDataKey),
					axisNodes     = currentTarget.ancestors(),
					doc           = currentTarget.get(<span class="hljs-string">'ownerDocument'</span>),
					delegates     = [],</pre></div></div>
            
        </li>
        
        
        <li id="section-512">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-512">&#182;</a>
              </div>
              <p>Used to escape loops when there are no more
notifiers to consider</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					count         = notifierData ?
						Y.Object.keys(notifierData).length :
						<span class="hljs-number">0</span>,
					target, notifiers, notifier, yuid, match, tmp, i, len, sub, ret;</pre></div></div>
            
        </li>
        
        
        <li id="section-513">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-513">&#182;</a>
              </div>
              <p>clear the notifications list (mainly for delegation)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				currentTarget.clearData(nodeDataKey);</pre></div></div>
            
        </li>
        
        
        <li id="section-514">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-514">&#182;</a>
              </div>
              <p>Order the delegate subs by their placement in the parent axis</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				axisNodes.push(currentTarget);</pre></div></div>
            
        </li>
        
        
        <li id="section-515">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-515">&#182;</a>
              </div>
              <p>document.get(‘ownerDocument’) returns null
which we’ll use to prevent having duplicate Nodes in the list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (doc) {
					axisNodes.unshift(doc);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-516">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-516">&#182;</a>
              </div>
              <p>ancestors() returns the Nodes from top to bottom</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				axisNodes._nodes.reverse();

				<span class="hljs-keyword">if</span> (count) {</pre></div></div>
            
        </li>
        
        
        <li id="section-517">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-517">&#182;</a>
              </div>
              <p>Store the count for step 2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					tmp = count;
					axisNodes.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
						<span class="hljs-keyword">var</span> yuid      = Y.stamp(node),
							notifiers = notifierData[yuid],
							i, len;

						<span class="hljs-keyword">if</span> (notifiers) {
							count--;
							<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = notifiers.length; i &lt; len; ++i) {
								<span class="hljs-keyword">if</span> (notifiers[i].handle.sub.filter) {
									delegates.push(notifiers[i]);
								}
							}
						}

						<span class="hljs-keyword">return</span> !count;
					});
					count = tmp;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-518">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-518">&#182;</a>
              </div>
              <p>Walk up the parent axis, notifying direct subscriptions and
testing delegate filters.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">while</span> (count &amp;&amp; (target = axisNodes.shift())) {
					yuid = Y.stamp(target);

					notifiers = notifierData[yuid];

					<span class="hljs-keyword">if</span> (notifiers) {
						<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = notifiers.length; i &lt; len; ++i) {
							notifier = notifiers[i];
							sub      = notifier.handle.sub;
							match    = <span class="hljs-literal">true</span>;

							e.currentTarget = target;

							<span class="hljs-keyword">if</span> (sub.filter) {
								match = sub.filter.apply(target,
									[target, e].concat(sub.args || []));</pre></div></div>
            
        </li>
        
        
        <li id="section-519">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-519">&#182;</a>
              </div>
              <p>No longer necessary to test against this
delegate subscription for the nodes along
the parent axis.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								delegates.splice(
									arrayIndex(delegates, notifier), <span class="hljs-number">1</span>);
							}

							<span class="hljs-keyword">if</span> (match) {</pre></div></div>
            
        </li>
        
        
        <li id="section-520">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-520">&#182;</a>
              </div>
              <p>undefined for direct subs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>								e.container = notifier.container;
								ret = notifier.fire(e);
							}

							<span class="hljs-keyword">if</span> (ret === <span class="hljs-literal">false</span> || e.stopped === <span class="hljs-number">2</span>) {
								<span class="hljs-keyword">break</span>;
							}
						}

						<span class="hljs-keyword">delete</span> notifiers[yuid];
						count--;
					}

					<span class="hljs-keyword">if</span> (e.stopped !== <span class="hljs-number">2</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-521">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-521">&#182;</a>
              </div>
              <p>delegates come after subs targeting this specific node
because they would not normally report until they’d
bubbled to the container node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = delegates.length; i &lt; len; ++i) {
							notifier = delegates[i];
							sub = notifier.handle.sub;

							<span class="hljs-keyword">if</span> (sub.filter.apply(target,
								[target, e].concat(sub.args || []))) {

								e.container = notifier.container;
								e.currentTarget = target;
								ret = notifier.fire(e);
							}

							<span class="hljs-keyword">if</span> (ret === <span class="hljs-literal">false</span> || e.stopped === <span class="hljs-number">2</span>) {
								<span class="hljs-keyword">break</span>;
							}
						}
					}

					<span class="hljs-keyword">if</span> (e.stopped) {
						<span class="hljs-keyword">break</span>;
					}
				}
			},

			<span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, sub, notifier</span>) </span>{
				sub.handle = <span class="hljs-keyword">this</span>._attach(node._node, notifier);
			},

			<span class="hljs-attr">detach</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, sub</span>) </span>{
				sub.handle.detach();
			},

			<span class="hljs-attr">delegate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, sub, notifier, filter</span>) </span>{
				<span class="hljs-keyword">if</span> (isString(filter)) {
					sub.filter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>{
						<span class="hljs-keyword">return</span> Y.Selector.test(target._node, filter,
							node === target ? <span class="hljs-literal">null</span> : node._node);
					};
				}

				sub.handle = <span class="hljs-keyword">this</span>._attach(node._node, notifier, <span class="hljs-literal">true</span>);
			},

			<span class="hljs-attr">detachDelegate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, sub</span>) </span>{
				sub.handle.detach();
			}
		}, <span class="hljs-literal">true</span>);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-522">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-522">&#182;</a>
              </div>
              <p>For IE, we need to defer to focusin rather than focus because
<code>el.focus(); doSomething();</code> executes el.onbeforeactivate, el.onactivate,
el.onfocusin, doSomething, then el.onfocus.  All others support capture
phase focus, which executes before doSomething.  To guarantee consistent
behavior for this use case, IE’s direct subscriptions are made against
focusin so subscribers will be notified before js following el.focus() is
executed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (useActivate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-523">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-523">&#182;</a>
              </div>
              <pre><code>name     capture phase       direct subscription
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>		define(<span class="hljs-string">"focus"</span>, <span class="hljs-string">"beforeactivate"</span>,   <span class="hljs-string">"focusin"</span>);
		define(<span class="hljs-string">"blur"</span>,  <span class="hljs-string">"beforedeactivate"</span>, <span class="hljs-string">"focusout"</span>);
	} <span class="hljs-keyword">else</span> {
		define(<span class="hljs-string">"focus"</span>, <span class="hljs-string">"focus"</span>, <span class="hljs-string">"focus"</span>);
		define(<span class="hljs-string">"blur"</span>,  <span class="hljs-string">"blur"</span>,  <span class="hljs-string">"blur"</span>);
	}


}, <span class="hljs-string">'3.7.3'</span>, {<span class="hljs-string">"requires"</span>: [<span class="hljs-string">"event-synthetic"</span>]});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
