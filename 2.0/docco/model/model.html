<!DOCTYPE html>

<html>
<head>
  <title>model.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>model.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>this file should not be stolen directly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>steal(<span class="hljs-string">'can/util'</span>, <span class="hljs-string">'can/map'</span>, <span class="hljs-string">'can/list'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(can)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="model-js">model.js</h2>
<p><code>can.Model</code><br><em>A <code>can.Map</code> that connects to a RESTful interface.</em></p>
<p>Generic deferred piping function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @add can.Model
	 */</span>
	<span class="hljs-keyword">var</span> pipe = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(def, model, func)</span> </span>{
		<span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> can.Deferred();
		def.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
			<span class="hljs-keyword">var</span> args = can.makeArray(<span class="hljs-built_in">arguments</span>),
				success = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">try</span> {
				args[<span class="hljs-number">0</span>] = model[func](args[<span class="hljs-number">0</span>]);
			} <span class="hljs-keyword">catch</span> (e) {
				success = <span class="hljs-literal">false</span>;
				d.rejectWith(d, [e].concat(args));
			}
			<span class="hljs-keyword">if</span> (success) {
				d.resolveWith(d, args);
			}
		}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
			d.rejectWith(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
		});

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> def.abort === <span class="hljs-string">'function'</span>) {
			d.abort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				<span class="hljs-keyword">return</span> def.abort();
			};
		}

		<span class="hljs-keyword">return</span> d;
	},
		modelNum = <span class="hljs-number">0</span>,
		getId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(inst)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Instead of using attr, use __get for performance.
Need to set reading</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (can.__reading) {
				can.__reading(inst, inst.constructor.id);
			}
			<span class="hljs-keyword">return</span> inst.__get(inst.constructor.id);
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Ajax <code>options</code> generator function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		ajax = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ajaxOb, data, type, dataType, success, error)</span> </span>{

			<span class="hljs-keyword">var</span> params = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>If we get a string, handle it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ajaxOb === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>If there’s a space, it’s probably the type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> parts = ajaxOb.split(<span class="hljs-regexp">/\s+/</span>);
				params.url = parts.pop();
				<span class="hljs-keyword">if</span> (parts.length) {
					params.type = parts.pop();
				}
			} <span class="hljs-keyword">else</span> {
				can.extend(params, ajaxOb);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>If we are a non-array object, copy to a new attrs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			params.data = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">"object"</span> &amp;&amp; !can.isArray(data) ?
				can.extend(params.data || {}, data) : data;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Get the url with any templated values filled out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			params.url = can.sub(params.url, params.data, <span class="hljs-literal">true</span>);

			<span class="hljs-keyword">return</span> can.ajax(can.extend({
				type: type || <span class="hljs-string">'post'</span>,
				dataType: dataType || <span class="hljs-string">'json'</span>,
				success: success,
				error: error
			}, params));
		},
		makeRequest = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(self, type, success, error, method)</span> </span>{
			<span class="hljs-keyword">var</span> args;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>if we pass an array as <code>self</code> it it means we are coming from
the queued request, and we’re passing already serialized data
self’s signature will be: [self, serializedData]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (can.isArray(self)) {
				args = self[<span class="hljs-number">1</span>];
				self = self[<span class="hljs-number">0</span>];
			} <span class="hljs-keyword">else</span> {
				args = self.serialize();
			}
			args = [args];
			<span class="hljs-keyword">var</span> deferred,</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>The model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				model = self.constructor,
				jqXHR;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><code>update</code> and <code>destroy</code> need the <code>id</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (type !== <span class="hljs-string">'create'</span>) {
				args.unshift(getId(self));
			}

			jqXHR = model[type].apply(model, args);

			deferred = jqXHR.pipe(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{
				self[method || type + <span class="hljs-string">"d"</span>](data, jqXHR);
				<span class="hljs-keyword">return</span> self;
			});</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Hook up <code>abort</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (jqXHR.abort) {
				deferred.abort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
					jqXHR.abort();
				};
			}

			deferred.then(success, error);
			<span class="hljs-keyword">return</span> deferred;
		}, initializers = {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>makes a models function that looks up the data in a particular property</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			models: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(prop)</span> </span>{
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(instancesRawData, oldList)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>until “end of turn”, increment reqs counter so instances will be added to the store</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					can.Model._reqs++;
					<span class="hljs-keyword">if</span> (!instancesRawData) {
						<span class="hljs-keyword">return</span>;
					}

					<span class="hljs-keyword">if</span> (instancesRawData <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.List) {
						<span class="hljs-keyword">return</span> instancesRawData;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Get the list type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>,
						tmp = [],
						Cls = self.List || ML,
						res = oldList <span class="hljs-keyword">instanceof</span> can.List ? oldList : <span class="hljs-keyword">new</span> Cls(),</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Did we get an <code>array</code>?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						arr = can.isArray(instancesRawData),</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Did we get a model list?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						ml = instancesRawData <span class="hljs-keyword">instanceof</span> ML,</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Get the raw <code>array</code> of objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						raw = arr ?</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>If an <code>array</code>, return the <code>array</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						instancesRawData :</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Otherwise if a model list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						(ml ?</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Get the raw objects from the list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							instancesRawData.serialize() :</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Get the object’s data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							can.getObject(prop || <span class="hljs-string">"data"</span>, instancesRawData));

					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> raw === <span class="hljs-string">'undefined'</span>) {
						<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Could not get any raw data while converting using .models'</span>);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>!steal-remove-start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!raw.length) {
						can.dev.warn(<span class="hljs-string">"model.js models has no data."</span>);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>!steal-remove-end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
					<span class="hljs-keyword">if</span> (res.length) {
						res.splice(<span class="hljs-number">0</span>);
					}

					can.each(raw, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(rawPart)</span> </span>{
						tmp.push(self.model(rawPart));
					});</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>We only want one change event so push everything at once</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					res.push.apply(res, tmp);

					<span class="hljs-keyword">if</span> (!arr) { <span class="hljs-comment">// Push other stuff onto `array`.</span>
						can.each(instancesRawData, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(val, prop)</span> </span>{
							<span class="hljs-keyword">if</span> (prop !== <span class="hljs-string">'data'</span>) {
								res.attr(prop, val);
							}
						});
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>at “end of turn”, clean up the store</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					setTimeout(can.proxy(<span class="hljs-keyword">this</span>._clean, <span class="hljs-keyword">this</span>), <span class="hljs-number">1</span>);
					<span class="hljs-keyword">return</span> res;
				};
			},
			model: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(prop)</span> </span>{
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attributes)</span> </span>{
					<span class="hljs-keyword">if</span> (!attributes) {
						<span class="hljs-keyword">return</span>;
					}
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> attributes.serialize === <span class="hljs-string">'function'</span>) {
						attributes = attributes.serialize();
					}
					<span class="hljs-keyword">if</span> (prop) {
						attributes = can.getObject(prop || <span class="hljs-string">'data'</span>, attributes);
					}

					<span class="hljs-keyword">var</span> id = attributes[<span class="hljs-keyword">this</span>.id],
						model = (id || id === <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-keyword">this</span>.store[id] ?
							<span class="hljs-keyword">this</span>.store[id].attr(attributes, <span class="hljs-keyword">this</span>.removeAttr || <span class="hljs-literal">false</span>) : <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>(attributes);

					<span class="hljs-keyword">return</span> model;
				};
			}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>This object describes how to make an ajax request for each ajax method.<br>The available properties are:
    <code>url</code> - The default url to use as indicated as a property on the model.
    <code>type</code> - The default http request type
    <code>data</code> - A method that takes the <code>arguments</code> and returns <code>data</code> used for ajax.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/** 
		 * @static
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @function can.Model.bind bind
		 * @parent can.Model.static
		 * @description Listen for events on a Model class.
		 *
		 * @signature `can.Model.bind(eventType, handler)`
		 * @param {String} eventType The type of event.  It must be
		 * `"created"`, `"updated"`, `"destroyed"`.
		 * @param {function} handler A callback function
		 * that gets called with the event and instance that was
		 * created, destroyed, or updated.
		 * @return {can.Model} The model constructor function.
		 *
		 * @body
		 * `bind(eventType, handler(event, instance))` listens to
		 * __created__, __updated__, __destroyed__ events on all
		 * instances of the model.
		 *
		 *     Task.bind("created", function(ev, createdTask){
		 *      this //-&gt; Task
		 *       createdTask.attr("name") //-&gt; "Dishes"
		 *     })
		 *
		 *     new Task({name: "Dishes"}).save();
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @function can.Model.unbind unbind
		 * @parent can.Model.static
		 * @description Stop listening for events on a Model class.
		 *
		 * @signature `can.Model.unbind(eventType, handler)`
		 * @param {String} eventType The type of event. It must be
		 * `"created"`, `"updated"`, `"destroyed"`.
		 * @param {function} handler A callback function
		 * that was passed to `bind`.
		 * @return {can.Model} The model constructor function.
		 *
		 * @body
		 * `unbind(eventType, handler)` removes a listener
		 * attached with [can.Model.bind].
		 *
		 *     var handler = function(ev, createdTask){
		 *
		 *     }
		 *     Task.bind("created", handler)
		 *     Task.unbind("created", handler)
		 *
		 * You have to pass the same function to `unbind` that you
		 * passed to `bind`.
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/**
		 * @property {String} can.Model.id id
		 * @parent can.Model.static
		 * The name of the id field.  Defaults to `'id'`. Change this if it is something different.
		 *
		 * For example, it's common in .NET to use `'Id'`.  Your model might look like:
		 *
		 *     Friend = can.Model.extend({
		 *       id: "Id"
		 *     },{});
		 */</span>
		<span class="hljs-comment">/**
		 * @property {Boolean} can.Model.removeAttr removeAttr
		 * @parent can.Model.static
		 * Sets whether model conversion should remove non existing attributes or merge with
		 * the existing attributes. The default is `false`.
		 * For example, if `Task.findOne({ id: 1 })` returns
		 *
		 *      { id: 1, name: 'Do dishes', index: 1, color: ['red', 'blue'] }
		 *
		 * for the first request and
		 *
		 *      { id: 1, name: 'Really do dishes', color: ['green'] }
		 *
		 *  for the next request, the actual model attributes would look like:
		 *
		 *      { id: 1, name: 'Really do dishes', index: 1, color: ['green', 'blue'] }
		 *
		 *  Because the attributes of the original model and the updated model will
		 *  be merged. Setting `removeAttr` to `true` will result in model attributes like
		 *
		 *      { id: 1, name: 'Really do dishes', color: ['green'] }
		 *
		 */</span>
		ajaxMethods = {
			<span class="hljs-comment">/**
			 * @description Specifies how to create a new resource on the server. `create(serialized)` is called
			 * by [can.Model.prototype.save save] if the model instance [can.Model.prototype.isNew is new].
			 * @function can.Model.create create
			 * @parent can.Model.static
			 *
			 *
			 * @signature `can.Model.create: function(serialized) -&gt; deferred`
			 *
			 * Specify a function to create persistent instances. The function will
			 * typically perform an AJAX request to a service that results in
			 * creating a record in a database.
			 *
			 * @param {Object} serialized The [can.Map::serialize serialized] properties of
			 * the model to create.
			 * @return {can.Deferred} A Deferred that resolves to an object of attributes
			 * that will be added to the created model instance.  The object __MUST__ contain
			 * an [can.Model.id id] property so that future calls to [can.Model.prototype.save save]
			 * will call [can.Model.update].
			 *
			 *
			 * @signature `can.Model.create: "[METHOD] /path/to/resource"`
			 *
			 * Specify a HTTP method and url to create persistent instances.
			 *
			 * If you provide a URL, the Model will send a request to that URL using
			 * the method specified (or POST if none is specified) when saving a
			 * new instance on the server. (See below for more details.)
			 *
			 * @param {HttpMethod} METHOD An HTTP method. Defaults to `"POST"`.
			 * @param {STRING} url The URL of the service to retrieve JSON data.
			 *
			 *
			 * @signature `can.Model.create: {ajaxSettings}`
			 *
			 * Specify an options object that is used to make a HTTP request to create
			 * persistent instances.
			 *
			 * @param {can.AjaxSettings} ajaxSettings A settings object that
			 * specifies the options available to pass to [can.ajax].
			 *
			 * @body
			 *
			 * `create(attributes) -&gt; Deferred` is used by [can.Model::save save] to create a
			 * model instance on the server.
			 *
			 * ## Implement with a URL
			 *
			 * The easiest way to implement create is to give it the url
			 * to post data to:
			 *
			 *     var Recipe = can.Model.extend({
			 *       create: "/recipes"
			 *     },{})
			 *
			 * This lets you create a recipe like:
			 *
			 *     new Recipe({name: "hot dog"}).save();
			 *
			 *
			 * ## Implement with a Function
			 *
			 * You can also implement create by yourself. Create gets called
			 * with `attrs`, which are the [can.Map::serialize serialized] model
			 * attributes.  Create returns a `Deferred`
			 * that contains the id of the new instance and any other
			 * properties that should be set on the instance.
			 *
			 * For example, the following code makes a request
			 * to `POST /recipes.json {'name': 'hot+dog'}` and gets back
			 * something that looks like:
			 *
			 *     {
			 *       "id": 5,
			 *       "createdAt": 2234234329
			 *     }
			 *
			 * The code looks like:
			 *
			 *     can.Model.extend("Recipe", {
			 *       create : function( attrs ){
			 *         return $.post("/recipes.json",attrs, undefined ,"json");
			 *       }
			 *     },{})
			 */</span>
			create: {
				url: <span class="hljs-string">"_shortName"</span>,
				type: <span class="hljs-string">"post"</span>
			},
			<span class="hljs-comment">/**
			 * @description Update a resource on the server.
			 * @function can.Model.update update
			 * @parent can.Model.static
			 * @signature `can.Model.update: "[METHOD] /path/to/resource"`
			 * If you provide a URL, the Model will send a request to that URL using
			 * the method specified (or PUT if none is specified) when updating an
			 * instance on the server. (See below for more details.)
			 * @return {can.Deferred} A Deferred that resolves to the updated model.
			 *
			 * @signature `can.Model.update: function(id, serialized) -&gt; can.Deffered`
			 * If you provide a function, the Model will expect you to do your own AJAX requests.
			 * @param {*} id The ID of the model to update.
			 * @param {Object} serialized The [can.Map::serialize serialized] properties of
			 * the model to update.
			 * @return {can.Deferred} A Deferred that resolves to the updated model.
			 *
			 * @body
			 * `update( id, attrs ) -&gt; Deferred` is used by [can.Model::save save] to
			 * update a model instance on the server.
			 *
			 * ## Implement with a URL
			 *
			 * The easist way to implement update is to just give it the url to `PUT` data to:
			 *
			 *     Recipe = can.Model.extend({
			 *       update: "/recipes/{id}"
			 *     },{});
			 *
			 * This lets you update a recipe like:
			 *
			 *     Recipe.findOne({id: 1}, function(recipe){
			 *       recipe.attr('name','salad');
			 *       recipe.save();
			 *     })
			 *
			 * This will make an XHR request like:
			 *
			 *     PUT /recipes/1
			 *     name=salad
			 *
			 * If your server doesn't use PUT, you can change it to post like:
			 *
			 *     Recipe = can.Model.extend({
			 *       update: "POST /recipes/{id}"
			 *     },{});
			 *
			 * The server should send back an object with any new attributes the model
			 * should have.  For example if your server updates the "updatedAt" property, it
			 * should send back something like:
			 *
			 *     // PUT /recipes/4 {name: "Food"} -&gt;
			 *     {
			 *       updatedAt : "10-20-2011"
			 *     }
			 *
			 * ## Implement with a Function
			 *
			 * You can also implement update by yourself.  Update takes the `id` and
			 * `attributes` of the instance to be updated.  Update must return
			 * a [can.Deferred Deferred] that resolves to an object that contains any
			 * properties that should be set on the instance.
			 *
			 * For example, the following code makes a request
			 * to '/recipes/5.json?name=hot+dog' and gets back
			 * something that looks like:
			 *
			 *     {
			 *       updatedAt: "10-20-2011"
			 *     }
			 *
			 * The code looks like:
			 *
			 *     Recipe = can.Model.extend({
			 *       update : function(id, attrs ) {
			 *         return $.post("/recipes/"+id+".json",attrs, null,"json");
			 *       }
			 *     },{});
			 */</span>
			update: {
				data: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, attrs)</span> </span>{
					attrs = attrs || {};
					<span class="hljs-keyword">var</span> identity = <span class="hljs-keyword">this</span>.id;
					<span class="hljs-keyword">if</span> (attrs[identity] &amp;&amp; attrs[identity] !== id) {
						attrs[<span class="hljs-string">"new"</span> + can.capitalize(id)] = attrs[identity];
						<span class="hljs-keyword">delete</span> attrs[identity];
					}
					attrs[identity] = id;
					<span class="hljs-keyword">return</span> attrs;
				},
				type: <span class="hljs-string">"put"</span>
			},
			<span class="hljs-comment">/**
			 * @description Destroy a resource on the server.
			 * @function can.Model.destroy destroy
			 * @parent can.Model.static
			 *
			 * @signature `can.Model.destroy: function(id) -&gt; deferred`
			 *
			 *
			 *
			 * If you provide a function, the Model will expect you to do your own AJAX requests.
			 * @param {*} id The ID of the resource to destroy.
			 * @return {can.Deferred} A Deferred that resolves to the destroyed model.
			 *
			 *
			 * @signature `can.Model.destroy: "[METHOD] /path/to/resource"`
			 *
			 * If you provide a URL, the Model will send a request to that URL using
			 * the method specified (or DELETE if none is specified) when deleting an
			 * instance on the server. (See below for more details.)
			 *
			 * @return {can.Deferred} A Deferred that resolves to the destroyed model.
			 *
			 *
			 *
			 * @body
			 * `destroy(id) -&gt; Deferred` is used by [can.Model::destroy] remove a model
			 * instance from the server.
			 *
			 * ## Implement with a URL
			 *
			 * You can implement destroy with a string like:
			 *
			 *     Recipe = can.Model.extend({
			 *       destroy : "/recipe/{id}"
			 *     },{})
			 *
			 * And use [can.Model::destroy] to destroy it like:
			 *
			 *     Recipe.findOne({id: 1}, function(recipe){
			 *          recipe.destroy();
			 *     });
			 *
			 * This sends a `DELETE` request to `/thing/destroy/1`.
			 *
			 * If your server does not support `DELETE` you can override it like:
			 *
			 *     Recipe = can.Model.extend({
			 *       destroy : "POST /recipe/destroy/{id}"
			 *     },{})
			 *
			 * ## Implement with a function
			 *
			 * Implement destroy with a function like:
			 *
			 *     Recipe = can.Model.extend({
			 *       destroy : function(id){
			 *         return $.post("/recipe/destroy/"+id,{});
			 *       }
			 *     },{})
			 *
			 * Destroy just needs to return a deferred that resolves.
			 */</span>
			destroy: {
				type: <span class="hljs-string">'delete'</span>,
				data: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, attrs)</span> </span>{
					attrs = attrs || {};
					attrs.id = attrs[<span class="hljs-keyword">this</span>.id] = id;
					<span class="hljs-keyword">return</span> attrs;
				}
			},
			<span class="hljs-comment">/**
			 * @description Retrieve multiple resources from a server.
			 * @function can.Model.findAll findAll
			 * @parent can.Model.static
			 *
			 * @signature `can.Model.findAll( params[, success[, error]] )`
			 *
			 * Retrieve multiple resources from a server.
			 *
			 * @param {Object} params Values to filter the request or results with.
			 * @param {function(can.Model.List)} [success(list)] A callback to call on successful retrieval. The callback recieves
			 * a can.Model.List of the retrieved resources.
			 * @param {function(can.AjaxSettings)} [error(xhr)] A callback to call when an error occurs. The callback receives the
			 * XmlHttpRequest object.
			 * @return {can.Deferred} A deferred that resolves to a [can.Model.List] of retrieved models.
			 *
			 *
			 * @signature `can.Model.findAll: findAllData( params ) -&gt; deferred`
			 *
			 * Implements `findAll` with a [can.Model.findAllData function]. This function
			 * is passed to [can.Model.makeFindAll makeFindAll] to create the external
			 * `findAll` method.
			 *
			 *     findAll: function(params){
			 *       return $.get("/tasks",params)
			 *     }
			 *
			 * @param {can.Model.findAllData} findAllData A function that accepts parameters
			 * specifying a list of instance data to retrieve and returns a [can.Deferred]
			 * that resolves to an array of those instances.
			 *
			 * @signature `can.Model.findAll: "[METHOD] /path/to/resource"`
			 *
			 * Implements `findAll` with a HTTP method and url to retrieve instance data.
			 *
			 *     findAll: "GET /tasks"
			 *
			 * If `findAll` is implemented with a string, this gets converted to
			 * a [can.Model.findAllData findAllData function]
			 * which is passed to [can.Model.makeFindAll makeFindAll] to create the external
			 * `findAll` method.
			 *
			 * @param {HttpMethod} METHOD An HTTP method. Defaults to `"GET"`.
			 *
			 * @param {STRING} url The URL of the service to retrieve JSON data.
			 *
			 * @return {JSON} The service should return a JSON object like:
			 *
			 *     {
			 *       "data": [
			 *         { "id" : 1, "name" : "do the dishes" },
			 *         { "id" : 2, "name" : "mow the lawn" },
			 *         { "id" : 3, "name" : "iron my shirts" }
			 *       ]
			 *     }
			 *
			 * This object is passed to [can.Model.models] to turn it into instances.
			 *
			 * _Note: .findAll can also accept an array, but you
			 * probably [should not be doing that](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)._
			 *
			 *
			 * @signature `can.Model.findAll: {ajaxSettings}`
			 *
			 * Implements `findAll` with a [can.AjaxSettings ajax settings object].
			 *
			 *     findAll: {url: "/tasks", dataType: "json"}
			 *
			 * If `findAll` is implemented with an object, it gets converted to
			 * a [can.Model.findAllData findAllData function]
			 * which is passed to [can.Model.makeFindAll makeFindAll] to create the external
			 * `findAll` method.
			 *
			 * @param {can.AjaxSettings} ajaxSettings A settings object that
			 * specifies the options available to pass to [can.ajax].
			 *
			 * @body
			 *
			 * ## Use
			 *
			 * `findAll( params, success(instances), error(xhr) ) -&gt; Deferred` is used to retrieve model
			 * instances from the server. After implementing `findAll`, use it to retrieve instances of the model
			 * like:
			 *
			 *     Recipe.findAll({favorite: true}, function(recipes){
			 *       recipes[0].attr('name') //-&gt; "Ice Water"
			 *     }, function( xhr ){
			 *       // called if an error
			 *     }) //-&gt; Deferred
			 *
			 *
			 * Before you can use `findAll`, you must implement it.
			 *
			 * ## Implement with a URL
			 *
			 * Implement findAll with a url like:
			 *
			 *     Recipe = can.Model.extend({
			 *       findAll : "/recipes.json"
			 *     },{});
			 *
			 * The server should return data that looks like:
			 *
			 *     [
			 *       {"id" : 57, "name": "Ice Water"},
			 *       {"id" : 58, "name": "Toast"}
			 *     ]
			 *
			 * ## Implement with an Object
			 *
			 * Implement findAll with an object that specifies the parameters to
			 * `can.ajax` (jQuery.ajax) like:
			 *
			 *     Recipe = can.Model.extend({
			 *       findAll : {
			 *         url: "/recipes.xml",
			 *         dataType: "xml"
			 *       }
			 *     },{})
			 *
			 * ## Implement with a Function
			 *
			 * To implement with a function, `findAll` is passed __params__ to filter
			 * the instances retrieved from the server and it should return a
			 * deferred that resolves to an array of model data. For example:
			 *
			 *     Recipe = can.Model.extend({
			 *       findAll : function(params){
			 *         return $.ajax({
			 *           url: '/recipes.json',
			 *           type: 'get',
			 *           dataType: 'json'})
			 *       }
			 *     },{})
			 *
			 */</span>
			findAll: {
				url: <span class="hljs-string">"_shortName"</span>
			},
			<span class="hljs-comment">/**
			 * @description Retrieve a resource from a server.
			 * @function can.Model.findOne findOne
			 * @parent can.Model.static
			 *
			 * @signature `can.Model.findOne( params[, success[, error]] )`
			 *
			 * Retrieve a single instance from the server.
			 *
			 * @param {Object} params Values to filter the request or results with.
			 * @param {function(can.Model)} [success(model)] A callback to call on successful retrieval. The callback recieves
			 * the retrieved resource as a can.Model.
			 * @param {function(can.AjaxSettings)} [error(xhr)] A callback to call when an error occurs. The callback receives the
			 * XmlHttpRequest object.
			 * @return {can.Deferred} A deferred that resolves to a [can.Model.List] of retrieved models.
			 *
			 * @signature `can.Model.findOne: findOneData( params ) -&gt; deferred`
			 *
			 * Implements `findOne` with a [can.Model.findOneData function]. This function
			 * is passed to [can.Model.makeFindOne makeFindOne] to create the external
			 * `findOne` method.
			 *
			 *     findOne: function(params){
			 *       return $.get("/task/"+params.id)
			 *     }
			 *
			 * @param {can.Model.findOneData} findOneData A function that accepts parameters
			 * specifying an instance to retreive and returns a [can.Deferred]
			 * that resolves to that instance.
			 *
			 * @signature `can.Model.findOne: "[METHOD] /path/to/resource"`
			 *
			 * Implements `findOne` with a HTTP method and url to retrieve an instance's data.
			 *
			 *     findOne: "GET /tasks/{id}"
			 *
			 * If `findOne` is implemented with a string, this gets converted to
			 * a [can.Model.makeFindOne makeFindOne function]
			 * which is passed to [can.Model.makeFindOne makeFindOne] to create the external
			 * `findOne` method.
			 *
			 * @param {HttpMethod} METHOD An HTTP method. Defaults to `"GET"`.
			 *
			 * @param {STRING} url The URL of the service to retrieve JSON data.
			 *
			 * @signature `can.Model.findOne: {ajaxSettings}`
			 *
			 * Implements `findOne` with a [can.AjaxSettings ajax settings object].
			 *
			 *     findOne: {url: "/tasks/{id}", dataType: "json"}
			 *
			 * If `findOne` is implemented with an object, it gets converted to
			 * a [can.Model.makeFindOne makeFindOne function]
			 * which is passed to [can.Model.makeFindOne makeFindOne] to create the external
			 * `findOne` method.
			 *
			 * @param {can.AjaxSettings} ajaxSettings A settings object that
			 * specifies the options available to pass to [can.ajax].
			 *
			 * @body
			 *
			 * ## Use
			 *
			 * `findOne( params, success(instance), error(xhr) ) -&gt; Deferred` is used to retrieve a model
			 * instance from the server.
			 *
			 * Use `findOne` like:
			 *
			 *     Recipe.findOne({id: 57}, function(recipe){
			 *      recipe.attr('name') //-&gt; "Ice Water"
			 *     }, function( xhr ){
			 *      // called if an error
			 *     }) //-&gt; Deferred
			 *
			 * Before you can use `findOne`, you must implement it.
			 *
			 * ## Implement with a URL
			 *
			 * Implement findAll with a url like:
			 *
			 *     Recipe = can.Model.extend({
			 *       findOne : "/recipes/{id}.json"
			 *     },{});
			 *
			 * If `findOne` is called like:
			 *
			 *     Recipe.findOne({id: 57});
			 *
			 * The server should return data that looks like:
			 *
			 *     {"id" : 57, "name": "Ice Water"}
			 *
			 * ## Implement with an Object
			 *
			 * Implement `findOne` with an object that specifies the parameters to
			 * `can.ajax` (jQuery.ajax) like:
			 *
			 *     Recipe = can.Model.extend({
			 *       findOne : {
			 *         url: "/recipes/{id}.xml",
			 *         dataType: "xml"
			 *       }
			 *     },{})
			 *
			 * ## Implement with a Function
			 *
			 * To implement with a function, `findOne` is passed __params__ to specify
			 * the instance retrieved from the server and it should return a
			 * deferred that resolves to the model data.  Also notice that you now need to
			 * build the URL manually. For example:
			 *
			 *     Recipe = can.Model.extend({
			 *       findOne : function(params){
			 *         return $.ajax({
			 *           url: '/recipes/' + params.id,
			 *           type: 'get',
			 *           dataType: 'json'})
			 *       }
			 *     },{})
			 *
			 *
			 */</span>
			findOne: {}
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Makes an ajax request <code>function</code> from a string.
    <code>ajaxMethod</code> - The <code>ajaxMethod</code> object defined above.
    <code>str</code> - The string the user provided. Ex: <code>findAll: &quot;/recipes.json&quot;</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		ajaxMaker = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ajaxMethod, str)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Return a <code>function</code> that serves as the ajax method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>If the ajax method has it’s own way of getting <code>data</code>, use that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				data = ajaxMethod.data ?
					ajaxMethod.data.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) :</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Otherwise use the data passed in.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				data;</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Return the ajax method with <code>data</code> and the <code>type</code> provided.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> ajax(str || <span class="hljs-keyword">this</span>[ajaxMethod.url || <span class="hljs-string">"_url"</span>], data, ajaxMethod.type || <span class="hljs-string">"get"</span>);
			};
		};

	can.Model = can.Map({
			fullName: <span class="hljs-string">'can.Model'</span>,
			_reqs: <span class="hljs-number">0</span>,
			<span class="hljs-comment">/**
			 * @hide
			 * @function can.Model.setup
			 * @parent can.Model.static
			 *
			 * Configures
			 *
			 */</span>
			setup: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(base)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>create store here if someone wants to use model without inheriting from it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>.store = {};
				can.Map.setup.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Set default list as model list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!can.Model) {
					<span class="hljs-keyword">return</span>;
				}
				<span class="hljs-comment">/**
				 * @property {can.Model.List} can.Model.static.List List
				 * @parent can.Model.static
				 *
				 * @description Specifies the type of List that [can.Model.findAll findAll]
				 * should return.
				 *
				 * @option {can.Model.List} A can.Model's List property is the
				 * type of [can.List List] returned
				 * from [can.Model.findAll findAll]. For example:
				 *
				 *     Task = can.Model.extend({
				 *       findAll: "/tasks"
				 *     },{})
				 *
				 *     Task.findAll({}, function(tasks){
				 *       tasks instanceof Task.List //-&gt; true
				 *     })
				 *
				 * Overwrite a Model's `List` property to add custom
				 * behavior to the lists provided to `findAll` like:
				 *
				 *     Task = can.Model.extend({
				 *       findAll: "/tasks"
				 *     },{})
				 *     Task.List = Task.List.extend({
				 *       completed: function(){
				 *         var count = 0;
				 *         this.each(function(task){
				 *           if( task.attr("completed") ) count++;
				 *         })
				 *         return count;
				 *       }
				 *     })
				 *
				 *     Task.findAll({}, function(tasks){
				 *       tasks.completed() //-&gt; 3
				 *     })
				 *
				 * When [can.Model] is extended,
				 * [can.Model.List] is extended and set as the extended Model's
				 * `List` property. The extended list's [can.List.Map Map] property
				 * is set to the extended Model.  For example:
				 *
				 *     Task = can.Model.extend({
				 *       findAll: "/tasks"
				 *     },{})
				 *     Task.List.Map //-&gt; Task
				 *
				 */</span>
				<span class="hljs-keyword">this</span>.List = ML({
					Map: <span class="hljs-keyword">this</span>
				}, {});
				<span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>,
					clean = can.proxy(<span class="hljs-keyword">this</span>._clean, self);</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>go through ajax methods and set them up</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				can.each(ajaxMethods, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(method, name)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>if an ajax method is not a function, it’s either
a string url like findAll: “/recipes” or an
ajax options object like {url: “/recipes”}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (!can.isFunction(self[name])) {</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>use ajaxMaker to convert that into a function
that returns a deferred with the data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						self[name] = ajaxMaker(method, self[name]);
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>check if there’s a make function like makeFindAll
these take deferred function and can do special
behavior with it (like look up data in a store)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (self[<span class="hljs-string">'make'</span> + can.capitalize(name)]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>pass the deferred method to the make method to get back
the “findAll” method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">var</span> newMethod = self[<span class="hljs-string">'make'</span> + can.capitalize(name)](self[name]);
						can.Construct._overwrite(self, base, name, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>increment the numer of requests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							can.Model._reqs++;
							<span class="hljs-keyword">var</span> def = newMethod.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
							<span class="hljs-keyword">var</span> then = def.then(clean, clean);
							then.abort = def.abort;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>attach abort to our then and return it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							<span class="hljs-keyword">return</span> then;
						});
					}
				});
				can.each(initializers, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(makeInitializer, name)</span> </span>{
					<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self[name] === <span class="hljs-string">'string'</span>) {
						can.Construct._overwrite(self, base, name, makeInitializer(self[name]));
					}
				});
				<span class="hljs-keyword">if</span> (self.fullName === <span class="hljs-string">'can.Model'</span> || !self.fullName) {
					modelNum++;
					self.fullName = <span class="hljs-string">'Model'</span> + modelNum;
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Add ajax converters.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				can.Model._reqs = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">this</span>._url = <span class="hljs-keyword">this</span>._shortName + <span class="hljs-string">'/{'</span> + <span class="hljs-keyword">this</span>.id + <span class="hljs-string">'}'</span>;
			},
			_ajax: ajaxMaker,
			_makeRequest: makeRequest,
			_clean: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				can.Model._reqs--;
				<span class="hljs-keyword">if</span> (!can.Model._reqs) {
					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> id <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.store) {
						<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.store[id]._bindings) {
							<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.store[id];
						}
					}
				}
				<span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];
			},
			<span class="hljs-comment">/**
			 * @function can.Model.models models
			 * @parent can.Model.static
			 * @description Convert raw data into can.Model instances.
			 *
			 * @signature `can.Model.models(data[, oldList])`
			 * @param {Array&lt;Object&gt;} data The raw data from a `[can.Model.findAll findAll()]` request.
			 * @param {can.Model.List} [oldList] If supplied, this List will be updated with the data from
			 * __data__.
			 * @return {can.Model.List} A List of Models made from the raw data.
			 *
			 * @signature `models: "PROPERTY"`
			 *
			 * Creates a `models` function that looks for the array of instance data in the PROPERTY
			 * property of the raw response data of [can.Model.findAll].
			 *
			 * @body
			 * `can.Model.models(data, xhr)` is used to
			 * convert the raw response of a [can.Model.findAll] request
			 * into a [can.Model.List] of model instances.
			 *
			 * This method is rarely called directly. Instead the deferred returned
			 * by findAll is piped into `models`.  This creates a new deferred that
			 * resolves to a [can.Model.List] of instances instead of an array of
			 * simple JS objects.
			 *
			 * If your server is returning data in non-standard way,
			 * overwriting `can.Model.models` is the best way to normalize it.
			 *
			 * ## Quick Example
			 *
			 * The following uses models to convert to a [can.Model.List] of model
			 * instances.
			 *
			 *     Task = can.Model.extend()
			 *     var tasks = Task.models([
			 *       {id: 1, name : "dishes", complete : false},
			 *       {id: 2, name: "laundry", compelte: true}
			 *     ])
			 *
			 *     tasks.attr("0.complete", true)
			 *
			 * ## Non-standard Services
			 *
			 * `can.Model.models` expects data to be an array of name-value pair
			 * objects like:
			 *
			 *     [{id: 1, name : "dishes"},{id:2, name: "laundry"}, ...]
			 *
			 * It can also take an object with additional data about the array like:
			 *
			 *     {
			 *       count: 15000 //how many total items there might be
			 *       data: [{id: 1, name : "justin"},{id:2, name: "brian"}, ...]
			 *     }
			 *
			 * In this case, models will return a [can.Model.List] of instances found in
			 * data, but with additional properties as expandos on the list:
			 *
			 *     var tasks = Task.models({
			 *       count : 1500,
			 *       data : [{id: 1, name: 'dishes'}, ...]
			 *     })
			 *     tasks.attr("name") // -&gt; 'dishes'
			 *     tasks.count // -&gt; 1500
			 *
			 * ### Overwriting Models
			 *
			 * If your service returns data like:
			 *
			 *     {thingsToDo: [{name: "dishes", id: 5}]}
			 *
			 * You will want to overwrite models to pass the base models what it expects like:
			 *
			 *     Task = can.Model.extend({
			 *       models : function(data){
			 *         return can.Model.models.call(this,data.thingsToDo);
			 *       }
			 *     },{})
			 *
			 * `can.Model.models` passes each instance's data to `can.Model.model` to
			 * create the individual instances.
			 */</span>
			models: initializers.models(<span class="hljs-string">"data"</span>),
			<span class="hljs-comment">/**
			 * @function can.Model.model model
			 * @parent can.Model.static
			 * @description Convert raw data into a can.Model instance.
			 * @signature `can.Model.model(data)`
			 * @param {Object} data The data to convert to a can.Model instance.
			 * @return {can.Model} An instance of can.Model made with the given data.
			 *
			 * @signature `model: "PROPERTY"`
			 *
			 * Creates a `model` function that looks for the attributes object in the PROPERTY
			 * property of raw instance data.
			 *
			 * @body
			 * `can.Model.model(attributes)` is used to convert data from the server into
			 * a model instance.  It is rarely called directly.  Instead it is invoked as
			 * a result of [can.Model.findOne] or [can.Model.findAll].
			 *
			 * If your server is returning data in non-standard way,
			 * overwriting `can.Model.model` is a good way to normalize it.
			 *
			 * ## Example
			 *
			 * The following uses `model` to convert to a model
			 * instance.
			 *
			 *     Task = can.Model.extend({},{})
			 *     var task = Task.model({id: 1, name : "dishes", complete : false})
			 *
			 *     tasks.attr("complete", true)
			 *
			 * `Task.model(attrs)` is very similar to simply calling `new Model(attrs)` except
			 * that it checks the model's store if the instance has already been created.  The model's
			 * store is a collection of instances that have event handlers.
			 *
			 * This means that if the model's store already has an instance, you'll get the same instance
			 * back.  Example:
			 *
			 *     // create a task
			 *     var taskA = new Task({id: 5, complete: true});
			 *
			 *     // bind to it, which puts it in the store
			 *      taskA.bind("complete", function(){});
			 *
			 *     // use model to create / retrieve a task
			 *     var taskB = Task.model({id: 5, complete: true});
			 *
			 *     taskA === taskB //-&gt; true
			 *
			 * ## Non-standard Services
			 *
			 * `can.Model.model` expects to retreive attributes of the model
			 * instance like:
			 *
			 *
			 *     {id: 5, name : "dishes"}
			 *
			 *
			 * If the service returns data formatted differently, like:
			 *
			 *     {todo: {name: "dishes", id: 5}}
			 *
			 * Overwrite `model` like:
			 *
			 *     Task = can.Model.extend({
			 *       model : function(data){
			 *         return can.Model.model.call(this,data.todo);
			 *       }
			 *     },{});
			 */</span>
			model: initializers.model()
		},

		<span class="hljs-comment">/**
		 * @prototype
		 */</span>
		{
			setup: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attrs)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>try to add things as early as possible to the store (#457)
we add things to the store before any properties are even set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> id = attrs &amp;&amp; attrs[<span class="hljs-keyword">this</span>.constructor.id];
				<span class="hljs-keyword">if</span> (can.Model._reqs &amp;&amp; id !== <span class="hljs-literal">null</span>) {
					<span class="hljs-keyword">this</span>.constructor.store[id] = <span class="hljs-keyword">this</span>;
				}
				can.Map.prototype.setup.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			},
			<span class="hljs-comment">/**
			 * @function can.Model.prototype.isNew isNew
			 * @description Check if a Model has yet to be saved on the server.
			 * @signature `model.isNew()`
			 * @return {Boolean} Whether an instance has been saved on the server.
			 * (This is determined by whether `id` has a value set yet.)
			 *
			 * @body
			 * `isNew()` returns if the instance is has been created
			 * on the server. This is essentially if the [can.Model.id]
			 * property is null or undefined.
			 *
			 *     new Recipe({id: 1}).isNew() //-&gt; false
			 */</span>
			isNew: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				<span class="hljs-keyword">var</span> id = getId(<span class="hljs-keyword">this</span>);
				<span class="hljs-keyword">return</span> !(id || id === <span class="hljs-number">0</span>); <span class="hljs-comment">// If `null` or `undefined`</span>
			},
			<span class="hljs-comment">/**
			 * @function can.Model.prototype.save save
			 * @description Save a model back to the server.
			 * @signature `model.save([success[, error]])`
			 * @param {function} [success] A callback to call on successful save. The callback recieves
			 * the can.Model after saving.
			 * @param {function} [error] A callback to call when an error occurs. The callback receives the
			 * XmlHttpRequest object.
			 * @return {can.Deferred} A Deferred that resolves to the Model after it has been saved.
			 *
			 * @body
			 * `model.save([success(model)],[error(xhr)])` creates or updates
			 * the model instance using [can.Model.create] or
			 * [can.Model.update] depending if the instance
			 * [can.Model::isNew has an id or not].
			 *
			 * ## Using `save` to create an instance.
			 *
			 * If `save` is called on an instance that does not have
			 * an [can.Model.id id] property, it calls [can.Model.create]
			 * with the instance's properties.  It also [can.trigger triggers]
			 * a "created" event on the instance and the model.
			 *
			 *     // create a model instance
			 *     var todo = new Todo({name: "dishes"})
			 *
			 *     // listen when the instance is created
			 *     todo.bind("created", function(ev){
			 *      this //-&gt; todo
			 *     })
			 *
			 *     // save it on the server
			 *     todo.save(function(todo){
			 *      console.log("todo", todo, "created")
			 *     });
			 *
			 * ## Using `save` to update an instance.
			 *
			 * If save is called on an instance that has
			 * an [can.Model.id id] property, it calls [can.Model.create]
			 * with the instance's properties.  When the save is complete,
			 * it triggers an "updated" event on the instance and the instance's model.
			 *
			 * Instances with an
			 * __id__ are typically retrieved with [can.Model.findAll] or
			 * [can.Model.findOne].
			 *
			 *
			 *     // get a created model instance
			 *     Todo.findOne({id: 5},function(todo){
			 *
			 *       // listen when the instance is updated
			 *       todo.bind("updated", function(ev){
			 *          this //-&gt; todo
			 *       })
			 *
			 *       // update the instance's property
			 *       todo.attr("complete", true)
			 *
			 *       // save it on the server
			 *       todo.save(function(todo){
			 *          console.log("todo", todo, "updated")
			 *       });
			 *
			 *     });
			 *
			 */</span>
			save: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(success, error)</span> </span>{
				<span class="hljs-keyword">return</span> makeRequest(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.isNew() ? <span class="hljs-string">'create'</span> : <span class="hljs-string">'update'</span>, success, error);
			},
			<span class="hljs-comment">/**
			 * @function can.Model.prototype.destroy destroy
			 * @description Destroy a Model on the server.
			 * @signature `model.destroy([success[, error]])`
			 * @param {function} [success] A callback to call on successful destruction. The callback recieves
			 * the can.Model as it was just prior to destruction.
			 * @param {function} [error] A callback to call when an error occurs. The callback receives the
			 * XmlHttpRequest object.
			 * @return {can.Deferred} A Deferred that resolves to the Model as it was before destruction.
			 *
			 * @body
			 * Destroys the instance by calling
			 * [Can.Model.destroy] with the id of the instance.
			 *
			 *     recipe.destroy(success, error);
			 *
			 * This triggers "destroyed" events on the instance and the
			 * Model constructor function which can be listened to with
			 * [can.Model::bind] and [can.Model.bind].
			 *
			 *     Recipe = can.Model.extend({
			 *       destroy : "DELETE /services/recipes/{id}",
			 *       findOne : "/services/recipes/{id}"
			 *     },{})
			 *
			 *     Recipe.bind("destroyed", function(){
			 *       console.log("a recipe destroyed");
			 *     });
			 *
			 *     // get a recipe
			 *     Recipe.findOne({id: 5}, function(recipe){
			 *       recipe.bind("destroyed", function(){
			 *         console.log("this recipe destroyed")
			 *       })
			 *       recipe.destroy();
			 *     })
			 */</span>
			destroy: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(success, error)</span> </span>{
				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isNew()) {
					<span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
					<span class="hljs-keyword">var</span> def = can.Deferred();
					def.then(success, error);
					<span class="hljs-keyword">return</span> def.done(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>{
						self.destroyed(data);
					})
						.resolve(self);
				}
				<span class="hljs-keyword">return</span> makeRequest(<span class="hljs-keyword">this</span>, <span class="hljs-string">'destroy'</span>, success, error, <span class="hljs-string">'destroyed'</span>);
			},
			<span class="hljs-comment">/**
			 * @description Listen to events on this Model.
			 * @function can.Model.prototype.bind bind
			 * @signature `model.bind(eventName, handler)`
			 * @param {String} eventName The event to bind to.
			 * @param {function} handler The function to call when the
			 * event occurs. __handler__ is passed the event and the
			 * Model instance.
			 * @return {can.Model} The Model, for chaining.
			 *
			 * @body
			 * `bind(eventName, handler(ev, args...) )` is used to listen
			 * to events on this model instance.  Example:
			 *
			 *     Task = can.Model.extend()
			 *     var task = new Task({name : "dishes"})
			 *     task.bind("name", function(ev, newVal, oldVal){})
			 *
			 * Use `bind` the
			 * same as [can.Map::bind] which should be used as
			 * a reference for listening to property changes.
			 *
			 * Bind on model can be used to listen to when
			 * an instance is:
			 *
			 *  - created
			 *  - updated
			 *  - destroyed
			 *
			 * like:
			 *
			 *     Task = can.Model.extend()
			 *     var task = new Task({name : "dishes"})
			 *
			 *     task.bind("created", function(ev, newTask){
			 *      console.log("created", newTask)
			 *     })
			 *     .bind("updated", function(ev, updatedTask){
			 *       console.log("updated", updatedTask)
			 *     })
			 *     .bind("destroyed", function(ev, destroyedTask){
			 *       console.log("destroyed", destroyedTask)
			 *     })
			 *
			 *     // create, update, and destroy
			 *     task.save(function(){
			 *       task.attr('name', "do dishes")
			 *           .save(function(){
			 *       task.destroy()
			 *           })
			 *     });
			 *
			 *
			 * `bind` also extends the inherited
			 * behavior of [can.Map::bind] to track the number
			 * of event bindings on this object which is used to store
			 * the model instance.  When there are no bindings, the
			 * model instance is removed from the store, freeing memory.
			 */</span>
			_bindsetup: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				<span class="hljs-keyword">this</span>.constructor.store[<span class="hljs-keyword">this</span>.__get(<span class="hljs-keyword">this</span>.constructor.id)] = <span class="hljs-keyword">this</span>;
				<span class="hljs-keyword">return</span> can.Map.prototype._bindsetup.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			},
			<span class="hljs-comment">/**
			 * @function can.Model.prototype.unbind unbind
			 * @description Stop listening to events on this Model.
			 * @signature `model.unbind(eventName[, handler])`
			 * @param {String} eventName The event to unbind from.
			 * @param {function} [handler] A handler previously bound with `bind`.
			 * If __handler__ is not passed, `unbind` will remove all handlers
			 * for the given event.
			 * @return {can.Model} The Model, for chaining.
			 *
			 * @body
			 * `unbind(eventName, handler)` removes a listener
			 * attached with [can.Model::bind].
			 *
			 *     var handler = function(ev, createdTask){
			 *
			 *     }
			 *     task.bind("created", handler)
			 *     task.unbind("created", handler)
			 *
			 * You have to pass the same function to `unbind` that you
			 * passed to `bind`.
			 *
			 * Unbind will also remove the instance from the store
			 * if there are no other listeners.
			 */</span>
			_bindteardown: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.constructor.store[getId(<span class="hljs-keyword">this</span>)];
				<span class="hljs-keyword">return</span> can.Map.prototype._bindteardown.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Change <code>id</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			___set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(prop, val)</span> </span>{
				can.Map.prototype.___set.call(<span class="hljs-keyword">this</span>, prop, val);</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>If we add an <code>id</code>, move it to the store.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (prop === <span class="hljs-keyword">this</span>.constructor.id &amp;&amp; <span class="hljs-keyword">this</span>._bindings) {
					<span class="hljs-keyword">this</span>.constructor.store[getId(<span class="hljs-keyword">this</span>)] = <span class="hljs-keyword">this</span>;
				}
			}
		});

	can.each({
		<span class="hljs-comment">/**
		 * @function can.Model.makeFindAll
		 * @parent can.Model.static
		 *
		 * @signature `can.Model.makeFindAll: function(findAllData) -&gt; findAll`
		 *
		 * Returns the external `findAll` method given the implemented [can.Model.findAllData findAllData] function.
		 *
		 * @params {can.Model.findAllData}
		 *
		 * [can.Model.findAll] is implemented with a `String`, [can.AjaxSettings ajax settings object], or
		 * [can.Model.findAllData findAllData] function. If it is implemented as
		 * a `String` or [can.AjaxSettings ajax settings object], those values are used
		 * to create a [can.Model.findAllData findAllData] function.
		 *
		 * The [can.Model.findAllData findAllData] function is passed to `makeFindAll`. `makeFindAll`
		 * should use `findAllData` internally to get the raw data for the request.
		 *
		 * @return {function(params,success,error):can.Deferred}
		 *
		 * Returns function that implements the external API of `findAll`.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * `makeFindAll` can be used to implement base models that perform special
		 * behavior. `makeFindAll` is passed a [can.Model.findAllData findAllData] function that retrieves raw
		 * data. It should return a function that when called, uses
		 * the findAllData function to get the raw data, convert them to model instances with
		 * [can.Model.models models].
		 *
		 * ## Caching
		 *
		 * The following uses `makeFindAll` to create a base `CachedModel`:
		 *
		 *     CachedModel = can.Model.extend({
		 *       makeFindAll: function(findAllData){
		 *         // A place to store requests
		 *         var cachedRequests = {};
		 *
		 *         return function(params, success, error){
		 *           // is this not cached?
		 *           if(! cachedRequests[JSON.stringify(params)] ) {
		 *             var self = this;
		 *             // make the request for data, save deferred
		 *             cachedRequests[JSON.stringify(params)] =
		 *               findAllData(params).then(function(data){
		 *                 // convert the raw data into instances
		 *                 return self.models(data)
		 *               })
		 *           }
		 *           // get the saved request
		 *           var def = cachedRequests[JSON.stringify(params)]
		 *           // hookup success and error
		 *           def.then(success,error)
		 *           return def;
		 *         }
		 *       }
		 *     },{})
		 *
		 * The following Todo model will never request the same list of todo's twice:
		 *
		 *     Todo = CachedModel({
		 *       findAll: "/todos"
		 *     },{})
		 *
		 *     // widget 1
		 *     Todo.findAll({})
		 *
		 *     // widget 2
		 *     Todo.findAll({})
		 */</span>
		makeFindAll: <span class="hljs-string">"models"</span>,
		<span class="hljs-comment">/**
		 * @function can.Model.makeFindOne
		 * @parent can.Model.static
		 *
		 * @signature `can.Model.makeFindOne: function(findOneData) -&gt; findOne`
		 *
		 * Returns the external `findOne` method given the implemented [can.Model.findOneData findOneData] function.
		 *
		 * @params {can.Model.findOneData}
		 *
		 * [can.Model.findOne] is implemented with a `String`, [can.AjaxSettings ajax settings object], or
		 * [can.Model.findOneData findOneData] function. If it is implemented as
		 * a `String` or [can.AjaxSettings ajax settings object], those values are used
		 * to create a [can.Model.findOneData findOneData] function.
		 *
		 * The [can.Model.findOneData findOneData] function is passed to `makeFindOne`. `makeFindOne`
		 * should use `findOneData` internally to get the raw data for the request.
		 *
		 * @return {function(params,success,error):can.Deferred}
		 *
		 * Returns function that implements the external API of `findOne`.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * `makeFindOne` can be used to implement base models that perform special
		 * behavior. `makeFindOne` is passed a [can.Model.findOneData findOneData] function that retrieves raw
		 * data. It should return a function that when called, uses
		 * the findOneData function to get the raw data, convert them to model instances with
		 * [can.Model.models models].
		 *
		 * ## Caching
		 *
		 * The following uses `makeFindOne` to create a base `CachedModel`:
		 *
		 *     CachedModel = can.Model.extend({
		 *       makeFindOne: function(findOneData){
		 *         // A place to store requests
		 *         var cachedRequests = {};
		 *
		 *         return function(params, success, error){
		 *           // is this not cached?
		 *           if(! cachedRequests[JSON.stringify(params)] ) {
		 *             var self = this;
		 *             // make the request for data, save deferred
		 *             cachedRequests[JSON.stringify(params)] =
		 *               findOneData(params).then(function(data){
		 *                 // convert the raw data into instances
		 *                 return self.model(data)
		 *               })
		 *           }
		 *           // get the saved request
		 *           var def = cachedRequests[JSON.stringify(params)]
		 *           // hookup success and error
		 *           def.then(success,error)
		 *           return def;
		 *         }
		 *       }
		 *     },{})
		 *
		 * The following Todo model will never request the same todo twice:
		 *
		 *     Todo = CachedModel({
		 *       findOne: "/todos/{id}"
		 *     },{})
		 *
		 *     // widget 1
		 *     Todo.findOne({id: 5})
		 *
		 *     // widget 2
		 *     Todo.findOne({id: 5})
		 */</span>
		makeFindOne: <span class="hljs-string">"model"</span>,
		makeCreate: <span class="hljs-string">"model"</span>,
		makeUpdate: <span class="hljs-string">"model"</span>
	}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(method, name)</span> </span>{
		can.Model[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(oldMethod)</span> </span>{
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				<span class="hljs-keyword">var</span> args = can.makeArray(<span class="hljs-built_in">arguments</span>),
					oldArgs = can.isFunction(args[<span class="hljs-number">1</span>]) ? args.splice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) : args.splice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>),
					def = pipe(oldMethod.apply(<span class="hljs-keyword">this</span>, oldArgs), <span class="hljs-keyword">this</span>, method);
				def.then(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>]);</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>return the original promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> def;
			};
		};
	});

	can.each([
		<span class="hljs-comment">/**
		 * @function can.Model.prototype.created created
		 * @hide
		 * Called by save after a new instance is created.  Publishes 'created'.
		 * @param {Object} attrs
		 */</span>
		<span class="hljs-string">"created"</span>,
		<span class="hljs-comment">/**
		 * @function can.Model.prototype.updated updated
		 * @hide
		 * Called by save after an instance is updated.  Publishes 'updated'.
		 * @param {Object} attrs
		 */</span>
		<span class="hljs-string">"updated"</span>,
		<span class="hljs-comment">/**
		 * @function can.Model.prototype.destroyed destroyed
		 * @hide
		 * Called after an instance is destroyed.
		 *   - Publishes "shortName.destroyed".
		 *   - Triggers a "destroyed" event on this model.
		 *   - Removes the model from the global list if its used.
		 *
		 */</span>
		<span class="hljs-string">"destroyed"</span>
	], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(funcName)</span> </span>{
		can.Model.prototype[funcName] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attrs)</span> </span>{
			<span class="hljs-keyword">var</span> stub,
				constructor = <span class="hljs-keyword">this</span>.constructor;</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Update attributes if attributes have been passed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			stub = attrs &amp;&amp; <span class="hljs-keyword">typeof</span> attrs === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">this</span>.attr(attrs.attr ? attrs.attr() : attrs);</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>triggers change event that bubble’s like
handler( ‘change’,’1.destroyed’ ). This is used
to remove items on destroyed from Model Lists.
but there should be a better way.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			can.trigger(<span class="hljs-keyword">this</span>, <span class="hljs-string">"change"</span>, funcName);</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>!steal-remove-start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			can.dev.log(<span class="hljs-string">"Model.js - "</span> + constructor.shortName + <span class="hljs-string">" "</span> + funcName);</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>!steal-remove-end</p>

            </div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Call event on the instance’s Class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			can.trigger(constructor, funcName, <span class="hljs-keyword">this</span>);
		};
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Model lists are just like <code>Map.List</code> except that when their items are 
destroyed, it automatically gets removed from the list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> ML = can.Model.List = can.List({
		setup: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(params)</span> </span>{
			<span class="hljs-keyword">if</span> (can.isPlainObject(params) &amp;&amp; !can.isArray(params)) {
				can.List.prototype.setup.apply(<span class="hljs-keyword">this</span>);
				<span class="hljs-keyword">this</span>.replace(<span class="hljs-keyword">this</span>.constructor.Map.findAll(params));
			} <span class="hljs-keyword">else</span> {
				can.List.prototype.setup.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			}
		},
		_changes: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ev, attr)</span> </span>{
			can.List.prototype._changes.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
			<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\w+\.destroyed/</span>.test(attr)) {
				<span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.indexOf(ev.target);
				<span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) {
					<span class="hljs-keyword">this</span>.splice(index, <span class="hljs-number">1</span>);
				}
			}
		}
	});

	<span class="hljs-keyword">return</span> can.Model;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
