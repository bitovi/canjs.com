<!DOCTYPE html>

<html>
<head>
  <title>control.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>control.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>steal(<span class="hljs-string">'can/util'</span>, <span class="hljs-string">'can/construct'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(can)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="control-js">control.js</h2>
<p><code>can.Control</code><br><em>Controller</em></p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Binds an element, returns a function that unbinds.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> bind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el, ev, callback)</span> </span>{

		can.bind.call(el, ev, callback);

		<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
			can.unbind.call(el, ev, callback);
		};
	},
		isFunction = can.isFunction,
		extend = can.extend,
		each = can.each,
		slice = [].slice,
		paramReplacer = <span class="hljs-regexp">/\{([^\}]+)\}/g</span>,
		special = can.getObject(<span class="hljs-string">"$.event.special"</span>, [can]) || {},</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Binds an element, returns a function that unbinds.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		delegate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el, selector, ev, callback)</span> </span>{
			can.delegate.call(el, selector, ev, callback);
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				can.undelegate.call(el, selector, ev, callback);
			};
		},</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Calls bind or unbind depending if there is a selector.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		binder = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el, ev, callback, selector)</span> </span>{
			<span class="hljs-keyword">return</span> selector ?
				delegate(el, can.trim(selector), ev, callback) :
				bind(el, ev, callback);
		},

		basicProcessor;

	<span class="hljs-keyword">var</span> Control = can.Control = can.Construct(
		<span class="hljs-comment">/**
		 * @add can.Control
		 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-comment">/** 
		 * @static
		 */</span>
		{</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Setup pre-processes which methods are event listeners.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @hide
			 *
			 * Setup pre-process which methods are event listeners.
			 *
			 */</span>
			setup: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Allow contollers to inherit “defaults” from super-classes as it 
done in <code>can.Construct</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				can.Construct.setup.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>If you didn’t provide a name, or are <code>control</code>, don’t do anything.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (can.Control) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Cache the underscored names.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> control = <span class="hljs-keyword">this</span>,
						funcName;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Calculate and cache actions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					control.actions = {};
					<span class="hljs-keyword">for</span> (funcName <span class="hljs-keyword">in</span> control.prototype) {
						<span class="hljs-keyword">if</span> (control._isAction(funcName)) {
							control.actions[funcName] = control._action(funcName);
						}
					}
				}
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Moves <code>this</code> to the first argument, wraps it with <code>jQuery</code> if it’s an element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			_shifter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(context, name)</span> </span>{

				<span class="hljs-keyword">var</span> method = <span class="hljs-keyword">typeof</span> name === <span class="hljs-string">"string"</span> ? context[name] : name;

				<span class="hljs-keyword">if</span> (!isFunction(method)) {
					method = context[method];
				}

				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
					context.called = name;
					<span class="hljs-keyword">return</span> method.apply(context, [<span class="hljs-keyword">this</span>.nodeName ? can.$(<span class="hljs-keyword">this</span>) : <span class="hljs-keyword">this</span>].concat(slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>)));
				};
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Return <code>true</code> if is an action.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @hide
			 * @param {String} methodName a prototype function
			 * @return {Boolean} truthy if an action or not
			 */</span>
			_isAction: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(methodName)</span> </span>{

				<span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.prototype[methodName],
					type = <span class="hljs-keyword">typeof</span> val;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>if not the constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">return</span> (methodName !== <span class="hljs-string">'constructor'</span>) &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>and is a function or links to a function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				(type === <span class="hljs-string">"function"</span> || (type === <span class="hljs-string">"string"</span> &amp;&amp; isFunction(<span class="hljs-keyword">this</span>.prototype[val]))) &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>and is in special, a processor, or has a funny character</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				!! (special[methodName] || processors[methodName] || <span class="hljs-regexp">/[^\w]/</span>.test(methodName));
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Takes a method name and the options passed to a control
and tries to return the data necessary to pass to a processor
(something that binds things).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @hide
			 * Takes a method name and the options passed to a control
			 * and tries to return the data necessary to pass to a processor
			 * (something that binds things).
			 *
			 * For performance reasons, this called twice.  First, it is called when
			 * the Control class is created.  If the methodName is templated
			 * like: "{window} foo", it returns null.  If it is not templated
			 * it returns event binding data.
			 *
			 * The resulting data is added to this.actions.
			 *
			 * When a control instance is created, _action is called again, but only
			 * on templated actions.
			 *
			 * @param {Object} methodName the method that will be bound
			 * @param {Object} [options] first param merged with class default options
			 * @return {Object} null or the processor and pre-split parts.
			 * The processor is what does the binding/subscribing.
			 */</span>
			_action: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(methodName, options)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>If we don’t have options (a <code>control</code> instance), we’ll run this 
later.  </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				paramReplacer.lastIndex = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">if</span> (options || !paramReplacer.test(methodName)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>If we have options, run sub to replace templates <code>{}</code> with a
value from the options or the window</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> convertedName = options ? can.sub(methodName, <span class="hljs-keyword">this</span>._lookup(options)) : methodName;
					<span class="hljs-keyword">if</span> (!convertedName) {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>!steal-remove-start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						can.dev.log(<span class="hljs-string">'can/control/control.js: No property found for handling '</span> + methodName);</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>!steal-remove-end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>If a <code>{}</code> template resolves to an object, <code>convertedName</code> will be
an array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> arr = can.isArray(convertedName),</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Get the name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						name = arr ? convertedName[<span class="hljs-number">1</span>] : convertedName,</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Grab the event off the end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						parts = name.split(<span class="hljs-regexp">/\s+/g</span>),
						event = parts.pop();

					<span class="hljs-keyword">return</span> {
						processor: processors[event] || basicProcessor,
						parts: [name, parts.join(<span class="hljs-string">" "</span>), event],
						delegate: arr ? convertedName[<span class="hljs-number">0</span>] : <span class="hljs-literal">undefined</span>
					};
				}
			},
			_lookup: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options)</span> </span>{
				<span class="hljs-keyword">return</span> [options, <span class="hljs-built_in">window</span>];
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>An object of <code>{eventName : function}</code> pairs that Control uses to 
hook up events auto-magically.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @property {Object.&lt;can.Control.processor&gt;} can.Control.processors processors
			 * @parent can.Control.static
			 *
			 * @description A collection of hookups for custom events on Controls.
			 *
			 * @body
			 * `processors` is an object that allows you to add new events to bind
			 * to on a control, or to change how existent events are bound. Each
			 * key-value pair of `processors` is a specification that pertains to
			 * an event where the key is the name of the event, and the value is
			 * a function that processes calls to bind to the event.
			 *
			 * The processor function takes five arguments:
			 *
			 * - _el_: The Control's element.
			 * - _event_: The event type.
			 * - _selector_: The selector preceding the event in the binding used on the Control.
			 * - _callback_: The callback function being bound.
			 * - _control_: The Control the event is bound on.
			 *
			 * Inside your processor function, you should bind _callback_ to the event, and
			 * return a function for can.Control to call when _callback_ needs to be unbound.
			 * (If _selector_ is defined, you will likely want to use some form of delegation
			 * to bind the event.)
			 *
			 * Here is a Control with a custom event processor set and two callbacks bound
			 * to that event:
			 *
			 * @codestart
			 * can.Control.processors.birthday = function(el, ev, selector, callback, control) {
			 *   if(selector) {
			 *     myFramework.delegate(ev, el, selector, callback);
			 *     return function() { myFramework.undelegate(ev, el, selector, callback); };
			 *   } else {
			 *     myFramework.bind(ev, el, callback);
			 *     return function() { myFramework.unbind(ev, el, callback); };
			 *   }
			 * };
			 *
			 * can.Control("EventTarget", { }, {
			 *   'birthday': function(el, ev) {
			 *     // do something appropriate for the occasion
			 *   },
			 *   '.grandchild birthday': function(el, ev) {
			 *     // do something appropriate for the occasion
			 *   }
			 * });
			 *
			 * var target = new EventTarget('#person');
			 * @codeend
			 *
			 * When `target` is initialized, can.Control will call `can.Control.processors.birthday`
			 * twice (because there are two event hookups for the _birthday_ event). The first
			 * time it's called, the arguments will be:
			 *
			 * - _el_: A NodeList that wraps the element with id 'person'.
			 * - _ev_: `'birthday'`
			 * - _selector_: `''`
			 * - _callback_: The function assigned to `' birthday'` in the prototype section of `EventTarget`'s
			 * definition.
			 * - _control_: `target` itself.
			 *
			 * The second time, the arguments are slightly different:
			 *
			 * - _el_: A NodeList that wraps the element with id 'person'.
			 * - _ev_: `'birthday'`
			 * - _selector_: `'.grandchild'`
			 * - _callback_: The function assigned to `'.grandchild birthday'` in the prototype section of `EventTarget`'s
			 * definition.
			 * - _control_: `target` itself.
			 *
			 * can.Control already has processors for these events:
			 *
			 *   - change
			 *   - click
			 *   - contextmenu
			 *   - dblclick
			 *   - focusin
			 *   - focusout
			 *   - keydown
			 *   - keyup
			 *   - keypress
			 *   - mousedown
			 *   - mouseenter
			 *   - mouseleave
			 *   - mousemove
			 *   - mouseout
			 *   - mouseover
			 *   - mouseup
			 *   - reset
			 *   - resize
			 *   - scroll
			 *   - select
			 *   - submit
			 */</span>
			processors: {},</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>A object of name-value pairs that act as default values for a 
control instance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			defaults: {}
			<span class="hljs-comment">/**
			 * @property {Object} can.Control.defaults defaults
			 * @parent can.Control.static
			 * @description Default values for the Control's options.
			 *
			 * @body
			 * `defaults` provides default values for a Control's options.
			 * Options passed into the constructor function will be shallowly merged
			 * into the values from defaults in [can.Control::setup], and
			 * the result will be stored in [can.Control::options this.options].
			 *
			 *     Message = can.Control.extend({
			 *       defaults: {
			 *         message: "Hello World"
			 *       }
			 *     }, {
			 *       init: function(){
			 *         this.element.text( this.options.message );
			 *       }
			 *     });
			 *
			 *     new Message( "#el1" ); //writes "Hello World"
			 *     new Message( "#el12", { message: "hi" } ); //writes hi
			 */</span>
		}, {
			<span class="hljs-comment">/**
			 * @prototype
			 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @functioncan.Control.prototype.init init
			 * @parent can.Control.prototype
			 * @description instance init method required for most applications of [can.Control]
			 * @signature `control.init(element,options)`
			 * @param element The wrapped element passed to the control.
			 *		Control accepts a raw HTMLElement, a CSS selector, or a NodeList.
			 *		This is set as `this.element` on the control instance.
			 * @param options The second argument passed to new Control,
			 *		extended with the can.Control's static _defaults__.
			 *		This is set as `this.options` on the control instance.
			 *		Note that static is used formally to indicate that
			 *		_default values are shared across control instances_.
			 *
			 * @body
			 * Any additional arguments provided to the constructor will be passed as normal.
			 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Sets <code>this.element</code>, saves the control in `data, binds event
handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @property {NodeList} can.Control.prototype.element element
			 * @parent can.Control.prototype
			 * @description The element associated with this control.
			 *
			 * @body
			 * The library-wrapped element this control is associated with,
			 * as passed into the constructor. If you want to change the element
			 * that a Control will attach to, you should do it in [can.Control::setup setup].
			 * If you change the element later, make sure to call [can.Control::on on]
			 * to rebind all the bindings.
			 *
			 * If `element` is removed from the DOM, [can.Control::destroy] will
			 * be called and the Control will be destroyed.
			 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @function can.Control.prototype.setup setup
			 * @parent can.Control.prototype
			 * @description Perform pre-initialization logic.
			 * @signature `control.setup(element, options)`
			 * @param {HTMLElement|NodeList|String} element The element as passed to the constructor.
			 * @param {Object} [options] option values for the control.  These get added to
			 * this.options and merged with [can.Control.static.defaults defaults].
			 * @return {undefined|Array} return an array if you want to change what init is called with. By
			 * default it is called with the element and options passed to the control.
			 *
			 * @body
			 * Setup is where most of control's magic happens.  It does the following:
			 *
			 * ### Sets this.element
			 *
			 * The first parameter passed to new Control( el, options ) is expected to be
			 * an element.  This gets converted to a Wrapped NodeList element and set as
			 * [can.Control.prototype.element this.element].
			 *
			 * ### Adds the control's name to the element's className
			 *
			 * Control adds it's plugin name to the element's className for easier
			 * debugging.  For example, if your Control is named "Foo.Bar", it adds
			 * "foo_bar" to the className.
			 *
			 * ### Saves the control in $.data
			 *
			 * A reference to the control instance is saved in $.data.  You can find
			 * instances of "Foo.Bar" like:
			 *
			 *     $( '#el' ).data( 'controls' )[ 'foo_bar' ]
			 *
			 * ### Merges Options
			 * Merges the default options with optional user-supplied ones.
			 * Additionally, default values are exposed in the static [can.Control.static.defaults defaults]
			 * so that users can change them.
			 *
			 * ### Binds event handlers
			 *
			 * Setup does the event binding described in [can.Control].
			 */</span>
			setup: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(element, options)</span> </span>{

				<span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">this</span>.constructor,
					pluginname = cls.pluginName || cls._fullName,
					arr;</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Want the raw element here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>.element = can.$(element);

				<span class="hljs-keyword">if</span> (pluginname &amp;&amp; pluginname !== <span class="hljs-string">'can_control'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Set element and <code>className</code> on element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">this</span>.element.addClass(pluginname);
				}
				arr = can.data(<span class="hljs-keyword">this</span>.element, <span class="hljs-string">'controls'</span>);
				<span class="hljs-keyword">if</span> (!arr) {
					arr = [];
					can.data(<span class="hljs-keyword">this</span>.element, <span class="hljs-string">'controls'</span>, arr);
				}
				arr.push(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Option merging.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/**
				 * @property {Object} can.Control.prototype.options options
				 * @parent can.Control.prototype
				 *
				 * @description
				 *
				 * Options used to configure a control.
				 *
				 * @body
				 *
				 * The `this.options` property is an Object that contains
				 * configuration data passed to a control when it is
				 * created (`new can.Control(element, options)`).
				 *
				 * In the following example, an options object with
				 * a message is passed to a `Greeting` control. The
				 * `Greeting` control changes the text of its [can.Control::element element]
				 * to the options' message value.
				 *
				 *     var Greeting = can.Control.extend({
				 *       init: function(){
				 *         this.element.text( this.options.message )
				 *       }
				 *     })
				 *
				 *     new Greeting("#greeting",{message: "I understand this.options"})
				 *
				 * The options argument passed when creating the control
				 * is merged with [can.Control.defaults defaults] in
				 * [can.Control.prototype.setup setup].
				 *
				 * In the following example, if no message property is provided,
				 * the defaults' message property is used.
				 *
				 *     var Greeting = can.Control.extend({
				 *       defaults: {
				 *         message: "Defaults merged into this.options"
				 *       }
				 *     },{
				 *       init: function(){
				 *         this.element.text( this.options.message )
				 *       }
				 *     })
				 *
				 *     new Greeting("#greeting")
				 *
				 */</span>
				<span class="hljs-keyword">this</span>.options = extend({}, cls.defaults, options);</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Bind all event handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>.on();</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Gets passed into <code>init</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-comment">/**
				 * @property {can.NodeList} can.Control.prototype.element element
				 *
				 * @description The element the Control is associated with.
				 *
				 * @parent can.Control.prototype
				 *
				 * @body
				 *
				 * The control instance's HTMLElement (or window) wrapped by the
				 * util library for ease of use. It is set by the first
				 * parameter to `new can.Construct( element, options )`
				 * in [can.Control::setup].  By default, a control listens to events on `this.element`.
				 *
				 * ### Quick Example
				 *
				 * The following `HelloWorld` control sets the control`s text to "Hello World":
				 *
				 *     HelloWorld = can.Control({
				 *       init: function(){
				 *		this.element.text( 'Hello World' );
				 *       }
				 *     });
				 *
				 *     // create the controller on the element
				 *     new HelloWorld( document.getElementById( '#helloworld' ) );
				 *
				 * ## Wrapped NodeList
				 *
				 * `this.element` is a wrapped NodeList of one HTMLELement (or window).  This
				 * is for convenience in libraries like jQuery where all methods operate only on a
				 * NodeList.  To get the raw HTMLElement, write:
				 *
				 *     this.element[0] //-&gt; HTMLElement
				 *
				 * The following details the NodeList used by each library with
				 * an example of updating its text:
				 *
				 * __jQuery__ `jQuery( HTMLElement )`
				 *
				 *     this.element.text("Hello World")
				 *
				 * __Zepto__ `Zepto( HTMLElement )`
				 *
				 *     this.element.text("Hello World")
				 *
				 * __Dojo__ `new dojo.NodeList( HTMLElement )`
				 *
				 *     this.element.text("Hello World")
				 *
				 * __Mootools__ `$$( HTMLElement )`
				 *
				 *     this.element.empty().appendText("Hello World")
				 *
				 * __YUI__
				 *
				 *     this.element.set("text", "Hello World")
				 *
				 *
				 * ## Changing `this.element`
				 *
				 * Sometimes you don't want what's passed to `new can.Control`
				 * to be this.element.  You can change this by overwriting
				 * setup or by unbinding, setting this.element, and rebinding.
				 *
				 * ### Overwriting Setup
				 *
				 * The following Combobox overwrites setup to wrap a
				 * select element with a div.  That div is used
				 * as `this.element`. Notice how `destroy` sets back the
				 * original element.
				 *
				 *     Combobox = can.Control({
				 *       setup: function( el, options ) {
				 *          this.oldElement = $( el );
				 *          var newEl = $( '&lt;div/&gt;' );
				 *          this.oldElement.wrap( newEl );
				 *          can.Control.prototype.setup.call( this, newEl, options );
				 *       },
				 *       init: function() {
				 *          this.element //-&gt; the div
				 *       },
				 *       ".option click": function() {
				 *         // event handler bound on the div
				 *       },
				 *       destroy: function() {
				 *          var div = this.element; //save reference
				 *          can.Control.prototype.destroy.call( this );
				 *          div.replaceWith( this.oldElement );
				 *       }
				 *     });
				 *
				 * ### unbinding, setting, and rebinding.
				 *
				 * You could also change this.element by calling
				 * [can.Control::off], setting this.element, and
				 * then calling [can.Control::on] like:
				 *
				 *     move: function( newElement ) {
				 *        this.off();
				 *        this.element = $( newElement );
				 *        this.on();
				 *     }
				 */</span>
				<span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>.element, <span class="hljs-keyword">this</span>.options];
			},
			<span class="hljs-comment">/**
			 * @function can.Control.prototype.on on
			 * @parent can.Control.prototype
			 *
			 * @description Bind an event handler to a Control, or rebind all event handlers on a Control.
			 *
			 * @signature `control.on([el,] selector, eventName, func)`
			 * @param {HTMLElement|jQuery collection|Object} [el=this.element]
			 * The element to be bound.  If no element is provided, the control's element is used instead.
			 * @param {CSSSelectorString} selector A css selector for event delegation.
			 * @param {String} eventName The event to listen for.
			 * @param {Function|String} func A callback function or the String name of a control function.  If a control
			 * function name is given, the control function is called back with the bound element and event as the first
			 * and second parameter.  Otherwise the function is called back like a normal bind.
			 * @return {Number} The id of the binding in this._bindings
			 *
			 * @body
			 * `on(el, selector, eventName, func)` binds an event handler for an event to a selector under the scope of the given element.
			 *
			 * @signature `control.on()`
			 *
			 * Rebind all of a control's event handlers.
			 *
			 * @return {Number} The number of handlers bound to this Control.
			 *
			 * @body
			 * `this.on()` is used to rebind
			 * all event handlers when [can.Control::options this.options] has changed.  It
			 * can also be used to bind or delegate from other elements or objects.
			 *
			 * ## Rebinding
			 *
			 * By using templated event handlers, a control can listen to objects outside
			 * `this.element`.  This is extremely common in MVC programming.  For example,
			 * the following control might listen to a task model's `completed` property and
			 * toggle a strike className like:
			 *
			 *     TaskStriker = can.Control({
			 *       "{task} completed": function(){
			 *			this.update();
			 *       },
			 *       update: function(){
			 *         if ( this.options.task.completed ) {
			 *			this.element.addClass( 'strike' );
			 *		} else {
			 *           this.element.removeClass( 'strike' );
			 *         }
			 *       }
			 *     });
			 *
			 *     var taskstriker = new TaskStriker({
			 *       task: new Task({ completed: 'true' })
			 *     });
			 *
			 * To update the `taskstriker`'s task, add a task method that updates
			 * this.options and rebinds the event handlers for the new task like:
			 *
			 *     TaskStriker = can.Control({
			 *       "{task} completed": function(){
			 *			this.update();
			 *       },
			 *       update: function() {
			 *         if ( this.options.task.completed ) {
			 *			this.element.addClass( 'strike' );
			 *		} else {
			 *           this.element.removeClass( 'strike' );
			 *         }
			 *       },
			 *       task: function( newTask ) {
			 *         this.options.task = newTask;
			 *         this.on();
			 *         this.update();
			 *       }
			 *     });
			 *
			 *     var taskstriker = new TaskStriker({
			 *       task: new Task({ completed: true })
			 *     });
			 *     taskstriker.task( new TaskStriker({
			 *       task: new Task({ completed: false })
			 *     }));
			 *
			 * ## Adding new events
			 *
			 * If events need to be bound to outside of the control and templated event handlers
			 * are not sufficient, you can call this.on to bind or delegate programmatically:
			 *
			 *     init: function() {
			 *        // calls somethingClicked( el, ev )
			 *        this.on( 'click', 'somethingClicked' );
			 *
			 *        // calls function when the window is clicked
			 *        this.on( window, 'click', function( ev ) {
			 *          //do something
			 *        });
			 *     },
			 *     somethingClicked: function( el, ev ) {
			 *
			 *     }
			 */</span>
			on: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el, selector, eventName, func)</span> </span>{
				<span class="hljs-keyword">if</span> (!el) {</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Adds bindings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">this</span>.off();</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Go through the cached list of actions and use the processor 
to bind</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">var</span> cls = <span class="hljs-keyword">this</span>.constructor,
						bindings = <span class="hljs-keyword">this</span>._bindings,
						actions = cls.actions,
						element = <span class="hljs-keyword">this</span>.element,
						destroyCB = can.Control._shifter(<span class="hljs-keyword">this</span>, <span class="hljs-string">"destroy"</span>),
						funcName, ready;

					<span class="hljs-keyword">for</span> (funcName <span class="hljs-keyword">in</span> actions) {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Only push if we have the action and no option is <code>undefined</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						<span class="hljs-keyword">if</span> (actions.hasOwnProperty(funcName) &amp;&amp;
							(ready = actions[funcName] || cls._action(funcName, <span class="hljs-keyword">this</span>.options))) {
							bindings.push(ready.processor(ready.delegate || element,
								ready.parts[<span class="hljs-number">2</span>], ready.parts[<span class="hljs-number">1</span>], funcName, <span class="hljs-keyword">this</span>));
						}
					}</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Setup to be destroyed…<br>don’t bind because we don’t want to remove it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					can.bind.call(element, <span class="hljs-string">"removed"</span>, destroyCB);
					bindings.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el)</span> </span>{
						can.unbind.call(el, <span class="hljs-string">"removed"</span>, destroyCB);
					});
					<span class="hljs-keyword">return</span> bindings.length;
				}

				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> el === <span class="hljs-string">'string'</span>) {
					func = eventName;
					eventName = selector;
					selector = el;
					el = <span class="hljs-keyword">this</span>.element;
				}

				<span class="hljs-keyword">if</span> (func === <span class="hljs-literal">undefined</span>) {
					func = eventName;
					eventName = selector;
					selector = <span class="hljs-literal">null</span>;
				}

				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func === <span class="hljs-string">'string'</span>) {
					func = can.Control._shifter(<span class="hljs-keyword">this</span>, func);
				}

				<span class="hljs-keyword">this</span>._bindings.push(binder(el, eventName, func, selector));

				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._bindings.length;
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Unbinds all event handlers on the controller.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @hide
			 * Unbinds all event handlers on the controller. You should never
			 * be calling this unless in use with [can.Control::on].
			 */</span>
			off: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
				<span class="hljs-keyword">var</span> el = <span class="hljs-keyword">this</span>.element[<span class="hljs-number">0</span>];
				each(<span class="hljs-keyword">this</span>._bindings || [], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{
					value(el);
				});</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Adds bindings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>._bindings = [];
			},</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Prepares a <code>control</code> for garbage collection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-comment">/**
			 * @description Remove a Control from an element and clean up the Control.
			 * @signature `control.destroy()`
			 *
			 * Prepares a control for garbage collection and is a place to
			 * reset any changes the control has made.
			 *
			 * @function can.Control.prototype.destroy destroy
			 * @parent can.Control.prototype
			 *
			 * @body
			 *
			 *
			 * ## Allowing Garbage Collection
			 *
			 * Destroy is called whenever a control's element is removed from the page using
			 * the library's standard HTML modifier methods.  This means that you
			 * don't have to call destroy yourself and it
			 * will be called automatically when appropriate.
			 *
			 * The following `Clicker` widget listens on the window for clicks and updates
			 * its element's innerHTML.  If we remove the element, the window's event handler
			 * is removed auto-magically:
			 *
			 *
			 *      Clickr = can.Control({
			 *       "{window} click": function() {
			 *			this.element.html( this.count ?
			 *			this.count++ : this.count = 0 );
			 *       }
			 *     });
			 *
			 *     // create a clicker on an element
			 *     new Clicker( "#clickme" );
			 *
			 *     // remove the element
			 *     $( '#clickme' ).remove();
			 *
			 *
			 * The methods you can use that will destroy controls automatically by library:
			 *
			 * __jQuery and Zepto__
			 *
			 *   - $.fn.remove
			 *   - $.fn.html
			 *   - $.fn.replaceWith
			 *   - $.fn.empty
			 *
			 * __Dojo__
			 *
			 *   - dojo.destroy
			 *   - dojo.empty
			 *   - dojo.place (with the replace option)
			 *
			 * __Mootools__
			 *
			 *   - Element.prototype.destroy
			 *
			 * __YUI__
			 *
			 *   - Y.Node.prototype.remove
			 *   - Y.Node.prototype.destroy
			 *
			 *
			 * ## Teardown in Destroy
			 *
			 * Sometimes, you want to reset a controlled element back to its
			 * original state when the control is destroyed.  Overwriting destroy
			 * lets you write teardown code of this manner.  __When overwriting
			 * destroy, make sure you call Control's base functionality__.
			 *
			 * The following example changes an element's text when the control is
			 * created and sets it back when the control is removed:
			 *
			 *     Changer = can.Control.extend({
			 *       init: function() {
			 *         this.oldText = this.element.text();
			 *         this.element.text( "Changed!!!" );
			 *       },
			 *       destroy: function() {
			 *         this.element.text( this.oldText );
			 *         can.Control.prototype.destroy.call( this );
			 *       }
			 *     });
			 *
			 *     // create a changer which changes #myel's text
			 *     var changer = new Changer( '#myel' );
			 *
			 *     // destroy changer which will reset it
			 *     changer.destroy();
			 *
			 * ## Base Functionality
			 *
			 * Control prepares the control for garbage collection by:
			 *
			 *   - unbinding all event handlers
			 *   - clearing references to this.element and this.options
			 *   - clearing the element's reference to the control
			 *   - removing it's [can.Control.pluginName] from the element's className
			 *
			 */</span>
			destroy: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Control already destroyed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.element === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>!steal-remove-start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					can.dev.warn(<span class="hljs-string">"can/control/control.js: Control already destroyed"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>!steal-remove-end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">return</span>;
				}
				<span class="hljs-keyword">var</span> Class = <span class="hljs-keyword">this</span>.constructor,
					pluginName = Class.pluginName || Class._fullName,
					controls;</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Unbind bindings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>.off();

				<span class="hljs-keyword">if</span> (pluginName &amp;&amp; pluginName !== <span class="hljs-string">'can_control'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Remove the <code>className</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">this</span>.element.removeClass(pluginName);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Remove from <code>data</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				controls = can.data(<span class="hljs-keyword">this</span>.element, <span class="hljs-string">"controls"</span>);
				controls.splice(can.inArray(<span class="hljs-keyword">this</span>, controls), <span class="hljs-number">1</span>);

				can.trigger(<span class="hljs-keyword">this</span>, <span class="hljs-string">"destroyed"</span>); <span class="hljs-comment">// In case we want to know if the `control` is removed.</span>

				<span class="hljs-keyword">this</span>.element = <span class="hljs-literal">null</span>;
			}
		});

	<span class="hljs-keyword">var</span> processors = can.Control.processors;</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Processors do the binding.
They return a function that unbinds when called.</p>
<p>The basic processor that binds events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	basicProcessor = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el, event, selector, methodName, control)</span> </span>{
		<span class="hljs-keyword">return</span> binder(el, event, can.Control._shifter(control, methodName), selector);
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Set common events to be processed as a <code>basicProcessor</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	each([<span class="hljs-string">"change"</span>, <span class="hljs-string">"click"</span>, <span class="hljs-string">"contextmenu"</span>, <span class="hljs-string">"dblclick"</span>, <span class="hljs-string">"keydown"</span>, <span class="hljs-string">"keyup"</span>,
		<span class="hljs-string">"keypress"</span>, <span class="hljs-string">"mousedown"</span>, <span class="hljs-string">"mousemove"</span>, <span class="hljs-string">"mouseout"</span>, <span class="hljs-string">"mouseover"</span>,
		<span class="hljs-string">"mouseup"</span>, <span class="hljs-string">"reset"</span>, <span class="hljs-string">"resize"</span>, <span class="hljs-string">"scroll"</span>, <span class="hljs-string">"select"</span>, <span class="hljs-string">"submit"</span>, <span class="hljs-string">"focusin"</span>,
		<span class="hljs-string">"focusout"</span>, <span class="hljs-string">"mouseenter"</span>, <span class="hljs-string">"mouseleave"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h1 id="104-add-touch-events-as-default-processors">104 - Add touch events as default processors</h1>
<p>TOOD feature detect?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-string">"touchstart"</span>, <span class="hljs-string">"touchmove"</span>, <span class="hljs-string">"touchcancel"</span>, <span class="hljs-string">"touchend"</span>, <span class="hljs-string">"touchleave"</span>
	], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(v)</span> </span>{
		processors[v] = basicProcessor;
	});

	<span class="hljs-keyword">return</span> Control;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
